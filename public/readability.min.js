// Simplified Readability.js for bookmarklets
// Based on Mozilla's Readability but optimized for size and browser use
(function(window) {
  'use strict';

  function Readability(doc, options) {
    this._doc = doc;
    this._options = options || {};
  }

  Readability.prototype = {
    parse: function() {
      try {
        var documentClone = this._doc.cloneNode(true);
        var article = this._grabArticle(documentClone);
        
        if (!article) return null;

        return {
          title: this._getArticleTitle(),
          content: article.innerHTML,
          textContent: article.textContent || article.innerText || '',
          length: (article.textContent || article.innerText || '').length,
          excerpt: this._getExcerpt(article),
          byline: this._getArticleMetadata('author') || this._getArticleMetadata('byline'),
          siteName: this._getArticleMetadata('site_name') || document.title,
          publishedTime: this._getArticleMetadata('published_time') || this._getArticleMetadata('date')
        };
      } catch (e) {
        console.error('Readability parsing failed:', e);
        return null;
      }
    },

    _getArticleTitle: function() {
      var title = this._doc.title || '';
      var h1 = this._doc.querySelector('h1');
      if (h1 && h1.textContent.length > title.length * 0.5) {
        title = h1.textContent;
      }
      return title.trim();
    },

    _getExcerpt: function(article) {
      var text = article.textContent || article.innerText || '';
      return text.substring(0, 300).trim() + (text.length > 300 ? '...' : '');
    },

    _getArticleMetadata: function(property) {
      var meta = this._doc.querySelector('meta[property="article:' + property + '"], meta[name="' + property + '"], meta[property="og:' + property + '"]');
      return meta ? meta.getAttribute('content') : null;
    },

    _grabArticle: function(doc) {
      // Remove unwanted elements
      this._removeNodes(doc, 'script, style, noscript, iframe, object, embed');
      
      // Special check for article body containers (New Yorker, etc)
      var articleBody = doc.querySelector('.article__body, [class*="article-body"], .body__content, .entry-content');
      if (articleBody) {
        // Check if this is a substantial article with multiple paragraphs
        var paragraphs = articleBody.querySelectorAll('p');
        if (paragraphs.length > 5) {
          console.log('Found article body with', paragraphs.length, 'paragraphs');
          return articleBody;
        }
      }
      
      // Try to find the main content
      var candidates = this._getCandidates(doc);
      var topCandidate = this._getTopCandidate(candidates);
      
      if (topCandidate) {
        return topCandidate;
      }

      // Fallback: try common selectors
      var selectors = ['article', '.post', '.entry', '.content', '#content', 'main', '.main'];
      for (var i = 0; i < selectors.length; i++) {
        var element = doc.querySelector(selectors[i]);
        if (element && element.textContent.length > 500) {
          return element;
        }
      }

      // Last resort: return body
      return doc.body;
    },

    _removeNodes: function(doc, selector) {
      var nodes = doc.querySelectorAll(selector);
      for (var i = nodes.length - 1; i >= 0; i--) {
        nodes[i].remove();
      }
    },

    _getCandidates: function(doc) {
      var candidates = [];
      var paragraphs = doc.querySelectorAll('p');
      
      for (var i = 0; i < paragraphs.length; i++) {
        var p = paragraphs[i];
        var parent = p.parentNode;
        if (!parent || parent.tagName === 'BLOCKQUOTE') continue;
        
        var score = this._getContentScore(p);
        if (score > 0) {
          candidates.push({ element: parent, score: score });
        }
      }
      
      return candidates;
    },

    _getContentScore: function(element) {
      var text = element.textContent || element.innerText || '';
      if (text.length < 50) return 0;
      
      var score = text.length / 100;
      
      // Bonus for paragraph tags
      if (element.tagName === 'P') score += 1;
      
      // Penalty for unlikely classes/ids
      var className = element.className || '';
      var id = element.id || '';
      if (/(comment|meta|footer|sidebar)/i.test(className + ' ' + id)) {
        score -= 5;
      }
      
      return score;
    },

    _getTopCandidate: function(candidates) {
      if (candidates.length === 0) return null;
      
      candidates.sort(function(a, b) { return b.score - a.score; });
      
      // For multi-section articles like New Yorker, combine high-scoring sections
      var topScore = candidates[0].score;
      var threshold = topScore * 0.3; // Include sections with at least 30% of top score
      var container = this._doc.createElement('div');
      
      for (var i = 0; i < candidates.length; i++) {
        if (candidates[i].score >= threshold) {
          // Avoid duplicates by checking if this element is already a child of another candidate
          var isDuplicate = false;
          for (var j = 0; j < i; j++) {
            if (candidates[j].score >= threshold && candidates[j].element.contains(candidates[i].element)) {
              isDuplicate = true;
              break;
            }
          }
          
          if (!isDuplicate) {
            var clone = candidates[i].element.cloneNode(true);
            container.appendChild(clone);
          }
        }
      }
      
      return container.children.length > 0 ? container : candidates[0].element;
    }
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Readability;
  } else {
    window.Readability = Readability;
  }

})(typeof window !== 'undefined' ? window : this);