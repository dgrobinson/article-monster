(globalThis["webpackChunkverso"] = globalThis["webpackChunkverso"] || []).push([[531],{

/***/ 15272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const autopilot_utils_vulcan_1 = __webpack_require__(25888);
/**
 * Singleton that manages vulcan sdk instances
 */
const VulcanSDKManager = {
    vulcanMap: new Map(),
    /**
     * Get a vulcan sdk that works with a given cdn url. Share instances for a given url
     *
     * @param vulcanUrl - path with protocol to a cdn (e.g. https://media.golfdigest.com)
     * @returns vulcan sdk configured for the give cdn url
     */
    get(vulcanUrl) {
        let vulcanSDK = this.vulcanMap.get(vulcanUrl);
        if (!vulcanSDK) {
            vulcanSDK = (0, autopilot_utils_vulcan_1.create)({ cdn: vulcanUrl });
            this.vulcanMap.set(vulcanUrl, vulcanSDK);
        }
        return vulcanSDK;
    }
};
exports["default"] = VulcanSDKManager;
//# sourceMappingURL=VulcanSDKManager.js.map

/***/ }),

/***/ 75163:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shim = exports.Design = void 0;
const styled_components_1 = __webpack_require__(92168);
const utils_1 = __webpack_require__(26865);
/**
 * This is a token list that helps developers with
 * accessing known tokens supported by our design
 * system using the new Design ConfigSet from
 * Verso Settings.
 *
 * Color tokens should be wrapped with a `var()`,
 * so applying a surface token as a background will
 * be implemented by:
 *
 * ```css
 * background: ${Design.Color.Surface}
 * ```
 *
 * Component tokens are applied as CSS classes and
 * should be applied to element that you want to
 * receive the tokens, like:
 *
 * ```jsx
 * <a className={Design.Component.BodyLink}>link</a>
 * ```
 */
exports.Design = {
    Color: {
        Border: '--color-border',
        BorderAccent: '--color-border-accent',
        BorderActive: '--color-border-active',
        BorderButtonPrimaryOutlined: '--color-border-button-primary-outlined',
        BorderButtonUtilityOutlined: '--color-border-button-utility-outlined',
        BorderDisabled: '--color-border-disabled',
        BorderError: '--color-border-error',
        BorderFocus: '--color-border-focus',
        BorderNavigation: '--color-border-navigation',
        BorderNavigationActive: '--color-border-navigation-active',
        BorderPullquote: '--color-border-pullquote',
        BorderStory: '--color-border-story',
        BorderSub: '--color-border-sub',
        BorderSubNavigation: '--color-border-sub-navigation',
        BorderToggleChipHover: '--color-border-toggle-chip-hover',
        BorderUtility: '--color-border-utility',
        BorderUtilitySubtle: '--color-border-utility-subtle',
        Icon: '--color-icon',
        IconAccent: '--color-icon-accent',
        IconActive: '--color-icon-active',
        IconDisabled: '--color-icon-disabled',
        IconSubtle: '--color-icon-subtle',
        Surface: '--color-surface',
        SurfaceAccent: '--color-surface-accent',
        SurfaceAd: '--color-surface-ad',
        SurfaceButtonPrimaryFilled: '--color-surface-button-primary-filled',
        SurfaceButtonPrimaryFilledActive: '--color-surface-button-primary-filled-active',
        SurfaceButtonPrimaryFilledHover: '--color-surface-button-primary-filled-hover',
        SurfaceButtonUtilityFilled: '--color-surface-button-utility-filled',
        SurfaceButtonUtilityFilledActive: '--color-surface-button-utility-filled-active',
        SurfaceButtonUtilityFilledHover: '--color-surface-button-utility-filled-hover',
        SurfaceBylineCard: '--color-surface-byline-card',
        SurfaceCardActive: '--color-surface-card-active',
        SurfaceCardDisabled: '--color-surface-card-disabled',
        SurfaceHover: '--color-surface-hover',
        SurfaceNavigationElevated: '--color-surface-navigation-elevated',
        SurfaceNavigationFeature: '--color-surface-navigation-feature',
        SurfaceNavigationFeatureBrand: '--color-surface-navigation-feature-brand',
        SurfaceNavigationFeatureBrandHover: '--color-surface-navigation-feature-brand-hover',
        SurfaceNavigationFeatureBrandPressed: '--color-surface-navigation-feature-brand-pressed',
        SurfaceNavigationOverlay: '--color-surface-navigation-overlay',
        SurfacePlaceholder: '--color-surface-placeholder',
        SurfacePressed: '--color-surface-pressed',
        SurfaceRubricCard: '--color-surface-rubric-card',
        SurfaceStatusCard: '--color-surface-status-card',
        SurfaceSubtle: '--color-surface-subtle',
        SurfaceToggleChip: '--color-surface-toggle-chip',
        SurfaceToggleChipActive: '--color-surface-toggle-chip-active',
        Text: '--color-text',
        TextAccent: '--color-text-accent',
        TextActive: '--color-text-active',
        TextAd: '--color-text-ad',
        TextBlockquote: '--color-text-blockquote',
        TextButtonPrimary: '--color-text-button-primary',
        TextButtonPrimaryFilled: '--color-text-button-primary-filled',
        TextButtonUtility: '--color-text-button-utility',
        TextButtonUtilityFilled: '--color-text-button-utility-filled',
        TextByline: '--color-text-byline',
        TextBylineCard: '--color-text-byline-card',
        TextBylineLink: '--color-text-byline-link',
        TextCardActive: '--color-text-card-active',
        TextCardDisabled: '--color-text-card-disabled',
        TextDek: '--color-text-dek',
        TextDisabled: '--color-text-disabled',
        TextError: '--color-text-error',
        TextHeading: '--color-text-heading',
        TextImageCaption: '--color-text-image-caption',
        TextImageCredit: '--color-text-image-credit',
        TextLink: '--color-text-link',
        TextNavigation: '--color-text-navigation',
        TextNavigationAccent: '--color-text-navigation-accent',
        TextNavigationBrand: '--color-text-navigation-brand',
        TextNavigationElevated: '--color-text-navigation-elevated',
        TextNavigationEmphasis: '--color-text-navigation-emphasis',
        TextNavigationFeature: '--color-text-navigation-feature',
        TextPlaceholder: '--color-text-placeholder',
        TextPricing: '--color-text-pricing',
        TextPubdate: '--color-text-pubdate',
        TextRubric: '--color-text-rubric',
        TextRubricCard: '--color-text-rubric-card',
        TextStatus: '--color-text-status',
        TextStatusCard: '--color-text-status-card',
        TextSubHeading: '--color-text-sub-heading',
        TextSubtle: '--color-text-subtle',
        TextSuccess: '--color-text-success',
        TextToggleChip: '--color-text-toggle-chip',
        TextToggleChipActive: '--color-text-toggle-chip-active'
    },
    Component: {
        BylineLink: 'byline-link',
        TextLink: 'text-link'
    }
};
function shim(theme, obj) {
    return (0, styled_components_1.css) `
    ${Object.keys(obj)
        .map((key) => `${key}: ${(0, utils_1.getColorToken)(theme, obj[key])};`)
        .join('\n')}
  `;
}
exports.shim = shim;
//# sourceMappingURL=design.js.map

/***/ }),

/***/ 59175:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatMarkdownData = void 0;
const marked_1 = __webpack_require__(6709);
const marked_mangle_1 = __webpack_require__(86376);
const marked_gfm_heading_id_1 = __webpack_require__(71563);
marked_1.marked.use({
    langPrefix: '',
    highlight: null
});
marked_1.marked.use((0, marked_gfm_heading_id_1.gfmHeadingId)(), (0, marked_mangle_1.mangle)());
const formatMarkdownData = (data) => {
    const parsedData = marked_1.marked.parseInline(data);
    return parsedData;
};
exports.formatMarkdownData = formatMarkdownData;
//# sourceMappingURL=format-markdown-data.js.map

/***/ }),

/***/ 55235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useEffect, useState } = React;
const { injectIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(44989)/* ["default"] */ .A);
const { connector } = __webpack_require__(57744);
const { TrackComponentChannel } = __webpack_require__(78788);
const { googleAnalytics } = __webpack_require__(90090);
const { saveNewsletterSubscriptions } = __webpack_require__(26430);
// CPP: DELETEME const {
//   setMarketingPermissions
// } = require('../../helpers/user/marketingPermissions');
const { createCookie, getCookie } = __webpack_require__(56892);
const Grid = __webpack_require__(86659);
const NewsletterSubscribeForm = __webpack_require__(36791);
const NewsletterSubscribeFormVariations = __webpack_require__(78409);
const NewsletterSlice = __webpack_require__(93744);
const newsletterHelpers = __webpack_require__(26430);
const NewsletterSlimLoggedIn = __webpack_require__(81704);
const ViewportMonitor = __webpack_require__(3990);
const { buildMarkName, buildMeasureName, perfMark, perfMeasure } = __webpack_require__(56822);
const recaptchaHelpers = __webpack_require__(48141);
const { trackNewsletterEvent } = __webpack_require__(14307);
const FETCH_COMPLETE = 'fetch-complete';
const FORM_FOCUS = 'form-focus';
const FORM_RENDER = 'form-render';
const FORM_SUBMIT = 'form-submit';
const NEWSLETTER_SUBSCRIBE = 'newsletter-subscribe';
const DISMISSED_COOKIE_EXPIRES_MS = 60 * 60 * 24 * 7 * 2 * 1000; // 2 weeks
const SUBSCRIBED_COOKIE_EXPIRES_MS = 60 * 60 * 24 * 30 * 2 * 1000; // 2 months
const EMAIL_COOKIE_EXPIRES_MS = 60 * 60 * 1000; // 1 hour
/**
 * ConnectedNewsletterSubscribeForm component
 *
 * @param {object} props - React props
 * @param {string} props.dangerousSuccessDek - Dek displayed on success
 * @param {string} props.dangerousSuccessHed - Hed displayed on success
 * @param {string | number} props.newsletterId - ID of newsletter to subscribe to
 * @param {string} props.newsletterType - Optional string identifying inline newsletter variations
 * @param {Function} [props.onSuccessHandler] - Handler for subscription success
 * @param {string} [props.position] - Optional string identifying where on the page is to render the subscribe form.
 * @param {string} [props.provider] - Optional newsletter subscriptions service provider
 * @param {string} [props.recaptchaSiteKey] - brand siteKey for recaptcha
 * @param {string} props.siteCode - the newsletter component placement tracking code
 * @param {string} [props.sourceCode] - the newsletter component placement tracking code
 * @param {string} [props.sourceCodeForCheckingReCaptcha] - the newsletter component for checking reCaptcha
 * @param {string} [props.textFieldName] - Name attribute for email input
 * @param {string} [props.currentPage] - Provides the current page if not mentioned the will take empty string
 * @param {string} props.userPlatformProxy -  brand upg proxy server url
 * @param {string} props.xClientID - brand upg x-client request header
 * @param {object} [props.variations] - Variation properties used in rendering the component.
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.showDangerousHed] - show/hide dangerousDek in sign up form or not
 *
 * @returns {ReactElement} <NewsletterSubscribeForm>
 */
class ConnectedNewsletterSubscribeForm extends React.Component {
    constructor(props) {
        super(props);
        this.onFocusHandler = () => {
            if (!this.state.hasFocused) {
                this.setBeaconFocusMark();
                this.setState({
                    hasFocused: true
                });
            }
        };
        /**
         * Perform the subscribe request.
         * Contains all core functionality surrounding making the request and then
         * relaying any relevant success/error states to the user.
         *
         * If the prop `recaptchaSiteKey` is not passed from the tenant config, then
         * this handler is passed as normal to the child form. The event is also
         * passed to the handler as usual.
         *
         * This method is called in `recaptchaCallback` below, which is then given to
         * the google recaptcha service to call once the user has completed the
         * verification task.
         *
         * @param {Event} event - Submit event
         * @param {string} recaptchaResponse - Recaptcha response token
         *
         * @returns {Promise<undefined>} Promise
         */
        this.onSubmitHandler = (event, recaptchaResponse) => {
            const { enableSlimUnitToggle, intl, newsletterId, provider, recaptchaSiteKey, siteCode, sourceCode, sourceCodeForCheckingReCaptcha, loggedInSourceCode, textFieldName, // email field name
            userEmail, userPlatformProxy, xClientID, newsletterType, hasAlternateNewsletterStyle, isAuthenticated, amguuid, dangerousHed, frequencyBadge, formName } = this.props;
            const htmlRef = event?.target || document;
            const emailField = htmlRef.querySelector(`[name=${textFieldName}]`);
            const userInputEmail = emailField?.value || '';
            const newsletterEventName = newsletterType === 'slim-newsletter'
                ? 'newsletter-signup-submit-inlineslim'
                : 'newsletter-signup-submit';
            googleAnalytics.emitGoogleTrackingEvent(newsletterEventName, {
                newsletterId: this.props.newsletterId
            });
            trackNewsletterEvent({
                type: 'signup',
                newsletter_id: String(newsletterId),
                newsletter_title: dangerousHed || null,
                cadence: frequencyBadge || null,
                subject: sourceCode
            });
            const emailFromCookie = getCookie('ns-anonymous-user-email');
            const resolvedEmail = userEmail || emailFromCookie;
            const fieldValues = { email: resolvedEmail };
            const shouldGetEmailFromForm = !enableSlimUnitToggle && !userEmail;
            if (shouldGetEmailFromForm) {
                // Fallback to grabbing email from the form
                const formInput = htmlRef.querySelector(`[name=${textFieldName}]`);
                if (formInput) {
                    fieldValues[textFieldName] = formInput.value;
                }
            }
            this.setBeaconSubmitMarks();
            this.setState({
                isRequestInflight: true
            });
            this.setState({
                isSubscribeClicked: true
            });
            const payload = {
                ...fieldValues,
                provider,
                siteCode,
                sourceCode: enableSlimUnitToggle && loggedInSourceCode
                    ? loggedInSourceCode
                    : sourceCode,
                sourceCodeForCheckingReCaptcha,
                subscriptions: [
                    {
                        status: 'SUBSCRIBED',
                        newsletterId
                    }
                ],
                marketingConsents: this.state.checkedMarketing,
                url: window.location.href,
                formName
            };
            let requestOptions = {
                userPlatformProxy,
                xClientID
            };
            if (isAuthenticated) {
                if (userInputEmail && userInputEmail !== this.props?.email) {
                    payload.email = userInputEmail;
                }
                else {
                    payload.email = this.props?.email;
                    requestOptions = {
                        ...requestOptions,
                        amgUUID: hasAlternateNewsletterStyle && amguuid
                    };
                }
            }
            if (recaptchaSiteKey) {
                payload.recaptchaResponse = recaptchaResponse;
            }
            requestOptions = {
                ...requestOptions,
                payload
            };
            /* CPP: DELETEME const apiCalls = [saveNewsletterSubscriptions(requestOptions)];
            const checkedMarketingObj = this.state.checkedMarketing || {};
            if (
              this.props.marketingPermissions &&
              Object.keys(checkedMarketingObj).length > 0
            ) {
              const marketingPayload = {
                brand: payload.siteCode,
                marketingPermissions: checkedMarketingObj,
                source: payload.sourceCode,
                userPlatformProxy: requestOptions.userPlatformProxy,
                xClientID: requestOptions.xClientID,
                email: payload.email
              };
        
              apiCalls.push(setMarketingPermissions(marketingPayload));
            } */
            /* CPP: DELETEME return Promise.all(apiCalls)
            .then(([result, marketingPermissionsResult]) => { */
            return Promise.resolve(saveNewsletterSubscriptions(requestOptions))
                .then((result) => {
                this.setBeaconFetchCompletionMarks();
                if (!isAuthenticated &&
                    hasAlternateNewsletterStyle &&
                    (!emailFromCookie || fieldValues.email !== emailFromCookie)) {
                    document.cookie = createCookie('ns-anonymous-user-email', requestOptions.payload.email, {
                        path: '/',
                        expirationInMs: EMAIL_COOKIE_EXPIRES_MS
                    });
                }
                const newPrefs = {
                    status: requestOptions.payload.subscriptions[0].status,
                    newsletterId: requestOptions.payload.subscriptions[0].newsletterId.toString()
                };
                const preferencesFromCookie = getCookie('ns-anonymous-user-pref');
                if (!isAuthenticated && hasAlternateNewsletterStyle) {
                    if (fieldValues.email === emailFromCookie && preferencesFromCookie) {
                        const savedCookieuserPref = JSON.parse(preferencesFromCookie);
                        savedCookieuserPref.push(newPrefs);
                        document.cookie = createCookie('ns-anonymous-user-pref', JSON.stringify(savedCookieuserPref), {
                            path: '/',
                            expirationInMs: EMAIL_COOKIE_EXPIRES_MS
                        });
                    }
                    else {
                        document.cookie = createCookie('ns-anonymous-user-pref', JSON.stringify([newPrefs]), {
                            path: '/',
                            expirationInMs: EMAIL_COOKIE_EXPIRES_MS
                        });
                    }
                }
                if (!result.savePreference.success) {
                    this.setState({
                        error: intl.formatMessage(translations.badResponse),
                        isRequestInflight: false
                    });
                    return;
                }
                /* CPP: DELETEME if (
                  this.props.marketingPermissions &&
                  marketingPermissionsResult.status >= 300
                ) {
                  this.setState({
                    error: intl.formatMessage(
                      translations.marketingPermissionBadResponse
                    ),
                    isRequestInflight: false
                  });
                  return;
                } */
                this.handleSuccess();
            })
                .catch((error) => {
                this.setState({
                    error: error.message,
                    isRequestInflight: false
                });
            });
        };
        /**
         * Set mark to track user time spent interacting with form
         *
         * @returns {undefined} undefined
         */
        this.setBeaconFocusMark = () => {
            perfMark(buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_FOCUS));
        };
        /**
         * Set performance beacons to track user metrics around form submission
         *
         * @returns {undefined} undefined
         */
        this.setBeaconSubmitMarks = () => {
            perfMark(buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_SUBMIT));
            perfMeasure(buildMeasureName(NEWSLETTER_SUBSCRIBE, FORM_FOCUS, FORM_SUBMIT), buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_FOCUS), buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_SUBMIT));
        };
        /**
         * Set performance beacons to track performance metrics around submission times
         *
         * @returns {undefined} undefined
         */
        this.setBeaconFetchCompletionMarks = () => {
            perfMark(buildMarkName(NEWSLETTER_SUBSCRIBE, FETCH_COMPLETE));
            perfMeasure(buildMeasureName(NEWSLETTER_SUBSCRIBE, FORM_SUBMIT, FETCH_COMPLETE), buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_SUBMIT), buildMarkName(NEWSLETTER_SUBSCRIBE, FETCH_COMPLETE));
        };
        /**
         * Set performance beacon to track time from form submit to component re-render
         *
         * @returns {undefined} undefined
         */
        this.setBeaconPostSubmitRenderMarks = () => {
            perfMark(buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_RENDER));
            perfMeasure(buildMeasureName(NEWSLETTER_SUBSCRIBE, FORM_SUBMIT, FORM_RENDER), buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_SUBMIT), buildMarkName(NEWSLETTER_SUBSCRIBE, FORM_RENDER));
        };
        this.fetchNewsletterPrefs = async () => {
            const { amguuid: amgUUID, doUpdateAuthenticatedStatus, provider, sailthruId: sid, userPlatformProxy, xClientID, newsletterId, isArticlePage } = this.props;
            const sailthruId = sid;
            const newsletterIds = [newsletterId];
            this.setState({ isPending: true });
            const options = {
                amgUUID,
                newsletterIds,
                provider,
                sailthruId,
                userPlatformProxy,
                xClientID
            };
            try {
                const result = await newsletterHelpers.getNewsletterSubscriptions(options);
                if (result.status !== 200) {
                    throw result;
                }
                const { newsletterSubscriptions: { data = [] } = {} } = result;
                if (data[0] && data[0].attributes.status === 'SUBSCRIBED') {
                    this.setState({
                        hasFetchedPrefs: true,
                        hasSubscribed: true,
                        isPending: false,
                        hideSuccessMsg: isArticlePage
                    });
                }
                return;
            }
            catch (error) {
                const errorState = {
                    hasBadResponse: false,
                    hasFetchedPrefs: false,
                    isPending: false
                };
                if (!sailthruId && error.status === 401) {
                    doUpdateAuthenticatedStatus();
                    errorState.hasUnknownError = true;
                }
                else if (sailthruId && error.status === 400) {
                    errorState.hasValidSailthruId = false;
                }
                else {
                    errorState.hasUnknownError = true;
                }
                this.setState(errorState);
            }
        };
        /**
         * Callback given to the recaptcha widget.
         * The widget passes in the response from the user recaptcha task, and expects
         * a promise to be returned.
         *
         * @param {string} recaptchaResponse - Recaptcha response token
         *
         * @returns {undefined} undefined
         */
        this.recaptchaCallback = (recaptchaResponse) => {
            return new Promise((resolve) => {
                this.onSubmitHandler(null, recaptchaResponse);
                resolve();
            });
        };
        /**
         * Changes the state after successful submission
         *
         * @returns {undefined} undefined
         */
        this.handleSuccess = () => {
            const { onSuccessHandler, newsletterId, newsletterType, variations: { isSlice } } = this.props;
            this.setState({
                hasSubscribed: true
            }, () => {
                // write subscribe success cookie for newsletter slice
                if (isSlice) {
                    document.cookie = createCookie(`ns-subscribed-${newsletterId}`, 'true', {
                        path: '/',
                        expirationInMs: SUBSCRIBED_COOKIE_EXPIRES_MS
                    });
                }
            });
            const newsletterEventName = newsletterType === 'slim-newsletter'
                ? 'newsletter-signup-complete_inlineslim'
                : 'newsletter-signup-complete';
            googleAnalytics.emitGoogleTrackingEvent(newsletterEventName, {
                newsletterId: this.props.newsletterId
            });
            if (onSuccessHandler) {
                onSuccessHandler();
            }
        };
        this.state = {
            error: '',
            hasFocused: false,
            hasSubscribed: false,
            isRequestInflight: false,
            hasBadResponse: false,
            hasFetchedPrefs: false,
            isPending: false,
            hasUnknownError: false,
            hideSuccessMsg: false,
            checkedMarketing: this.props.checkedMarketing || {},
            isSubscribeClicked: false
        };
    }
    componentDidMount() {
        const { isAuthenticated, hasAlternateNewsletterStyle, newsletterId, isArticlePage } = this.props;
        const { hasFetchedPrefs, isPending, hasUnknownError, hasBadResponse } = this.state;
        /**
         * getting anonymous user preference and email from cookies.
         */
        if (!isAuthenticated &&
            hasAlternateNewsletterStyle &&
            getCookie('ns-anonymous-user-pref')) {
            const isSubscribed = JSON.parse(getCookie('ns-anonymous-user-pref'))?.find((pref) => pref.newsletterId === newsletterId);
            if (isSubscribed) {
                this.setState({
                    hasSubscribed: true
                });
            }
            if (isSubscribed && isArticlePage) {
                this.setState({
                    hideSuccessMsg: true
                });
            }
        }
        if (isAuthenticated &&
            hasAlternateNewsletterStyle &&
            !hasFetchedPrefs &&
            !isPending &&
            !hasUnknownError &&
            !hasBadResponse) {
            this.fetchNewsletterPrefs();
        }
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ConnectedNewsletterSubscribeForm',
            variation: this.props.variationName
        });
    }
    // Do not re-render component when hasFocussed has changed.
    shouldComponentUpdate(_nextProps, nextState) {
        const hasFocusedChanged = nextState.hasFocused !== this.state.hasFocused;
        return !hasFocusedChanged;
    }
    componentDidUpdate(previousProps) {
        if (previousProps.checkedMarketing !== this.props.checkedMarketing) {
            this.setState({ checkedMarketing: this.props.checkedMarketing });
        }
    }
    render() {
        const { error, hasSubscribed, hideSuccessMsg } = this.state;
        if (hideSuccessMsg) {
            return null;
        }
        const { intl, dangerousDek, dangerousHed, dangerousSuccessDek, dangerousSuccessHed, hasAlternateNewsletterStyle, newsletterId, recaptchaSiteKey, variations, frequencyBadge, showDangerousHed, sourceCode, sourceCodeForCheckingReCaptcha, ...additionalProps } = this.props;
        const customInvalidityMessages = {
            email: {
                typeMismatch: intl.formatMessage(translations.typeMismatchMessage)
            }
        };
        const submitHandler = recaptchaSiteKey
            ? recaptchaHelpers.executeV2Recaptcha
            : this.onSubmitHandler;
        const NewsletterSubscribeComponent = ({ children, ...props }) => {
            const [shouldHideNLSlice, setHideNLSlice] = useState(false);
            useEffect(() => {
                // should hide the slice either been dismissed or have subscribed to the list
                setHideNLSlice(Boolean(getCookie(`ns-dismiss-${newsletterId}`)) ||
                    Boolean(getCookie(`ns-subscribed-${newsletterId}`)) ||
                    false);
            }, []);
            if (variations.isSlice) {
                // Default to inline slice
                let NSComponent = NewsletterSlice;
                if (variations.slicePosition === 'top') {
                    NSComponent = NewsletterSlice.PersistTop;
                }
                else if (variations.slicePosition === 'bottom') {
                    NSComponent = NewsletterSlice.PersistBottom;
                }
                const onDismissed = () => {
                    document.cookie = createCookie(`ns-dismiss-${newsletterId}`, 'true', {
                        path: '/',
                        expirationInMs: DISMISSED_COOKIE_EXPIRES_MS
                    });
                };
                return (React.createElement(NSComponent, { key: `newsletter-slice${shouldHideNLSlice ? '-hidden' : ''}`, hasBeenDismissed: shouldHideNLSlice, hasSubscribed: hasSubscribed, onDismissed: onDismissed, ...props }));
            }
            const { newsletterType, bgImageOneForHighImpactVariation = '', bgImageTwoForHighImpactVariation = '' } = props;
            if (newsletterType === 'aggressive-newsletter')
                return React.createElement(NewsletterSubscribeFormVariations.Aggressive, { ...props });
            if (newsletterType === 'aggressive-center-newsletter')
                return (React.createElement(NewsletterSubscribeFormVariations.AggressiveCenter, { ...props }));
            if (newsletterType === 'slim-newsletter')
                return React.createElement(NewsletterSubscribeFormVariations.Slim, { ...props });
            if (newsletterType === 'impact-newsletter' &&
                (bgImageOneForHighImpactVariation || bgImageTwoForHighImpactVariation))
                return React.createElement(NewsletterSubscribeFormVariations.HighImpact, { ...props });
            if (newsletterType === 'impact-newsletter' &&
                bgImageOneForHighImpactVariation === '' &&
                bgImageTwoForHighImpactVariation === '')
                return (React.createElement(Grid.WithMargins, null,
                    React.createElement(NewsletterSubscribeForm, { ...props }, children)));
            // only the NewsletterSubscribeForm format accepts custom content
            return (React.createElement(NewsletterSubscribeForm, { ...props }, children));
        };
        NewsletterSubscribeComponent.propTypes = NewsletterSubscribeForm.propTypes;
        const { dangerousLoggedInSuccessHed } = this.props;
        const dangerousHedStr = showDangerousHed ? dangerousHed : '';
        const onIntersectionViewport = (isInViewport, unobserveIntersection) => {
            if (!isInViewport || this.state.isSubscribeClicked) {
                return;
            }
            unobserveIntersection();
            const entityData = {
                type: 'impression',
                newsletter_id: String(newsletterId),
                newsletter_title: dangerousHed,
                cadence: frequencyBadge,
                subject: sourceCode
            };
            trackNewsletterEvent(entityData);
        };
        return (React.createElement(React.Fragment, null, this.props.newsletterType === 'slim-newsletter' &&
            this.props.enableSlimUnitToggle ? (React.createElement(ViewportMonitor, { onIntersectionViewport: onIntersectionViewport, observerOptions: { rootMargin: '0px' }, className: "connected-newsletter-viewport" },
            React.createElement(NewsletterSlimLoggedIn, { hasAlternateNewsletterStyle: hasAlternateNewsletterStyle, ...this.props, dangerousDek: dangerousDek, dangerousHed: dangerousHed, dangerousSuccessHed: dangerousLoggedInSuccessHed || dangerousSuccessHed, hasSubscribed: hasSubscribed, onToggleChecked: this.onSubmitHandler }))) : (React.createElement(NewsletterSubscribeComponent, { newsletterId: newsletterId, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle, ...additionalProps, customInvalidityMessages: customInvalidityMessages, dangerousDek: hasSubscribed
                ? dangerousSuccessDek ||
                    intl.formatMessage(translations.successDek)
                : dangerousDek, dangerousHed: hasSubscribed
                ? dangerousSuccessHed ||
                    intl.formatMessage(translations.successHed)
                : dangerousHedStr, errors: error
                ? [
                    {
                        text: '',
                        messages: [`${error}`]
                    }
                ]
                : undefined, hasSubscribed: hasSubscribed, isSubmitDisabled: this.state.isRequestInflight, onFocusHandler: this.onFocusHandler, onSubmitHandler: submitHandler, recaptchaCallback: this.recaptchaCallback, recaptchaSiteKey: recaptchaSiteKey, setBeaconPostSubmitRenderMarks: this.setBeaconPostSubmitRenderMarks, sourceCode: sourceCode, sourceCodeForCheckingReCaptcha: sourceCodeForCheckingReCaptcha, frequencyBadge: frequencyBadge }))));
    }
}
ConnectedNewsletterSubscribeForm.propTypes = {
    ...NewsletterSubscribeForm.propTypes,
    checkedMarketing: PropTypes.object,
    dangerousSuccessDek: PropTypes.string,
    dangerousSuccessHed: PropTypes.string,
    hasAlternateNewsletterStyle: PropTypes.bool,
    intl: PropTypes.object,
    isArticlePage: PropTypes.bool,
    marketingPermissions: PropTypes.func,
    newsletterId: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
        .isRequired,
    newsletterType: PropTypes.string,
    onSuccessHandler: PropTypes.func,
    position: PropTypes.string,
    provider: PropTypes.string,
    recaptchaSiteKey: PropTypes.string,
    showDangerousHed: PropTypes.bool,
    siteCode: PropTypes.string,
    sourceCode: PropTypes.string,
    sourceCodeForCheckingReCaptcha: PropTypes.string,
    textFieldLabel: PropTypes.string,
    textFieldName: PropTypes.string,
    userPlatformProxy: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        isSlice: PropTypes.oneOf([true, false]),
        slicePosition: PropTypes.oneOf(['top', 'bottom', 'inline'])
    }),
    xClientID: PropTypes.string
};
ConnectedNewsletterSubscribeForm.defaultProps = {
    hasAlternateNewsletterStyle: false,
    isArticlePage: false,
    showDangerousHed: true,
    textFieldName: 'email',
    variations: {
        isSlice: false,
        slicePosition: 'inline'
    }
};
ConnectedNewsletterSubscribeForm.displayName =
    'ConnectedNewsletterSubscribeForm';
module.exports = injectIntl(connector(ConnectedNewsletterSubscribeForm, {
    keysToSpread: ['userPlatform', 'user']
}));
//# sourceMappingURL=ConnectedNewsletterSubscribeForm.js.map

/***/ }),

/***/ 577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const ConnectedNewsletterSubscribeFormVariations = __webpack_require__(53167);
module.exports = asConfiguredComponent(ConnectedNewsletterSubscribeFormVariations, 'ConnectedNewsletterSubscribeForm');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44989:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    errorMessage: {
        id: 'ConnectedNewsletterSubscribeForm.ErrorMessage',
        defaultMessage: 'Subscription failed:',
        description: 'ConnectedNewsletterSubscribeForm component error message'
    },
    successDek: {
        id: 'ConnectedNewsletterSubscribeForm.SuccessDek',
        defaultMessage: "You've successfully subscribed to our newsletter....",
        description: 'ConnectedNewsletterSubscribeForm component success dek'
    },
    successHed: {
        id: 'ConnectedNewsletterSubscribeForm.SuccessHed',
        defaultMessage: "You're all set...",
        description: 'ConnectedNewsletterSubscribeForm component success hed'
    },
    typeMismatchMessage: {
        id: 'ConnectedNewsletterSubscribeForm.TypeMismatchMessage',
        defaultMessage: 'Invalid email. Double check and try again.',
        description: 'ConnectedNewsletterSubscribeForm component type mismatch message'
    },
    badResponse: {
        id: 'ConnectedNewsletterSubscribeForm.BadResponse',
        defaultMessage: 'Bad response for signup newsletter',
        description: 'ConnectedNewsletterSubscribeForm component bad response message for signup newsletter'
    }
    /* CPP: DELETEME marketingPermissionBadResponse: {
      id: 'ConnectedNewsletterSubscribeForm.marketingPermissionBadResponse',
      defaultMessage: 'Bad response',
      description:
        'ConnectedNewsletterSubscribeForm component bad response message'
    } */
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 53167:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const ConnectedNewsletterSubscribeForm = __webpack_require__(55235);
ConnectedNewsletterSubscribeForm.SliceInline = asVariation(ConnectedNewsletterSubscribeForm, 'SliceInline', {
    isSlice: true,
    slicePosition: 'inline',
    variationDisplayName: 'Newsletter Slice Inline'
});
module.exports = ConnectedNewsletterSubscribeForm;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 27529:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled } = __webpack_require__(92168);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const ContributorBio = __webpack_require__(65920);
const TagCloud = __webpack_require__(6494);
const RecircList = __webpack_require__(10281);
const MagazineDisclaimer = __webpack_require__(24010);
const ConnectedNewsletterSubscribeForm = __webpack_require__(577);
const CNEVideoEmbed = __webpack_require__(59098);
const { BREAKPOINTS } = __webpack_require__(96472);
const { ContributorSpotlightInnerContainer, ContributorSpotlightContainer, ContributorSpotlightSummaryGrid } = __webpack_require__(5676);
const { ContributorSpotlightMainSectionGrid } = __webpack_require__(12378);
const { FeaturedStoriesGrid, FeaturedStoriesSectionTitle } = __webpack_require__(30259);
const { FeaturedStoriesCarousel } = __webpack_require__(74898);
const { SummaryCarouselRow } = __webpack_require__(34751);
const { ContributorGrid } = __webpack_require__(24283);
const { ResponsiveImageContainer } = __webpack_require__(7228);
const { ToutWrapper } = __webpack_require__(15956);
const { GridWrapper, GridItem } = __webpack_require__(40653);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorToken, getTypographyStyles, minScreen, minMaxScreen, styledProperty } = __webpack_require__(26865);
const { universalGridCore } = __webpack_require__(89085);
const SeriesNavigation = __webpack_require__(78118);
const ContentFooterNewsletterForm = styled(ConnectedNewsletterSubscribeForm).withConfig({ displayName: 'ContentFooterNewsletterForm' }) ``;
const ContentFooterContributorSpotlightWrapper = styled.div.withConfig({
    displayName: 'ContentFooterContributorSpotlightWrapper'
}) `
  ${universalGridCore()}
  ${applyGridSpacing('padding')}
  ${GridItem} {
    :nth-of-type(1) {
      grid-column: 2 / span 6;
    }

    :nth-of-type(2) {
      grid-column: 2 / span 6;
    }
  }
  ${ContributorSpotlightMainSectionGrid} {
    display: block;
  }
  ${ContributorGrid} {
    border-top: ${calculateSpacing(0.125)} solid;
    border-bottom: ${calculateSpacing(0.125)} solid
      ${getColorToken('colors.foundation.menu.dividers')};
    padding: ${calculateSpacing(4)} 0 ${calculateSpacing(2)} 0;
  }
  ${FeaturedStoriesGrid} {
    border-bottom: ${calculateSpacing(0.125)} solid;
    padding: 0 0 ${calculateSpacing(4)} 0;
  }
  ${ContributorSpotlightInnerContainer} {
    border-bottom: none;
  }
  ${ContributorSpotlightContainer} {
    grid-column: 1 / -1;
    padding-right: 0;
    padding-left: 0;

    ${({ isAdRail }) => !isAdRail &&
    `
      ${minScreen(BREAKPOINTS.md)} {
        grid-column: 3 / span 8;
      }`}

    ${({ isAdRail }) => isAdRail &&
    `
      ${minScreen(BREAKPOINTS.lg)} {
              grid-column: 2 / span 6;
            }`}
  }
  ${ContributorSpotlightSummaryGrid} {
    padding-bottom: 0;
  }
  ${FeaturedStoriesSectionTitle} {
    margin-top: ${calculateSpacing(2)};
    ${minScreen(BREAKPOINTS.lg)} {
      margin-top: 0;
    }
  }
  ${FeaturedStoriesCarousel} {
    margin-bottom: 0;
    border-bottom: ${calculateSpacing(0.125)} solid;
    padding-bottom: ${calculateSpacing(2)};
  }
  ${SummaryCarouselRow} {
    padding-bottom: 0;
  }
  ${ToutWrapper} {
    ${minScreen(BREAKPOINTS.lg)} {
      margin-top: ${calculateSpacing(4)};
      border-top: none;
      padding-top: 0;
    }
  }
`;
const ContentFooterBottom = styled.div.withConfig({
    displayName: 'ContentFooterBottom'
}) `
  .newsletter-subscribe-form {
    padding: ${calculateSpacing(6)} ${calculateSpacing(4)};

    ${minScreen(BREAKPOINTS.md)} {
      padding: ${calculateSpacing(8)} ${calculateSpacing(4)};
    }
  }

  .newsletter-subscribe-form__hed {
    padding-bottom: 0;
  }
`;
const ContentFooterMagazineDisclaimer = styled(MagazineDisclaimer).withConfig({
    displayName: 'ContentFooterMagazineDisclaimer'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.description-embed')}
  margin: ${calculateSpacing(-1)} 0 ${calculateSpacing(4)} 0;
  color: ${getColorToken('colors.consumption.body.standard.body')};

  a:hover,
  a:link,
  a:visited {
    text-decoration: underline;
    color: ${getColorToken('colors.consumption.body.standard.body')};
  }
`;
const getTopSpacingFooterRelated = css `
  margin-top: ${calculateSpacing(6)};
  ${minScreen(BREAKPOINTS.md)} {
    margin-top: ${calculateSpacing(8)};
  }
`;
const ContentFooterRelated = styled(RecircList).withConfig({
    displayName: 'ContentFooterRelated'
}) `
  ${styledProperty('hasFullBleedRecircBackground', true, `
      background-color: ${getColorToken('discovery.lead.secondary.background')};
    `)}
  ${({ hasTopSpacingFooterRelated }) => hasTopSpacingFooterRelated && getTopSpacingFooterRelated}
  .recirc-list--high-density {
    ${minMaxScreen('0px', BREAKPOINTS.md)} {
      margin-top: ${calculateSpacing(2)};
    }
  }

  .rubric.summary-item__rubric a.rubric__link {
    text-decoration: none;
  }
`;
const ContentFooterRelatedVideo = styled.div.withConfig({
    displayName: 'ContentFooterRelatedVideo'
}) `
  border-top: 2px solid ${getColorToken('colors.discovery.body.white.divider')};
  border-bottom: 2px solid
    ${getColorToken('colors.discovery.body.white.divider')};
  padding: ${calculateSpacing(2)} 0;
`;
const ContentFooterRelatedVideoHeader = styled(BaseText).withConfig({
    displayName: 'ContentFooterRelatedVideoHeader'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-tertiary')};
  color: ${getColorToken('colors.discovery.body.white.heading')};
`;
const ContentFooterRelatedPlayer = styled(CNEVideoEmbed).withConfig({
    displayName: 'ContentFooterRelatedPlayer'
}) `
  margin: ${calculateSpacing(2)} 0;
`;
const ContentFooterRelatedVideoTitle = styled(BaseText).withConfig({
    displayName: 'ContentFooterRelatedVideoTitle'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-primary')};
  color: ${getColorToken('colors.discovery.body.white.heading')};
`;
const ContentFooterRelatedVideoDek = styled(BaseText).withConfig({
    displayName: 'ContentFooterRelatedVideoDek'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.description-core')};
  margin-top: ${calculateSpacing(1)};
  color: ${getColorToken('colors.discovery.body.white.description')};
`;
const ContentFooterTagCloud = styled(TagCloud).withConfig({
    displayName: 'ContentFooterTagCloud'
}) `
  grid-column: 1 / span 4;

  ${minScreen(BREAKPOINTS.md)} {
    grid-column: 3 / span 8;
  }
`;
const ContentFooterContributorBio = styled(ContributorBio).withConfig({
    displayName: 'ContentFooterContributorBio'
}) `
  .contributor-bio__content {
    color: ${getColorToken('colors.consumption.body.standard.body-deemphasized')};
  }

  .contributor-bio__responsive-image {
    margin-right: ${calculateSpacing(3)};

    .responsive-image,
    ${ResponsiveImageContainer} {
      all: initial;
      max-width: 90px;
    }
  }
`;
const ReadMoGrid = styled.div.withConfig({ displayName: 'ReadMoGrid' }) `
  ${cssVariablesGrid()}
  ${applyGridSpacing('padding')}

  display: grid;
  grid-template-columns: repeat(4, 1fr);
  column-gap: var(--grid-gap);
  margin: 0 auto;
  width: 100%;
  max-width: none;
  row-gap: var(--grid-gap);

  ${minScreen(BREAKPOINTS.md)} {
    grid-template-columns: repeat(12, 1fr);
  }
`;
const ReadMoGridColumn = styled.div.withConfig({
    displayName: 'ReadMoGridColumn'
}) `
  grid-column: 1 / span 4;

  ${minScreen(BREAKPOINTS.md)} {
    grid-column: 3 / span 8;
  }
`;
const ContentFooterNewsletterContentWrapper = styled.div.withConfig({
    displayName: 'ContentFooterNewsletterContentWrapper'
}) `
  ${({ isNewsletterFullBleed }) => isNewsletterFullBleed &&
    css `
      &:first-child {
        background: ${getColorToken('colors.consumption.lead.standard.background')};

        .newsletter-subscribe-form {
          grid-column: 1 / -1;
          ${minScreen(BREAKPOINTS.md)} {
            grid-column: 3 / span 8;
          }
          ${minScreen(BREAKPOINTS.lg)} {
            grid-column: 4 / span 6;
          }
        }
      }
    `}

  ${({ isNewsletterFullBleed, newsletterPalette }) => isNewsletterFullBleed &&
    newsletterPalette === 'inverted' &&
    css `
      &:first-child {
        background-color: ${getColorToken('colors.foundation.footer.bg')};
      }
    `}

  ${GridWrapper}

 > :not(.grid-layout__content) {
    display: contents;
  }
`;
const ContentFooterWrapper = styled.div.withConfig({
    displayName: 'ContentFooterWrapper'
}) `
  @media print {
    .content-footer__bottom {
      display: none;
    }

    .content-footer {
      .grid {
        display: block;
      }
    }
  }

  ${ContentFooterNewsletterForm}.newsletter-slice {
    /* help with spacing around the newsletter slice in content footer */
    margin-top: ${calculateSpacing(5)};
    margin-bottom: ${calculateSpacing(-5)};
  }

  &.content-footer--mobile-truncated {
    ${ContentFooterNewsletterForm} {
      display: none;
    }
  }

  .contributors,
  .linkstack,
  ${ContentFooterRelatedVideo},
    ${ContentFooterMagazineDisclaimer},
    ${ContentFooterNewsletterForm} {
    grid-column: 1 / -1;

    ${minScreen(BREAKPOINTS.md)} {
      grid-column: 3 / span 8;

      &.grid--item.grid-columns--start-2-end-10 {
        grid-column-end: 10;
        grid-column-start: 2;
      }
    }
  }

  ${({ isNarrow }) => isNarrow &&
    `
      .contributors,
      .linkstack,
      ${ContentFooterRelatedVideo},
      ${ContentFooterMagazineDisclaimer},
      ${ContentFooterNewsletterForm},
      ${ReadMoGridColumn},
      ${ContentFooterTagCloud} {
        ${minScreen(BREAKPOINTS.md)} {
          grid-column: 4 / span 6;
        }
      }
  `}
`;
const ContentWrapperGrid = styled.div.withConfig({
    displayName: 'ContentWrapperMarginGrid'
}) `
  ${universalGridCore()}
`;
const ContentFooterSeriesNavigation = styled(SeriesNavigation).withConfig({
    displayName: 'ContentFooterSeriesNavigation'
}) `
  padding-top: ${calculateSpacing(6)};
`;
module.exports = {
    ContentFooterWrapper,
    ContentFooterRelatedVideo,
    ContentFooterContributorBio,
    ContentFooterTagCloud,
    ContentFooterRelated,
    ContentFooterMagazineDisclaimer,
    ContentFooterBottom,
    ContentFooterNewsletterForm,
    ContentFooterRelatedVideoHeader,
    ContentFooterRelatedPlayer,
    ContentFooterRelatedVideoTitle,
    ContentFooterContributorSpotlightWrapper,
    ContentFooterRelatedVideoDek,
    ContentFooterNewsletterContentWrapper,
    ReadMoGrid,
    ReadMoGridColumn,
    ContentWrapperGrid,
    ContentFooterSeriesNavigation
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 24283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { roundImageBase } = __webpack_require__(52027);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const { calculateSpacing, getColorStyles, getColorToken, getTypographyStyles, getLinkStyles, minScreen } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const { BaseLink } = __webpack_require__(60881);
const ResponsiveAsset = __webpack_require__(73275);
const SocialIcons = __webpack_require__(35676);
const { SocialIconExternalLink, SocialIconsList } = __webpack_require__(51000);
const Clamp = __webpack_require__(48286);
const { ButtonLabel } = __webpack_require__(18974);
const { ToutHed, ToutDek } = __webpack_require__(15956);
/// minimum width for scaling avatar images
/// set as pixels to ensure predictable limits no matter what the root-em
/// @type pixels
const ContributorHeaderAvatarMinWidth = '126px';
/// maximum width for scaling avatar images
/// set as pixels to ensure predictable limits no matter what the root-em
/// @type pixels
const ContributorHeaderAvatarMaxWidth = '200px';
const getBioTypography = () => css `
  ${({ enableFictionContributor, isDenseHeader, isFeaturedAuthor, theme }) => {
    return enableFictionContributor || isFeaturedAuthor || isDenseHeader
        ? css `
          ${getTypographyStyles(theme, 'typography.definitions.discovery.description-feature')}
        `
        : css `
          ${getTypographyStyles(theme, 'typography.definitions.discovery.description-page')}
        `;
}}
`;
// 1. Imports Discovery Page Hed Section typography styles. Returns: font-family, font-size, font-weight, font-style, font-variant-ligatures, text-transform, letter-spacing. See discovery.scss for complete list of variables and mixins.
const ContributorHeaderName = styled(BaseText).withConfig({
    displayName: 'ContributorHeaderName'
}) `
  ${({ isDenseHeader, theme }) => isDenseHeader
    ? getTypographyStyles(theme, 'typography.definitions.discovery.hed-break-out')
    : getTypographyStyles(theme, 'typography.definitions.discovery.page-hed-subsection')};

  margin-top: 0;
  margin-bottom: ${calculateSpacing(1)};

  ${({ shouldRemoveNameMargin }) => shouldRemoveNameMargin && `margin: 0;`}
  color: ${({ theme }) => getColorToken(theme, 'colors.discovery.lead.secondary.hed')};
`;
ContributorHeaderName.defaultProps = {
    as: 'h1'
};
// 1. Imports Global Editorial Accreditation Feature typography styles. Returns: font-family, font-size, font-weight, font-style, font-variant-ligatures, text-transform, letter-spacing. See discovery.scss for complete list of variables and mixins.
const ContributorHeaderTitle = styled(BaseText).withConfig({
    displayName: 'ContributorHeaderTitle'
}) `
  margin-top: 0;
  margin-bottom: ${calculateSpacing(3)};

  ${({ isDenseHeader, theme }) => isDenseHeader
    ? `
      color: ${getColorToken(theme, 'colors.discovery.lead.secondary.description')};/* 1 */
      margin-bottom: 0px;
      `
    : `
     color:${getColorToken(theme, 'colors.discovery.lead.secondary.accent')}; /* 1 */
    `}
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-feature')};
`;
ContributorHeaderTitle.defaultProps = {
    as: 'h2'
};
// 1. Imports Discovery Description Page typography styles. Returns: font-family, font-size, font-weight, font-style, font-variant-ligatures, text-transform, letter-spacing. See discovery.scss for complete list of variables and mixins.
const ContributorHeaderBio = styled.div.withConfig({
    displayName: 'ContributorHeaderBio'
}) `
  ${getBioTypography()};

  ${({ contributorBioAlignment }) => contributorBioAlignment !== 'default' &&
    `text-align: ${contributorBioAlignment};`}

  margin-top: 0;
  margin-bottom: 1rem;

  ${({ theme, descriptionToken = 'colors.discovery.lead.secondary.description' }) => getColorStyles(theme, 'color', descriptionToken)};

  ${({ isDenseHeader, theme }) => !isDenseHeader &&
    `
  a {
    ${getLinkStyles(theme, 'colors.discovery.lead.secondary.link', 'colors.discovery.lead.secondary.link-hover')}
  }`}

  ${({ isFeaturedAuthor }) => isFeaturedAuthor &&
    `
    > p {
      margin-top: ${calculateSpacing(2)};
      margin-bottom: ${calculateSpacing(2)};
    }
  `}
  ${({ isDenseHeader, theme }) => isDenseHeader &&
    `
  margin-bottom: 0;
  margin-top:${calculateSpacing(2)};

  > p {
    margin-bottom: 0px;
  }
  a {
    ${getLinkStyles(theme, 'colors.discovery.body.light.accent', 'colors.discovery.lead.secondary.link-hover', 'global')}
  }
  
`}
`;
// 1. Imports Consumption Editorial Body Core typography styles. Returns: font-family, font-size, font-weight, font-style, font-variant-ligatures, text-transform, letter-spacing. See consumption_editorial.scss for complete list of variables and mixins.
// 2. Adds pipe character between website and email
const ContributorHeaderShortBio = styled.div.withConfig({
    displayName: 'ContributorHeaderShortBio'
}) `
  margin-top: 0;
  margin-bottom: 1rem;
  color: ${({ theme }) => getColorToken(theme, 'colors.discovery.lead.secondary.description')};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.body-core')}; /* 1 */
  a {
    ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', null)}
  }

  a + a {
    margin-left: 1rem; /* 2 */
    border-left: 1px solid;
    padding-left: 1rem;
  }
`;
const ContributorDenseHeaderWrapper = styled.div.withConfig({
    displayName: 'ContributorDenseHeaderWrapper'
}) `
  display: grid;
  ${({ isImage }) => {
    if (isImage) {
        return css `
        grid-template-columns: ${calculateSpacing(10.5)} auto;
      `;
    }
    return css `
      grid-template-columns: auto auto;
    `;
}}
`;
const ContributorNameAndTitleWrapper = styled.div.withConfig({
    displayName: 'ContributorNameAndTitleWrapper'
}) `
  ${({ isDenseHeader }) => isDenseHeader &&
    `grid-column: auto;
      min-width: 0;`}
`;
const ContributorHeaderSocialIcons = styled(SocialIcons).withConfig({
    displayName: 'ContributorHeaderSocialIcons'
}) `
  .contributor-header__social-icons {
    ${SocialIconsList} {
      @media (min-width: ${BREAKPOINTS.md}) {
        justify-content: flex-start;
      }
    }
  }
  ${SocialIconsList} {
    justify-content: center;
    @media (min-width: ${BREAKPOINTS.md}) {
      justify-content: flex-start;
    }

    ${SocialIconExternalLink} {
      .icon {
        path {
          fill: ${({ theme }) => getColorToken(theme, 'colors.discovery.lead.secondary.link')};
        }
      }

      &:hover {
        .icon {
          path {
            fill: ${({ theme }) => getColorToken(theme, 'colors.discovery.lead.secondary.link-hover')};
          }
        }
      }
    }
  }
`;
const ContributorGrid = styled.div.withConfig({
    displayName: 'ContributorGrid'
}) `
  ${cssVariablesGrid()}
  ${applyGridSpacing('padding')}
  ${({ hasLeftAlignedHeader }) => hasLeftAlignedHeader && `margin: 0 auto;`}
  ${({ shouldApplyMaxWidth }) => shouldApplyMaxWidth && `max-width: ${BREAKPOINTS.xxl};`}
  ${({ hasPaddingTop }) => hasPaddingTop && `padding-top: ${calculateSpacing(8)};`}             
                
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  column-gap: var(--grid-gap);
  padding-bottom: ${calculateSpacing(8)};
  width: 100%;
  text-align: center;
  row-gap: var(--grid-gap);

  ${minScreen(BREAKPOINTS.md)} {
    grid-template-columns: repeat(12, 1fr);
    justify-items: auto;
    text-align: inherit;
  }
`;
const ContributorHeaderWrapper = styled.div.withConfig({
    displayName: 'ContributorHeaderWrapper'
}) `
  ${({ enableFictionContributor, theme }) => {
    if (enableFictionContributor) {
        return (theme &&
            `background: ${getColorToken(theme, 'colors.discovery.lead.primary.background')}`);
    }
    return (theme &&
        `background: ${getColorToken(theme, 'colors.discovery.lead.secondary.background')}`);
}}
`;
const ContributorAvatarImageWrapper = styled.div.withConfig({
    displayName: 'ContributorAvatarImageWrapper'
}) `
  grid-column: 1 / -1;
  justify-self: center;

  ${({ theme, hasAvatarImageBackground }) => hasAvatarImageBackground
    ? css `
          background: ${getColorToken(theme, 'colors.discovery.lead.secondary.background')};
          border-radius: 50%;
        `
    : `background: ${getColorToken(theme, 'colors.discovery.lead.primary.background')};`}

  ${minScreen(BREAKPOINTS.md)} {
    align-self: start;

    ${({ ledeAlignment }) => ledeAlignment === 'center'
    ? 'grid-column: 5 / span 4;'
    : 'grid-column: 1 / span 3;'}

    ${({ hasLeftAlignedHeader }) => hasLeftAlignedHeader &&
    `
        grid-column: 1 / span 3;
        justify-self: auto;
        min-width: ${ContributorHeaderAvatarMinWidth};
        max-width: ${ContributorHeaderAvatarMaxWidth};
        margin-left: auto;
        margin-right: auto;
      `}
  }
`;
const ContributorAvatarImage = styled(ResponsiveAsset).withConfig({
    displayName: 'ContributorAvatarImage'
}) `
  img {
    width: 100%;
    min-width: ${ContributorHeaderAvatarMinWidth};
    max-width: ${ContributorHeaderAvatarMaxWidth};
  }

  ${({ avatarImageShape }) => avatarImageShape === 'round'
    ? roundImageBase('100%', ContributorHeaderAvatarMinWidth, ContributorHeaderAvatarMaxWidth)
    : ''}

  ${({ hasSmallAvatar }) => hasSmallAvatar ? `width: ${ContributorHeaderAvatarMinWidth}` : ''}
`;
const ContributorLogo = styled(ResponsiveAsset).withConfig({
    displayName: 'ContributorLogo'
}) `
  grid-column: auto;

  img {
    margin-right: ${calculateSpacing(2.5)};
    border-radius: 50%;
    width: ${calculateSpacing(8)};
    height: ${calculateSpacing(8)};
  }
`;
const headerContentCenter = css `
  grid-column: 1 / -1;
  text-align: center;

  ${SocialIconsList} {
    justify-content: center;
  }

  ${minScreen(BREAKPOINTS.md)} {
    grid-column: 4 / span 6;

    ${({ isContributorImageEmpty, isFeaturedAuthor }) => isFeaturedAuthor &&
    isContributorImageEmpty &&
    `
        grid-column: 1 / span 6;
      `}
  }
`;
const headerContentDefault = css `
  grid-column: 1 / -1;

  ${minScreen(BREAKPOINTS.md)} {
    grid-column: 4 / span 8;

    ${({ isContributorImageEmpty, isFeaturedAuthor }) => isFeaturedAuthor &&
    isContributorImageEmpty &&
    `
        grid-column: 1 / span 8;
      `}
  }

  ${minScreen(BREAKPOINTS.lg)} {
    grid-column: 4 / span 6;

    ${({ hasLeftAlignedHeader }) => hasLeftAlignedHeader && `grid-column: 4 / span 6;`}

    ${({ isContributorImageEmpty, isFeaturedAuthor }) => isFeaturedAuthor &&
    isContributorImageEmpty &&
    `
        grid-column: 1 / span 6;
      `}
  }
`;
const applyContributorReadMore = ({ showReadMore }) => {
    if (showReadMore) {
        return `
      font-size: ${calculateSpacing(1.5)};
    `;
    }
    return '';
};
const ContributorHeaderContent = styled.div.withConfig({
    displayName: 'ContributorHeaderContent'
}) `
  ${({ ledeAlignment }) => ledeAlignment === 'center' ? headerContentCenter : headerContentDefault}
  ${({ hasBorders, theme }) => hasBorders &&
    `
  padding-top: ${calculateSpacing(4)};
  padding-bottom: ${calculateSpacing(4)};
  border-width: 1px 0;
  border-style: solid;
  border-bottom-style: ridge;
  ${getColorStyles(theme, 'border-top-color', 'colors.consumption.lead.standard.divider')};
`}
${ToutHed}, ${ToutDek} {
    color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.description')};
  }
`;
const ContributorHeaderBioClamp = styled(Clamp).withConfig({
    displayName: 'ContributorHeaderBioClamp'
}) `
  ${({ enableFictionContributor, breakpoint }) => enableFictionContributor &&
    css `
      ${minScreen(BREAKPOINTS[breakpoint])} {
        button {
          display: none;
        }
      }
    `}

  ${({ contributorBioAlignment }) => contributorBioAlignment !== 'default' &&
    `text-align: ${contributorBioAlignment};`}

  ${ButtonLabel}:hover {
    text-decoration: underline;
  }
`;
const ContributorHeaderSeeMoreLink = styled(BaseLink).withConfig({
    displayName: 'ContributorHeaderSeeMoreLink'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
  ${applyContributorReadMore}
  display: inline-block;
`;
ContributorHeaderSeeMoreLink.defaultProps = {
    as: 'a',
    colorStaticLinkToken: 'colors.discovery.body.light.accent',
    colorToken: null,
    linkStyle: 'global',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
module.exports = {
    ContributorHeaderWrapper,
    ContributorGrid,
    ContributorAvatarImage,
    ContributorAvatarImageWrapper,
    ContributorHeaderContent,
    ContributorHeaderName,
    ContributorHeaderTitle,
    ContributorHeaderShortBio,
    ContributorHeaderBio,
    ContributorHeaderBioClamp,
    ContributorHeaderSocialIcons,
    ContributorHeaderSeeMoreLink,
    ContributorDenseHeaderWrapper,
    ContributorNameAndTitleWrapper,
    ContributorLogo
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 30259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeaturedStoriesGrid = exports.FeaturedStoriesSectionTitle = exports.FeaturedStoriesList = void 0;
const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles, maxScreen, minScreen, getColorToken } = __webpack_require__(26865);
const { maxThresholds } = __webpack_require__(99906);
const { BREAKPOINTS } = __webpack_require__(96472);
const SectionTitle = __webpack_require__(35864);
const SummaryList = __webpack_require__(22539);
const { SummaryItemWrapper } = __webpack_require__(63637);
const { SummaryItemBylineWrapper } = __webpack_require__(277);
const { SummaryItemContent, SummaryItemDek, SummaryItemAssetContainer } = __webpack_require__(68116);
const { SummaryItemHedBase } = __webpack_require__(36211);
const FeaturedStoriesList = styled(SummaryList).withConfig({
    displayName: 'FeaturedStoriesList'
}) ``;
exports.FeaturedStoriesList = FeaturedStoriesList;
const FeaturedStoriesGrid = styled.section.withConfig({
    displayName: 'FeaturedStoriesGrid'
}) `
  ${maxScreen(`${maxThresholds.md}px`)} {
    display: none;
  }
  ${FeaturedStoriesList} {
    padding: 0;

    ${SummaryItemAssetContainer} {
      ${minScreen(BREAKPOINTS.md)} {
        width: ${calculateSpacing(15, 'px')};
        height: ${calculateSpacing(11.25, 'px')};
      }
      width: ${calculateSpacing(10, 'px')};
      height: ${calculateSpacing(7.5, 'px')};
    }

    ${SummaryItemWrapper} {
      display: grid;
      grid-template-areas: 'image content';
      grid-template-columns: ${calculateSpacing(7.5)} auto;
      margin-bottom: ${calculateSpacing(2)};
      padding-bottom: ${calculateSpacing(2)};
      gap: ${calculateSpacing(4)};
      ${minScreen(BREAKPOINTS.md)} {
        gap: ${calculateSpacing(10)};
        margin-bottom: ${calculateSpacing(1)};
      }

      :last-of-type {
        margin-bottom: 0;
        border-bottom: 0;
        padding-bottom: 0;
      }
    }

    ${SummaryItemContent} {
      padding-top: 0;

      ${SummaryItemHedBase} {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
      }

      ${SummaryItemDek} {
        margin: 0;
      }

      ${SummaryItemBylineWrapper} {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-tertiary')};
        display: flex;
        align-items: center;
        padding-top: ${calculateSpacing(0.625, 'px')};
      }
    }
  }
`;
exports.FeaturedStoriesGrid = FeaturedStoriesGrid;
const FeaturedStoriesSectionTitle = styled(SectionTitle).withConfig({
    displayName: 'FeaturedStoriesSectionTitle'
}) `
  ${minScreen(BREAKPOINTS.md)} {
    margin-top: ${calculateSpacing(5)};
    border-bottom-width: 1px;
  }

  h2 {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};
    justify-self: start;
    width: 444.8px;
    height: 18px;
    color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.context-tertiary')};
  }

  ${maxScreen(BREAKPOINTS.md)} {
    margin-bottom: ${calculateSpacing(1)};
  }

  ${minScreen(BREAKPOINTS.md)} {
    margin-bottom: ${calculateSpacing(2)};
  }
`;
exports.FeaturedStoriesSectionTitle = FeaturedStoriesSectionTitle;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 12378:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContributorSpotlightMainSectionGrid = void 0;
const grid_1 = __importDefault(__webpack_require__(86659));
const styles_1 = __webpack_require__(40653);
const { default: styled } = __webpack_require__(92168);
const { minScreen, maxScreen, calculateSpacing, getColorToken } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { maxThresholds } = __webpack_require__(99906);
const { ContributorHeaderContent, ContributorGrid } = __webpack_require__(24283);
const { ToutWrapper } = __webpack_require__(15956);
const ContributorSpotlightMainSectionGrid = styled(grid_1.default.NoMarginsTwoUp).withConfig({
    displayName: 'ContributorSpotlightMainSectionGrid'
}) `
  ${maxScreen(`${maxThresholds.lg}px`)} {
    && {
      display: unset;
    }
  }

  > ${styles_1.GridItem} {
    :nth-of-type(1) {
      text-align: left;

      ${({ hasFeaturedStories }) => !hasFeaturedStories &&
    `
    grid-column: 4/ span 6;
  `}
    }

    :nth-of-type(2) {
      display: flex;
      flex-direction: column;
      justify-content: space-between;

      ${minScreen(BREAKPOINTS.xxl)} {
        grid-column: span 5;
      }
    }
  }
  ${ContributorHeaderContent} {
    grid-column: 1 / span 12;
    text-align: left;
  }

  ${ContributorGrid} {
    padding: ${calculateSpacing(6)} 0 0 0;
    ${maxScreen(BREAKPOINTS.lg)} {
      border-bottom: ${calculateSpacing(0.125)} solid
        ${getColorToken('colors.foundation.menu.dividers')};
      padding: ${calculateSpacing(8)} 0 ${calculateSpacing(4)} 0;
    }
  }

  ${ToutWrapper} {
    ${minScreen(BREAKPOINTS.lg)} {
      margin-top: ${calculateSpacing(3)};
      border-top: ${calculateSpacing(0.125)} solid
        ${getColorToken('colors.foundation.menu.dividers')};
      padding-top: ${calculateSpacing(2)};
    }
  }
`;
exports.ContributorSpotlightMainSectionGrid = ContributorSpotlightMainSectionGrid;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 74898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeaturedStoriesCarousel = exports.FeaturedStoriesSectionTitle = void 0;
const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles, minScreen, maxScreen, getColorToken } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const SectionTitle = __webpack_require__(35864);
const { RubricWrapper } = __webpack_require__(6613);
const { SummaryItemContent } = __webpack_require__(68116);
const { CarouselListButton, CarouselWrapper } = __webpack_require__(44802);
const { SummaryCarousel, SummaryCarouselRow } = __webpack_require__(34751);
const FeaturedStoriesSectionTitle = styled(SectionTitle).withConfig({
    displayName: 'FeaturedStoriesSectionTitle'
}) `
  padding-bottom: 0;
  ${maxScreen(BREAKPOINTS.md)} {
    margin-top: ${calculateSpacing(3)};
    border-bottom-width: 1px;
  }

  h2 {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};
    justify-self: start;
    width: 444.8px;
    height: 18px;
    color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.context-tertiary')};
  }
`;
exports.FeaturedStoriesSectionTitle = FeaturedStoriesSectionTitle;
const FeaturedStoriesCarousel = styled.section.withConfig({
    displayName: 'FeaturedStoriesCarousel'
}) `
  ${SummaryCarousel} {
    ul {
      margin-right: ${calculateSpacing(-3)};
      margin-left: ${calculateSpacing(-3)};

      li {
        width: 60%;

        &:last-child {
          padding-right: ${calculateSpacing(3)};
        }
      }
    }
  }
  ${SummaryCarouselRow} {
    padding-bottom: 0;
  }

  ${minScreen(BREAKPOINTS.md)} {
    display: none;
  }

  ${CarouselListButton} {
    display: none;
  }
  ${CarouselWrapper} {
    margin-bottom: 0;
  }
  ${RubricWrapper} {
    display: none;
  }

  ${SummaryItemContent} {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
  }
`;
exports.FeaturedStoriesCarousel = FeaturedStoriesCarousel;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 5676:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContributorSpotlightSummaryGrid = exports.ContributorSpotlightSectionTitle = exports.ContributorSpotlightSingleColumn = exports.ContributorSpotlightInnerContainer = exports.ContributorSpotlightContainer = exports.SpotlightMainFeatureHeader = void 0;
const layout_1 = __webpack_require__(1123);
const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getColorToken, getTypographyStyles, getLinkStyles, minScreen, getSectionSpacingStyling } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const SectionTitle = __webpack_require__(35864);
const { SectionTitleDek } = __webpack_require__(33500);
const ContributorSpotlightContainer = styled.section.withConfig({
    displayName: 'ContributorSpotlightContainer'
}) `
  padding: ${calculateSpacing(3)};

  ${minScreen(BREAKPOINTS.md)} {
    ${({ hasConsistentSpacing, theme }) => {
    if (hasConsistentSpacing &&
        getSectionSpacingStyling(theme, 'gap-md') !== '0px') {
        return `padding-top: 0; padding-bottom: 0`;
    }
    return `padding-top: ${calculateSpacing(4)};
      padding-bottom: ${calculateSpacing(4)};`;
}}
  }

  ${(0, layout_1.cssVariablesGrid)()}
  ${(0, layout_1.applyGridSpacing)('padding')}
`;
exports.ContributorSpotlightContainer = ContributorSpotlightContainer;
const ContributorSpotlightInnerContainer = styled.div.withConfig({
    displayName: 'ContributorSpotlightInnerContainer'
}) `
  margin: 0 auto;
  border-bottom: ${calculateSpacing(0.125, 'px')} solid;
  max-width: calc(${BREAKPOINTS.xxl} - (2 * ${calculateSpacing(8)}));
`;
exports.ContributorSpotlightInnerContainer = ContributorSpotlightInnerContainer;
const ContributorSpotlightSingleColumn = styled.div.withConfig({
    displayName: 'ContributorSpotlightSingleColumn'
}) `
  .summary-item {
    width: 100%;
  }
`;
exports.ContributorSpotlightSingleColumn = ContributorSpotlightSingleColumn;
const ContributorSpotlightSectionTitle = styled(SectionTitle).withConfig({
    displayName: 'ContributorSpotlightHeader'
}) `
  display: flex;

  justify-content: center;
  border-top: ${calculateSpacing(0.125, 'px')} solid;
  border-bottom: ${calculateSpacing(0.125)} solid
    ${getColorToken('colors.foundation.menu.dividers')};

  ${SectionTitleDek} {
    margin-top: 0;
    padding-top: 0;
    text-underline-offset: ${calculateSpacing(0.375, 'px')};
    ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.utility-link.default', 'colors.foundation.collapsed-menu.utility-link.hover', 'navigation')};
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
  }
`;
exports.ContributorSpotlightSectionTitle = ContributorSpotlightSectionTitle;
const ContributorSpotlightSummaryGrid = styled.section.withConfig({
    displayName: 'ContributorSpotlightSummaryGrid'
}) `
  display: grid;
  ${(0, layout_1.cssVariablesGrid)()}
  grid-template-areas:
  'stories'
  'body';
  grid-template-columns: repeat(1, 1fr);
  padding-bottom: ${calculateSpacing(3)};

  ${minScreen(BREAKPOINTS.md)} {
    grid-template-areas: 'body';
  }
`;
exports.ContributorSpotlightSummaryGrid = ContributorSpotlightSummaryGrid;
const SpotlightMainFeatureHeader = styled.h2.withConfig({
    displayName: 'SpotlightMainFeatureHeader'
}) `
  margin: 0 auto;
  padding-bottom: ${calculateSpacing(3)};
  text-align: center;
  text-transform: uppercase;

  ${({ theme }) => css `
      ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-feature')}
      ${getColorStyles(theme, 'color', 'colors.discovery.body.brand.heading')};
    `};

  ${minScreen(BREAKPOINTS.lg)} {
    max-width: 80%;
  }
`;
exports.SpotlightMainFeatureHeader = SpotlightMainFeatureHeader;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 44920:
/***/ ((module) => {

/**
 * withRedirect - add the window location as a redirect query parameter
 *
 * Query parameters are stripped from the window location when used as a redirect
 *
 * window location: https://www.wired.com/story/now-physical-jobs-going-remote/
 * target: https://wired.com/auth/initiate =>
 * updated: https://wired.com/auth/initiate?redirectURL=https%3A%2F%2Fwww.wired.com%2Fstory%2Fnow-physical-jobs-going-remote%2F
 *
 * @param {string} url - target URL
 * @returns {string} - updated URL
 */
const withRedirect = (url) => {
    if (!url)
        return url;
    try {
        const updatedURL = new URL(url, window.location.origin);
        const redirectURL = new URL(window.location.pathname, window.location.origin);
        updatedURL.searchParams.set('redirectURL', redirectURL.toString());
        return updatedURL.toString();
    }
    catch {
        return url;
    }
};
module.exports = {
    withRedirect
};
//# sourceMappingURL=URLs.js.map

/***/ }),

/***/ 51806:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const get = __webpack_require__(58156);
const isEqual = __webpack_require__(2404);
const classnames = __webpack_require__(32485);
const connect = __webpack_require__(34967);
const KEEPALIVE_COMPONENTS = {
    NavCTA: true,
    NavDrawer: true
};
/**
 * asJourneyUnit
 *
 * A higher order component that handles rendering of Journey Unit Components.
 *
 * In order for the component to render, the HOC respectively utilizes the data from:
 * - JourneyBus History (window.jBus)
 * - cnBus events
 * - Redux Store / Tenant Config
 *
 * @param {ReactElement} Component - A React component
 * @param {string} [className] - optional class name for journey unit wrapper
 */
const asJourneyUnit = (Component, className) => {
    const { displayName: componentName } = Component;
    const keepAlive = KEEPALIVE_COMPONENTS[componentName];
    const isIntendedComponent = (name) => componentName.split(/[()]/).includes(name);
    class JourneyUnit extends React.Component {
        constructor(props) {
            super(props);
            this.onAppears = (onBehalfOf) => {
                window.cnBus.emit(`journey.component.appears.${onBehalfOf}`, {
                    componentName: onBehalfOf,
                    state: this.state
                });
            };
            let payload = {};
            if (!get(props, 'journey.url')) {
                const components = get(props, 'journey.components', {});
                const { variation, data } = components[componentName] || {};
                if (data)
                    payload = { component: { name: componentName, variation }, data };
            }
            this.state = { payload };
            this.callbacks = [];
            this.isComponentMounted = false;
            if ( false || !window.cnBus)
                return;
            // eslint-disable-next-line no-shadow
            window.cnBus.on('journey.unit.render.begin', (payload) => {
                if ( false || !window.cnBus)
                    return;
                if (payload.renderer !== 'verso')
                    return;
                if (!isIntendedComponent(payload.component?.name))
                    return;
                if (isEqual(this.state.payload, payload))
                    return;
                this.onUpdate(() => {
                    if (!this.isComponentMounted || !this.element)
                        return false;
                    const updatedPayload = {
                        ...payload,
                        element: this.element,
                        keepAlive
                    };
                    window.cnBus.emit('journey.unit.render.end', updatedPayload);
                    return true;
                });
                if (this.isComponentMounted)
                    this.setState({ payload });
            });
            // eslint-disable-next-line no-shadow
            window.cnBus.on('journey.unit.empty.begin', (payload) => {
                if ( false || !window.cnBus)
                    return;
                if (payload.renderer !== 'verso')
                    return;
                if (!isIntendedComponent(payload.component?.name))
                    return;
                if (isEqual(this.state.payload, {}))
                    return;
                this.onUpdate(() => {
                    if (!this.isComponentMounted || this.element !== null)
                        return false;
                    window.cnBus.emit('journey.unit.empty.end', payload);
                    return true;
                });
                if (this.isComponentMounted)
                    this.setState({ payload: {} });
            });
        }
        componentDidMount() {
            this.isComponentMounted = true;
            // Look if the event's been fired before the HOC was mounted
            if (!window.jBus)
                return;
            window.jBus.whenAnEventOccurs({
                id: 'journey.unit.render.begin',
                payload: { component: { name: componentName } },
                callback: ({ payload }) => this.setState({ payload }, () => {
                    const updatedPayload = {
                        ...this.state.payload,
                        element: this.element,
                        keepAlive
                    };
                    if ( false || !window.cnBus)
                        return;
                    window.cnBus.emit('journey.unit.render.end', updatedPayload);
                })
            })();
        }
        componentDidUpdate() {
            // execute callbacks, retaining any that failed to execute for later retrial
            this.callbacks = this.callbacks.filter((callback) => !callback());
        }
        componentWillUnmount() {
            this.isComponentMounted = false;
        }
        onUpdate(callback) {
            this.callbacks.push(callback);
        }
        render() {
            const { payload } = this.state;
            const { component: { name, variation } = {} } = payload;
            if (!isIntendedComponent(name))
                return null;
            const onRenderedToDOM = (element) => {
                this.element = element;
            };
            const ComponentVariation = typeof Component[variation] === 'function'
                ? Component[variation]
                : Component;
            return (React.createElement("div", { ref: onRenderedToDOM, className: classnames('journey-unit__container', {
                    [className]: !!className
                }) },
                React.createElement(ComponentVariation, { ...payload, ...this.props, onAppears: this.onAppears })));
        }
    }
    JourneyUnit.propTypes = {
        journey: PropTypes.shape({
            components: PropTypes.objectOf(PropTypes.shape({
                variation: PropTypes.string,
                data: PropTypes.object.isRequired
            })),
            url: PropTypes.string
        })
    };
    const connected = connect(JourneyUnit, {
        keysToPluck: ['journey']
    });
    connected.wrapped = Component;
    connected.asJourneyUnitApplied = true;
    return connected;
};
module.exports = asJourneyUnit;
//# sourceMappingURL=asJourneyUnit.js.map

/***/ }),

/***/ 19120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useEffect, useState } = React;
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const { Iframe, Wrapper } = __webpack_require__(89116);
const { withRedirect } = __webpack_require__(44920);
const onMessage = (setHeight) => (event) => {
    const { origin } = event;
    if (!event || !event.data || !(origin === window.location.origin)) {
        return;
    }
    const { data: { type, action, height } } = event;
    if (type !== 'Journey' || !action || action !== 'resizeUnit') {
        return;
    }
    if (height < 250 || height > 900) {
        return;
    }
    setHeight(height);
};
const initialize = (setHeight) => {
    const listener = onMessage(setHeight);
    window.addEventListener('message', listener, false);
    return () => window.removeEventListener('message', listener);
};
const ContentBar = ({ data }) => {
    const [height, setHeight] = useState(320);
    useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'ContentBar'
            });
    }, []);
    useEffect(() => {
        return initialize(setHeight);
    }, []);
    return (React.createElement(Wrapper, { iFrameHeight: height },
        React.createElement(Iframe, { ...data.iframe, src: withRedirect(data.iframe.src) })));
};
ContentBar.displayName = 'ContentBar';
ContentBar.propTypes = {
    data: PropTypes.shape({
        iframe: PropTypes.object.isRequired
    })
};
ContentBar.requiredDataFields = ['iframe'];
module.exports = ContentBar;
//# sourceMappingURL=ContentBar.js.map

/***/ }),

/***/ 48536:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const ContentBar = __webpack_require__(19120);
const asJourneyUnit = __webpack_require__(51806);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, asJourneyUnit]);
module.exports = wrap(ContentBar);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 89116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorToken } = __webpack_require__(26865);
const Wrapper = styled.div.withConfig({
    displayName: 'Wrapper'
}) `
  display: flex;
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  flex-direction: column;
  transition: all 0.5s ease-in-out;
  box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, 0.1);
  background-color: ${getColorToken('colors.interactive.base.white')};

  ${({ iFrameHeight }) => iFrameHeight &&
    `height: ${iFrameHeight}px;
  `}
`;
const Iframe = styled.iframe.withConfig({
    displayName: 'Iframe'
}) `
  border: none;
  width: 100%;
  height: 100%;
`;
module.exports = {
    Iframe,
    Wrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 44638:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useEffect, useMemo, useState, useRef } = __webpack_require__(96540);
const classNames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const { Container, TopSection, LargeImage, SmallImage, ContentContainer, Hed, Dek, CTAMobileContainer, CTADesktopContainer, SubscribeBtn, SignInContainer, SignInText, SignInLink, RTBContainer, RTBGrid, RTBRow, RTBBullet, Divider } = __webpack_require__(19053);
const { withRedirect } = __webpack_require__(44920);
const { TrackComponentChannel } = __webpack_require__(78788);
const { withFormatter } = __webpack_require__(98750);
const { withModalFocusTrap } = __webpack_require__(96258);
const Formatted = {
    Hed: withFormatter(Hed),
    Dek: withFormatter(Dek)
};
function CheckSvg() {
    return (React.createElement("svg", { width: "13", height: "13", viewBox: "0 0 13 13", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("path", { d: "M1 8.25L5 10.75L12 0.75", strokeWidth: "2" })));
}
const ExpandedCanvas = ({ data, viewport }) => {
    const containerRef = useRef(null);
    const rtbContainerRef = useRef(null);
    const topSectionRef = useRef(null);
    const rtbs = data.includeRTBs
        ? [data.rtb.one, data.rtb.two, data.rtb.three]
        : [];
    const [showRtbs, setShowRtbs] = useState(false);
    const [maxHeight, setMaxHeight] = useState();
    const determineMaxHeight = () => {
        const rtbContainer = rtbContainerRef.current;
        if (!rtbContainer)
            return undefined;
        const barrierContainer = containerRef.current;
        const topSection = topSectionRef.current;
        const barrierContainerPadding = parseInt(window.getComputedStyle(barrierContainer).paddingTop, 10) * 2;
        const initialHeight = topSection.offsetHeight + barrierContainerPadding;
        return showRtbs ? initialHeight + rtbContainer.offsetHeight : initialHeight;
    };
    useEffect(() => {
        const initializeUnit = () => {
            const rtbContainer = rtbContainerRef.current;
            if (!rtbContainer)
                return;
            const newMaxHeight = determineMaxHeight();
            setMaxHeight(newMaxHeight);
            const adjustMaxHeight = () => {
                const triggerElement = document.querySelector('.body__inner-container:last-child')
                    ?.lastElementChild ||
                    document.querySelector('[data-journey-hook="recipe-content"]')
                        ?.lastElementChild ||
                    document.querySelector('#main-content');
                setShowRtbs(window.scrollY >= triggerElement?.offsetTop);
                const newMaxHeight = determineMaxHeight();
                newMaxHeight && setMaxHeight(newMaxHeight);
            };
            window.addEventListener('scroll', adjustMaxHeight);
        };
        setTimeout(() => {
            initializeUnit();
        }, 100);
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'ExpandedCanvas'
            });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useMemo(() => {
        if (!rtbContainerRef.current)
            return;
        const barrierContainer = containerRef.current;
        const newMaxHeight = determineMaxHeight();
        if (newMaxHeight)
            barrierContainer.style.maxHeight = `${newMaxHeight}px`;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [viewport, showRtbs]);
    return (React.createElement(Container, { "data-testid": "expanded-canvas", ref: containerRef, maxHeight: maxHeight },
        React.createElement(TopSection, { ref: topSectionRef },
            data.img.src && React.createElement(LargeImage, { src: data.img.src, alt: data.img.alt }),
            React.createElement(ContentContainer, null,
                React.createElement(Formatted.Hed, { html: data.hed }),
                data.img.src && React.createElement(SmallImage, { src: data.img.src, alt: data.img.alt }),
                React.createElement(Formatted.Dek, { html: data.dek[viewport] }),
                React.createElement(CTAMobileContainer, null,
                    React.createElement(SubscribeBtn, { className: "cm__subscribe", href: withRedirect(data.cta.url[viewport]) }, data.cta.text[viewport]),
                    React.createElement(SignInContainer, null,
                        React.createElement(SignInText, null,
                            data.signIn.copy,
                            "\u00A0"),
                        React.createElement(SignInLink, { className: "cm__signin", href: withRedirect(data.signIn.cta.url) }, data.signIn.cta.text)))),
            React.createElement(CTADesktopContainer, null,
                React.createElement(SubscribeBtn, { className: "cm__subscribe", href: withRedirect(data.cta.url[viewport]) }, data.cta.text[viewport]),
                React.createElement(SignInContainer, null,
                    React.createElement(SignInText, null,
                        data.signIn.copy,
                        "\u00A0"),
                    React.createElement(SignInLink, { className: "cm__signin", href: withRedirect(data.signIn.cta.url) }, data.signIn.cta.text)))),
        data.includeRTBs && (React.createElement(RTBContainer, { className: classNames({ hidden: !showRtbs }), ref: rtbContainerRef },
            React.createElement(Divider, null),
            React.createElement(RTBGrid, null, rtbs.map((text, index) => (React.createElement(RTBRow, { key: index },
                data.rtbBulletUrl ? (React.createElement(RTBBullet, { src: data.rtbBulletUrl, alt: "RTB bullet" })) : (React.createElement(CheckSvg, null)),
                React.createElement("span", null, text)))))))));
};
ExpandedCanvas.propTypes = {
    data: PropTypes.shape({
        hed: PropTypes.string,
        dek: PropTypes.shape({
            mobile: PropTypes.string,
            tablet: PropTypes.string,
            desktop: PropTypes.string
        }),
        img: PropTypes.shape({
            src: PropTypes.string,
            alt: PropTypes.string
        }),
        cta: PropTypes.shape({
            url: PropTypes.shape({
                mobile: PropTypes.string,
                tablet: PropTypes.string,
                desktop: PropTypes.string
            }),
            text: PropTypes.shape({
                mobile: PropTypes.string,
                tablet: PropTypes.string,
                desktop: PropTypes.string
            })
        }),
        signIn: PropTypes.shape({
            copy: PropTypes.string,
            cta: PropTypes.shape({
                url: PropTypes.string,
                text: PropTypes.string
            })
        }),
        rtbBulletUrl: PropTypes.string,
        rtb: PropTypes.shape({
            one: PropTypes.string,
            two: PropTypes.string,
            three: PropTypes.string
        }),
        includeRTBs: PropTypes.bool
    }),
    viewport: PropTypes.string.isRequired
};
const FocusedExpandedCanvas = withModalFocusTrap(ExpandedCanvas);
FocusedExpandedCanvas.displayName = 'ExpandedCanvas';
FocusedExpandedCanvas.requireDataFields = [
    'hed',
    'dek.desktop',
    'dek.tablet',
    'dek.mobile',
    'cta.url.mobile',
    'cta.url.tablet',
    'cta.url.desktop',
    'cta.text.mobile',
    'cta.text.tablet',
    'cta.text.desktop',
    'signIn.copy',
    'signIn.cta.url',
    'signIn.cta.text',
    'rtb.one',
    'rtb.two',
    'rtb.three',
    'rtbBulletUrl',
    'includeRTBs'
];
module.exports = FocusedExpandedCanvas;
//# sourceMappingURL=ExpandedCanvas.js.map

/***/ }),

/***/ 23043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const ExpandedCanvas = __webpack_require__(44638);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withJourneyTheme } = __webpack_require__(43219);
const wrap = flow([withJourneyTheme, withViewport, asJourneyUnit]);
module.exports = wrap(ExpandedCanvas);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { colorPickerFactory } = __webpack_require__(43219);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText } = __webpack_require__(76955);
const { getTypographyStyles } = __webpack_require__(26865);
const { inTablet } = __webpack_require__(94130);
const colorFor = colorPickerFactory('ExpandedCanvas');
const Container = styled.div.withConfig({
    displayName: 'ExpandedCanvasContainer'
}) `
  display: flex;
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  flex-direction: column;
  transition: all 0.5s ease-in-out;
  box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, 0.1);
  background-color: ${colorFor('background')};
  padding: 32px 20px 24px;
  ${({ maxHeight }) => maxHeight &&
    css `
      max-height: ${maxHeight}px;
    `};

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    padding: 40px 48px;
  }
`;
const TopSection = styled.div.withConfig({
    displayName: 'TopSection'
}) `
  display: flex;
  flex-direction: column;
  align-items: center;
  align-self: center;
  max-width: 1152px;
  gap: 24px;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    flex-direction: row;
  }
  ${inTablet} {
    width: 100%;
  }
  ${`@media(min-width: ${BREAKPOINTS.lg})`} {
    justify-content: space-around;
    gap: 56px;
  }
`;
const LargeImage = styled.img.withConfig({
    displayName: 'LargeImage'
}) `
  display: none;
  width: 207px;
  height: 139px;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    display: block;
  }

  ${`@media(min-width: ${BREAKPOINTS.lg})`} {
    width: 264px;
    height: 186px;
  }
`;
const SmallImage = styled.img.withConfig({
    displayName: 'SmallImage'
}) `
  margin-top: 20px;
  width: 120px;
  height: 80px;
  object-fit: cover;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    display: none;
  }
`;
const ContentContainer = styled.div.withConfig({
    displayName: 'ContentContainer'
}) `
  display: flex;
  flex-direction: column;
  align-items: center;
  font-family: FuturaPT, Arial, Helvetica, sans-serif;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    align-items: flex-start;
  }

  ${inTablet} {
    flex: 1;
  }
`;
const Hed = styled(BaseText).withConfig({
    displayName: 'Hed'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-hed')};
  color: ${colorFor('hed')};
`;
const Dek = styled(BaseText).withConfig({
    displayName: 'Dek'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-body')};
  margin-top: 20px;
  text-align: center;
  color: ${colorFor('dek')};

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    margin-top: 16px;
    text-align: left;
  }

  & mark {
    background: transparent;
    color: ${colorFor('dekMark')};
  }
`;
const CTAMobileContainer = styled.div.withConfig({
    displayName: 'CTAMobileContainer'
}) `
  margin-top: 24px;
  width: 295px;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    margin-top: 16px;
    width: 322px;
  }

  ${`@media(min-width: ${BREAKPOINTS.lg})`} {
    display: none;
  }
`;
const SubscribeBtn = styled.a.withConfig({
    displayName: 'SubscribeBtn'
}) `
  display: block;
  background-color: ${colorFor('ctaButtonBackground')};
  padding: 16px 0;
  width: 100%;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-core')};
  text-align: center;
  text-decoration: none;
  color: ${colorFor('ctaCopy')};

  &:hover {
    text-decoration: underline;
  }
`;
const CTADesktopContainer = styled.div.withConfig({
    displayName: 'CTADesktopContainer'
}) `
  display: none;
  min-width: 322px;

  ${`@media(min-width: ${BREAKPOINTS.lg})`} {
    display: block;
    min-width: 295px;
  }
`;
const SignInContainer = styled.div.withConfig({
    displayName: 'SignInContainer'
}) `
  display: flex;
  justify-content: center;
  margin-top: 8px;
  line-height: 16px;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    justify-content: flex-start;
  }

  ${`@media(min-width: ${BREAKPOINTS.lg})`} {
    justify-content: center;
  }
`;
const SignInText = styled.div.withConfig({
    displayName: 'SignInText'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  color: ${colorFor('signInCopy')};
`;
const SignInLink = styled.a.withConfig({
    displayName: 'SignInLink'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  text-decoration: underline;
  color: ${colorFor('signInLink')};
`;
const RTBContainer = styled.div.withConfig({
    displayName: 'RTBContainer'
}) `
  display: flex;
  flex-direction: column;
  align-self: center;
  transition: opacity 0.5s;
  max-width: 1152px;

  &.hidden {
    opacity: 0;
  }
`;
const Divider = styled.div.withConfig({
    displayName: 'Divider'
}) `
  margin: 24px 0;
  border-bottom: 1px solid ${colorFor('divider')};

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    margin: 40px 0;
  }
`;
const RTBGrid = styled.div.withConfig({
    displayName: 'RTBGrid'
}) `
  display: grid;
  gap: 8px;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 24px;
  }

  ${`@media(min-width: ${BREAKPOINTS.lg})`} {
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 32px;
  }
`;
const RTBRow = styled.div.withConfig({
    displayName: 'RTBRow'
}) `
  display: flex;
  align-items: flex-start;
  gap: 8px;

  & svg {
    flex-shrink: 0;
    margin-top: 4px;
    stroke: ${colorFor('rtbSvg')};
  }

  & span {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
    color: ${colorFor('rtbCopy')};
  }
`;
const RTBBullet = styled.img.withConfig({
    displayName: 'RTBBullet'
}) `
  flex-shrink: 0;
  margin-top: 4px;
  width: 13px;
  height: 13px;
  object-fit: cover;
`;
module.exports = {
    Container,
    TopSection,
    LargeImage,
    SmallImage,
    ContentContainer,
    Hed,
    Dek,
    CTAMobileContainer,
    CTADesktopContainer,
    SubscribeBtn,
    SignInContainer,
    SignInText,
    SignInLink,
    RTBContainer,
    RTBGrid,
    RTBRow,
    RTBBullet,
    Divider
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 64764:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Footer Default component as placeholder when
 * Footer Image is explicitly enabled
 *
 * @returns {JSX.Element} - React Component
 */
const DefaultComponent = () => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'FooterDefault'
            });
    });
    return React.createElement("div", null);
};
DefaultComponent.propTypes = {};
DefaultComponent.displayName = 'Footer';
module.exports = DefaultComponent;
//# sourceMappingURL=Component.js.map

/***/ }),

/***/ 33843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const Component = __webpack_require__(64764);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(Component);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const get = __webpack_require__(58156);
const { useEffect } = __webpack_require__(96540);
const { Anchor, Image } = __webpack_require__(62429);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Footer component - Image variation
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.ctaUrl.mobile - mobile URL
 * @param {string} props.data.ctaUrl.tablet - tablet URL
 * @param {string} props.data.ctaUrl.desktop - desktop URL
 * @param {string} props.data.imageSrc.alt - alternative text
 * @param {string} props.data.imageSrc.mobile - mobile image src
 * @param {string} props.data.imageSrc.tablet - tablet image src
 * @param {string} props.data.imageSrc.desktop - desktop image src
 * @param {string} props.viewport - display viewport
 * @returns {ReactElement} - React Component
 */
const FooterImage = ({ data, viewport }) => {
    const subscribeUrl = get(data, `ctaUrl.${viewport}`);
    const imageSrc = get(data, `imageSrc.${viewport}`);
    const imageAlt = get(data, `imageSrc.alt`);
    const scale = get(data, `imageSrc.scale`);
    useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'FooterImage',
                variation: 'Image'
            });
    });
    return (React.createElement(Anchor, { href: subscribeUrl, target: "_blank", rel: "noreferrer", "aria-label": "Opens in a new window" },
        React.createElement(Image, { alt: imageAlt, src: imageSrc, scale: scale })));
};
FooterImage.displayName = 'Footer.Image';
FooterImage.propTypes = {
    data: PropTypes.shape({
        ctaUrl: PropTypes.shape({
            mobile: PropTypes.string.isRequired,
            tablet: PropTypes.string.isRequired,
            desktop: PropTypes.string.isRequired
        }).isRequired,
        imageSrc: PropTypes.shape({
            alt: PropTypes.string.isRequired,
            scale: PropTypes.bool,
            mobile: PropTypes.string.isRequired,
            tablet: PropTypes.string.isRequired,
            desktop: PropTypes.string.isRequired
        }).isRequired
    }),
    viewport: PropTypes.oneOf(['mobile', 'tablet', 'desktop']).isRequired
};
FooterImage.requireDataFields = [
    'subscribeUrl.desktop',
    'subscribeUrl.tablet',
    'subscribeUrl.mobile',
    'imageSrc.alt',
    'imageSrc.desktop',
    'imageSrc.tablet',
    'imageSrc.mobile'
];
module.exports = FooterImage;
//# sourceMappingURL=Image.js.map

/***/ }),

/***/ 43283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const Image = __webpack_require__(8126);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(Image);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 62429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const Anchor = styled.a.withConfig({
    displayName: 'FooterAnchor'
}) `
  display: flex;
  justify-content: center;
`;
const Image = styled.img.withConfig({
    displayName: 'FooterImage'
}) `
  ${({ scale }) => scale &&
    `
    width: 940px;
    height: 140px;
  
    @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
      width: 276px;
      height: 100px;
    }
    @media (min-width: ${BREAKPOINTS.md}) and (max-width: calc(${BREAKPOINTS.lg} - 1px)) {
      width: 724px;
      height: 190px;
    }`}
`;
module.exports = {
    Anchor,
    Image
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 49289:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Default = __webpack_require__(33843);
const Image = __webpack_require__(43283);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const Footer = Default;
// All Variations
Footer.Image = Image;
module.exports = asJourneyUnit(Footer);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8608:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const Grid = __webpack_require__(86659);
const { ContentFooterNewsletterContentWrapper, ContentFooterNewsletterForm } = __webpack_require__(27529);
/**
 * FooterNewsletter component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.buttonLabel - button label
 * @param {string} props.data.dangerousDek - dangerous dek
 * @param {string} props.data.dangerousDisclaimer - dangerous disclaimer
 * @param {string} props.data.newsletterId - newsletter Id
 * @param {Element} props.contentWrapper - Required content wrapper component
 * @param {boolean} props.isFullBleed - Optional renders fullbleed newsletter block
 * @returns {ReactElement} - React Component
 */
const FooterNewsletter = ({ data, contentWrapper, isFullBleed }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'FooterNewsletter'
            });
    }, []);
    const formName = 'newsletter';
    const position = 'content-footer';
    const sourceCode = 'article-newsletter';
    const textFieldLabel = '';
    const hasJourneyUniqueButtonName = true;
    const newsletter = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data.dangerousHed,
        newsletterId: data.newsletterId,
        formName,
        position,
        sourceCode,
        textFieldLabel,
        hasJourneyUniqueButtonName,
        isArticlePage: true
    };
    const NewsletterContentWrapper = isFullBleed
        ? Grid.WithMargins
        : contentWrapper;
    return (React.createElement(ContentFooterNewsletterContentWrapper, { isNewsletterFullBleed: isFullBleed },
        React.createElement(NewsletterContentWrapper, null,
            React.createElement(ContentFooterNewsletterForm, { ...newsletter }))));
};
FooterNewsletter.displayName = 'FooterNewsletter';
FooterNewsletter.propTypes = {
    contentWrapper: PropTypes.elementType.isRequired,
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    }),
    isFullBleed: PropTypes.bool
};
FooterNewsletter.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'dangerousHed',
    'newsletterId'
];
module.exports = FooterNewsletter;
//# sourceMappingURL=FooterNewsletter.js.map

/***/ }),

/***/ 65786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const FooterNewsletter = __webpack_require__(8608);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(FooterNewsletter);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 12814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { withModalFocusTrap } = __webpack_require__(96258);
const { TrackComponentChannel } = __webpack_require__(78788);
const { CtaWrapper, DekParagraph, GoTo, HedTitle, ModalOverlay, PictureWrapper, SignInCopy, SignInLink, SignInWrapper, SubscribeButton, SubscribeButtonWrapper, UnitWrapper, Wrapper } = __webpack_require__(26182);
const Formatted = {
    Hed: withFormatter(HedTitle),
    Dek: withFormatter(DekParagraph)
};
/**
 * Image using the <picture> tag
 * to change the their source by device (using viewport)
 *
 * @param {object} img - image data
 * @param {string} img.img - img src by device and alt text
 * @param {string} img.viewport - viewport (desktop, tablet, mobile)
 * @returns {ReactElement} - React Component
 */
function Image({ img, viewport }) {
    return (React.createElement(PictureWrapper, null,
        React.createElement("source", { srcSet: img[viewport].src }),
        React.createElement("img", { src: img[viewport].src, alt: img.alt })));
}
const imagePropTypes = {
    img: PropTypes.shape({
        alt: PropTypes.string.isRequired,
        desktop: PropTypes.shape({
            src: PropTypes.string.isRequired
        }),
        mobile: PropTypes.shape({
            src: PropTypes.string.isRequired
        }),
        tablet: PropTypes.shape({
            src: PropTypes.string.isRequired
        })
    }).isRequired,
    viewport: PropTypes.string.isRequired
};
Image.propTypes = imagePropTypes;
/**
 * Cta component with SignIn and Subscribe
 *
 * @param {object} Cta - properties
 * @param {object} Cta.button - button link by devices { hed, url }
 * @param {object} Cta.signIn - sign in { copy, hed, url }
 * @param {object} Cta.goTo - goTo { hed, url }
 * @param {string} Cta.viewport - viewport (desktop, tablet or mobile)
 * @returns {ReactElement} - React Component
 */
function Cta({ button, signIn, goTo, viewport }) {
    return (React.createElement(CtaWrapper, null,
        React.createElement(SubscribeButtonWrapper, null,
            React.createElement(SubscribeButton, { href: button[viewport].url }, button[viewport].hed)),
        React.createElement(SignInWrapper, null,
            React.createElement(SignInCopy, null,
                signIn.copy,
                "\u00A0"),
            React.createElement(SignInLink, { href: withRedirect(signIn.url) }, signIn.hed)),
        React.createElement(GoTo, { href: goTo.url }, goTo.hed)));
}
const ctaPropTypes = {
    button: PropTypes.shape({
        mobile: PropTypes.shape({
            hed: PropTypes.string.isRequired,
            url: PropTypes.string.isRequired
        }).isRequired,
        tablet: PropTypes.shape({
            hed: PropTypes.string.isRequired,
            url: PropTypes.string.isRequired
        }).isRequired,
        desktop: PropTypes.shape({
            hed: PropTypes.string.isRequired,
            url: PropTypes.string.isRequired
        }).isRequired
    }).isRequired,
    goTo: PropTypes.shape({
        hed: PropTypes.string.isRequired,
        url: PropTypes.string.isRequired
    }).isRequired,
    signIn: PropTypes.shape({
        copy: PropTypes.string.isRequired,
        hed: PropTypes.string.isRequired,
        url: PropTypes.string.isRequired
    }).isRequired,
    viewport: PropTypes.string.isRequired
};
Cta.propTypes = ctaPropTypes;
/**
 * FullBarrier component
 *
 * @param {object} payload - payload from cn bus
 * @param {object} payload.data - unit data
 * @param {string} payload.data.hed - hed title
 * @param {string} payload.data.dek - dek paragraph
 * @param {object} payload.data.img - img object by device { alt, [device]: { hed, src } }
 * @param {object} payload.data.ctaButton - cta by device { hed, url }
 * @param {object} payload.data.signIn - sign in with copy, hed and url { copy, hed, url }
 * @param {object} payload.data.goTo - goTo { hed, url }
 * @param {string} payload.viewport - viewport (desktop, tablet or mobile)
 * @returns {ReactElement} - React Component
 */
function FullBarrier({ data: { hed, dek, img, ctaButton, signIn, goTo }, viewport }) {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'FullBarrier'
            });
    }, []);
    return (React.createElement(Wrapper, { "data-testid": "full-barrier" },
        React.createElement(ModalOverlay, { ariaLive: "assertive", "aria-labelledby": "hed", "aria-describedby": "dek", className: "modal-wrapper", role: "alertdialog" },
            React.createElement(UnitWrapper, null,
                React.createElement(Formatted.Hed, { id: "hed", html: hed }),
                React.createElement(Image, { img: img, viewport: viewport }),
                React.createElement(Formatted.Dek, { id: "dek", html: dek }),
                React.createElement(Cta, { button: ctaButton, signIn: signIn, goTo: goTo, viewport: viewport })))));
}
FullBarrier.propTypes = {
    data: PropTypes.shape({
        ctaButton: ctaPropTypes.button,
        dek: PropTypes.string.isRequired,
        hed: PropTypes.string.isRequired,
        img: imagePropTypes.img,
        signIn: ctaPropTypes.signIn,
        goTo: ctaPropTypes.goTo
    }),
    viewport: PropTypes.string.isRequired
};
const FocusedBarrier = withModalFocusTrap(FullBarrier);
FocusedBarrier.displayName = 'FullBarrier';
FocusedBarrier.requireDataFields = [
    'img.mobile.src',
    'img.tablet.src',
    'img.desktop.src',
    'img.alt',
    'ctaButton.mobile.hed',
    'ctaButton.mobile.url',
    'ctaButton.tablet.hed',
    'ctaButton.tablet.url',
    'ctaButton.desktop.hed',
    'ctaButton.desktop.url',
    'signIn.copy',
    'signIn.hed',
    'signIn.url',
    'goTo.hed',
    'goTo.url',
    'hed',
    'dek'
];
module.exports = FocusedBarrier;
//# sourceMappingURL=FullBarrier.js.map

/***/ }),

/***/ 81802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const FullBarrier = __webpack_require__(12814);
const asJourneyUnit = __webpack_require__(51806);
const { withDataFallback } = __webpack_require__(58872);
const { withJourneyTheme } = __webpack_require__(43219);
const { withViewport } = __webpack_require__(17936);
const wrap = flow([
    withDataFallback,
    withViewport,
    withJourneyTheme,
    asJourneyUnit
]);
module.exports = wrap(FullBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 26182:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { colorPickerFactory } = __webpack_require__(43219);
const { getZIndex, getTypographyStyles } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const colorFor = colorPickerFactory('FullBarrier');
const Wrapper = styled.div.withConfig({ displayName: 'Wrapper' }) `
  position: fixed;
  top: 0;
  left: 0;
  z-index: ${getZIndex('hyperstitialLayer')};
`;
const ModalOverlay = styled.div.withConfig({ displayName: 'ModalOverlay' }) `
  display: flex;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: rgba(0, 0, 0, 0.6);
  padding: 16px 0;
  overflow: auto;
`;
const UnitWrapper = styled.div.withConfig({ displayName: 'UnitWrapper' }) `
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: auto;
  background-color: ${colorFor('background')};
  padding: 0 32px;
  width: 500px;

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    padding: 0 24px;
    width: 327px;
  }
`;
const SubscribeButtonWrapper = styled.div.withConfig({
    displayName: 'SubscribeButtonWrapper'
}) `
  width: 327px;

  ${`@media(min-width: ${BREAKPOINTS.sm})`} {
    width: 279px;
  }
`;
const SubscribeButton = styled.a.withConfig({
    displayName: 'SubscribeButton'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-core')};

  display: block;
  margin-bottom: 24px;
  background-color: ${colorFor('ctaButtonBackground')};
  padding: 16px 0;
  text-transform: none;
  text-decoration: none;
  line-height: 18px;
  color: ${colorFor('ctaCopy')};
  font-size: 14px;
  font-weight: bold;

  &:hover {
    background-color: ${colorFor('ctaHover')};
  }
`;
const CtaWrapper = styled.div.withConfig({
    displayName: 'CtaWrapper'
}) `
  display: flex;
  flex-direction: column;
  margin: 0 auto;
  text-align: center;
`;
const PictureWrapper = styled.picture.withConfig({
    displayName: 'PictureWrapper'
}) `
  img {
    width: 200px;
    height: auto;
  }
`;
const DekParagraph = styled.span.withConfig({
    displayName: 'DekParagraph'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.body-core')};

  margin: 24px auto 32px auto;
  text-align: center;
  line-height: 32px;
  color: ${colorFor('dek')};

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    margin-bottom: 24px;
  }
`;
const HedTitle = styled.span.withConfig({
    displayName: 'HedTitle'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.hed-standard')};

  margin: 32px auto 24px auto;
  text-align: center;
  color: ${colorFor('hed')};
  font-size: 38px;

  @media (min-width: ${BREAKPOINTS.lg}) {
    font-size: 38px;
  }
  @media (min-width: ${BREAKPOINTS.md}) {
    font-size: 38px;
  }
  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    margin-top: 24px;
  }
`;
const SignInWrapper = styled.span.withConfig({
    displayName: 'SignInWrapper'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')};

  margin-bottom: 16px;
  line-height: 16px;

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    margin-bottom: 8px;
  }
`;
const SignInCopy = styled.span.withConfig({
    displayName: 'SignInCopy'
}) `
  color: ${colorFor('signInCopy')};
`;
const SignInLink = styled.a.withConfig({
    displayName: 'signInLink'
}) `
  color: ${colorFor('signInLink')};
`;
const GoTo = styled.a.withConfig({
    displayName: 'GoTo'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')};

  margin-bottom: 32px;
  line-height: 16px;
  color: ${colorFor('goTo')};

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    margin-bottom: 24px;
  }
`;
module.exports = {
    Wrapper,
    ModalOverlay,
    UnitWrapper,
    GoTo,
    SubscribeButtonWrapper,
    SubscribeButton,
    SignInWrapper,
    SignInCopy,
    SignInLink,
    PictureWrapper,
    CtaWrapper,
    DekParagraph,
    HedTitle
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 2000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
// To be added
const InContent = () => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InContent'
            });
    });
    return React.createElement("div", null);
};
InContent.displayName = 'InContent';
InContent.requireDataFields = [];
module.exports = InContent;
//# sourceMappingURL=InContent.js.map

/***/ }),

/***/ 49428:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const InContent = __webpack_require__(2000);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(InContent);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const get = __webpack_require__(58156);
const PropTypes = __webpack_require__(5556);
const { Wrapper, Anchor, Image } = __webpack_require__(46444);
const { TrackComponentChannel } = __webpack_require__(78788);
const InContent = ({ data, viewport = 'desktop' }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InContent'
            });
    });
    return (React.createElement(Wrapper, { scaleImageToFit: get(data, `image.scale`) === 'true' },
        React.createElement(Anchor, { href: get(data, `subscribeURL.${viewport}`), target: "_blank", rel: "noreferrer", "aria-label": "Opens in a new window" },
            React.createElement(Image, { src: get(data, `image.${viewport}`), alt: get(data, `image.alt`) }))));
};
InContent.displayName = 'InContent.Image';
InContent.propTypes = {
    data: PropTypes.shape({
        image: PropTypes.shape({
            alt: PropTypes.string,
            desktop: PropTypes.string,
            mobile: PropTypes.string,
            scale: PropTypes.string,
            tablet: PropTypes.string
        }),
        subscribeURL: PropTypes.shape({
            desktop: PropTypes.string,
            mobile: PropTypes.string,
            tablet: PropTypes.string
        })
    }),
    viewport: PropTypes.string.isRequired
};
InContent.requireDataFields = [
    'image.alt',
    'image.desktop',
    'image.mobile',
    'image.scale',
    'image.tablet',
    'subscribeURL.desktop',
    'subscribeURL.mobile',
    'subscribeURL.tablet'
];
module.exports = InContent;
//# sourceMappingURL=InContent.js.map

/***/ }),

/***/ 95272:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const InContent = __webpack_require__(88612);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(InContent);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 46444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { inMobile, inTablet, inDesktop } = __webpack_require__(94130);
const Anchor = styled.a.withConfig({
    displayName: 'InContentAnchor'
}) `
  ${inTablet} {
    position: absolute;
    right: 0;
    left: 0;
    margin: 0 auto;
  }
`;
const Image = styled.img.withConfig({
    displayName: 'InContentImage'
}) ``;
const scaleImageToFitStyles = css `
  overflow: hidden;

  ${inMobile} {
    width: 276px;
    height: 100px;
  }
  ${inTablet} {
    height: 190px;

    ${Anchor} {
      width: 724px;
    }
  }
  ${inDesktop} {
    width: 450px;
    height: 140px;
  }

  ${Image} {
    width: 100%;
    height: 100%;
  }
`;
const Wrapper = styled.div.withConfig({
    displayName: 'InContentWrapper'
}) `
  margin: 0 auto;
  text-align: center;
  ${(props) => (props.scaleImageToFit ? scaleImageToFitStyles : '')}
`;
module.exports = {
    Wrapper,
    Image,
    Anchor
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 10202:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Default = __webpack_require__(49428);
const Image = __webpack_require__(95272);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
// For now its an empty component
const InContent = Default;
// All Variations
InContent.Image = Image;
module.exports = asJourneyUnit(InContent);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 45145:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useRef, useState, useEffect, forwardRef } = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const { Backdrop, Container, Iframe, Drawer, FloatingBar, FloatingBarLink, FloatingBarCopy } = __webpack_require__(20020);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const Formatted = {
    FloatingBarLink: withFormatter(FloatingBarLink),
    FloatingBarCopy: withFormatter(FloatingBarCopy)
};
const onMessage = ({ setIframeHeight, setIsClosing, setShowModal }) => (event) => {
    if (!event || !event.data) {
        return;
    }
    const { data: { type, action, height } } = event;
    if (type !== 'Journey' || !action) {
        return;
    }
    switch (action) {
        case 'resizeUnit':
            if (height >= 250) {
                setIframeHeight(Math.min(height, window.innerHeight));
            }
            break;
        case 'toBarrierPage':
            setIsClosing(true);
            setTimeout(() => {
                setShowModal(false);
                setIsClosing(false);
            }, 300);
            break;
        case 'toLegalPage':
            setShowModal(true);
            break;
        case 'toSuccessPage':
            setShowModal(true);
            break;
        default:
    }
};
const initialize = (payload) => {
    const listener = onMessage(payload);
    window.addEventListener('message', listener, false);
    return () => window.removeEventListener('message', listener);
};
const ModalWrapper = ({ children, isClosing }) => (React.createElement(Backdrop, null,
    React.createElement(Drawer, { isClosing: isClosing }, children)));
ModalWrapper.propTypes = {
    children: PropTypes.node,
    isClosing: PropTypes.bool
};
const Wrapper = forwardRef(({ children, isClosing, showModal }, ref) => showModal ? (React.createElement(ModalWrapper, { isClosing: isClosing }, children)) : (React.createElement(Container, { ref: ref }, children)));
Wrapper.propTypes = {
    children: PropTypes.node,
    isClosing: PropTypes.bool,
    showModal: PropTypes.bool
};
const InContentBarrier = ({ data, viewport }) => {
    const [iframeHeight, setIframeHeight] = useState(320);
    const [showModal, setShowModal] = useState(false);
    const [isClosing, setIsClosing] = useState(false);
    const [isFloatingBarVisible, setIsFloatingBarVisible] = useState(true);
    const mainComponentRef = useRef(null);
    const { floatingBar, iframe } = data[viewport];
    const iframeUrl = React.useMemo(() => withRedirect(iframe.src), [iframe.src]);
    useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InContentBarrier'
            });
    }, []);
    const setWrapperRef = React.useCallback((node) => {
        mainComponentRef.current = node;
        if (mainComponentRef.observer) {
            mainComponentRef.observer.disconnect();
            mainComponentRef.observer = null;
        }
        if (node) {
            mainComponentRef.observer = new IntersectionObserver(([entry]) => {
                setIsFloatingBarVisible(!entry.isIntersecting);
            }, { threshold: 0.35 });
            mainComponentRef.observer.observe(node);
        }
        return null;
    }, []);
    useEffect(() => {
        return initialize({ setIframeHeight, setIsClosing, setShowModal });
    }, []);
    return (React.createElement(React.Fragment, null,
        React.createElement(Wrapper, { isClosing: isClosing, showModal: showModal, ref: setWrapperRef },
            React.createElement(Iframe, { iframeHeight: iframeHeight, showModal: showModal, src: iframeUrl, title: iframe.title })),
        React.createElement(FloatingBar, { isVisible: isFloatingBarVisible && !showModal, "data-testid": "InContentBarrierFloatingBar" },
            React.createElement(Formatted.FloatingBarCopy, { html: floatingBar.copy }),
            "\u00A0",
            React.createElement(Formatted.FloatingBarLink, { href: withRedirect(floatingBar.url), html: floatingBar.linkCopy }))));
};
InContentBarrier.displayName = 'InContentBarrier';
InContentBarrier.propTypes = {
    data: PropTypes.shape({
        mobile: PropTypes.shape({
            iframe: PropTypes.shape({
                src: PropTypes.string.isRequired,
                title: PropTypes.string.isRequired
            }).isRequired,
            floatingBar: PropTypes.shape({
                copy: PropTypes.string,
                linkCopy: PropTypes.string,
                url: PropTypes.string
            })
        }).isRequired,
        tablet: PropTypes.shape({
            iframe: PropTypes.shape({
                src: PropTypes.string.isRequired,
                title: PropTypes.string.isRequired
            }).isRequired,
            floatingBar: PropTypes.shape({
                copy: PropTypes.string,
                linkCopy: PropTypes.string,
                url: PropTypes.string
            })
        }).isRequired,
        desktop: PropTypes.shape({
            iframe: PropTypes.shape({
                src: PropTypes.string.isRequired,
                title: PropTypes.string.isRequired
            }).isRequired,
            floatingBar: PropTypes.shape({
                copy: PropTypes.string,
                linkCopy: PropTypes.string,
                url: PropTypes.string
            })
        }).isRequired
    }).isRequired,
    viewport: PropTypes.string.isRequired
};
InContentBarrier.requireDataFields = [
    'mobile.iframe.src',
    'mobile.iframe.title',
    'mobile.floatingBar.copy',
    'mobile.floatingBar.linkCopy',
    'mobile.floatingBar.url',
    'tablet.iframe.src',
    'tablet.iframe.title',
    'tablet.floatingBar.copy',
    'tablet.floatingBar.linkCopy',
    'tablet.floatingBar.url',
    'desktop.iframe.src',
    'desktop.iframe.title',
    'desktop.floatingBar.copy',
    'desktop.floatingBar.linkCopy',
    'desktop.floatingBar.url'
];
module.exports = InContentBarrier;
//# sourceMappingURL=InContentBarrier.js.map

/***/ }),

/***/ 99312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const InContentBarrier = __webpack_require__(45145);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback]);
module.exports = wrap(InContentBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled, keyframes } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles } = __webpack_require__(26865);
const { inMobile } = __webpack_require__(94130);
const closeRight = keyframes `
  from {
    transform: translateX(0);
  }

  to {
    transform: translateX(100%);
  }
`;
const fadeIn = keyframes `
  from {
    background-color: transparent;
  }

  to {
    background-color: rgba(0, 0, 0, 0.6);
  }
`;
const slideDown = keyframes `
  from {
    transform: translateY(0);
  }

  to {
    transform: translateY(100%);
  }
`;
const slideRight = keyframes `
  from {
    transform: translateX(100%);
  }

  to {
    transform: translateX(0);
  }
`;
const slideUp = keyframes `
  from {
    transform: translateY(100 %);
  }

  to {
    transform: translateY(0);
  }
`;
const Backdrop = styled.div.withConfig({
    displayName: 'InContentBarrierBackdrop'
}) `
  display: flex;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  align-items: center;
  justify-content: center;
  animation: ${fadeIn} 0.3s ease-out forwards;
  z-index: 1000;
`;
const Drawer = styled.div.withConfig({
    displayName: 'InContentBarrierDrawer'
}) `
  position: fixed;
  right: 0;
  animation: ${slideRight} 0.3s ease-out;
  box-shadow: -2px 0 4px 0 rgba(0, 0, 0, 0.05);
  background-color: white;
  width: 532px;
  height: 100vh;

  ${({ isClosing }) => isClosing &&
    css `
      animation: ${closeRight} 0.3s ease-out forwards;
    `}

  ${inMobile} {
    right: auto;
    bottom: 0;
    animation: ${slideUp} 0.3s ease-out;
    border-radius: 16px 16px 0 0;
    box-shadow: 0 -2px 4px 0 rgba(0, 0, 0, 0.05);
    padding-top: 16px;
    width: 100vw;
    height: fit-content;

    ${({ isClosing }) => isClosing &&
    css `
        animation: ${slideDown} 0.3s ease-out forwards;
      `}
  }
`;
const Container = styled.div.withConfig({
    displayName: 'InContentBarrierContainer'
}) `
  display: flex;
  position: relative;
  flex-direction: column;
  align-items: center;
  margin-top: 20px;
  margin-bottom: 64px;
  text-align: center;

  &::before {
    position: absolute;
    bottom: calc(100% + 20px);
    left: 0;
    ${({ theme }) => {
    const color = getColorToken(theme, 'colors.background.white', {
        rgbOnly: true
    });
    return `
        background: linear-gradient(
          to top,
          rgba(${color}, 1) 0%,
          rgba(${color}, 0) 100%
        );
      `;
}}
    width: 100%;
    height: 84px;
    ${inMobile} {
      height: 200px;
    }
    content: '';
    pointer-events: none;
  }
`;
const Iframe = styled.iframe.withConfig({
    displayName: 'InContentBarrierIframe'
}) `
  border: none;
  width: 100%;
  ${({ iframeHeight, showModal }) => showModal ? `height: 100%;` : `height: ${iframeHeight + 1}px;`}

  ${inMobile} {
    ${({ iframeHeight }) => iframeHeight && `height: ${iframeHeight + 1}px;`}
  }
`;
const FloatingBar = styled.div.withConfig({
    displayName: 'InContentBarrierFloatingBar'
}) `
  ${({ theme }) => `
    background-color: ${getColorToken(theme, 'colors.background.white')};
  `}
  display: flex;
  position: fixed;
  bottom: 32px;
  ${inMobile} {
    bottom: 16px;
  }
  left: 50%;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  transform: translateX(-50%);
  transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
  visibility: ${({ isVisible }) => (isVisible ? 'visible' : 'hidden')};
  opacity: ${({ isVisible }) => (isVisible ? 1 : 0)};
  pointer-events: ${({ isVisible }) => (isVisible ? 'auto' : 'none')};
  z-index: 10000;
  border-radius: 4px;
  ${({ theme }) => `
    box-shadow: 0 0 32px 0 rgba(${getColorToken(theme, 'colors.interactive.base.black', { rgbOnly: true })}, 0.2);
  `}
  width: calc(100% - 96px);
  ${inMobile} {
    width: calc(100% - 48px);
  }
  height: 40px;
  line-height: 15px;
`;
const FloatingBarLink = styled.a.withConfig({
    displayName: 'InContentBarrierFloatingBarLink'
}) `
  ${({ theme }) => `
    ${getTypographyStyles(theme, 'typography.definitions.utility.button-utility')}
    &&&[href] {
      text-decoration: underline;
      color: ${getColorToken(theme, 'colors.interactive.base.brand-primary')};
    }
  `}
`;
const FloatingBarCopy = styled.span.withConfig({
    displayName: 'InContentBarrierFloatingBarCopy'
}) `
  ${({ theme }) => `
    color: ${getColorToken(theme, 'colors.interactive.base.black')};
    ${getTypographyStyles(theme, 'typography.definitions.utility.body')}
  `}
`;
module.exports = {
    Backdrop,
    Container,
    Drawer,
    Iframe,
    FloatingBar,
    FloatingBarLink,
    FloatingBarCopy
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 27756:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useRef, useState, useEffect } = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { TrackComponentChannel } = __webpack_require__(78788);
const { Container, SignInContainer, SignInCopy, SignInLink, Hed, ImageContainer, StyledImage, Dek, CTAButton, FloatingBar, FloatingBarLink, FloatingBarCopy } = __webpack_require__(39169);
const Formatted = {
    SignInCopy: withFormatter(SignInCopy),
    SignInLink: withFormatter(SignInLink),
    Hed: withFormatter(Hed),
    Dek: withFormatter(Dek),
    FloatingBarLink: withFormatter(FloatingBarLink),
    FloatingBarCopy: withFormatter(FloatingBarCopy)
};
const InContentBarrier = ({ data = {}, viewport }) => {
    const mainComponentRef = useRef(null);
    const [isFloatingBarVisible, setIsFloatingBarVisible] = useState(true);
    useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InContentBarrier'
            });
    }, []);
    useEffect(() => {
        const observedElement = mainComponentRef.current;
        if (!observedElement)
            return null;
        const observer = new IntersectionObserver(([entry]) => {
            setIsFloatingBarVisible(!entry.isIntersecting);
        }, { threshold: 0.35 });
        observer.observe(observedElement);
        return () => {
            observer.disconnect();
        };
    }, []);
    const { hed, dek, signIn = { copy: '', url: '', linkCopy: '' }, image, cta, floatingBar } = data[viewport];
    return (React.createElement(React.Fragment, null,
        React.createElement(Container, { ref: mainComponentRef },
            React.createElement(SignInContainer, null,
                React.createElement(Formatted.SignInCopy, { html: data.signIn?.copy || signIn.copy }),
                "\u00A0",
                React.createElement(Formatted.SignInLink, { href: withRedirect(data.signIn?.cta?.url || signIn.url), html: data.signIn?.cta?.text || signIn.linkCopy })),
            React.createElement(Formatted.Hed, { html: hed }),
            React.createElement(ImageContainer, null,
                React.createElement(StyledImage, { src: image.src, alt: image.alt })),
            React.createElement(Formatted.Dek, { html: dek }),
            React.createElement(CTAButton, { href: withRedirect(cta.url), label: cta.copy, inputKind: "link" })),
        React.createElement(FloatingBar, { isVisible: isFloatingBarVisible },
            React.createElement(Formatted.FloatingBarCopy, { html: floatingBar.copy }),
            "\u00A0",
            React.createElement(Formatted.FloatingBarLink, { href: withRedirect(floatingBar.url), html: floatingBar.linkCopy }))));
};
const dataPropTypes = {
    hed: PropTypes.string,
    dek: PropTypes.string,
    signIn: PropTypes.shape({
        copy: PropTypes.string,
        linkCopy: PropTypes.string,
        url: PropTypes.string
    }),
    image: PropTypes.shape({
        src: PropTypes.string,
        alt: PropTypes.string
    }),
    cta: PropTypes.shape({
        copy: PropTypes.string,
        url: PropTypes.string
    }),
    floatingBar: PropTypes.shape({
        copy: PropTypes.string,
        linkCopy: PropTypes.string,
        url: PropTypes.string
    })
};
InContentBarrier.propTypes = {
    data: PropTypes.shape({
        signIn: PropTypes.shape({
            copy: PropTypes.string,
            cta: PropTypes.shape({
                url: PropTypes.string,
                text: PropTypes.string
            })
        }),
        mobile: PropTypes.shape(dataPropTypes),
        tablet: PropTypes.shape(dataPropTypes),
        desktop: PropTypes.shape(dataPropTypes)
    }),
    viewport: PropTypes.string
};
InContentBarrier.displayName = 'InContentBarrier';
InContentBarrier.requireDataFields = [
    'mobile.dek',
    'mobile.hed',
    'mobile.image.src',
    'mobile.image.alt',
    'mobile.cta.copy',
    'mobile.cta.url',
    'mobile.floatingBar.copy',
    'mobile.floatingBar.linkCopy',
    'mobile.floatingBar.url',
    'tablet.hed',
    'tablet.dek',
    'tablet.image.src',
    'tablet.image.alt',
    'tablet.cta.copy',
    'tablet.cta.url',
    'tablet.floatingBar.copy',
    'tablet.floatingBar.linkCopy',
    'tablet.floatingBar.url',
    'desktop.hed',
    'desktop.dek',
    'desktop.image.src',
    'desktop.image.alt',
    'desktop.cta.copy',
    'desktop.cta.url',
    'desktop.floatingBar.copy',
    'desktop.floatingBar.linkCopy',
    'desktop.floatingBar.url'
];
module.exports = InContentBarrier;
//# sourceMappingURL=InContentBarrier.js.map

/***/ }),

/***/ 30879:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const InContentBarrier = __webpack_require__(27756);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback]);
module.exports = wrap(InContentBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 39169:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const Button = __webpack_require__(73730);
const { getColorToken, getTypographyStyles } = __webpack_require__(26865);
const { inMobile } = __webpack_require__(94130);
const { ZINDEX_MAP } = __webpack_require__(96472);
const Container = styled.div.withConfig({
    displayName: 'InContentBarrierContainer'
}) `
  display: flex;
  position: relative;
  flex-direction: column;
  align-items: center;
  margin-top: 20px;
  margin-bottom: 64px;
  text-align: center;

  &::before {
    position: absolute;
    bottom: calc(100% + 20px);
    left: 0;
    ${({ theme }) => {
    const color = getColorToken(theme, 'colors.background.white', {
        rgbOnly: true
    });
    return `
        background: linear-gradient(
          to top,
          rgba(${color}, 1) 0%,
          rgba(${color}, 0) 100%
        );
      `;
}}
    width: 100%;
    height: 84px;
    ${inMobile} {
      height: 200px;
    }
    content: '';
    pointer-events: none;
  }
`;
const SignInContainer = styled.div.withConfig({
    displayName: 'InContentBarrierSignInContainer'
}) `
  margin-bottom: 32px;
  line-height: normal;
`;
const SignInCopy = styled.span.withConfig({
    displayName: 'InContentBarrierSignInCopy'
}) `
  ${({ theme }) => `
    color: ${getColorToken(theme, 'colors.interactive.base.deemphasized')};
    ${getTypographyStyles(theme, 'typography.definitions.utility.body')}
  `}
`;
const SignInLink = styled.a.withConfig({
    displayName: 'InContentBarrierSignInLink'
}) `
  ${({ theme }) => `
    ${getTypographyStyles(theme, 'typography.definitions.utility.body')}
    &&&[href] {
      text-decoration: underline;
      color: ${getColorToken(theme, 'colors.interactive.base.brand-primary')};
    }
  `}
`;
const Hed = styled.div.withConfig({
    displayName: 'InContentBarrierHed'
}) `
  ${({ theme }) => `
    color: ${getColorToken(theme, 'colors.interactive.base.black')};
    ${getTypographyStyles(theme, 'typography.definitions.utility.modal-hed')}
  `}
  margin-bottom: 48px;
`;
const ImageContainer = styled.div.withConfig({
    displayName: 'InContentBarrierImageContainer'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 48px;
  width: 234px;
  height: 156px;
  overflow: hidden;
`;
const StyledImage = styled.img.withConfig({
    displayName: 'InContentBarrierStyledImage'
}) `
  display: block;
  width: 100%;
  height: 100%;
  object-fit: scale-down;
  object-position: center;
`;
const Dek = styled.div.withConfig({
    displayName: 'InContentBarrierDek'
}) `
  ${({ theme }) => `
    color: ${getColorToken(theme, 'colors.interactive.base.black')};
    ${getTypographyStyles(theme, 'typography.definitions.utility.modal-body')}
  `}
  margin-bottom: 32px;
  ${inMobile} {
    margin-bottom: 48px;
  }
`;
const CTAButton = styled(Button.Primary).withConfig({
    displayName: 'InContentBarrierCTAButton'
}) `
  ${({ theme }) => `
    color: ${getColorToken(theme, 'colors.interactive.base.white')};
    background-color: ${getColorToken(theme, 'colors.interactive.base.brand-primary')};
    ${getTypographyStyles(theme, 'typography.definitions.utility.button-utility')}
  `}
  border-radius: 4px;
  width: 320px;
  ${inMobile} {
    width: 100%;
  }
`;
const FloatingBar = styled.div.withConfig({
    displayName: 'InContentBarrierFloatingBar'
}) `
  ${({ theme }) => `
    background-color: ${getColorToken(theme, 'colors.background.white')};
  `}
  display: flex;
  position: fixed;
  bottom: 32px;
  ${inMobile} {
    bottom: 16px;
  }
  left: 50%;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  transform: translateX(-50%);
  transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
  visibility: ${({ isVisible }) => (isVisible ? 'visible' : 'hidden')};
  opacity: ${({ isVisible }) => (isVisible ? 1 : 0)};
  pointer-events: ${({ isVisible }) => (isVisible ? 'auto' : 'none')};
  z-index: ${ZINDEX_MAP.persistentBottomLayer};
  border-radius: 4px;
  ${({ theme }) => `
    box-shadow: 0 0 32px 0 rgba(${getColorToken(theme, 'colors.interactive.base.black', { rgbOnly: true })}, 0.2);
  `}
  width: calc(100% - 96px);
  ${inMobile} {
    width: calc(100% - 48px);
  }
  height: 40px;
  line-height: 15px;
`;
const FloatingBarLink = styled.a.withConfig({
    displayName: 'InContentBarrierFloatingBarLink'
}) `
  ${({ theme }) => `
    ${getTypographyStyles(theme, 'typography.definitions.utility.button-utility')}
    &&&[href] {
      text-decoration: underline;
      color: ${getColorToken(theme, 'colors.interactive.base.brand-primary')};
    }
  `}
`;
const FloatingBarCopy = styled.span.withConfig({
    displayName: 'InContentBarrierFloatingBarCopy'
}) `
  ${({ theme }) => `
    color: ${getColorToken(theme, 'colors.interactive.base.black')};
    ${getTypographyStyles(theme, 'typography.definitions.utility.body')}
  `}
`;
module.exports = {
    Container,
    SignInContainer,
    SignInCopy,
    SignInLink,
    Hed,
    ImageContainer,
    StyledImage,
    Dek,
    CTAButton,
    FloatingBar,
    FloatingBarLink,
    FloatingBarCopy
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 21757:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ContentBar = __webpack_require__(99312);
const Default = __webpack_require__(30879);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const InContentBarrier = Default;
// All Variations
InContentBarrier.ContentBar = ContentBar;
module.exports = asJourneyUnit(InContentBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 29985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { Link, Wrapper } = __webpack_require__(94339);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * InlineBarrier component
 *
 * @param {object} payload - payload from cn bus
 * @param {object} payload.data - unit data
 * @param {string} payload.data.hed - first text copy
 * @param {string} payload.data.dek - second text copy
 * @param {string} payload.data.subscribe.cta - subscribe text
 * @param {string} payload.data.subscribe.url - subscribe url
 * @param {string} payload.data.signIn.cta - sign-in text
 * @param {string} payload.data.signIn.url - sign-in url
 * @returns {ReactElement} - React Component
 */
const InlineBarrier = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InlineBarrier'
            });
    }, []);
    const { hed, dek, subscribe, signIn } = data;
    const FormattedSpan = withFormatter((props) => React.createElement("span", { ...props }));
    return (React.createElement(Wrapper, { className: "journey-unit__inline-barrier" },
        React.createElement("span", null,
            React.createElement(FormattedSpan, { html: hed }),
            "\u00A0",
            React.createElement(Link, { href: subscribe.url, target: "_blank", rel: "noopener noreferrer", "aria-label": "Opens in a new window" }, subscribe.cta),
            ".\u00A0",
            React.createElement(FormattedSpan, { html: dek }),
            "\u00A0",
            React.createElement(Link, { href: withRedirect(signIn.url) }, signIn.cta),
            ".")));
};
InlineBarrier.displayName = 'InlineBarrier';
InlineBarrier.propTypes = {
    data: PropTypes.shape({
        hed: PropTypes.string,
        dek: PropTypes.string,
        subscribe: PropTypes.shape({
            cta: PropTypes.string,
            url: PropTypes.string
        }),
        signIn: PropTypes.shape({
            cta: PropTypes.string,
            url: PropTypes.string
        })
    })
};
InlineBarrier.requireDataFields = [
    'hed',
    'dek',
    'subscribe.cta',
    'subscribe.url',
    'signIn.cta',
    'signIn.url'
];
module.exports = InlineBarrier;
//# sourceMappingURL=InlineBarrier.js.map

/***/ }),

/***/ 77497:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const InlineBarrier = __webpack_require__(29985);
const { withDataFallback } = __webpack_require__(58872);
module.exports = withDataFallback(InlineBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getLinkStyles } = __webpack_require__(26865);
const Link = styled.a.withConfig({ displayName: 'Link' }) `
  ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')};
`;
const Wrapper = styled.div.withConfig({ displayName: 'Wrapper' }) `
  min-height: 100px;
`;
module.exports = {
    Link,
    Wrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 22877:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { Link, Wrapper } = __webpack_require__(31815);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * InlineBarrier component - Beta variation
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.hed - first text copy
 * @param {string} props.data.dek - second text copy
 * @param {string} props.data.subscribe.desktop.cta - desktop text
 * @param {string} props.data.subscribe.desktop.url - desktop URL
 * @param {string} props.data.subscribe.tablet.cta - tablet text
 * @param {string} props.data.subscribe.tablet.url - tablet URL
 * @param {string} props.data.subscribe.mobile.cta - mobile text
 * @param {string} props.data.subscribe.mobile.url - mobile URL
 * @param {string} props.data.signIn.cta - sign-in text
 * @param {string} props.data.signIn.url - sign-in url
 * @param {string} props.viewport - display viewport
 * @returns {ReactElement} - React Component
 */
const InlineBarrier = ({ data, viewport }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InlineBarrier'
            });
    }, []);
    const { hed, dek, subscribe, signIn } = data;
    const FormattedSpan = withFormatter((props) => React.createElement("span", { ...props }));
    return (React.createElement(Wrapper, { className: "journey-unit__inline-barrier" },
        React.createElement("span", null,
            React.createElement(FormattedSpan, { html: hed }),
            "\u00A0",
            React.createElement(Link, { href: subscribe[viewport].url, target: "_blank", rel: "noopener noreferrer", "aria-label": "Opens in a new window" }, subscribe[viewport].cta),
            ".\u00A0",
            React.createElement(FormattedSpan, { html: dek }),
            "\u00A0",
            React.createElement(Link, { href: withRedirect(signIn.url) }, signIn.cta),
            ".")));
};
InlineBarrier.displayName = 'InlineBarrier.Beta';
InlineBarrier.propTypes = {
    data: PropTypes.shape({
        hed: PropTypes.string,
        dek: PropTypes.string,
        subscribe: PropTypes.shape({
            desktop: PropTypes.shape({
                cta: PropTypes.string,
                url: PropTypes.string
            }),
            tablet: PropTypes.shape({
                cta: PropTypes.string,
                url: PropTypes.string
            }),
            mobile: PropTypes.shape({
                cta: PropTypes.string,
                url: PropTypes.string
            })
        }),
        signIn: PropTypes.shape({
            cta: PropTypes.string,
            url: PropTypes.string
        })
    }),
    viewport: PropTypes.string
};
InlineBarrier.requireDataFields = [
    'hed',
    'dek',
    'subscribe.desktop.cta',
    'subscribe.desktop.url',
    'subscribe.tablet.cta',
    'subscribe.tablet.url',
    'subscribe.mobile.cta',
    'subscribe.mobile.url',
    'signIn.cta',
    'signIn.url'
];
module.exports = InlineBarrier;
//# sourceMappingURL=InlineBarrier.js.map

/***/ }),

/***/ 58117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const InlineBarrier = __webpack_require__(22877);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(InlineBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 31815:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getLinkStyles } = __webpack_require__(26865);
const Link = styled.a.withConfig({ displayName: 'Link' }) `
  ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')};
`;
const Wrapper = styled.div.withConfig({ displayName: 'Wrapper' }) `
  min-height: 100px;
`;
module.exports = {
    Link,
    Wrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 92726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Alpha = __webpack_require__(77497);
const Beta = __webpack_require__(58117);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const InlineBarrier = Alpha;
// All Variations
InlineBarrier.Alpha = Alpha;
InlineBarrier.Beta = Beta;
module.exports = asJourneyUnit(InlineBarrier);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 72372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const ConnectedNewsletterSubscribeForm = __webpack_require__(577);
/**
 * InlineNewsletter component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.buttonLabel - button label
 * @param {string} props.data.dangerousDek - dangerous dek
 * @param {string} props.data.dangerousDisclaimer - dangerous disclaimer
 * @param {string} props.data.newsletterId - newsletter Id
 * @returns {ReactElement} - React Component
 */
const InlineNewsletter = ({ data }) => {
    const formName = 'newsletter-subscribe';
    const newsletterType = 'slim-newsletter';
    const patternType = 'consumption';
    const isArticlePage = true;
    const sourceCode = 'slim-newsletter';
    const hasJourneyUniqueButtonName = true;
    const newsletter = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data.dangerousHed,
        newsletterId: data.newsletterId,
        formName,
        textFieldLabel: '',
        newsletterType,
        patternType,
        isArticlePage,
        sourceCode,
        hasJourneyUniqueButtonName
    };
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'InlineNewsletter'
            });
    }, []);
    return (React.createElement("div", null,
        React.createElement(ConnectedNewsletterSubscribeForm, { ...newsletter })));
};
InlineNewsletter.displayName = 'InlineNewsletter';
InlineNewsletter.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string,
        dangerousDek: PropTypes.string,
        dangerousDisclaimer: PropTypes.string,
        dangerousHed: PropTypes.string,
        newsletterId: PropTypes.string
    })
};
module.exports = InlineNewsletter;
//# sourceMappingURL=InlineNewsletter.js.map

/***/ }),

/***/ 40064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const InlineNewsletter = __webpack_require__(72372);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(InlineNewsletter);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 41859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const get = __webpack_require__(58156);
const { useEffect, useRef } = __webpack_require__(96540);
const { Button } = __webpack_require__(31436);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * NavCTA component - Button variation
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.copy.mobile - mobile copy
 * @param {string} props.data.copy.tablet - tablet copy
 * @param {string} props.data.copy.desktop - desktop copy
 * @param {string} props.data.subscribeUrl.mobile - mobile URL
 * @param {string} props.data.subscribeUrl.tablet - tablet URL
 * @param {string} props.data.subscribeUrl.desktop - desktop URL
 * @param {Function} props.onAppears - callback used to indicate that the rollover has appeared on behalf of the CTA
 * @param {string} props.viewport - display viewport
 * @returns {ReactElement} - React Component
 */
const NavCTA = ({ data, viewport, onAppears }) => {
    const subscribeUrl = get(data, `subscribeUrl.${viewport}`);
    const copy = get(data, `copy.${viewport}`);
    const linkRef = useRef(null);
    const a11yRollover = (rollover, action) => {
        rollover.setAttribute('aria-hidden', `${action === 'hide'}`);
    };
    useEffect(() => {
        linkRef.current.fired = true;
        const timeout = setTimeout(() => {
            const navCta = linkRef.current;
            const rollover = window.document.querySelector('a[class*="nav-rollover"], [class*="nav-rollover"] a');
            if (navCta && rollover) {
                ['mouseenter', 'focus'].forEach((eventName) => {
                    [navCta, rollover].forEach((node) => node.addEventListener(eventName, () => {
                        a11yRollover(rollover, 'show');
                    }));
                    rollover.addEventListener(eventName, () => {
                        linkRef.current.fired = false;
                    });
                    navCta.addEventListener(eventName, () => {
                        if (linkRef.current.fired) {
                            onAppears('NavRollover');
                        }
                        linkRef.current.fired = true;
                    });
                });
                ['mouseleave', 'blur'].forEach((eventName) => {
                    [navCta, rollover].forEach((node) => node.addEventListener(eventName, () => {
                        a11yRollover(rollover, 'hide');
                    }));
                    rollover.addEventListener(eventName, () => {
                        const newTimeout = setTimeout(() => {
                            linkRef.current.fired = document.activeElement !== navCta;
                            clearTimeout(newTimeout);
                            // Assign "fired" variable ASAP
                            // w/o this timeout "document.activeElement" is <body>
                        }, 0);
                    });
                    navCta.addEventListener(eventName, () => {
                        linkRef.current.fired = true;
                    });
                });
            }
            clearTimeout(timeout);
            // Timeout to give Journey enough time to have the "rollover" available
        }, 500);
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NavCTA',
                variation: 'Button'
            });
        // Don't add "linkRef.current" as "deps", it will trigger the "useEffect" twice
        // causing changing the attribute "aria-hidden" twice as well. Each time "aria-hidden" is changed
        // The Journey Builder, MutationObserver is going to be triggered each time "aria-hidden" changes.
    }, [onAppears]);
    return (React.createElement(Button, { href: subscribeUrl, target: "_blank", ref: linkRef, "aria-label": "Opens in a new window" }, copy));
};
NavCTA.displayName = 'NavCTA.Button';
NavCTA.propTypes = {
    data: PropTypes.shape({
        copy: PropTypes.shape({
            mobile: PropTypes.string,
            tablet: PropTypes.string,
            desktop: PropTypes.string
        }),
        subscribeUrl: PropTypes.shape({
            mobile: PropTypes.string,
            tablet: PropTypes.string,
            desktop: PropTypes.string
        })
    }),
    onAppears: PropTypes.func,
    viewport: PropTypes.string.isRequired
};
NavCTA.requireDataFields = [
    'copy.mobile',
    'copy.tablet',
    'copy.desktop',
    'subscribeUrl.mobile',
    'subscribeUrl.tablet',
    'subscribeUrl.desktop'
];
module.exports = NavCTA;
//# sourceMappingURL=NavCTA.js.map

/***/ }),

/***/ 6024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NavCTA = __webpack_require__(41859);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(NavCTA);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 31436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles } = __webpack_require__(26865);
const Button = styled.a.withConfig({
    displayName: 'NavCTALink'
}) `
  display: inline-flex;
  align-items: center;
  border-radius: 1px;
  background-color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.brand-primary')};
  padding: 8px;
  height: 100%;
  text-decoration: none;
  /* stylelint-disable-next-line declaration-no-important */
  line-height: unset !important;
  white-space: nowrap;

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-core')};

  color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};

  &:link {
    color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
  }

  &:visited {
    color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
  }

  &:hover,
  &:focus {
    text-decoration: none;
  }
`;
module.exports = {
    Button
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 71135:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const get = __webpack_require__(58156);
const { useEffect, useRef } = __webpack_require__(96540);
const { Link } = __webpack_require__(82552);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * NavCTA component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.copy.mobile - mobile copy
 * @param {string} props.data.copy.tablet - tablet copy
 * @param {string} props.data.copy.desktop - desktop copy
 * @param {string} props.data.subscribeUrl.mobile - mobile URL
 * @param {string} props.data.subscribeUrl.tablet - tablet URL
 * @param {string} props.data.subscribeUrl.desktop - desktop URL
 * @param {Function} props.onAppears - callback used to indicate that the rollover has appeared on behalf of the CTA
 * @param {string} props.viewport - display viewport
 * @returns {ReactElement} - React Component
 */
const NavCTA = ({ data, viewport, onAppears }) => {
    const subscribeUrl = get(data, `subscribeUrl.${viewport}`);
    const copy = get(data, `copy.${viewport}`);
    const linkRef = useRef(null);
    const a11yRollover = (rollover, action) => {
        rollover.setAttribute('aria-hidden', `${action === 'hide'}`);
    };
    useEffect(() => {
        linkRef.current.fired = true;
        const timeout = setTimeout(() => {
            const navCta = linkRef.current;
            const rollover = window.document.querySelector('a[class*="nav-rollover"], [class*="nav-rollover"] a');
            if (navCta && rollover) {
                ['mouseenter', 'focus'].forEach((eventName) => {
                    [navCta, rollover].forEach((node) => node.addEventListener(eventName, () => {
                        a11yRollover(rollover, 'show');
                    }));
                    rollover.addEventListener(eventName, () => {
                        linkRef.current.fired = false;
                    });
                    navCta.addEventListener(eventName, () => {
                        if (linkRef.current.fired) {
                            onAppears('NavRollover');
                        }
                        linkRef.current.fired = true;
                    });
                });
                ['mouseleave', 'blur'].forEach((eventName) => {
                    [navCta, rollover].forEach((node) => node.addEventListener(eventName, () => {
                        a11yRollover(rollover, 'hide');
                    }));
                    rollover.addEventListener(eventName, () => {
                        const newTimeout = setTimeout(() => {
                            linkRef.current.fired = document.activeElement !== navCta;
                            clearTimeout(newTimeout);
                            // Assign "fired" variable ASAP
                            // w/o this timeout "document.activeElement" is <body>
                        }, 0);
                    });
                    navCta.addEventListener(eventName, () => {
                        linkRef.current.fired = true;
                    });
                });
            }
            clearTimeout(timeout);
            // Timeout to give Journey enough time to have the "rollover" available
        }, 500);
        // Don't add "linkRef.current" as "deps", it will trigger the "useEffect" twice
        // causing changing the attribute "aria-hidden" twice as well. Each time "aria-hidden" is changed
        // The Journey Builder, MutationObserver is going to be triggered each time "aria-hidden" changes.
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NavCTA',
                variation: 'Link'
            });
    }, [onAppears]);
    return (React.createElement(Link, { href: subscribeUrl, target: "_blank", ref: linkRef, "aria-label": "Opens in a new window" }, copy));
};
NavCTA.displayName = 'NavCTA';
NavCTA.propTypes = {
    data: PropTypes.shape({
        copy: PropTypes.shape({
            mobile: PropTypes.string,
            tablet: PropTypes.string,
            desktop: PropTypes.string
        }),
        subscribeUrl: PropTypes.shape({
            mobile: PropTypes.string,
            tablet: PropTypes.string,
            desktop: PropTypes.string
        })
    }),
    onAppears: PropTypes.func,
    viewport: PropTypes.string.isRequired
};
NavCTA.requireDataFields = [
    'copy.mobile',
    'copy.tablet',
    'copy.desktop',
    'subscribeUrl.mobile',
    'subscribeUrl.tablet',
    'subscribeUrl.desktop'
];
module.exports = NavCTA;
//# sourceMappingURL=NavCTA.js.map

/***/ }),

/***/ 67516:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NavCTA = __webpack_require__(71135);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport]);
module.exports = wrap(NavCTA);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 82552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles, isInverted } = __webpack_require__(26865);
const { resolveMenuKey } = __webpack_require__(70698);
const Link = styled.a.withConfig({
    displayName: 'NavCTALink'
}) `
  display: block;
  text-decoration: none;
  white-space: nowrap;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}
  color: ${({ theme }) => getColorToken(theme, 'colors.foundation.collapsed-menu.nav-link.hover')};

  &:link {
    color: ${({ theme }) => getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.hover'))};
  }

  &:visited {
    ${({ theme, isActive }) => isActive
    ? `color: ${getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
        ? 'colors.consumption.lead.inverted.link-hover'
        : 'colors.foundation.collapsed-menu.nav-link.hover'))};}`
    : isInverted(theme) &&
        `color : ${getColorToken(theme, resolveMenuKey(theme, 'colors.consumption.lead.inverted.link'))}`}
  }

  &:hover,
  &:focus {
    text-decoration: none;

    ${({ theme }) => isInverted(theme) &&
    `color : ${getColorToken(theme, resolveMenuKey(theme, 'colors.consumption.lead.inverted.link-hover'))}`}
  }
`;
module.exports = {
    Link
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 23543:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Button = __webpack_require__(6024);
const Link = __webpack_require__(67516);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const NavCTA = Link;
// All Variations
NavCTA.Button = Button;
NavCTA.Link = Link;
module.exports = asJourneyUnit(NavCTA, 'nav-cta__component');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18754:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { Item, OverlayNavigationItem, OverlayNavigationLink } = __webpack_require__(75134);
const { TrackComponentChannel } = __webpack_require__(78788);
const { MegaMenuUtilityLinks } = __webpack_require__(10246);
const { NavDrawerTextClickable } = __webpack_require__(57867);
const NavDrawer = ({ data, viewport, use }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NavDrawer'
            });
    }, []);
    switch (use) {
        case 'OverlayNavigation':
            return (React.createElement(OverlayNavigationItem, null,
                React.createElement(OverlayNavigationLink, { className: "cm-nav-drawer", href: data.ctaUrl[viewport], as: "a", contentAlign: "vertical" }, data.cta)));
        case 'SecondaryMenu':
            return (React.createElement(Item, { className: "cm-nav-drawer", attributes: {
                    'aria-label': data.cta
                }, links: [
                    {
                        text: data.cta,
                        url: data.ctaUrl[viewport],
                        isExternalLink: true
                    }
                ], contentAlign: "vertical" }));
        case 'MegaMenu':
            return (React.createElement("div", { className: "cm-nav-drawer" },
                React.createElement(MegaMenuUtilityLinks, { utilityLinksOneItem: true, links: [
                        {
                            text: data.cta,
                            url: data.ctaUrl[viewport]
                        }
                    ] })));
        case 'OneNavTextClickable':
            return (React.createElement(NavDrawerTextClickable, { label: data.cta, url: data.ctaUrl[viewport] }));
        default:
            return null;
    }
};
NavDrawer.displayName = 'NavDrawer';
NavDrawer.propTypes = {
    data: PropTypes.shape({
        cta: PropTypes.string.isRequired,
        ctaUrl: PropTypes.shape({
            mobile: PropTypes.string.isRequired,
            tablet: PropTypes.string.isRequired,
            desktop: PropTypes.string.isRequired
        })
    }),
    use: PropTypes.oneOf([
        'OverlayNavigation',
        'SecondaryMenu',
        'MegaMenu',
        'OneNavTextClickable'
    ]).isRequired,
    viewport: PropTypes.string
};
NavDrawer.requireDataFields = [
    'cta',
    'ctaUrl.mobile',
    'ctaUrl.tablet',
    'ctaUrl.desktop'
];
module.exports = NavDrawer;
//# sourceMappingURL=NavDrawer.js.map

/***/ }),

/***/ 96802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NavDrawer = __webpack_require__(18754);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, withViewport, asJourneyUnit]);
module.exports = wrap(NavDrawer);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 75134:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { SecondaryMenuUtilityLinks } = __webpack_require__(90098);
const { OverlayNavigationUtilityLink, OverlayNavigationUtilityListItem } = __webpack_require__(18550);
const Item = styled(SecondaryMenuUtilityLinks).withConfig({
    displayName: 'JourneyNavDrawerItem'
}) ``;
const OverlayNavigationItem = styled(OverlayNavigationUtilityListItem).withConfig({
    displayName: 'JourneyNavDrawerMegaMenuItem'
}) ``;
const OverlayNavigationLink = styled(OverlayNavigationUtilityLink).withConfig({
    displayName: 'JourneyNavDrawerMegaMenuLink'
}) ``;
module.exports = {
    Item,
    OverlayNavigationItem,
    OverlayNavigationLink
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 98892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useEffect } = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
const { Wrapper, Copy, Hed, Dek, UnitWrapper, CTA, Image } = __webpack_require__(32788);
const NavRollover = ({ data, isStoryBook = false }) => {
    useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NavRollover'
            });
    });
    const { hed, dek, cta, img } = data;
    return (React.createElement(Wrapper, { "data-testid": "NavRollover", isStoryBook: isStoryBook },
        React.createElement(UnitWrapper, { href: cta.url },
            React.createElement(Copy, null,
                React.createElement(Hed, null, hed),
                React.createElement(Dek, null, dek),
                React.createElement(CTA, null, cta.text)),
            React.createElement(Image, { src: img.url, alt: img.alt }))));
};
NavRollover.displayName = 'NavRollover';
NavRollover.propTypes = {
    data: PropTypes.shape({
        hed: PropTypes.string.isRequired,
        dek: PropTypes.string.isRequired,
        cta: PropTypes.shape({
            text: PropTypes.string.isRequired,
            url: PropTypes.string.isRequired
        }),
        img: PropTypes.shape({
            alt: PropTypes.string.isRequired,
            url: PropTypes.string.isRequired
        })
    }),
    isStoryBook: PropTypes.bool
};
NavRollover.requireDataFields = [
    'hed',
    'dek',
    'cta.url',
    'cta.text',
    'img.url',
    'img.alt'
];
module.exports = NavRollover;
//# sourceMappingURL=NavRollover.js.map

/***/ }),

/***/ 90768:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NavRollover = __webpack_require__(98892);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback]);
module.exports = wrap(NavRollover);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 32788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles } = __webpack_require__(26865);
const HideRollover = css `
  position: absolute;
  transform: translateY(-14px);
  transition: opacity 0.2s linear 0s, transform 0.2s ease 0s,
    visibility 0.2s linear 0s;
  visibility: hidden;
  transition-delay: 300ms;
  opacity: 0;
  z-index: 80;
`;
const ShowRollover = css `
  transform: translateY(0);
  visibility: visible;
  opacity: 1;
  transition-delay: 0s;
`;
const Wrapper = styled.div.withConfig({ displayName: 'Wrapper' }) `
  ${({ isStoryBook }) => !isStoryBook &&
    `
    ${HideRollover}
    
    &:hover,
    &:focus {
      ${ShowRollover}

    }
  `}
`;
const UnitWrapper = styled.a.withConfig({ displayName: 'UnitWrapper' }) `
  display: block;
  position: relative;
  margin-top: 8px;
  border: 1px solid rgba(233, 233, 233, 1);
  background-color: rgba(255, 255, 255, 1);
  padding: 13px 20px;
  width: 225.43px;
  height: 130px;
  text-decoration: none;
`;
const Copy = styled.div.withConfig({ displayName: 'Copy' }) `
  display: flex;
  flex-direction: column;
  max-width: 133px;
  color: ${getColorToken('colors.interactive.base.black')};
`;
const Hed = styled.span.withConfig({
    displayName: 'Hed'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.title-secondary')};
  text-transform: uppercase;
`;
const Dek = styled.span.withConfig({
    displayName: 'Dek'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.list')};
  max-width: 119px;
`;
const Image = styled.img.withConfig({
    displayName: 'Image'
}) `
  position: absolute;
  right: 0;
  bottom: 0;
  width: auto;
  height: 121px;
`;
const CTA = styled.span.withConfig({
    displayName: 'CTAButton'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.title-secondary')};

  margin-top: 8px;
  background-color: rgba(34, 35, 40, 1);
  width: 83.41px;
  height: 28.55px;
  text-align: center;
  text-transform: uppercase;
  line-height: 28.55px;
  color: ${getColorToken('colors.interactive.base.white')};
  font-size: 9px;
`;
module.exports = {
    Wrapper,
    UnitWrapper,
    Copy,
    Hed,
    Dek,
    Image,
    CTA,
    ShowRollover,
    HideRollover
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 16745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useEffect } = __webpack_require__(96540);
const { Anchor, Image, Wrapper } = __webpack_require__(64488);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * NavRollover component - Image variation
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.ctaUrl - CTA URL
 * @param {string} props.data.image.alt - image alt text
 * @param {boolean} props.data.image.scale - option to scale the image
 * @param {string} props.data.image.src - image src url
 * @param {boolean} props.isStoryBook - StoryBook
 * @returns {ReactElement} - React Component
 */
const NavRollover = ({ data, isStoryBook }) => {
    const { ctaUrl, image: { src: imageSrc, alt: imageAlt, scale } } = data;
    useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NavRollover',
                variation: 'Image'
            });
    });
    return (React.createElement(Wrapper, { isStoryBook: isStoryBook },
        React.createElement(Anchor, { href: ctaUrl, target: "_blank", "data-testid": "NavRollover", "aria-label": "Opens in a new window" },
            React.createElement(Image, { alt: imageAlt, src: imageSrc, scaleImageToFit: scale }))));
};
NavRollover.displayName = 'NavRollover.Image';
NavRollover.propTypes = {
    data: PropTypes.shape({
        ctaUrl: PropTypes.string.isRequired,
        image: PropTypes.shape({
            alt: PropTypes.string.isRequired,
            scale: PropTypes.bool,
            src: PropTypes.string.isRequired
        }).isRequired
    }),
    isStoryBook: PropTypes.bool
};
NavRollover.requireDataFields = ['ctaUrl', 'image.alt', 'image.src'];
module.exports = NavRollover;
//# sourceMappingURL=Image.js.map

/***/ }),

/***/ 16652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const Image = __webpack_require__(16745);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback]);
module.exports = wrap(Image);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 64488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { ZINDEX_MAP } = __webpack_require__(96472);
const { ShowRollover, HideRollover } = __webpack_require__(32788);
const Wrapper = styled.div.withConfig({ displayName: 'Wrapper' }) `
  ${({ isStoryBook }) => !isStoryBook &&
    `
    ${HideRollover}
    width: 300px;
    height: 200px;
    overflow: hidden;
    z-index: ${ZINDEX_MAP.navFixed};

    &:hover,
    &:focus,
    &:focus-within{
     ${ShowRollover}
    }
  `}
`;
const Anchor = styled.a.withConfig({
    displayName: 'NavRolloverAnchor'
}) `
  display: flex;
  justify-content: center;
`;
const Image = styled.img.withConfig({
    displayName: 'NavRolloverImage'
}) `
  ${({ scaleImageToFit }) => scaleImageToFit &&
    `
    width: 300px;
    height: 200px;
  `}
`;
module.exports = {
    Wrapper,
    Anchor,
    Image
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 69390:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Default = __webpack_require__(90768);
const Image = __webpack_require__(16652);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const NavRollover = Default;
// All Variations
NavRollover.Image = Image;
module.exports = asJourneyUnit(NavRollover, 'nav-rollover__component');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClick = __webpack_require__(38267);
/**
 * NewsletterExtended component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.buttonLabel - button label
 * @param {string} props.data.dangerousDek - dangerous dek
 * @param {string} props.data.dangerousDisclaimer - dangerous disclaimer
 * @param {string} props.data.newsletterId - newsletter Id
 * @param {Element} props.contentWrapper - Required content wrapper component
 * @returns {ReactElement} - React Component
 */
const NewsletterExtended = ({ data, contentWrapper }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'Newsletter',
                variation: 'Extended'
            });
    }, []);
    const formName = 'newsletter-one-click-extended';
    const sourceCode = 'article-newsletter-oneclick';
    const variationName = 'Extended';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data.dangerousHed,
        newsletterId: data.newsletterId,
        ContentWrapper: contentWrapper,
        formName,
        sourceCode,
        variationName
    };
    return React.createElement(NewsletterOneClick.Extended, { ...props });
};
NewsletterExtended.displayName = 'NewsletterExtended';
NewsletterExtended.propTypes = {
    contentWrapper: PropTypes.elementType.isRequired,
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterExtended.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'dangerousHed',
    'newsletterId'
];
module.exports = NewsletterExtended;
//# sourceMappingURL=NewsletterExtended.js.map

/***/ }),

/***/ 44572:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterExtended = __webpack_require__(18240);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterExtended);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 84610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClick = __webpack_require__(38267);
/**
 * NewsletterExtraSlim component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.buttonLabel - button label
 * @param {string} props.data.dangerousDek - dangerous dek
 * @param {string} props.data.dangerousDisclaimer - dangerous disclaimer
 * @param {string} props.data.newsletterId - newsletter Id
 * @param {Element} props.contentWrapper - Required content wrapper component
 * @returns {ReactElement} - React Component
 */
const NewsletterExtraSlim = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'Newsletter',
                variation: 'Slim'
            });
    }, []);
    const formName = 'newsletter-one-click-extra-slim';
    const sourceCode = 'extraSlim-newsletter';
    const variationName = 'ExtraSlim';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        newsletterId: data.newsletterId,
        formName,
        sourceCode,
        variationName
    };
    return React.createElement(NewsletterOneClick.ExtraSlim, { ...props });
};
NewsletterExtraSlim.displayName = 'NewsletterExtraSlim';
NewsletterExtraSlim.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterExtraSlim.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'newsletterId'
];
module.exports = NewsletterExtraSlim;
//# sourceMappingURL=NewsletterExtraSlim.js.map

/***/ }),

/***/ 72924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterExtraSlim = __webpack_require__(84610);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterExtraSlim);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 82030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClick = __webpack_require__(38267);
/**
 * NewsletterExtraSlimWithActionSheet component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.buttonLabel - button label
 * @param {string} props.data.dangerousDek - dangerous dek
 * @param {string} props.data.dangerousDisclaimer - dangerous disclaimer
 * @param {string} props.data.newsletterId - newsletter Id
 * @param {Element} props.contentWrapper - Required content wrapper component
 * @returns {ReactElement} - React Component
 */
const NewsletterExtraSlimWithActionSheet = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'Newsletter',
                variation: 'Slim'
            });
    }, []);
    const formName = 'newsletter-one-click-extra-slim-with-action-sheet';
    const sourceCode = 'extraSlim-newsletter-with-action-sheet';
    const variationName = 'ExtraSlimWithActionSheet';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        newsletterId: data.newsletterId,
        formName,
        sourceCode,
        variationName
    };
    return React.createElement(NewsletterOneClick.ExtraSlimWithActionSheet, { ...props });
};
NewsletterExtraSlimWithActionSheet.displayName =
    'NewsletterExtraSlimWithActionSheet';
NewsletterExtraSlimWithActionSheet.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterExtraSlimWithActionSheet.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'newsletterId'
];
module.exports = NewsletterExtraSlimWithActionSheet;
//# sourceMappingURL=NewsletterExtraSlimWithActionSheet.js.map

/***/ }),

/***/ 1969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterExtraSlimWithActionSheet = __webpack_require__(82030);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterExtraSlimWithActionSheet);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 51932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClick = __webpack_require__(38267);
const NewsletterOneClickSlim = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NewsletterOneClick',
                variation: 'Slim'
            });
    }, []);
    const formName = 'newsletter-one-click-slim';
    const sourceCode = 'newsletter-slim-oneclick';
    const variationName = 'SlimOneClick';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data.dangerousHed,
        newsletterId: data.newsletterId,
        formName,
        sourceCode,
        variationName
    };
    return React.createElement(NewsletterOneClick.SlimOneClick, { ...props });
};
NewsletterOneClickSlim.displayName = 'NewsletterOneClickSlim';
NewsletterOneClickSlim.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterOneClickSlim.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'dangerousHed',
    'newsletterId'
];
module.exports = NewsletterOneClickSlim;
//# sourceMappingURL=NewsletterOneClickSlim.js.map

/***/ }),

/***/ 9860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterOneClickSlim = __webpack_require__(51932);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterOneClickSlim);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 27558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterPlp = __webpack_require__(32334);
const NewsletterPLP = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NewsletterPLP'
            });
    }, []);
    const formName = 'newsletter-plp';
    const sourceCode = 'newsletter-plp';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data.dangerousHed,
        newsletterId: data.newsletterId,
        imageUrl: data.imageUrl,
        formName,
        sourceCode
    };
    return React.createElement(NewsletterPlp, { ...props });
};
NewsletterPLP.displayName = 'NewsletterPLP';
NewsletterPLP.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired,
        imageUrl: PropTypes.string.isRequired
    })
};
NewsletterPLP.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'dangerousHed',
    'newsletterId',
    'imageUrl'
];
module.exports = NewsletterPLP;
//# sourceMappingURL=NewsletterPLP.js.map

/***/ }),

/***/ 69275:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterPLP = __webpack_require__(27558);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterPLP);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 61974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const RibbonUnitCountDown = (__webpack_require__(95959)/* ["default"] */ .A);
const NewsletterRibbon = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NewsletterRibbon'
            });
    }, []);
    const formName = 'newsletter-ribbon';
    const sourceCode = 'newsletter-ribbon';
    const props = {
        buttonLabel: data.buttonLabel,
        buttonLabelLive: data.buttonLabelLive,
        buttonLabelAfter: data.buttonLabelAfter,
        dangerousDek: data.dangerousDek,
        dangerousDekCountdown: data.dangerousDekCountdown,
        dangerousDekAfter: data.dangerousDekAfter,
        landingPageURL: data.landingPageURL,
        landingPageURLLive: data.landingPageURLLive,
        landingPageURLAfter: data.landingPageURLAfter,
        liveIndicator: data.liveIndicator,
        countDownStartTime: data.countDownStartTime,
        eventStartTime: data.eventStartTime,
        eventEndTime: data.eventEndTime,
        formName,
        sourceCode
    };
    return React.createElement(RibbonUnitCountDown, { ...props });
};
NewsletterRibbon.displayName = 'NewsletterRibbon';
NewsletterRibbon.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        buttonLabelLive: PropTypes.string.isRequired,
        buttonLabelAfter: PropTypes.string.isRequired,
        dangerousDekCountdown: PropTypes.string.isRequired,
        dangerousDekAfter: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        landingPageURL: PropTypes.string.isRequired,
        landingPageURLLive: PropTypes.string.isRequired,
        liveIndicator: PropTypes.boolean,
        landingPageURLAfter: PropTypes.string.isRequired,
        countDownStartTime: PropTypes.string.isRequired,
        eventStartTime: PropTypes.string.isRequired,
        eventEndTime: PropTypes.string.isRequired
    })
};
NewsletterRibbon.requireDataFields = [
    'buttonLabel',
    'buttonLabelLive',
    'buttonLabelAfter',
    'dangerousDekCountdown',
    'dangerousDekAfter',
    'dangerousDek',
    'landingPageURL',
    'landingPageURLLive',
    'liveIndicator',
    'landingPageURLAfter',
    'countDownStartTime',
    'eventStartTime',
    'eventEndTime'
];
module.exports = NewsletterRibbon;
//# sourceMappingURL=NewsletterRibbon.js.map

/***/ }),

/***/ 55509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterRibbon = __webpack_require__(61974);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback]);
module.exports = wrap(NewsletterRibbon);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 70820:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const RibbonUnit = (__webpack_require__(35989)/* ["default"] */ .A);
const NewsletterRibbon = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NewsletterRibbon'
            });
    }, []);
    const formName = 'newsletter-ribbon';
    const sourceCode = 'newsletter-ribbon';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        landingPageURL: data.landingPageURL,
        liveIndicator: data.liveIndicator,
        formName,
        sourceCode
    };
    return React.createElement(RibbonUnit, { ...props });
};
NewsletterRibbon.displayName = 'NewsletterRibbon';
NewsletterRibbon.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        landingPageURL: PropTypes.string.isRequired,
        liveIndicator: PropTypes.boolean
    })
};
NewsletterRibbon.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'landingPageURL'
];
module.exports = NewsletterRibbon;
//# sourceMappingURL=NewsletterRibbon.js.map

/***/ }),

/***/ 5159:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterRibbon = __webpack_require__(70820);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback]);
module.exports = wrap(NewsletterRibbon);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 33125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Default = __webpack_require__(5159);
const Countdown = __webpack_require__(55509);
const asJourneyUnit = __webpack_require__(51806);
const NewsletterRibbon = Default;
// All Variations
NewsletterRibbon.Countdown = Countdown;
module.exports = asJourneyUnit(NewsletterRibbon);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 60288:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClick = __webpack_require__(38267);
const NewsletterSlim = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'Newsletter',
                variation: 'Slim'
            });
    }, []);
    const formName = 'newsletter-one-click-slim';
    const sourceCode = 'slim-newsletter-oneclick';
    const variationName = 'Slim';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data.dangerousHed,
        newsletterId: data.newsletterId,
        formName,
        sourceCode,
        variationName
    };
    return React.createElement(NewsletterOneClick.Slim, { ...props });
};
NewsletterSlim.displayName = 'NewsletterSlim';
NewsletterSlim.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterSlim.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'dangerousHed',
    'newsletterId'
];
module.exports = NewsletterSlim;
//# sourceMappingURL=NewsletterSlim.js.map

/***/ }),

/***/ 33648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterSlim = __webpack_require__(60288);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterSlim);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 26798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClickVertical = __webpack_require__(81159);
const NewsletterVertical = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NewsletterVertical'
            });
    }, []);
    const formName = 'newsletter-one-click-vertical';
    const sourceCode = 'vertical-newsletter';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data?.dangerousHed,
        imageMaxWidth: data?.imageMaxWidth,
        imageUrl: data?.imageUrl,
        logoMaxHeight: data?.logoMaxHeight,
        logoUrl: data.logoUrl,
        newsletterId: data.newsletterId,
        formName,
        sourceCode
    };
    return React.createElement(NewsletterOneClickVertical, { ...props });
};
NewsletterVertical.displayName = 'NewsletterVertical';
NewsletterVertical.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string,
        imageMaxWidth: PropTypes.number,
        imageUrl: PropTypes.string,
        logoMaxHeight: PropTypes.number,
        logoUrl: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterVertical.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'logoUrl',
    'newsletterId'
];
module.exports = NewsletterVertical;
//# sourceMappingURL=NewsletterVertical.js.map

/***/ }),

/***/ 4747:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterVertical = __webpack_require__(26798);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterVertical);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 52360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterOneClickVertical = __webpack_require__(81159);
const NewsletterVerticalBottom = ({ data, contentWrapper }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'NewsletterVerticalBottom'
            });
    }, []);
    const formName = 'newsletter-one-click-vertical-bottom';
    const sourceCode = 'newsletter-vertical-bottom';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        dangerousHed: data?.dangerousHed,
        ContentWrapper: contentWrapper,
        hasContentWrapper: true,
        imageMaxWidth: data?.imageMaxWidth,
        imageUrl: data?.imageUrl,
        logoMaxHeight: data?.logoMaxHeight,
        logoUrl: data.logoUrl,
        newsletterId: data.newsletterId,
        formName,
        sourceCode
    };
    return React.createElement(NewsletterOneClickVertical, { ...props });
};
NewsletterVerticalBottom.displayName = 'NewsletterVerticalBottom';
NewsletterVerticalBottom.propTypes = {
    contentWrapper: PropTypes.elementType.isRequired,
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string,
        imageMaxWidth: PropTypes.number,
        imageUrl: PropTypes.string,
        logoMaxHeight: PropTypes.number,
        logoUrl: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterVerticalBottom.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'logoUrl',
    'newsletterId'
];
module.exports = NewsletterVerticalBottom;
//# sourceMappingURL=NewsletterVerticalBottom.js.map

/***/ }),

/***/ 34824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterVerticalBottom = __webpack_require__(52360);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterVerticalBottom);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 96478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const NewsletterOneClickVerticalPullQuote = __webpack_require__(74840);
const NewsletterVerticalPullQuote = ({ data }) => {
    const formName = 'newsletter-one-click-vertical-pullquote';
    const sourceCode = 'vertical-newsletter-pullquote';
    const props = {
        buttonLabel: data.buttonLabel,
        dangerousDek: data.dangerousDek,
        dangerousDisclaimer: data.dangerousDisclaimer,
        newsletterId: data.newsletterId,
        formName,
        sourceCode
    };
    return React.createElement(NewsletterOneClickVerticalPullQuote, { ...props });
};
NewsletterVerticalPullQuote.displayName = 'NewsletterVerticalPullQuote';
NewsletterVerticalPullQuote.propTypes = {
    data: PropTypes.shape({
        buttonLabel: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousDisclaimer: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired
    })
};
NewsletterVerticalPullQuote.requireDataFields = [
    'buttonLabel',
    'dangerousDek',
    'dangerousDisclaimer',
    'newsletterId'
];
module.exports = NewsletterVerticalPullQuote;
//# sourceMappingURL=NewsletterVerticalPullQuote.js.map

/***/ }),

/***/ 75996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const NewsletterVerticalPullQuote = __webpack_require__(96478);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(NewsletterVerticalPullQuote);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 71372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useState } = React;
const PropTypes = __webpack_require__(5556);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { TrackComponentChannel } = __webpack_require__(78788);
const { Wrapper, ContentContainer, ExpandedContentWrapper, CollapsedContentWrapper, ChevronButton, StyledChevron, Column, SubHedCopy, SubHedImage, Hed, Dek, CTAButton, CTALink, Image, SignInContainer, SignInCopy, SignInLink, Copy } = __webpack_require__(92669);
const Formatted = {
    CTALink: withFormatter(CTALink),
    Copy: withFormatter(Copy),
    Dek: withFormatter(Dek),
    Hed: withFormatter(Hed),
    SubHedCopy: withFormatter(SubHedCopy)
};
const contentPropTypes = {
    collapsed: PropTypes.shape({
        copy: PropTypes.string,
        cta: PropTypes.shape({
            url: PropTypes.string,
            copy: PropTypes.string
        })
    }),
    expanded: PropTypes.shape({
        subHed: PropTypes.shape({
            renderSubHedImage: PropTypes.bool,
            copy: PropTypes.string,
            img: PropTypes.shape({
                alt: PropTypes.string,
                src: PropTypes.string
            })
        }),
        hed: PropTypes.string,
        dek: PropTypes.string,
        cta: PropTypes.shape({
            url: PropTypes.string,
            copy: PropTypes.string
        }),
        signIn: PropTypes.shape({
            copy: PropTypes.string,
            linkCopy: PropTypes.string,
            url: PropTypes.string
        }),
        img: PropTypes.shape({
            src: PropTypes.string,
            alt: PropTypes.string
        })
    })
};
const ExpandedContent = ({ expanded = {}, shouldHide, imageSize, signInData }) => {
    const { subHed: { renderSubHedImage = false, copy: subHedCopy, img: subHedImage = {} } = {}, hed, dek, cta = {}, signIn = {}, img = {} } = expanded;
    return (React.createElement(ExpandedContentWrapper, { shouldHide: shouldHide, hasImage: img.src },
        React.createElement(Column, null,
            !renderSubHedImage && subHedCopy && (React.createElement(Formatted.SubHedCopy, { html: subHedCopy })),
            renderSubHedImage && subHedImage.src && (React.createElement(SubHedImage, { ...subHedImage })),
            React.createElement(Formatted.Hed, { html: hed }),
            React.createElement(Formatted.Dek, { html: dek }),
            React.createElement(CTAButton, { href: cta.url }, cta.copy),
            React.createElement(SignInContainer, null,
                React.createElement(SignInCopy, null,
                    signInData?.copy || signIn.copy,
                    "\u00A0"),
                React.createElement(SignInLink, { href: withRedirect(signInData?.cta?.url || signIn.url) }, signInData?.cta?.text || signIn.linkCopy))),
        img.src && React.createElement(Image, { src: img.src, alt: img.alt, size: imageSize })));
};
ExpandedContent.propTypes = {
    expanded: contentPropTypes.expanded,
    imageSize: PropTypes.oneOf(['small', 'large']),
    shouldHide: PropTypes.bool,
    signInData: PropTypes.shape({
        copy: PropTypes.string,
        cta: PropTypes.shape({
            url: PropTypes.string,
            text: PropTypes.string
        })
    })
};
const CollapsedContent = ({ collapsed = {}, shouldHide }) => {
    const { copy, cta = {} } = collapsed;
    return (React.createElement(CollapsedContentWrapper, { shouldHide: shouldHide },
        copy && React.createElement(Formatted.Copy, { html: `${copy}` }),
        "\u00A0",
        React.createElement(Formatted.CTALink, { href: cta.url, html: cta.copy })));
};
CollapsedContent.propTypes = {
    collapsed: contentPropTypes.collapsed,
    shouldHide: PropTypes.bool
};
function PaywallBar({ data = {}, viewport, isStoryBook }) {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'PaywallBar'
            });
    }, []);
    const [isExpanded, setExpanded] = useState(data.initialStatus === 'expanded');
    const containerId = Math.random()
        .toString(26)
        .substr(2, 12)
        .replace(/\d+/g, '');
    return (React.createElement(Wrapper, { "data-testid": "paywall-bar", expanded: isExpanded, isStoryBook: isStoryBook, className: viewport, role: "dialog", "aria-describedby": containerId },
        React.createElement(ChevronButton, { onClick: () => setExpanded(!isExpanded), "aria-label": isExpanded ? 'Collapse' : 'Expand', "aria-expanded": isExpanded, "aria-controls": containerId, expanded: isExpanded },
            React.createElement(StyledChevron, null)),
        React.createElement(ContentContainer, { id: containerId, role: "region", "aria-live": "polite" },
            React.createElement(ExpandedContent, { ...data[viewport], shouldHide: !isExpanded, imageSize: data.imageSize, signInData: data.signIn }),
            React.createElement(CollapsedContent, { ...data[viewport], shouldHide: isExpanded }))));
}
PaywallBar.propTypes = {
    data: PropTypes.shape({
        signIn: PropTypes.shape({
            copy: PropTypes.string,
            cta: PropTypes.shape({
                url: PropTypes.string,
                text: PropTypes.string
            })
        }),
        initialStatus: PropTypes.oneOf(['expanded', 'collapsed']),
        imageSize: PropTypes.oneOf(['small', 'large']),
        mobile: PropTypes.shape(contentPropTypes),
        tablet: PropTypes.shape(contentPropTypes),
        desktop: PropTypes.shape(contentPropTypes)
    }),
    isStoryBook: PropTypes.bool,
    viewport: PropTypes.string
};
PaywallBar.displayName = 'PaywallBar';
PaywallBar.requireDataFields = [
    'initialStatus',
    'imageSize',
    'mobile.expanded.hed',
    'mobile.expanded.dek',
    'mobile.expanded.cta.url',
    'mobile.expanded.cta.copy',
    'mobile.collapsed.copy',
    'mobile.collapsed.cta.url',
    'mobile.collapsed.cta.copy',
    'tablet.expanded.hed',
    'tablet.expanded.dek',
    'tablet.expanded.cta.url',
    'tablet.expanded.cta.copy',
    'tablet.expanded.img.src',
    'tablet.expanded.img.alt',
    'tablet.collapsed.copy',
    'tablet.collapsed.cta.url',
    'tablet.collapsed.cta.copy',
    'desktop.expanded.hed',
    'desktop.expanded.dek',
    'desktop.expanded.cta.url',
    'desktop.expanded.cta.copy',
    'desktop.expanded.img.src',
    'desktop.expanded.img.alt',
    'desktop.collapsed.copy',
    'desktop.collapsed.cta.url',
    'desktop.collapsed.cta.copy'
];
module.exports = PaywallBar;
//# sourceMappingURL=PaywallBar.js.map

/***/ }),

/***/ 26419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const PaywallBar = __webpack_require__(71372);
const { withDataFallback } = __webpack_require__(58872);
const { withViewport } = __webpack_require__(17936);
const { withJourneyTheme } = __webpack_require__(43219);
const wrap = flow([withDataFallback, withViewport, withJourneyTheme]);
module.exports = wrap(PaywallBar);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 92669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { colorPickerFactory } = __webpack_require__(43219);
const { getTypographyStyles } = __webpack_require__(26865);
const { ChevronRight } = __webpack_require__(97504);
const Grid = __webpack_require__(86659);
const { GridItem } = __webpack_require__(40653);
const { inMobile, inTablet, inDesktop, inExtraLargeDesktop } = __webpack_require__(94130);
const colorFor = colorPickerFactory('PaywallBar');
const Wrapper = styled.div.withConfig({ displayName: 'PaywallBarWrapper' }) `
  display: flex;
  position: relative;
  transition: height 0.4s ease-in-out;
  box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, 0.1);
  background-color: ${colorFor('background')};
  width: 100%;
  height: ${({ expanded }) => (expanded ? '351' : '58')}px;

  ${({ isStoryBook }) => isStoryBook && 'margin-top: 150px'};

  ${inMobile} {
    align-items: center;
    ${({ expanded }) => (expanded ? 'justify-content: center' : '')};
  }
  ${inDesktop} {
    height: ${({ expanded }) => (expanded ? '320' : '58')}px;
  }
`;
const ContentContainer = styled.div.withConfig({
    displayName: 'PaywallBarContentContainer'
}) `
  width: 100%;
  height: 100%;
  ${inMobile} {
    display: flex;
  }
`;
const ExpandedContentWrapper = styled(Grid.NoMargins).withConfig({
    displayName: 'PaywallBarExpandedContent'
}) `
  > ${GridItem} {
    grid-column: auto / span 6;

    ${inMobile} {
      &:first-child {
        grid-column: span 4;
      }
    }
    ${({ hasImage }) => hasImage &&
    `
      &:last-child{
        margin: auto;
      }`}
  }
  display: flex;
  padding: 32px 24px;

  ${inMobile} {
    margin: 0 auto;
    text-align: center;
  }
  ${inTablet} {
    justify-content: space-between;
    padding-right: 48px;
    padding-left: 48px;
    width: 100%;
  }
  ${inDesktop} {
    justify-content: space-between;
    padding-right: 48px;
    padding-left: 48px;
    width: 100%;
  }
  ${inExtraLargeDesktop} {
    padding-right: 64px;
    padding-left: 64px;
  }

  && {
    ${({ shouldHide }) => (shouldHide ? 'display: none' : '')}
  }
`;
const CollapsedContentWrapper = styled.div.withConfig({
    displayName: 'PaywallBarCollapsedContent'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  display: flex;
  align-items: center;
  padding-left: 64px;
  height: 100%;

  ${inMobile} {
    padding-left: 24px;
  }
  ${inTablet} {
    padding-left: 48px;
  }
  ${({ shouldHide }) => (shouldHide ? 'display: none' : '')}
`;
const ChevronButton = styled.button.withConfig({
    displayName: 'PaywallBarChevronButton'
}) `
  position: absolute;
  top: 12px;
  right: 16px;
  transform: rotate(${({ expanded }) => (expanded ? '90' : '270')}deg);
  transition: 0.4s ease-in-out, top 0.4s ease-in-out;
  background-color: transparent;
  padding: 0;
  width: 32px;
  height: 32px;
  color: ${colorFor('chevronButton')};
`;
const StyledChevron = styled(ChevronRight).withConfig({
    displayName: 'PaywallBarChevron'
}) `
  & {
    width: 32px;
    height: 32px;
    fill: ${colorFor('chevronButton')};
  }
`;
const Column = styled.div.withConfig({ displayName: 'PaywallBarColumn' }) `
  display: flex;
  flex-direction: column;
  max-height: 256px;
`;
const SubHedCopy = styled.span.withConfig({
    displayName: 'PaywallBarSubHedCopy'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')};
  line-height: 20px;
  color: ${colorFor('subHed')};
`;
const SubHedImage = styled.img.withConfig({
    displayName: 'PaywallBarSubHedImage'
}) `
  margin: 0;
  height: auto;

  ${inMobile} {
    margin: auto;
    width: 200px;
  }

  ${inTablet} {
    width: 230px;
  }

  ${inDesktop} {
    width: 250px;
  }
`;
const Hed = styled.span.withConfig({ displayName: 'PaywallBarHed' }) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-hed')};
  margin: 16px 0 0;
  color: ${colorFor('hed')};

  ${inMobile} {
    margin: 16px auto 0;
  }
`;
const Dek = styled.span.withConfig({ displayName: 'PaywallBarDek' }) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-body')};

  max-width: 460px;
  max-height: 72px;
  color: ${colorFor('dek')};

  ${inMobile} {
    margin: auto;
    max-width: 327px;
  }
  ${inTablet} {
    max-width: 324px;
  }
`;
const Copy = styled.span.withConfig({ displayName: 'PaywallBarCopy' }) `
  color: ${colorFor('collapsedCopy')};
`;
const Link = styled.a.withConfig({ displayName: 'PaywallBarLink' }) `
  &:hover {
    opacity: 0.8;
    text-decoration: underline;
  }
`;
const CTAButton = styled.a.withConfig({
    displayName: 'PaywallBarCTAButton'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-core')};

  display: block;
  margin: 32px 0 16px;
  border-radius: 4px;
  background-color: ${colorFor('ctaButtonBackground')};
  width: 100%;
  max-width: 327px;
  text-align: center;
  text-decoration: none;
  line-height: 48px;
  color: ${colorFor('ctaCopy')};

  &:hover {
    background-color: ${colorFor('ctaHover')};
  }

  ${inMobile} {
    margin: 32px auto 16px;
  }
  ${inTablet} {
    width: 320px;
  }
`;
const CTALink = styled(Link).withConfig({ displayName: 'PaywallBarCTALink' }) `
  text-decoration: underline;
  color: ${colorFor('collapsedCtaLink')};
`;
const Image = styled.img.withConfig({
    displayName: 'PaywallBarImage'
}) `
  margin: auto;
  width: 200px;
  height: auto;
  object-fit: cover;

  ${inDesktop} {
    ${({ size }) => size === 'large' && `width: 375px;`};
  }
`;
const SignInContainer = styled.div.withConfig({
    displayName: 'PaywallBarSignInContainer'
}) `
  line-height: 20px;
`;
const SignInCopy = styled.span.withConfig({
    displayName: 'PaywallBarSignInCopy'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  color: ${colorFor('signInCopy')};
`;
const SignInLink = styled(Link).withConfig({
    displayName: 'PaywallBarSignInLink'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  color: ${colorFor('signInLink')};
`;
module.exports = {
    Wrapper,
    ContentContainer,
    ExpandedContentWrapper,
    CollapsedContentWrapper,
    ChevronButton,
    StyledChevron,
    Column,
    SubHedCopy,
    SubHedImage,
    Hed,
    Dek,
    Image,
    CTAButton,
    CTALink,
    SignInContainer,
    SignInCopy,
    SignInLink,
    Copy
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 1038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useState } = React;
const PropTypes = __webpack_require__(5556);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { TrackComponentChannel } = __webpack_require__(78788);
const { Wrapper, ContentContainer, ExpandedContentWrapper, CollapsedContentWrapper, ChevronButton, StyledChevron, Column, SubHedCopy, SubHedImage, Hed, Dek, CTAButton, CTALink, Image, SignInContainer, SignInCopy, SignInLink, Copy, TopImage, CollapsedImage, CollapsedCopyWrapper } = __webpack_require__(61803);
const Formatted = {
    CTALink: withFormatter(CTALink),
    Copy: withFormatter(Copy),
    Dek: withFormatter(Dek),
    Hed: withFormatter(Hed),
    SubHedCopy: withFormatter(SubHedCopy)
};
const contentPropTypes = {
    collapsed: PropTypes.shape({
        copy: PropTypes.string,
        cta: PropTypes.shape({
            url: PropTypes.string,
            copy: PropTypes.string
        }),
        img: PropTypes.shape({
            alt: PropTypes.string,
            src: PropTypes.string
        })
    }),
    expanded: PropTypes.shape({
        subHed: PropTypes.shape({
            renderSubHedImage: PropTypes.bool,
            copy: PropTypes.string,
            img: PropTypes.shape({
                alt: PropTypes.string,
                src: PropTypes.string
            })
        }),
        hed: PropTypes.string,
        dek: PropTypes.string,
        cta: PropTypes.shape({
            url: PropTypes.string,
            copy: PropTypes.string
        }),
        signIn: PropTypes.shape({
            copy: PropTypes.string,
            linkCopy: PropTypes.string,
            url: PropTypes.string
        }),
        img: PropTypes.shape({
            src: PropTypes.string,
            alt: PropTypes.string
        }),
        topImg: PropTypes.shape({
            src: PropTypes.string,
            alt: PropTypes.string
        })
    })
};
const ExpandedContent = ({ expanded = {}, shouldHide, imageSize, signInData }) => {
    const { subHed: { renderSubHedImage = false, copy: subHedCopy, img: subHedImage = {} } = {}, hed, dek, cta = {}, signIn = {}, img = {}, topImg = {} } = expanded;
    return (React.createElement(ExpandedContentWrapper, { shouldHide: shouldHide, hasImage: img.src },
        React.createElement(Column, null,
            topImg.src ? (React.createElement(TopImage, { src: topImg.src, alt: topImg.alt })) : (React.createElement(React.Fragment, null,
                !renderSubHedImage && subHedCopy && (React.createElement(Formatted.SubHedCopy, { html: subHedCopy })),
                renderSubHedImage && subHedImage.src && (React.createElement(SubHedImage, { ...subHedImage })))),
            React.createElement(Formatted.Hed, { html: hed }),
            React.createElement(Formatted.Dek, { html: dek }),
            React.createElement(CTAButton, { href: cta.url }, cta.copy),
            React.createElement(SignInContainer, null,
                React.createElement(SignInCopy, null,
                    signInData?.copy || signIn.copy,
                    "\u00A0"),
                React.createElement(SignInLink, { href: withRedirect(signInData?.cta?.url || signIn.url) }, signInData?.cta?.text || signIn.linkCopy))),
        img.src && React.createElement(Image, { src: img.src, alt: img.alt, size: imageSize })));
};
ExpandedContent.propTypes = {
    expanded: contentPropTypes.expanded,
    imageSize: PropTypes.oneOf(['small', 'large']),
    shouldHide: PropTypes.bool,
    signInData: PropTypes.shape({
        copy: PropTypes.string,
        cta: PropTypes.shape({
            url: PropTypes.string,
            text: PropTypes.string
        })
    })
};
const CollapsedContent = ({ collapsed = {}, shouldHide }) => {
    const { copy, cta = {}, img = {} } = collapsed;
    return (React.createElement(CollapsedContentWrapper, { shouldHide: shouldHide },
        img.src && React.createElement(CollapsedImage, { src: img.src, alt: img.alt }),
        React.createElement(CollapsedCopyWrapper, null,
            copy && React.createElement(Formatted.Copy, { html: `${copy}` }),
            React.createElement(Formatted.CTALink, { href: cta.url, html: cta.copy }))));
};
CollapsedContent.propTypes = {
    collapsed: contentPropTypes.collapsed,
    shouldHide: PropTypes.bool
};
function PaywallBar({ data = {}, viewport, isStoryBook }) {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'PaywallBar'
            });
    }, []);
    const [isExpanded, setExpanded] = useState(data.initialStatus === 'expanded');
    const containerId = Math.random()
        .toString(26)
        .substr(2, 12)
        .replace(/\d+/g, '');
    return (React.createElement(Wrapper, { "data-testid": "paywall-bar-mobile-image", expanded: isExpanded, isStoryBook: isStoryBook, className: viewport, role: "dialog", "aria-describedby": containerId },
        React.createElement(ChevronButton, { onClick: () => setExpanded(!isExpanded), "aria-label": isExpanded ? 'Collapse' : 'Expand', "aria-expanded": isExpanded, "aria-controls": containerId, expanded: isExpanded },
            React.createElement(StyledChevron, null)),
        React.createElement(ContentContainer, { id: containerId, role: "region", "aria-live": "polite" },
            React.createElement(ExpandedContent, { ...data[viewport], shouldHide: !isExpanded, imageSize: data.imageSize, signInData: data.signIn }),
            React.createElement(CollapsedContent, { ...data[viewport], shouldHide: isExpanded }))));
}
PaywallBar.propTypes = {
    data: PropTypes.shape({
        signIn: PropTypes.shape({
            copy: PropTypes.string,
            cta: PropTypes.shape({
                url: PropTypes.string,
                text: PropTypes.string
            })
        }),
        initialStatus: PropTypes.oneOf(['expanded', 'collapsed']),
        imageSize: PropTypes.oneOf(['small', 'large']),
        mobile: PropTypes.shape(contentPropTypes),
        tablet: PropTypes.shape(contentPropTypes),
        desktop: PropTypes.shape(contentPropTypes)
    }),
    isStoryBook: PropTypes.bool,
    viewport: PropTypes.string
};
PaywallBar.displayName = 'PaywallBar';
PaywallBar.requireDataFields = [
    'initialStatus',
    'imageSize',
    'mobile.expanded.hed',
    'mobile.expanded.dek',
    'mobile.expanded.cta.url',
    'mobile.expanded.cta.copy',
    'mobile.expanded.topImg.src',
    'mobile.expanded.topImg.alt',
    'mobile.collapsed.copy',
    'mobile.collapsed.cta.url',
    'mobile.collapsed.cta.copy',
    'mobile.collapsed.img.src',
    'mobile.collapsed.img.alt',
    'tablet.expanded.hed',
    'tablet.expanded.dek',
    'tablet.expanded.cta.url',
    'tablet.expanded.cta.copy',
    'tablet.expanded.img.src',
    'tablet.expanded.img.alt',
    'tablet.collapsed.copy',
    'tablet.collapsed.cta.url',
    'tablet.collapsed.cta.copy',
    'desktop.expanded.hed',
    'desktop.expanded.dek',
    'desktop.expanded.cta.url',
    'desktop.expanded.cta.copy',
    'desktop.expanded.img.src',
    'desktop.expanded.img.alt',
    'desktop.collapsed.copy',
    'desktop.collapsed.cta.url',
    'desktop.collapsed.cta.copy'
];
module.exports = PaywallBar;
//# sourceMappingURL=PaywallBar.js.map

/***/ }),

/***/ 1601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const PaywallBar = __webpack_require__(1038);
const { withDataFallback } = __webpack_require__(58872);
const { withViewport } = __webpack_require__(17936);
const { withJourneyTheme } = __webpack_require__(43219);
const wrap = flow([withDataFallback, withViewport, withJourneyTheme]);
module.exports = wrap(PaywallBar);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 61803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css, keyframes } = __webpack_require__(92168);
const { colorPickerFactory } = __webpack_require__(43219);
const { getTypographyStyles } = __webpack_require__(26865);
const { ChevronRight } = __webpack_require__(97504);
const Grid = __webpack_require__(86659);
const { GridItem } = __webpack_require__(40653);
const { inMobile, inTablet, inDesktop, inExtraLargeDesktop } = __webpack_require__(94130);
const colorFor = colorPickerFactory('PaywallBar');
const fadeInAnimation = keyframes `
  0% { opacity: 0; }

  100% { opacity: 1; }
`;
const Wrapper = styled.div.withConfig({ displayName: 'PaywallBarWrapper' }) `
  display: flex;
  position: relative;
  transition: height 0.4s cubic-bezier(0.65, 0, 0.35, 1);
  box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, 0.1);
  background-color: ${colorFor('background')};
  width: 100%;

  ${({ isStoryBook }) => isStoryBook &&
    css `
      position: absolute;
      bottom: 0;
    `};

  ${inMobile} {
    align-items: center;
    ${({ expanded }) => expanded && 'justify-content: center'};

    height: ${({ expanded }) => (expanded ? '320' : '104')}px;
  }

  ${inTablet} {
    height: ${({ expanded }) => (expanded ? '351' : '58')}px;
  }

  ${inDesktop} {
    height: ${({ expanded }) => (expanded ? '320' : '58')}px;
  }
`;
const ContentContainer = styled.div.withConfig({
    displayName: 'PaywallBarContentContainer'
}) `
  width: 100%;
  height: 100%;
  ${inMobile} {
    display: flex;
  }
`;
const ExpandedContentWrapper = styled(Grid.NoMargins).withConfig({
    displayName: 'PaywallBarExpandedContent'
}) `
  > ${GridItem} {
    display: flex;
    grid-column: auto / span 6;
    flex-direction: column;
    justify-content: center;
    height: 100%;

    ${inMobile} {
      &:first-child {
        grid-column: span 4;
      }
    }
    ${({ hasImage }) => hasImage &&
    `
      &:last-child{
        margin: auto;
      }`}
  }
  display: flex;
  animation: ${fadeInAnimation} 0.4s cubic-bezier(0, 0, 1, 1) both;
  padding: 32px 24px;
  height: 100%;

  ${inMobile} {
    margin: 0 auto;
    padding: 16px 20px;
    text-align: center;
  }
  ${inTablet} {
    justify-content: space-between;
    padding-right: 48px;
    padding-left: 48px;
    width: 100%;
  }
  ${inDesktop} {
    justify-content: space-between;
    padding-right: 48px;
    padding-left: 48px;
    width: 100%;
  }
  ${inExtraLargeDesktop} {
    padding-right: 64px;
    padding-left: 64px;
  }

  && {
    ${({ shouldHide }) => shouldHide && 'display: none'}
  }
`;
const CollapsedContentWrapper = styled.div.withConfig({
    displayName: 'PaywallBarCollapsedContent'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  display: flex;
  align-items: center;
  animation: ${fadeInAnimation} 0.4s cubic-bezier(0, 0, 1, 1) both;
  padding-left: 64px;
  height: 100%;

  ${inMobile} {
    padding-left: 20px;
  }

  ${inTablet} {
    padding-left: 48px;
  }

  ${({ shouldHide }) => shouldHide && 'display: none'}
`;
const CollapsedImage = styled.img.withConfig({
    displayName: 'PaywallBarCollapsedImage'
}) `
  margin: auto 12px auto 0;
  width: 80px;
  height: auto;
  object-fit: cover;
`;
const CollapsedCopyWrapper = styled.div.withConfig({
    displayName: 'PaywallBarCollapsedCopy'
}) `
  display: flex;
  line-height: 20px;

  ${inMobile} {
    flex-direction: column;

    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  }
`;
const ChevronButton = styled.button.withConfig({
    displayName: 'PaywallBarChevronButton'
}) `
  position: absolute;
  top: 12px;
  right: 16px;
  transform: rotate(${({ expanded }) => (expanded ? '90' : '270')}deg);
  transition: 0.4s cubic-bezier(0.65, 0, 0.35, 1),
    top 0.4s cubic-bezier(0.65, 0, 0.35, 1);
  z-index: 1;
  background-color: transparent;
  padding: 0;
  width: 32px;
  height: 32px;
  color: ${colorFor('chevronButton')};

  ${inMobile} {
    top: ${({ expanded }) => (expanded ? '32px' : '36px')};
    right: 20px;
  }
`;
const StyledChevron = styled(ChevronRight).withConfig({
    displayName: 'PaywallBarChevron'
}) `
  & {
    width: 32px;
    height: 32px;
    fill: ${colorFor('chevronButton')};
  }
`;
const Column = styled.div.withConfig({ displayName: 'PaywallBarColumn' }) `
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 100%;
  max-height: 256px;
`;
const SubHedCopy = styled.span.withConfig({
    displayName: 'PaywallBarSubHedCopy'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')};
  line-height: 20px;
  color: ${colorFor('subHed')};
`;
const SubHedImage = styled.img.withConfig({
    displayName: 'PaywallBarSubHedImage'
}) `
  margin: 0;
  height: auto;

  ${inMobile} {
    margin: auto;
    width: 200px;
  }

  ${inTablet} {
    width: 230px;
  }

  ${inDesktop} {
    width: 250px;
  }
`;
const Hed = styled.span.withConfig({ displayName: 'PaywallBarHed' }) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-hed')};
  margin: 16px 0 0;
  color: ${colorFor('hed')};

  ${inMobile} {
    margin: 12px auto 0;
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-hed')};
  }
`;
const Dek = styled.span.withConfig({ displayName: 'PaywallBarDek' }) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.modal-body')};

  max-width: 460px;
  max-height: 72px;
  color: ${colorFor('dek')};

  ${inMobile} {
    margin: 8px auto 0;
    max-width: 327px;
  }

  ${inTablet} {
    max-width: 324px;
  }
`;
const Copy = styled.span.withConfig({ displayName: 'PaywallBarCopy' }) `
  padding-right: 8px;
  color: ${colorFor('collapsedCopy')};
`;
const Link = styled.a.withConfig({ displayName: 'PaywallBarLink' }) `
  &:hover {
    opacity: 0.8;
    text-decoration: underline;
  }
`;
const CTAButton = styled.a.withConfig({
    displayName: 'PaywallBarCTAButton'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-core')};

  display: block;
  margin: 32px 0 16px;
  border-radius: 4px;
  background-color: ${colorFor('ctaButtonBackground')};
  width: 100%;
  max-width: 327px;
  text-align: center;
  text-decoration: none;
  line-height: 48px;
  color: ${colorFor('ctaCopy')};

  &:hover {
    background-color: ${colorFor('ctaHover')};
  }

  ${inMobile} {
    margin: 16px auto;
  }

  ${inTablet} {
    width: 320px;
  }
`;
const CTALink = styled(Link).withConfig({ displayName: 'PaywallBarCTALink' }) `
  text-decoration: underline;
  color: ${colorFor('collapsedCtaLink')};
`;
const Image = styled.img.withConfig({
    displayName: 'PaywallBarImage'
}) `
  margin: auto;
  width: 200px;
  height: auto;
  object-fit: cover;

  ${inDesktop} {
    ${({ size }) => size === 'large' && `width: 375px;`};
  }
`;
const TopImage = styled.img.withConfig({
    displayName: 'PaywallBarTopImage'
}) `
  margin: auto;
  width: 113px;
  height: auto;
  object-fit: cover;
`;
const SignInContainer = styled.div.withConfig({
    displayName: 'PaywallBarSignInContainer'
}) `
  line-height: 20px;
  ${inMobile} {
    line-height: 18px;
  }
`;
const SignInCopy = styled.span.withConfig({
    displayName: 'PaywallBarSignInCopy'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  color: ${colorFor('signInCopy')};
`;
const SignInLink = styled(Link).withConfig({
    displayName: 'PaywallBarSignInLink'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  color: ${colorFor('signInLink')};
`;
module.exports = {
    Wrapper,
    ContentContainer,
    ExpandedContentWrapper,
    CollapsedContentWrapper,
    CollapsedCopyWrapper,
    CollapsedImage,
    ChevronButton,
    StyledChevron,
    Column,
    SubHedCopy,
    SubHedImage,
    Hed,
    Dek,
    Image,
    TopImage,
    CTAButton,
    CTALink,
    SignInContainer,
    SignInCopy,
    SignInLink,
    Copy
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 86281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Default = __webpack_require__(26419);
const MobileImage = __webpack_require__(1601);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const PaywallBar = Default;
// All Variations
PaywallBar.MobileImage = MobileImage;
module.exports = asJourneyUnit(PaywallBar);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 10891:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { withFormatter } = __webpack_require__(98750);
const { TrackComponentChannel } = __webpack_require__(78788);
const { PaywallBarThinWrapper, PaywallBarThinContentContainer, PaywallBarThinContentWrapper, CTALink, ChevronRightButton, StyledChevronRightButton } = __webpack_require__(2433);
const Formatted = {
    CTALink: withFormatter(CTALink)
};
const contentPropTypes = {
    cta: PropTypes.shape({
        url: PropTypes.string,
        copy: PropTypes.string
    })
};
const Content = ({ cta }) => {
    return (React.createElement(PaywallBarThinContentWrapper, null, cta && React.createElement(Formatted.CTALink, { href: cta.url, html: cta.copy })));
};
Content.propTypes = contentPropTypes;
const PaywallBarThin = ({ data = {}, viewport, isStoryBook }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'PaywallBarThin'
            });
    }, []);
    const containerId = Math.random()
        .toString(26)
        .substr(2, 12)
        .replace(/\d+/g, '');
    return (React.createElement(PaywallBarThinWrapper, { "data-testid": "paywall-bar-thin-button", isStoryBook: isStoryBook, className: viewport, role: "dialog", "aria-describedby": containerId, href: data[viewport]?.cta?.url },
        React.createElement(PaywallBarThinContentContainer, { id: containerId, role: "region", "aria-live": "polite" },
            React.createElement(Content, { ...data[viewport] }),
            React.createElement(ChevronRightButton, { "aria-label": "Chevron Right", className: viewport },
                React.createElement(StyledChevronRightButton, null)))));
};
PaywallBarThin.propTypes = {
    data: PropTypes.shape({
        mobile: PropTypes.shape(contentPropTypes),
        tablet: PropTypes.shape(contentPropTypes),
        desktop: PropTypes.shape(contentPropTypes)
    }),
    isStoryBook: PropTypes.bool,
    viewport: PropTypes.string
};
PaywallBarThin.displayName = 'PaywallBarThin';
PaywallBarThin.requireDataFields = [
    'mobile.cta.url',
    'mobile.cta.copy',
    'tablet.cta.url',
    'tablet.cta.copy',
    'desktop.cta.url',
    'desktop.cta.copy'
];
module.exports = PaywallBarThin;
//# sourceMappingURL=PaywallBarThin.js.map

/***/ }),

/***/ 23551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const PaywallBarThin = __webpack_require__(10891);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const { withJourneyTheme } = __webpack_require__(43219);
const wrap = flow([withViewport, withDataFallback, withJourneyTheme]);
module.exports = wrap(PaywallBarThin);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getTypographyStyles, calculateSpacing } = __webpack_require__(26865);
const { inMobile, inTablet, inExtraLargeDesktop, inDesktop } = __webpack_require__(94130);
const { colorPickerFactory } = __webpack_require__(43219);
const { ChevronRight } = __webpack_require__(97504);
const colorFor = colorPickerFactory('PaywallBarThin');
const PaywallBarThinWrapper = styled.a.withConfig({
    displayName: 'PaywallBarThinWrapper'
}) `
  display: flex;
  position: relative;
  box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, 0.1);
  background-color: ${colorFor('background')};
  width: 100%;
  height: 40px;

  ${({ isStoryBook }) => isStoryBook && 'margin-top: 150px'};
`;
const PaywallBarThinContentContainer = styled.div.withConfig({
    displayName: 'PaywallBarThinContentContainer'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 0;
  width: 100%;
  height: 100%;

  &:hover {
    opacity: 0.8;
    text-decoration: underline;
  }

  ${inMobile} {
    margin: 0 ${calculateSpacing(3)};
    padding: 10px 0;
  }

  ${inTablet} {
    margin: 0 ${calculateSpacing(6)};
    padding: 4px 0;
  }

  ${inDesktop} {
    margin: 0 ${calculateSpacing(6)};
  }

  ${inExtraLargeDesktop} {
    margin: 0 ${calculateSpacing(8)};
  }
`;
const PaywallBarThinContentWrapper = styled.div.withConfig({
    displayName: 'PaywallBarThinContentWrapper'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  text-align: center;

  ${inMobile} {
    max-width: calc(100vw - ${calculateSpacing(14)});
  }
`;
const CTALink = styled.a.withConfig({
    displayName: 'PaywallBarThinCTALink'
}) `
  text-decoration: underline;
  color: ${colorFor('ctaButtonBackground')};
  font-size: 14px;
  font-weight: 700;
`;
const ChevronRightButton = styled.button.withConfig({
    displayName: 'PaywallBarThinChevronRight'
}) `
  display: flex;
  margin-left: ${calculateSpacing(1)};
  background-color: transparent;
  padding: 0;
  width: 24px;
  height: 24px;
  color: ${colorFor('chevronRight')};

  ${inMobile} {
    position: absolute;
    right: 0;
    margin-right: ${calculateSpacing(3)};
  }
`;
const StyledChevronRightButton = styled(ChevronRight).withConfig({
    displayName: 'PaywallBarThinChevronRightButton'
}) `
  & {
    width: 24px;
    height: 24px;
    fill: ${colorFor('chevronRight')};
  }
`;
module.exports = {
    PaywallBarThinWrapper,
    PaywallBarThinContentContainer,
    PaywallBarThinContentWrapper,
    CTALink,
    ChevronRightButton,
    StyledChevronRightButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 5722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { withFormatter } = __webpack_require__(98750);
const { TrackComponentChannel } = __webpack_require__(78788);
const { PaywallBarThinWrapper, PaywallBarThinContentContainer, PaywallBarThinContentWrapper, CTALink, Copy, CloseButton, StyledCloseButton } = __webpack_require__(59000);
const Formatted = {
    CTALink: withFormatter(CTALink),
    Copy: withFormatter(Copy)
};
const contentPropTypes = {
    copy: PropTypes.string,
    cta: PropTypes.shape({
        url: PropTypes.string,
        copy: PropTypes.string
    })
};
const Content = ({ copy, cta }) => {
    return (React.createElement(PaywallBarThinContentWrapper, null,
        copy && React.createElement(Formatted.Copy, { html: `${copy}` }),
        "\u00A0",
        cta && React.createElement(Formatted.CTALink, { href: cta.url, html: cta.copy })));
};
Content.propTypes = contentPropTypes;
const PaywallBarThin = ({ data = {}, viewport, isStoryBook }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'PaywallBarThin'
            });
    }, []);
    const [hidePaywallBarThin, setHidePaywallBarThin] = React.useState(false);
    const { showCloseButton } = data;
    const containerId = Math.random()
        .toString(26)
        .substr(2, 12)
        .replace(/\d+/g, '');
    return (React.createElement(PaywallBarThinWrapper, { "data-testid": "paywall-bar-thin", isStoryBook: isStoryBook, className: viewport, role: "dialog", "aria-describedby": containerId, hidePaywallBarThin: hidePaywallBarThin },
        React.createElement(PaywallBarThinContentContainer, { id: containerId, role: "region", "aria-live": "polite" },
            React.createElement(Content, { ...data[viewport] }),
            showCloseButton && (React.createElement(CloseButton, { "aria-label": "Close", onClick: () => setHidePaywallBarThin(true), type: "button", className: viewport },
                React.createElement(StyledCloseButton, null))))));
};
PaywallBarThin.propTypes = {
    data: PropTypes.shape({
        mobile: PropTypes.shape(contentPropTypes),
        tablet: PropTypes.shape(contentPropTypes),
        desktop: PropTypes.shape(contentPropTypes)
    }),
    isStoryBook: PropTypes.bool,
    showCloseButton: PropTypes.bool,
    viewport: PropTypes.string
};
PaywallBarThin.displayName = 'PaywallBarThin';
PaywallBarThin.requireDataFields = [
    'mobile.copy',
    'mobile.cta.url',
    'mobile.cta.copy',
    'tablet.copy',
    'tablet.cta.url',
    'tablet.cta.copy',
    'desktop.copy',
    'desktop.cta.url',
    'desktop.cta.copy'
];
module.exports = PaywallBarThin;
//# sourceMappingURL=PaywallBarThin.js.map

/***/ }),

/***/ 27516:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const PaywallBarThin = __webpack_require__(5722);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const { withJourneyTheme } = __webpack_require__(43219);
const wrap = flow([withViewport, withDataFallback, withJourneyTheme]);
module.exports = wrap(PaywallBarThin);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 59000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getTypographyStyles, calculateSpacing } = __webpack_require__(26865);
const { inMobile } = __webpack_require__(94130);
const { colorPickerFactory } = __webpack_require__(43219);
const { Close } = __webpack_require__(97504);
const colorFor = colorPickerFactory('PaywallBarThin');
const PaywallBarThinWrapper = styled.div.withConfig({
    displayName: 'PaywallBarThinWrapper'
}) `
  display: flex;
  position: relative;
  box-shadow: 0 -4px 10px 0 rgba(0, 0, 0, 0.1);
  background-color: ${colorFor('background')};
  width: 100%;
  height: 40px;

  ${({ isStoryBook }) => isStoryBook && 'margin-top: 150px'};

  && {
    ${({ hidePaywallBarThin }) => (hidePaywallBarThin ? 'display: none' : '')}
  }
`;
const PaywallBarThinContentContainer = styled.div.withConfig({
    displayName: 'PaywallBarThinContentContainer'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 ${calculateSpacing(6)};
  padding: 4px 0;
  width: 100%;
  height: 100%;

  ${inMobile} {
    margin: 0 ${calculateSpacing(3)};
    padding: 10px 0;
  }
`;
const PaywallBarThinContentWrapper = styled.div.withConfig({
    displayName: 'PaywallBarThinContentWrapper'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.body')};
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  max-width: calc(100vw - ${calculateSpacing(12)});
  height: 100%;
`;
const Copy = styled.span.withConfig({ displayName: 'PaywallBarThinCopy' }) `
  color: ${colorFor('collapsedCopy')};
`;
const Link = styled.a.withConfig({ displayName: 'PaywallBarThinLink' }) `
  &:hover {
    opacity: 0.8;
    text-decoration: underline;
  }
`;
const CTALink = styled(Link).withConfig({
    displayName: 'PaywallBarThinCTALink'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  text-decoration: underline;
  color: ${colorFor('ctaButtonBackground')};
  font-size: 14px;
  font-weight: 700;
`;
const CloseButton = styled.button.withConfig({
    displayName: 'PaywallBarThinCloseButton'
}) `
  display: flex;
  position: absolute;
  right: 0;
  margin-right: ${calculateSpacing(6)};
  background-color: transparent;
  width: 32px;
  height: 32px;
  color: ${colorFor('closeButton')};

  ${inMobile} {
    margin-right: ${calculateSpacing(3)};
  }
`;
const StyledCloseButton = styled(Close).withConfig({
    displayName: 'PaywallBarThinClose'
}) `
  & {
    width: 32px;
    height: 32px;
    fill: ${colorFor('closeButton')};
  }
`;
module.exports = {
    PaywallBarThinWrapper,
    PaywallBarThinContentContainer,
    PaywallBarThinContentWrapper,
    CTALink,
    Copy,
    CloseButton,
    StyledCloseButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 97986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Default = __webpack_require__(27516);
const Button = __webpack_require__(23551);
const asJourneyUnit = __webpack_require__(51806);
// Default Variation
const PaywallBarThin = Default;
// All Variations
PaywallBarThin.Button = Button;
module.exports = asJourneyUnit(PaywallBarThin);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 52180:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { withRedirect } = __webpack_require__(44920);
const { withFormatter } = __webpack_require__(98750);
const { BREAKPOINTS } = __webpack_require__(96472);
const { RegGateWrapper, RegGateHed, RegGateDek, RegGateDiv, RegGateSubscribe, RegGateCreateAccountButton, RegGateColumnLeft, RegGateColumnRight, RegGateColumn, RegGateLink, RegGateSpan, RegGateBlock } = __webpack_require__(79604);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * RegistrationGate component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {string} props.data.hed - first text copy
 * @param {string} props.data.dek - second text copy
 * @param {string} props.data.copy - second text copy
 * @param {string} props.data.signIn.cta - text
 * @param {string} props.data.signIn.url -  url
 * @param {string} props.data.btn.url - url
 * @param {string} props.data.btn.copy -  text
 * @param {string} props.subscribe.text - text
 * @param {string} props.subscribe.linktext - linktext
 * @param {string} props.subscribe.url - url
 * @returns {ReactElement} - React Component
 */
const RegistrationGate = ({ data }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'RegistrationGate'
            });
    }, []);
    const { hed, dek, signIn, copy, btn, subscribe } = data;
    const hasSubscription = !!subscribe.text;
    const mql = window.matchMedia(`(min-width: ${BREAKPOINTS.lg})`);
    const isDesktop = mql.matches;
    const Formatted = {
        RegGateHed: withFormatter(RegGateHed),
        RegGateDek: withFormatter(RegGateDek)
    };
    return (React.createElement(RegGateWrapper, { className: "journey-unit__registration-gate registration-gate" },
        React.createElement(RegGateBlock, null,
            React.createElement(RegGateColumn, null,
                React.createElement(RegGateColumnLeft, null,
                    React.createElement(Formatted.RegGateHed, { html: hed }),
                    React.createElement(Formatted.RegGateDek, { html: dek }),
                    hasSubscription && isDesktop && (React.createElement(RegGateSubscribe, null,
                        subscribe.text,
                        "\u00A0",
                        React.createElement(RegGateLink, { className: "registration-gate__subsrcibe__link", href: subscribe.url }, subscribe.linktext)))),
                React.createElement(RegGateColumnRight, null,
                    React.createElement(RegGateDiv, null,
                        React.createElement(RegGateCreateAccountButton, { className: "registration-gate__button", href: withRedirect(btn.url) }, btn.copy),
                        React.createElement(RegGateSpan, null,
                            copy,
                            "\u00A0",
                            React.createElement(RegGateLink, { className: "registration-gate__sign-in__link", href: withRedirect(signIn.url) }, signIn.cta))))),
            hasSubscription && !isDesktop && (React.createElement(RegGateSubscribe, null,
                subscribe.text,
                "\u00A0",
                React.createElement(RegGateLink, { className: "registration-gate__subsrcibe__link", href: subscribe.url }, subscribe.linktext))))));
};
RegistrationGate.displayName = 'RegistrationGate';
RegistrationGate.propTypes = {
    data: PropTypes.shape({
        hed: PropTypes.string,
        dek: PropTypes.string,
        copy: PropTypes.string,
        signIn: PropTypes.shape({
            url: PropTypes.string,
            cta: PropTypes.string
        }),
        btn: PropTypes.shape({
            url: PropTypes.string,
            copy: PropTypes.string
        }),
        subscribe: PropTypes.shape({
            text: PropTypes.string,
            linktext: PropTypes.string,
            url: PropTypes.string
        })
    })
};
RegistrationGate.requireDataFields = [
    'hed',
    'dek',
    'copy',
    'signIn.cta',
    'signIn.url',
    'btn.url',
    'btn.copy'
];
module.exports = RegistrationGate;
//# sourceMappingURL=RegistrationGate.js.map

/***/ }),

/***/ 96752:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const RegistrationGate = __webpack_require__(52180);
const asJourneyUnit = __webpack_require__(51806);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withDataFallback, asJourneyUnit]);
module.exports = wrap(RegistrationGate);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 79604:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorToken, calculateSpacing } = __webpack_require__(26865);
const { BaseText, BaseLink } = __webpack_require__(76955);
const { inMobile, inTablet, inDesktop } = __webpack_require__(94130);
const RegGateWrapper = styled.div.withConfig({ displayName: 'RegGateWrapper' }) `
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  animation: move 3s;
  z-index: 500;
  background-color: ${getColorToken('colors.background.white')};
  width: 100%;
  @keyframes move {
    from {
      bottom: -100%;
    }

    to {
      ${inMobile} {
        bottom: ${calculateSpacing(3, 'px')};
      }
      ${inTablet} {
        bottom: ${calculateSpacing(6, 'px')};
      }
      ${inDesktop} {
        bottom: ${calculateSpacing(7, 'px')};
      }
    }
  }

  ::before {
    position: absolute;
    margin-top: -${calculateSpacing(32.5, 'px')};
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    background: linear-gradient(
      180deg,
      rgba(0, 0, 0, 0) 0%,
      rgba(0, 0, 0, 0.35) 100%
    );
    width: 100%;
    height: ${calculateSpacing(32.5, 'px')};
    content: '';
    ${inMobile} {
      margin-top: -${calculateSpacing(16.25, 'px')};
      height: ${calculateSpacing(16.25, 'px')};
    }
  }
`;
const RegGateColumn = styled.div.withConfig({
    displayName: 'RegGateColumn'
}) `
  ${inMobile} {
    margin-right: ${calculateSpacing(3, 'px')};
    margin-left: ${calculateSpacing(3, 'px')};
    text-align: center;
  }
  ${inTablet} {
    margin-right: ${calculateSpacing(6, 'px')};
    margin-left: ${calculateSpacing(6, 'px')};
    text-align: center;
  }
  ${inDesktop} {
    display: flex;
    margin-bottom: ${calculateSpacing(7, 'px')};
  }
`;
const RegGateColumnLeft = styled.div.withConfig({
    displayName: 'RegGateColumnLeft'
}) `
  flex: none;
  margin-left: 0;
  width: 100%;
  ${inDesktop} {
    margin-left: ${calculateSpacing(6, 'px')};
    width: calc(
      100% - (2 * ${calculateSpacing(8, 'px')}) - ${calculateSpacing(33, 'px')}
    );
  }
`;
const RegGateBlock = styled.div.withConfig({
    displayName: 'RegGateBlock'
}) `
  ${inMobile} {
    margin-bottom: ${calculateSpacing(5, 'px')};
  }

  ${inTablet} {
    margin-bottom: ${calculateSpacing(5, 'px')};
  }
`;
const RegGateColumnRight = styled.div.withConfig({
    displayName: 'RegGateColumnRight'
}) `
  flex: none;
  align-items: center;
  margin-right: 0;
  margin-left: 0;
  width: 100%;
  text-align: center;
  ${inDesktop} {
    float: right;
    margin-right: ${calculateSpacing(6, 'px')};
    margin-left: auto;
    width: ${calculateSpacing(33, 'px')};
  }
`;
const RegGateHed = styled(BaseText).withConfig({
    displayName: 'RegGateHed'
}) `
  margin-top: ${calculateSpacing(5, 'px')};
  ${inMobile} {
    margin-bottom: ${calculateSpacing(2, 'px')};
  }
  ${inTablet} {
    margin-bottom: ${calculateSpacing(1, 'px')};
  }
  ${inDesktop} {
    margin-top: ${calculateSpacing(7, 'px')};
    margin-bottom: ${calculateSpacing(1, 'px')};
  }
`;
RegGateHed.defaultProps = {
    colorToken: 'consumption.lead.standard.context-signature',
    typeIdentity: 'typography.definitions.discovery.hed-feature'
};
const RegGateDek = styled(BaseText).withConfig({
    displayName: 'RegGateDek'
}) `
  margin-bottom: ${calculateSpacing(3, 'px')};
  ${inDesktop} {
    margin-bottom: 0;
  }
`;
RegGateDek.defaultProps = {
    colorToken: 'consumption.lead.standard.context-signature',
    typeIdentity: 'typography.definitions.consumptionEditorial.body-feature'
};
const RegGateSubscribe = styled(BaseText).withConfig({
    displayName: 'RegGateSpan'
}) `
  margin-top: ${calculateSpacing(2, 'px')};
  text-align: center;
  ${inDesktop} {
    margin-right: 0;
    margin-left: 0;
    text-align: left;
  }
  ${inMobile} {
    margin-right: ${calculateSpacing(3, 'px')};
    margin-left: ${calculateSpacing(3, 'px')};
  }
  ${inTablet} {
    margin-right: ${calculateSpacing(6, 'px')};
    margin-left: ${calculateSpacing(6, 'px')};
  }
`;
RegGateSubscribe.defaultProps = {
    colorToken: 'consumption.lead.standard.context-signature',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const RegGateDiv = styled.div.withConfig({
    displayName: 'RegGateDiv'
}) `
  position: relative;
  top: 50%;
`;
const RegGateCreateAccountButton = styled(BaseLink).withConfig({
    displayName: 'RegGateCreateAccountButton'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.brand-primary')};
  padding: ${calculateSpacing(2, 'px')} ${calculateSpacing(2.5, 'px')};

  :link,
  :visited {
    text-transform: none;
    text-decoration: none;
    color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
  }
  ${inMobile} {
    margin: 0;
  }
  ${inTablet} {
    margin: 0 auto;
    width: ${calculateSpacing(26, 'px')};
  }
`;
RegGateCreateAccountButton.defaultProps = {
    typeToken: 'typography.definitions.utility.button-core'
};
const RegGateSpan = styled(BaseText).withConfig({
    displayName: 'RegGateSpan'
}) `
  text-align: center;
  ${inMobile} {
    margin-top: ${calculateSpacing(3, 'px')};
  }
  ${inTablet} {
    margin-top: ${calculateSpacing(2, 'px')};
  }
  ${inDesktop} {
    margin-top: ${calculateSpacing(2, 'px')};
  }
`;
RegGateSpan.defaultProps = {
    colorToken: 'consumption.lead.standard.context-signature',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const RegGateLink = styled(BaseLink).withConfig({
    displayName: 'RegGateLink'
}) `
  & {
    color: ${getColorToken('colors.interactive.base.black')};

    :link {
      text-decoration: underline;
    }
  }
`;
RegGateLink.defaultProps = {
    typeToken: 'typography.definitions.utility.assistive-text'
};
module.exports = {
    RegGateWrapper,
    RegGateHed,
    RegGateDek,
    RegGateDiv,
    RegGateSubscribe,
    RegGateColumn,
    RegGateColumnLeft,
    RegGateColumnRight,
    RegGateCreateAccountButton,
    RegGateSpan,
    RegGateLink,
    RegGateBlock
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 6606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterSubscriptionOnly = __webpack_require__(83344);
const NewsletterSubscribeSubscriptionOnly = __webpack_require__(29105);
/**
 * SubscriptionOnlyNewsletters component
 *
 * @param {object} props - properties
 * @param {object} props.data - unit data
 * @param {boolean} props.isAuthenticated - is user authenticated
 * @param {Array} props.userSubscribedNewsletterIds - array of user subscribed newsletter ids
 * @param {string} props.amguuid - user amgUUID
 * @param {string} props.siteCode - brand site code
 * @param {string} props.xClientID - brand x-client
 * @param {string} props.email - user email
 * @param {string} props.isCallFromSubscribeForm - to make sure it comes from individual newsletter page
 * @param {boolean} props.hasSubscribed - Whether user has been successfully subscribed
 * @param {boolean} props.hasAlternateNewsletterStyle - optional have new styling or not
 * @param {string} [props.sourceCode] - the newsletter component placement tracking code
 * @param {string} props.userEmail - optional email of the user
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} props.isFullViewPort - isFullViewPort from variation
 * @param {string} [props.alertBadge] - Component alertBadge for newsletter
 * @param {string} props.utilityLedeVariation - utilityLedeVariation from variation
 * @param {boolean} [props.shouldHaveExtraPadding] - Optional to add extra padding on the lede text, defauts to false
 * @param {string} props.shouldUseAlternativeLedeStyle - shouldUseAlternativeLedeStyle from variation
 * @param {string} [props.frequencyPrefix] - frequency Prefix for frequency badge prefix for the newsletter
 * @param {string} [props.translationsSignUp] - translationsSignUp from translation file
 * @param {string} [props.translationsSignUpMessage] - translationsSignUpMessage from translation file
 * @param {boolean} [props.hasSignedUp] - Whether user has been hasSignedUp to  subscribe
 * @param {Function} [props.onSignedUpHandler] - Optional submit event handler
 * @param {string} props.buttonLabel - Label for button
 * @param {Function} [props.onSubmitHandler] - Optional submit event handler
 * @param {string} props.textFieldLabel - Label for input
 * @param {string} props.textFieldName - Input name
 * @param {string} [props.provider] - Optional newsletter subscriptions service provider
 * @param {string} [props.sourceCodeForCheckingReCaptcha] - the newsletter component for checking reCaptcha
 * @param {string} [props.recaptchaSiteKey] - brand siteKey for recaptcha
 * @param {string} props.userPlatformProxy - brand upg proxy server url
 * @param {string} [props.brand] - Brand code for specific css styles of functionality
 * @param {string} [props.translationsPreviewText] - translationsPreviewText from translation file
 * @param {string} [props.dangerousDisclaimer] - Optional HTML disclaimer text
 * @param {string} props.isStackedSubscribeForm - isStackedSubscribeForm from variation
 * @param {Function} [props.onSuccessHandler] - Optional success handler
 * @param {string} [props.placeholder] - Optional placeholder string
 * @param {boolean} [props.isImageFullBleed] - Optional flag for horizontal image in a full viewport
 * @param {Function} [props.handleNewsletterIdFromJourney] - Optional newsletter id callback function
 * @returns {ReactElement} - React Component
 */
const SubscriptionOnlyNewsletters = ({ data, isAuthenticated, isCallFromSubscribeForm = false, hasSubscribed, hasAlternateNewsletterStyle, sourceCode, userEmail, variationName, isFullViewPort, alertBadge, utilityLedeVariation, shouldHaveExtraPadding, shouldUseAlternativeLedeStyle, frequencyPrefix, translationsSignUp, translationsSignUpMessage, hasSignedUp, onSignedUpHandler, buttonLabel, onSubmitHandler, textFieldLabel, textFieldName, provider, sourceCodeForCheckingReCaptcha, recaptchaSiteKey, userPlatformProxy, brand, translationsPreviewText, dangerousDisclaimer, isStackedSubscribeForm, onSuccessHandler, placeholder, isImageFullBleed, handleNewsletterIdFromJourney, userSubscribedNewsletterIds, amguuid, siteCode, xClientID, email }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SubscriptionOnlyNewsletters'
        });
    }, []);
    if (isCallFromSubscribeForm) {
        let url = window.location.href.indexOf('?') !== -1
            ? window.location.href.substring(0, window.location.href.indexOf('?'))
            : window.location.href;
        if (url.endsWith('/')) {
            url = url.slice(0, -1);
        }
        const slugValue = url.split('/').pop().toString();
        const slugMatchedData = data.Newsletters.find((obj) => {
            return obj.slug.includes(slugValue);
        });
        return (React.createElement(NewsletterSubscribeSubscriptionOnly, { dangerousDek: slugMatchedData.dangerousDek, dangerousHed: slugMatchedData.dangerousHed, newsletterId: slugMatchedData.newsletterId, imageAltText: slugMatchedData.imageAltText, imageUrl: slugMatchedData.imageUrl, name: slugMatchedData.name, newsletterTemplateUrl: slugMatchedData.newsletterTemplateUrl, slug: slugMatchedData.slug, frequencyBadge: slugMatchedData.frequencyBadge, hasSubscribed: hasSubscribed, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle, sourceCode: sourceCode, userEmail: userEmail, variationName: variationName, isFullViewPort: isFullViewPort, alertBadge: alertBadge, utilityLedeVariation: utilityLedeVariation, shouldHaveExtraPadding: shouldHaveExtraPadding, shouldUseAlternativeLedeStyle: shouldUseAlternativeLedeStyle, frequencyPrefix: frequencyPrefix, isAuthenticated: isAuthenticated, translationsSignUp: translationsSignUp, translationsSignUpMessage: translationsSignUpMessage, hasSignedUp: hasSignedUp, onSignedUpHandler: onSignedUpHandler, buttonLabel: buttonLabel, onSubmitHandler: onSubmitHandler, textFieldLabel: textFieldLabel, textFieldName: textFieldName, provider: provider, siteCode: siteCode, sourceCodeForCheckingReCaptcha: sourceCodeForCheckingReCaptcha, recaptchaSiteKey: recaptchaSiteKey, userPlatformProxy: userPlatformProxy, xClientID: xClientID, brand: brand, translationsPreviewText: translationsPreviewText, dangerousDisclaimer: dangerousDisclaimer, isStackedSubscribeForm: isStackedSubscribeForm, onSuccessHandler: onSuccessHandler, placeholder: placeholder, isImageFullBleed: isImageFullBleed, handleNewsletterIdFromJourney: handleNewsletterIdFromJourney, subscribeButtonURL: slugMatchedData.subscribeButtonURL }));
    }
    return (React.createElement(NewsletterSubscriptionOnly, { Newsletters: data?.Newsletters, isAuthenticated: isAuthenticated, userSubscribedNewsletterIds: userSubscribedNewsletterIds, amguuid: amguuid, siteCode: siteCode, xClientID: xClientID, email: email }));
};
SubscriptionOnlyNewsletters.displayName = 'SubscriptionOnlyNewsletters';
const NewslettersShape = PropTypes.shape({
    alertBadge: PropTypes.string.isRequired,
    dangerousDek: PropTypes.string.isRequired,
    dangerousHed: PropTypes.string.isRequired,
    frequencyBadge: PropTypes.string.isRequired,
    imageAltText: PropTypes.string.isRequired,
    imageUrl: PropTypes.string.isRequired,
    name: PropTypes.string.isRequired,
    newsletterId: PropTypes.string.isRequired,
    newsletterTemplateUrl: PropTypes.string.isRequired,
    slug: PropTypes.string.isRequired,
    subscribeButtonURL: PropTypes.string.isRequired
});
SubscriptionOnlyNewsletters.propTypes = {
    alertBadge: PropTypes.string,
    amguuid: PropTypes.string,
    brand: PropTypes.string,
    buttonLabel: PropTypes.string,
    dangerousDisclaimer: PropTypes.string,
    data: PropTypes.shape({
        Newsletters: PropTypes.arrayOf(NewslettersShape)
    }),
    email: PropTypes.string,
    frequencyPrefix: PropTypes.string,
    handleNewsletterIdFromJourney: PropTypes.func,
    hasAlternateNewsletterStyle: PropTypes.bool,
    hasSignedUp: PropTypes.bool,
    hasSubscribed: PropTypes.bool,
    isAuthenticated: PropTypes.bool,
    isCallFromSubscribeForm: PropTypes.bool,
    isFullViewPort: PropTypes.bool,
    isImageFullBleed: PropTypes.bool,
    isStackedSubscribeForm: PropTypes.bool,
    onSignedUpHandler: PropTypes.func,
    onSubmitHandler: PropTypes.func,
    onSuccessHandler: PropTypes.func,
    placeholder: PropTypes.string,
    provider: PropTypes.string,
    recaptchaSiteKey: PropTypes.string,
    shouldHaveExtraPadding: PropTypes.bool,
    shouldUseAlternativeLedeStyle: PropTypes.bool,
    siteCode: PropTypes.string,
    sourceCode: PropTypes.string,
    sourceCodeForCheckingReCaptcha: PropTypes.string,
    textFieldLabel: PropTypes.string,
    textFieldName: PropTypes.string,
    translationsPreviewText: PropTypes.string,
    translationsSignUp: PropTypes.string,
    translationsSignUpMessage: PropTypes.string,
    userEmail: PropTypes.string,
    userPlatformProxy: PropTypes.string,
    userSubscribedNewsletterIds: PropTypes.array,
    utilityLedeVariation: PropTypes.string,
    variationName: PropTypes.string,
    xClientID: PropTypes.string
};
SubscriptionOnlyNewsletters.requireDataFields = [
    'alertBadge',
    'dangerousDek',
    'dangerousHed',
    'frequencyBadge',
    'imageAltText',
    'imageUrl',
    'name',
    'newsletterId',
    'newsletterTemplateUrl',
    'slug',
    'subscribeButtonURL'
];
module.exports = SubscriptionOnlyNewsletters;
//# sourceMappingURL=SubscriptionOnlyNewsletters.js.map

/***/ }),

/***/ 11055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const SubscriptionOnlyNewsletters = __webpack_require__(6606);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const { withDataFallback } = __webpack_require__(58872);
const wrap = flow([withViewport, withDataFallback, asJourneyUnit]);
module.exports = wrap(SubscriptionOnlyNewsletters);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94408:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TickerContainer, TickerWrapper, Image, Text, Copy, TextLink } = __webpack_require__(66228);
const { TrackComponentChannel } = __webpack_require__(78788);
const { withFormatter } = __webpack_require__(98750);
const Formatted = {
    Copy: withFormatter(Copy)
};
const Ticker = ({ data, viewport }) => {
    React.useEffect(() => {
        window.Kendra &&
            window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
                name: 'Ticker'
            });
    }, []);
    return (React.createElement(TickerContainer, null,
        React.createElement(TickerWrapper, { withBorderTop: data.withBorderTop, withBorderBottom: data.withBorderBottom },
            React.createElement(Image, { src: data.image.url, alt: data.image.alt }),
            React.createElement(Text, null,
                React.createElement(Formatted.Copy, { html: data.copy }),
                ' ',
                React.createElement(TextLink, { href: data.signIn.url[viewport], className: "cm__signin" }, data.signIn.text)))));
};
Ticker.displayName = 'Ticker';
Ticker.propTypes = {
    data: PropTypes.shape({
        copy: PropTypes.string,
        signIn: PropTypes.shape({
            url: PropTypes.shape({
                mobile: PropTypes.string,
                tablet: PropTypes.string,
                desktop: PropTypes.string
            }),
            text: PropTypes.string
        }),
        image: PropTypes.shape({
            url: PropTypes.string,
            alt: PropTypes.string
        }),
        withBorderTop: PropTypes.bool,
        withBorderBottom: PropTypes.bool
    }),
    viewport: PropTypes.string.isRequired
};
Ticker.requireDataFields = [
    'copy',
    'signIn.text',
    'signIn.url.mobile',
    'signIn.url.tablet',
    'signIn.url.desktop',
    'image.url',
    'image.alt',
    'withBorderTop',
    'withBorderBottom'
];
module.exports = Ticker;
//# sourceMappingURL=Ticker.js.map

/***/ }),

/***/ 96720:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const Ticker = __webpack_require__(94408);
const asJourneyUnit = __webpack_require__(51806);
const { withViewport } = __webpack_require__(17936);
const wrap = flow([withViewport, asJourneyUnit]);
module.exports = wrap(Ticker);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 66228:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText, BaseLink } = __webpack_require__(76955);
const { getColorToken } = __webpack_require__(26865);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const TickerContainer = styled.div.withConfig({
    displayName: 'TickerContainer'
}) `
  ${cssVariablesGrid()}
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: flex-start;
  margin: 0 auto;
  width: 100%;
  max-width: ${BREAKPOINTS.xxl};
  ${applyGridSpacing('padding')}
`;
const TickerWrapper = styled.div.withConfig({ displayName: 'TickerWrapper' }) `
  display: flex;
  flex-direction: row;
  align-items: center;
  ${({ theme, withBorderTop }) => withBorderTop &&
    `border-top: 1px solid ${getColorToken(theme, 'colors.interactive.base.border')};`}
  ${({ theme, withBorderBottom }) => withBorderBottom &&
    `border-bottom: 1px solid ${getColorToken(theme, 'colors.interactive.base.border')};`}
  background-color: white;
  padding: 16px 0;
  gap: 16px;
  width: 100%;

  ${`@media(min-width: ${BREAKPOINTS.md})`} {
    justify-content: center;
    width: 100%;
  }
`;
const Image = styled.img.withConfig({ displayName: 'Image' }) `
  border-radius: 8px;
  width: 48px;
  height: 48px;
  object-fit: cover;
`;
const Text = styled(BaseText).withConfig({ displayName: 'Text' }) ``;
Text.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.black',
    typeIdentity: 'typography.definitions.utility.body'
};
const Copy = styled(BaseText).withConfig({ displayName: 'Copy' }) ``;
Copy.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.black',
    typeIdentity: 'typography.definitions.utility.body'
};
const TextLink = styled(BaseLink).withConfig({ displayName: 'TextLink' }) `
  &.cm__signin {
    color: ${getColorToken('colors.interactive.base.brand-primary')};
  }
`;
TextLink.defaultProps = {
    typeIdentity: 'typography.definitions.utility.button-utility'
};
module.exports = {
    TickerContainer,
    TickerWrapper,
    Image,
    Text,
    Copy,
    TextLink
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 12501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ContentBar = __webpack_require__(48536);
const ExpandedCanvas = __webpack_require__(23043);
const Footer = __webpack_require__(49289);
const FooterNewsletter = __webpack_require__(65786);
const FullBarrier = __webpack_require__(81802);
const InContent = __webpack_require__(10202);
const InlineBarrier = __webpack_require__(92726);
const InlineNewsletter = __webpack_require__(40064);
const NavCTA = __webpack_require__(23543);
const NavDrawer = __webpack_require__(96802);
const NavRollover = __webpack_require__(69390);
const NewsletterExtended = __webpack_require__(44572);
const NewsletterExtraSlim = __webpack_require__(72924);
const NewsletterExtraSlimWithActionSheet = __webpack_require__(1969);
const NewsletterSlim = __webpack_require__(33648);
const NewsletterVertical = __webpack_require__(4747);
const NewsletterVerticalBottom = __webpack_require__(34824);
const NewsletterVerticalPullQuote = __webpack_require__(75996);
const NewsletterOneClickSlim = __webpack_require__(9860);
const NewsletterRibbon = __webpack_require__(33125);
const PaywallBar = __webpack_require__(86281);
const PaywallBarThin = __webpack_require__(97986);
const RegistrationGate = __webpack_require__(96752);
const Ticker = __webpack_require__(96720);
const InContentBarrier = __webpack_require__(21757);
const SubscriptionOnlyNewsletters = __webpack_require__(11055);
module.exports = {
    ContentBar,
    ExpandedCanvas,
    Footer,
    FooterNewsletter,
    FullBarrier,
    InContent,
    InContentBarrier,
    InlineBarrier,
    InlineNewsletter,
    NavCTA,
    NavDrawer,
    NavRollover,
    NewsletterExtended,
    NewsletterExtraSlim,
    NewsletterExtraSlimWithActionSheet,
    NewsletterSlim,
    NewsletterVertical,
    NewsletterVerticalBottom,
    NewsletterVerticalPullQuote,
    NewsletterOneClickSlim,
    NewsletterRibbon,
    PaywallBar,
    PaywallBarThin,
    RegistrationGate,
    Ticker,
    SubscriptionOnlyNewsletters
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { BREAKPOINTS } = __webpack_require__(96472);
// Common media queries to use in Journey Units
const inMobile = `@media(max-width: calc(${BREAKPOINTS.md} - 1px))`;
const inTablet = `@media(min-width: ${BREAKPOINTS.md}) and (max-width: calc(${BREAKPOINTS.lg} - 1px))`;
const inDesktop = `@media(min-width: ${BREAKPOINTS.lg})`;
const inExtraLargeDesktop = `@media(min-width: ${BREAKPOINTS.xl})`;
module.exports = {
    inMobile,
    inTablet,
    inDesktop,
    inExtraLargeDesktop
};
//# sourceMappingURL=mediaQueries.js.map

/***/ }),

/***/ 58872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useEffect } = __webpack_require__(96540);
const get = __webpack_require__(58156);
const set = __webpack_require__(63560);
const fallback = (data, Component) => {
    const { requireDataFields: fields = [] } = Component;
    const dataFallback = { ...data };
    fields.forEach((field) => set(dataFallback, field, get(dataFallback, field, '').toString()));
    const missingFields = fields.filter((field) => !get(dataFallback, field));
    return {
        data: dataFallback,
        missingFields
    };
};
/**
 * withDataFallback - Higher Order Component that sets the wrapped component's
 * required data fields to empty strings if they are missing, this is to avoid
 * white screen of death when we try to apply different functionalities to a
 * component that is not present.
 *
 * @param {React.Component} Component - a React Component
 * @returns {React.Component} - a React Component
 */
const withDataFallback = (Component) => {
    /**
     *
     * @param {object} props - React props
     * @returns {React.Element} - a React element
     */
    const DataFallback = (props) => {
        const { data, missingFields } = fallback(props.data || {}, Component);
        const { displayName } = Component;
        useEffect(() => {
            if (missingFields.length && window.cnBus) {
                window.cnBus.emit('journey.client.error', {
                    message: 'Verso Component is missing required data fields',
                    data: {
                        displayName,
                        missingFields
                    }
                });
            }
        });
        return React.createElement(Component, { ...props, data: data });
    };
    DataFallback.displayName = Component.displayName;
    DataFallback.propTypes = {
        data: PropTypes.object
    };
    return DataFallback;
};
module.exports = { withDataFallback };
//# sourceMappingURL=withDataFallback.js.map

/***/ }),

/***/ 98750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const omit = __webpack_require__(90179);
const PropTypes = __webpack_require__(5556);
// Only tags handled by the formatter in Journeys are accepted.
const acceptedTags = ['strong', 'ins', 'i', 'del', 'br', 'mark'].join('|');
const acceptedTagsRegex = new RegExp(`<(${acceptedTags})/?>`, 'i');
/**
 *
 * Applies setInnerHTML only when HTML contains accepted tags.
 * If other tags are present, the component is returned with escaped html.
 *
 * Note that an element within the component should be capable of receiving
 * the dangerouslySetInnerHTML prop to inject the HTML.
 *
 * @param {React.Component} Component - a React Component
 * @returns {React.Component} - a React Component
 */
const withFormatter = (Component) => {
    /**
     * @param {object} props - React props
     * @param {string} props.html - string with html to parse
     * @returns {React.Element|null} - A React Element
     */
    const FormattedComponent = (props) => {
        const { html } = props;
        if (!html) {
            return null;
        }
        const tags = html.match(/<[^/][^>]*>/gim); // only opening tags
        const isValid = tags && tags.every((tag) => tag.match(acceptedTagsRegex));
        if (isValid) {
            return (React.createElement(Component, { ...omit(props, 'html'), dangerouslySetInnerHTML: { __html: html } }));
        }
        return React.createElement(Component, { ...omit(props, 'html') }, html);
    };
    FormattedComponent.propTypes = {
        html: PropTypes.string
    };
    return FormattedComponent;
};
module.exports = { withFormatter };
//# sourceMappingURL=withFormatter.js.map

/***/ }),

/***/ 43219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useContext } = __webpack_require__(96540);
const { ThemeContext } = __webpack_require__(92168);
const PropTypes = __webpack_require__(5556);
const { getColorToken } = __webpack_require__(26865);
const journeyThemes = {
    default: {
        background: 'colors.background.light',
        hed: 'colors.interactive.base.black',
        dek: 'colors.interactive.base.black',
        dekMark: 'colors.interactive.base.brand-primary',
        subHed: 'colors.interactive.base.black',
        ctaButtonBackground: 'colors.interactive.base.brand-primary',
        ctaHover: 'colors.interactive.base.brand-secondary',
        ctaCopy: 'colors.interactive.base.white',
        collapsedCtaLink: 'colors.interactive.base.black',
        collapsedCopy: 'colors.interactive.base.black',
        signInCopy: 'colors.interactive.base.deemphasized',
        signInLink: 'colors.interactive.base.brand-primary',
        chevronButton: 'colors.interactive.base.black',
        divider: 'colors.interactive.base.border',
        rtbSvg: 'colors.interactive.base.brand-primary',
        rtbCopy: 'colors.interactive.base.black',
        goTo: 'colors.interactive.base.black',
        closeButton: 'colors.interactive.base.deemphasized',
        chevronRight: 'colors.interactive.base.brand-primary'
    },
    brand: {
        background: 'colors.interactive.base.brand-primary',
        hed: 'colors.interactive.base.white',
        dek: 'colors.interactive.base.white',
        dekMark: 'colors.interactive.base.white',
        subHed: 'colors.interactive.base.white',
        ctaButtonBackground: 'colors.interactive.base.white',
        ctaHover: 'colors.interactive.base.light',
        ctaCopy: 'colors.interactive.base.brand-primary',
        collapsedCtaLink: 'colors.interactive.base.white',
        collapsedCopy: 'colors.interactive.base.white',
        signInCopy: 'colors.interactive.base.white',
        signInLink: 'colors.interactive.base.white',
        chevronButton: 'colors.interactive.base.white',
        divider: 'colors.interactive.base.white',
        rtbSvg: 'colors.interactive.base.white',
        rtbCopy: 'colors.interactive.base.white',
        goTo: 'colors.interactive.base.white',
        closeButton: 'colors.interactive.base.deemphasized',
        chevronRight: 'colors.interactive.base.white'
    },
    light: {
        background: 'colors.interactive.base.white',
        hed: 'colors.interactive.base.brand-primary',
        dek: 'colors.interactive.base.black',
        dekMark: 'colors.interactive.base.black',
        subHed: 'colors.interactive.base.black',
        ctaButtonBackground: 'colors.interactive.base.brand-primary',
        ctaHover: 'colors.interactive.base.brand-secondary',
        ctaCopy: 'colors.interactive.base.white',
        collapsedCtaLink: 'colors.interactive.base.black',
        collapsedCopy: 'colors.interactive.base.black',
        signInCopy: 'colors.interactive.base.deemphasized',
        signInLink: 'colors.interactive.base.brand-primary',
        chevronButton: 'colors.interactive.base.black',
        divider: 'colors.interactive.base.border',
        rtbSvg: 'colors.interactive.base.brand-primary',
        rtbCopy: 'colors.interactive.base.black',
        goTo: 'colors.interactive.base.brand-primary',
        closeButton: 'colors.interactive.base.deemphasized',
        chevronRight: 'colors.interactive.base.brand-primary'
    },
    dark: {
        background: 'colors.interactive.base.black',
        hed: 'colors.interactive.base.white',
        dek: 'colors.interactive.base.white',
        dekMark: 'colors.interactive.base.white',
        subHed: 'colors.interactive.base.white',
        ctaButtonBackground: 'colors.interactive.base.white',
        ctaHover: 'colors.interactive.base.light',
        ctaCopy: 'colors.interactive.base.brand-primary',
        collapsedCtaLink: 'colors.interactive.base.white',
        collapsedCopy: 'colors.interactive.base.white',
        signInCopy: 'colors.interactive.base.white',
        signInLink: 'colors.interactive.base.white',
        chevronButton: 'colors.interactive.base.white',
        divider: 'colors.interactive.base.white',
        rtbSvg: 'colors.interactive.base.white',
        rtbCopy: 'colors.interactive.base.white',
        goTo: 'colors.interactive.base.white',
        closeButton: 'colors.interactive.base.deemphasized',
        chevronRight: 'colors.interactive.base.white'
    }
};
// journeyThemeOverrides handle brand-identity tokens of style elements that are component-specific
const journeyThemeOverrides = {
    ExpandedCanvas: {
        background: 'colors.interactive.base.white'
    },
    FullBarrier: {
        background: 'colors.interactive.base.white',
        signInCopy: 'colors.interactive.base.black',
        signInLink: 'colors.interactive.base.black'
    }
};
/**
 * colorPickerFactory - picks the color of an element based on the selected journey theme for a component
 * @param {string} componentName - name of the component
 * @param {string} style - styles such as 'background', 'hed', etc.
 * @param {object} theme - theme object of styled-component
 * @param {object} theme.journey - journey theme object
 * @param {object} theme.journey[componentName] - journey theme object of a journey component
 * @param {string} theme.journey[componentName][style] - style token of the given component in
 * the journey theme object. Ex: theme.journey.PaywallBar.background: 'colors.interactive.base.white'
 * @returns {string} - color of the token
 */
const colorPickerFactory = (componentName) => (style) => ({ theme }) => getColorToken(theme.journey[componentName][style]);
/**
 * withJourneyTheme - A Higher Order Component that is responsible for setting the
 * bundle derived from the theme parameter
 *
 * @param {React.Component} Component - a React Component
 * @returns {React.Component} - a React Component
 */
const withJourneyTheme = (Component) => {
    /**
     * @param {object} props - React props
     * @param {object} props.component - journey component data
     * @param {string} props.component.name - journey component name
     * @param {object} props.configuration - configuration data
     * @param {object} props.configuration.theme - journey theme
     * @returns {React.Element} - A React Element
     */
    const ThemeComponent = (props) => {
        const { component, configuration } = props;
        const componentName = component.name;
        const theme = configuration?.theme || 'default';
        const overrides = (theme === 'default' && journeyThemeOverrides[componentName]) || {};
        const bundle = { ...journeyThemes[theme], ...overrides };
        const themeContext = useContext(ThemeContext);
        themeContext.journey = themeContext.journey || {};
        themeContext.journey[componentName] = bundle;
        return React.createElement(Component, { ...props });
    };
    ThemeComponent.displayName = Component.displayName;
    ThemeComponent.propTypes = {
        component: PropTypes.shape({
            name: PropTypes.string.isRequired
        }),
        configuration: PropTypes.shape({
            theme: PropTypes.string
        })
    };
    return ThemeComponent;
};
module.exports = {
    colorPickerFactory,
    withJourneyTheme
};
//# sourceMappingURL=withJourneyTheme.js.map

/***/ }),

/***/ 96258:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useState, useEffect, useCallback, useRef } = __webpack_require__(96540);
const { default: useFocusTrap } = __webpack_require__(64744);
const focusA11yScreenReader = (nodeToIgnore, { disable } = {}) => {
    // [data-in-view] attribute will be available on any page content type
    // that indicate the type of page for verso
    // Example: data-in-view="{"pattern":"ArticlePage"}", data-in-view="{"pattern":"GalleryPage"}"
    const allAppElements = document.querySelectorAll('#app-root > [data-in-view] > *');
    allAppElements.forEach((item) => {
        const shouldIgnore = disable || nodeToIgnore === item;
        if (shouldIgnore) {
            item.removeAttribute('aria-hidden');
            return;
        }
        item.setAttribute('aria-hidden', 'true');
    });
};
const withModalFocusTrap = (Component) => {
    const FocusedComponent = (props) => {
        const [shouldFocusTrap, setShouldFocusTrap] = useState(false);
        const a11yRef = useRef(null);
        const trapA11yScreenReader = useCallback(focusA11yScreenReader, []);
        const setFocusTrap = useFocusTrap(shouldFocusTrap);
        useEffect(() => {
            if (!a11yRef.current)
                return undefined;
            const ref = a11yRef.current.parentNode.parentNode;
            setShouldFocusTrap(true);
            setFocusTrap(ref);
            trapA11yScreenReader(ref);
            return () => {
                setShouldFocusTrap(false);
                trapA11yScreenReader(ref, { disable: true });
            };
        }, [setFocusTrap, trapA11yScreenReader]);
        return (React.createElement("div", { ref: a11yRef },
            React.createElement("button", { "aria-hidden": "true", tabIndex: "-1", style: { visibility: 'hidden' } }),
            React.createElement(Component, { ...props })));
    };
    return FocusedComponent;
};
module.exports = { withModalFocusTrap };
//# sourceMappingURL=withModalFocusTrap.js.map

/***/ }),

/***/ 17936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const viewports = [
    {
        name: 'desktop',
        query: 'screen and (min-width: 1024px)'
    },
    {
        name: 'tablet',
        query: 'screen and (min-width: 768px) and (max-width: 1023px)'
    },
    {
        name: 'mobile',
        query: 'screen and (max-width: 767px)'
    }
];
/**
 * withViewport
 *
 * A higher order component that handles determination of the current viewport
 *
 * @param {ReactElement} Component - A React component
 */
const withViewport = (Component) => {
    class Viewport extends React.Component {
        constructor() {
            super(...arguments);
            this.state = { name: 'desktop' };
            this.viewports = [];
            this.render = () => React.createElement(Component, { ...this.props, viewport: this.state.name });
        }
        componentDidMount() {
            viewports.forEach(({ name, query }) => {
                const list = window.matchMedia(query);
                if (!list)
                    return;
                if (list.matches)
                    this.setState({ name });
                const listener = ({ matches }) => matches && this.setState({ name });
                if (list.addEventListener)
                    list.addEventListener('change', listener);
                this.viewports.push({ name, query, list, listener });
            });
        }
        componentWillUnmount() {
            this.viewports.forEach(({ list, listener }) => {
                if (list.removeEventListener)
                    list.removeEventListener('change', listener);
            });
        }
    }
    Viewport.displayName = Component.displayName;
    Viewport.propTypes = {
        viewport: PropTypes.string
    };
    return Viewport;
};
module.exports = { withViewport, viewports };
//# sourceMappingURL=withViewport.js.map

/***/ }),

/***/ 9445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { renderToString } = __webpack_require__(65848);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(2768)/* ["default"] */ .A);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * MagazineDisclaimer component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Top-level class to add
 * @param {string} [props.issueDate] - Issue Date of magazine
 * @param {string} [props.issueLink] - Issue link to be used for the magazine URL path
 * @param {string} [props.originalHed] - Optional original headline used in magazine issue
 *
 * @returns {ReactElement} <div>
 */
const MagazineDisclaimer = ({ className, issueDate, issueLink, originalHed }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'MagazineDisclaimer'
        });
    }, []);
    const { formatMessage } = useIntl();
    const anchorTag = (text) => renderToString(React.createElement("a", { href: issueLink || '/magazine/', dangerouslySetInnerHTML: { __html: text } }));
    return (React.createElement("footer", { className: className, "data-testid": "MagazineDisclaimerWrapper", dangerouslySetInnerHTML: {
            __html: originalHed
                ? formatMessage(translations.disclaimerWithHed, {
                    issueDate: anchorTag(issueDate),
                    hed: originalHed
                })
                : formatMessage(translations.disclaimerNoHed, {
                    issueDate: anchorTag(issueDate)
                })
        } }));
};
MagazineDisclaimer.propTypes = {
    className: PropTypes.string.isRequired,
    issueDate: PropTypes.string.isRequired,
    issueLink: PropTypes.string.isRequired,
    originalHed: PropTypes.string
};
MagazineDisclaimer.displayName = 'Magazine Disclaimer';
module.exports = MagazineDisclaimer;
//# sourceMappingURL=MagazineDisclaimer.js.map

/***/ }),

/***/ 24010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(9445);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2768:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    disclaimerNoHed: {
        id: 'MagazineDisclaimer.DisclaimerNoHed',
        defaultMessage: 'Published in the print edition of the {issueDate}, issue.',
        description: 'disclaimer text without headline'
    },
    disclaimerWithHed: {
        id: 'MagazineDisclaimer.DisclaimerWithHed',
        defaultMessage: 'Published in the print edition of the {issueDate}, issue, with the headline {hed}.',
        description: 'disclaimer text with headline'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 6114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const PullquoteEmbed = __webpack_require__(40007);
const NewsletterOneClick = __webpack_require__(38267);
const { NewsletterOneClickVerticalPullQuoteWrapper } = __webpack_require__(27004);
const NewsletterOneClickVerticalPullQuote = (props) => {
    return (React.createElement(NewsletterOneClickVerticalPullQuoteWrapper, null,
        React.createElement(PullquoteEmbed.LeftBorder, null,
            React.createElement(NewsletterOneClick.SlimStacked, { ...props }))));
};
NewsletterOneClickVerticalPullQuote.propTypes = {
    buttonLabel: PropTypes.string.isRequired,
    dangerousDek: PropTypes.string,
    dangerousDisclaimer: PropTypes.string,
    newsletterId: PropTypes.string.isRequired
};
NewsletterOneClickVerticalPullQuote.displayName =
    'NewsletterOneClickVerticalPullQuote';
module.exports = NewsletterOneClickVerticalPullQuote;
//# sourceMappingURL=NewsletterOneClickVerticalPullQuote.js.map

/***/ }),

/***/ 74840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6114);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 27004:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getTypographyStyles } = __webpack_require__(26865);
const { NewsletterOneClickWrapper, NewsletterOneClickDek, NewsletterOneClickHed, NewsletterOneClickDisclaimer } = __webpack_require__(66661);
const NewsletterOneClickVerticalPullQuoteWrapper = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalPullQuoteWrapper'
}) `
  ${NewsletterOneClickWrapper} {
    border-top: none;

    &.newsletter-one-click-wrapper--SlimStacked {
      ${NewsletterOneClickDek} {
        ${getTypographyStyles('typography.definitions.consumptionEditorial.display-small')};
      }
      ${NewsletterOneClickHed} {
        margin: 0;
      }
    }

    ${NewsletterOneClickDisclaimer} {
      span {
        p {
          margin-bottom: 0;
        }
      }
    }
  }
`;
module.exports = {
    NewsletterOneClickVerticalPullQuoteWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 60251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(60082)/* ["default"] */ .A);
const { connector } = __webpack_require__(57744);
const TextField = __webpack_require__(89662);
const FormErrorContext = __webpack_require__(45548);
const { TrackComponentChannel } = __webpack_require__(78788);
const { saveNewsletterSubscriptions } = __webpack_require__(26430);
const { isUserSubscribedToNewsletter } = __webpack_require__(29727);
const { createValidationErrorMessage } = __webpack_require__(88511);
const { NewsletterOneClickWrapper, NewsletterOneClickVerticalWrapper, NewsletterOneClickVerticalComponent, NewsletterOneClickVerticalDisclaimer, NewsletterOneClickVerticalHed, NewsletterOneClickVerticalDek, NewsletterOneClickVerticalFormWrapper, NewsletterOneClickVerticalSignUpButton, NewsletterOneClickVerticalFormValidation, NewsletterOneClickVerticalLogo, NewsletterOneClickVerticalImage } = __webpack_require__(68272);
const NewsletterWrapper = __webpack_require__(69413);
/**
 * NewsletterOneClickVertical Component
 *
 * @param {object} [props] - React props
 * @param {string} [props.buttonLabel] - Required sign up button label
 * @param {string} [props.dangerousDek] - Optional dangerousDek text
 * @param {string} [props.dangerousDisclaimer] - Optional dangerousDisclaimer text
 * @param {string} [props.dangerousHed] - Optional dangerousHed text
 * @param {string} [props.formName] - Required formName
 * @param {string} [props.newsletterId] - Required newsletter Id
 * @param {string} [props.sourceCode] - Required sourceCode
 * @param {string} [props.imageMaxWidth] - Optional imageMaxWidth
 * @param {string} [props.imageUrl] - Optional imageUrl
 * @param {string} [props.logoMaxHeight] - Optional logoMaxHeight
 * @param {string} [props.logoUrl] - Optional logoUrl
 * @param {object} [props.user] - Required User information
 * @param {boolean} [props.user.isAuthenticated] - Represents if the user is currently authenticated
 * @param {string} [props.user.amguuid] - User's amguuid
 * @param {string} [props.user.email] - User's email
 * @param {object} [props.userPlatform] - User platform details
 * @param {string} [props.userPlatform.siteCode] -  Brand siteCode
 * @param {string} [props.userPlatform.userPlatformProxy] - Brand user platform proxy server url
 * @param {string} [props.userPlatform.xClientID] - xClientID from brand tenant config
 * @returns <NewsletterOneClickVertical>
 */
const NewsletterOneClickVertical = (props) => {
    const { buttonLabel, ContentWrapper, hasContentWrapper = false, newsletterId, dangerousDek, dangerousDisclaimer, dangerousHed, formName, sourceCode, imageMaxWidth = 10, imageUrl, logoMaxHeight = 1.5, logoUrl, user: { isAuthenticated, amguuid, email }, userPlatform: { siteCode, userPlatformProxy, xClientID } } = props;
    const [isSubscribed, setIsSubscribed] = React.useState(false);
    const [isSignedup, setIsSignedUp] = React.useState(false);
    const [isRequestInflight, setIsRequestInflight] = React.useState(false);
    const [label, setLabel] = React.useState(buttonLabel);
    const [error, setError] = React.useState('');
    const [hideNewletterUnit, setHideNewletterUnit] = React.useState(false);
    const [showVersion2, setShowVersion2] = React.useState(false);
    const { formatMessage } = useIntl();
    const customInvalidityMessages = {
        email: {
            typeMismatch: formatMessage(translations.typeMismatchMessage)
        }
    };
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterOneClickVertical'
        });
        if (imageUrl) {
            setShowVersion2(true);
        }
        if (isAuthenticated) {
            const options = {
                newsletterIds: [newsletterId],
                amgUUID: amguuid,
                userPlatformProxy,
                xClientID,
                provider: 'sailthru'
            };
            isUserSubscribedToNewsletter(options)
                .then((result) => {
                if (result) {
                    setIsSubscribed(true);
                    setHideNewletterUnit(true);
                }
                else {
                    setIsSubscribed(false);
                }
            })
                .catch((error) => {
                console.log('error ', error);
                setError(formatMessage(translations.badResponse));
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const submitHandler = (e) => {
        e?.preventDefault();
        setIsSignedUp(true);
        setIsRequestInflight(true);
        const opts = {
            amgUUID: amguuid,
            siteCode,
            xClientID,
            payload: {
                email: e?.target?.querySelector(`[name=email]`)?.value || email,
                formName,
                sourceCode,
                subscriptions: [
                    {
                        status: 'SUBSCRIBED',
                        newsletterId
                    }
                ]
            }
        };
        Promise.resolve(saveNewsletterSubscriptions(opts))
            .then((result) => {
            if (result.savePreference.success) {
                setIsSubscribed(true);
                setLabel('Signed Up');
            }
            else {
                setError(formatMessage(translations.errorMessage));
                setIsSignedUp(false);
            }
            setIsRequestInflight(false);
        })
            .catch((error) => {
            console.log(error);
            setError(formatMessage(translations.badResponse));
            setIsRequestInflight(false);
            setIsSignedUp(false);
        });
    };
    if (hideNewletterUnit)
        return React.createElement(React.Fragment, null);
    return (React.createElement(NewsletterWrapper, { ContentWrapper: ContentWrapper, hasContentWrapper: hasContentWrapper },
        React.createElement(NewsletterOneClickWrapper, { hasContentWrapper: hasContentWrapper },
            React.createElement(NewsletterOneClickVerticalWrapper, null,
                React.createElement(NewsletterOneClickVerticalComponent, null,
                    showVersion2 && logoUrl && (React.createElement(NewsletterOneClickVerticalLogo, { logoMaxHeight: logoMaxHeight },
                        React.createElement("img", { src: logoUrl, alt: "logo" }))),
                    !showVersion2 && dangerousHed && (React.createElement(NewsletterOneClickVerticalHed, { dangerouslySetInnerHTML: { __html: dangerousHed } })),
                    showVersion2 && imageUrl && (React.createElement(NewsletterOneClickVerticalImage, { imageMaxWidth: imageMaxWidth },
                        React.createElement("img", { src: imageUrl, alt: "logo" }))),
                    React.createElement(NewsletterOneClickVerticalFormWrapper, null,
                        dangerousDek && (React.createElement(NewsletterOneClickVerticalDek, { dangerouslySetInnerHTML: { __html: dangerousDek } })),
                        isAuthenticated && (React.createElement(NewsletterOneClickVerticalSignUpButton, { label: label, inputKind: "submit", shouldUseFullWidth: true, isDisabled: isSubscribed || isRequestInflight, onClickHandler: submitHandler })),
                        !isAuthenticated && (React.createElement(NewsletterOneClickVerticalFormValidation, { customInvalidityMessages: customInvalidityMessages, onSubmitHandler: submitHandler },
                            React.createElement(FormErrorContext.Consumer, null, (validationErrors) => (React.createElement(TextField.SingleLine, { buttonInputKind: "submit", buttonLabel: label, label: "", placeholder: "Enter your email", name: "email", type: "email", isRequired: true, formName: formName, hasAttachedButton: true, hasAttachedButtonForMobile: false, isDisabled: isRequestInflight || isSignedup, isNeverStacked: false, isInvalid: validationErrors?.length > 0, errorPosition: "belowButton", errorText: validationErrors && validationErrors.length > 0
                                    ? createValidationErrorMessage(validationErrors)
                                    : error, buttonClassName: "NewsletterOneClickSignUpButton" })))))),
                    !showVersion2 && logoUrl && (React.createElement(NewsletterOneClickVerticalLogo, { logoMaxHeight: logoMaxHeight },
                        React.createElement("img", { src: logoUrl, alt: "logo" }))))),
            dangerousDisclaimer && (React.createElement(NewsletterOneClickVerticalDisclaimer, null,
                React.createElement("span", { dangerouslySetInnerHTML: { __html: dangerousDisclaimer } }))))));
};
NewsletterOneClickVertical.propTypes = {
    buttonLabel: PropTypes.string.isRequired,
    ContentWrapper: PropTypes.elementType,
    dangerousDek: PropTypes.string,
    dangerousDisclaimer: PropTypes.string,
    dangerousHed: PropTypes.string,
    formName: PropTypes.string.isRequired,
    hasContentWrapper: PropTypes.bool,
    imageMaxWidth: PropTypes.number,
    imageUrl: PropTypes.string,
    logoMaxHeight: PropTypes.number,
    logoUrl: PropTypes.string,
    newsletterId: PropTypes.string.isRequired,
    sourceCode: PropTypes.string.isRequired,
    user: PropTypes.shape({
        isAuthenticated: PropTypes.bool,
        amguuid: PropTypes.string,
        email: PropTypes.string
    }).isRequired,
    userPlatform: PropTypes.shape({
        siteCode: PropTypes.string,
        userPlatformProxy: PropTypes.string,
        xClientID: PropTypes.string
    }).isRequired
};
NewsletterOneClickVertical.displayName = 'NewsletterOneClickVertical';
module.exports = connector(NewsletterOneClickVertical, {
    keysToPluck: ['user', 'userPlatform']
});
//# sourceMappingURL=NewsletterOneClickVertical.js.map

/***/ }),

/***/ 81159:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(60251);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 68272:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const Button = __webpack_require__(73730);
const { TextFieldWrapper, TextFieldButton, TextFieldErrorText } = __webpack_require__(60434);
const { UtilityValidationDescriptionErrors, UtilityValidationDescriptionWrapper } = __webpack_require__(69195);
const { calculateSpacing, getTypographyStyles, getColorToken, minScreen, maxScreen } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const FormWithValidation = __webpack_require__(72983);
const NewsletterOneClickWrapper = styled.div.withConfig({
    displayName: 'NewsletterOneClickWrapper'
}) `
  ${({ hasContentWrapper }) => hasContentWrapper && `margin-top: ${calculateSpacing(8)};`}
`;
const NewsletterOneClickVerticalWrapper = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalWrapper'
}) `
  aspect-ratio: 9/16;
  border: 1px solid ${getColorToken('colors.interactive.base.border')};
  text-align: center;
  ${minScreen(BREAKPOINTS.md)} {
    aspect-ratio: unset;
  }
`;
const NewsletterOneClickVerticalComponent = styled.div.withConfig({
    displayName: 'NewsletterOneClickVertical'
}) `
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  margin: 0;
  padding: 2rem 1.5rem;
  ${maxScreen(BREAKPOINTS.md)} {
    height: 100%;
  }
  ${minScreen(BREAKPOINTS.md)} {
    row-gap: 2rem;
  }
`;
const NewsletterOneClickVerticalHed = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalHed'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')};
  color: ${getColorToken('colors.interactive.base.black')};
  ${minScreen(BREAKPOINTS.lg)} {
    max-width: 375px;
  }
`;
const NewsletterOneClickVerticalDek = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalDek'
}) `
  ${getTypographyStyles('typography.definitions.consumptionEditorial.subhed-break-primary')};
  margin-bottom: 0.75rem;
  color: ${getColorToken('colors.interactive.base.black')};
`;
const NewsletterOneClickVerticalFormWrapper = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalFormWrapper'
}) `
  width: 100%;
  ${minScreen(BREAKPOINTS.md)} {
    margin: 0 auto;
    width: 100%;
    max-width: 375px;
  }
`;
const NewsletterOneClickVerticalSignUpButton = styled(Button.Utility).withConfig({
    displayName: 'NewsletterOneClickVerticalSignUpButton'
}) `
  ${minScreen(BREAKPOINTS.md)} {
    max-width: none;
  }
`;
const NewsletterOneClickVerticalFormValidation = styled(FormWithValidation).withConfig({
    displayName: 'NewsletterOneClickVerticalFormValidation'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')};
  width: 100%;
  color: ${getColorToken('colors.interactive.base.black')};

  ${TextFieldWrapper} {
    grid-template-columns: none;
    margin-bottom: 0;
  }

  ${TextFieldButton} {
    margin-top: 0.75rem;
  }

  ${TextFieldErrorText} {
    ${minScreen(BREAKPOINTS.md)} {
      grid-column: -1 / 1;
    }
  }

  ${UtilityValidationDescriptionErrors} {
    display: none;
  }

  ${UtilityValidationDescriptionWrapper} {
    margin-bottom: 0;
    padding: 0;
  }
`;
const NewsletterOneClickVerticalLogo = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalLogo'
}) `
  ${({ logoMaxHeight }) => {
    if (logoMaxHeight) {
        return `
      img {
        max-height: ${logoMaxHeight}rem;
      }
      `;
    }
    return ``;
}}
`;
const NewsletterOneClickVerticalDisclaimer = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalDisclaimer'
}) `
  ${getTypographyStyles('typography.definitions.utility.assistive-text')};
  margin-top: 0.75rem;
  color: ${getColorToken('colors.interactive.base.dark')};
`;
const NewsletterOneClickVerticalImage = styled.div.withConfig({
    displayName: 'NewsletterOneClickVerticalImage'
}) `
  ${({ imageMaxWidth }) => {
    if (imageMaxWidth) {
        return `
      img {
        max-width: ${imageMaxWidth}rem;
      }
      `;
    }
    return ``;
}}
`;
module.exports = {
    NewsletterOneClickWrapper,
    NewsletterOneClickVerticalWrapper,
    NewsletterOneClickVerticalComponent,
    NewsletterOneClickVerticalDisclaimer,
    NewsletterOneClickVerticalHed,
    NewsletterOneClickVerticalDek,
    NewsletterOneClickVerticalFormWrapper,
    NewsletterOneClickVerticalSignUpButton,
    NewsletterOneClickVerticalFormValidation,
    NewsletterOneClickVerticalLogo,
    NewsletterOneClickVerticalImage
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 60082:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    errorMessage: {
        id: 'NewsletterOneClickVerticalForm.ErrorMessage',
        defaultMessage: 'Subscription failed',
        description: 'NewsletterOneClickVerticalForm component error message'
    },
    typeMismatchMessage: {
        id: 'NewsletterOneClickVerticalForm.TypeMismatchMessage',
        defaultMessage: 'Invalid email. Double check and try again.',
        description: 'NewsletterOneClickVerticalForm component type mismatch message'
    },
    badResponse: {
        id: 'NewsletterOneClickVerticalForm.BadResponse',
        defaultMessage: 'Bad response for signup newsletter',
        description: 'NewsletterOneClickVerticalForm component bad response message for signup newsletter'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 20104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(70759)/* ["default"] */ .A);
const { connector } = __webpack_require__(57744);
const TextField = __webpack_require__(89662);
const CloseIcon = __webpack_require__(30616);
const { TrackComponentChannel } = __webpack_require__(78788);
const { saveNewsletterSubscriptions } = __webpack_require__(26430);
const { isUserSubscribedToNewsletter } = __webpack_require__(29727);
const FormErrorContext = __webpack_require__(45548);
const { createValidationErrorMessage } = __webpack_require__(88511);
const { NewsletterOneClickWrapper, NewsletterOneClickDek, NewsletterOneClickHed, NewsletterOneClickDisclaimer, NewsletterOneClickSignUpButton, NewsletterOneClickStyledCheckbox, NewsletterOneClickNativeCheckbox, NewsletterOneClickFormValidation, NewsletterOneClickErrorText, NewsletterOneClickModalWrapper, NewsletterOneClickModalCloseButton } = __webpack_require__(66661);
const NewsletterWrapper = __webpack_require__(69413);
const StickyBox = __webpack_require__(28433);
/**
 * NewsletterOneClick Component
 *
 * @param {object} [props] - React props
 * @param {string} [props.buttonLabel] - Required sign up button label
 * @param {Element} [props.ContentWrapper] - Optional content wrapper component
 * @param {string} [props.dangerousDek] - Required dangerousDek text
 * @param {string} [props.dangerousDisclaimer] - Required dangerousDisclaimer text
 * @param {string} [props.dangerousHed] - Required dangerousHed text
 * @param {string} [props.formName] - Required formName
 * @param {string} [props.newsletterId] - Required newsletter Id
 * @param {string} [props.sourceCode] - Required sourceCode
 * @param {object} [props.user] - Required User information
 * @param {boolean} [props.user.isAuthenticated] - Represents if the user is currently authenticated
 * @param {string} [props.user.amguuid] - User's amguuid
 * @param {string} [props.user.email] - User's email
 * @param {object} [props.userPlatform] - User platform details
 * @param {string} [props.userPlatform.siteCode] -  Brand siteCode
 * @param {string} [props.userPlatform.userPlatformProxy] - Brand user platform proxy server url
 * @param {string} [props.userPlatform.xClientID] - xClientID from brand tenant config
 * @param {string} [props.variationName] -  Component variation name used for Component Tracking
 * @param {object} [props.variations] - Optional variations
 * @param {boolean} [props.variations.isActionSheet] - Optional isActionSheet [true, false]
 * @param {string} [props.variations.isNativeStyledCheckbox] - Optional isNativeStyledCheckbox [true, false]
 * @param {string} [props.variations.isSignUpButton] - Optional isSignUpButton [true, false]
 * @param {string} [props.variations.isNeverStacked] - Optional isNeverStacked [true, false]
 * @param {string} [props.variations.hasContentWrapper] - Optional hasContentWrapper [true, false]
 * @param {string} [props.variations.shouldRenderHed] - Optional hasContentWrapper [true, false]
 *
 * @returns <NewsletterOneClick>
 */
const NewsletterOneClick = (props) => {
    const { buttonLabel, ContentWrapper, dangerousDek, dangerousDisclaimer, dangerousHed, formName, newsletterId, sourceCode, user: { isAuthenticated, amguuid, email }, userPlatform: { siteCode, userPlatformProxy, xClientID }, variationName, variations: { hasContentWrapper = false, isActionSheet = false, isNativeStyledCheckbox = false, isSignUpButton = false, isNeverStacked = false, shouldRenderHed = false } } = props;
    const [isSubscribed, setIsSubscribed] = React.useState(false);
    const [isSignedup, setIsSignedUp] = React.useState(false);
    const [isRequestInflight, setIsRequestInflight] = React.useState(false);
    const [label, setLabel] = React.useState(buttonLabel);
    const [error, setError] = React.useState('');
    const [hideNewletterUnit, setHideNewletterUnit] = React.useState(false);
    const [showActionSheet, setShowActionSheet] = React.useState(false);
    const { formatMessage } = useIntl();
    const customInvalidityMessages = {
        email: {
            typeMismatch: formatMessage(translations.typeMismatchMessage)
        }
    };
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterOneClick',
            variation: variationName
        });
    }, [variationName]);
    React.useEffect(() => {
        if (isAuthenticated) {
            const options = {
                newsletterIds: [newsletterId],
                amgUUID: amguuid,
                userPlatformProxy,
                xClientID,
                provider: 'sailthru'
            };
            isUserSubscribedToNewsletter(options)
                .then((result) => {
                if (result) {
                    setIsSubscribed(true);
                    setHideNewletterUnit(true);
                }
                else {
                    setIsSubscribed(false);
                }
            })
                .catch((error) => {
                console.log('error ', error);
                setError(formatMessage(translations.badResponse));
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const submitHandler = (e) => {
        e?.preventDefault();
        setIsSignedUp(true);
        setIsRequestInflight(true);
        const opts = {
            amgUUID: amguuid,
            siteCode,
            xClientID,
            payload: {
                email: e?.target?.querySelector(`[name=email]`)?.value || email,
                formName,
                sourceCode,
                subscriptions: [
                    {
                        status: 'SUBSCRIBED',
                        newsletterId
                    }
                ]
            }
        };
        Promise.resolve(saveNewsletterSubscriptions(opts))
            .then((result) => {
            if (result.savePreference.success) {
                setIsSubscribed(true);
                setLabel('Signed Up');
                setShowActionSheet(false);
            }
            else {
                setError(formatMessage(translations.errorMessage));
                setIsSignedUp(false);
            }
            setIsRequestInflight(false);
        })
            .catch((error) => {
            console.log(error);
            setError(formatMessage(translations.badResponse));
            setIsRequestInflight(false);
            setIsSignedUp(false);
            setIsSubscribed(false);
        });
    };
    const handleOnChange = (e) => {
        if (e.target.checked && isAuthenticated) {
            submitHandler();
        }
        else {
            setShowActionSheet(true);
        }
    };
    const nativeInputProps = {
        type: 'checkbox',
        inputType: 'checkbox',
        autoComplete: 'off',
        id: `slim-article-${newsletterId}`,
        name: `slim-article-${newsletterId}`,
        checked: isSubscribed,
        value: isSubscribed,
        onChange: handleOnChange,
        disabled: isSubscribed,
        className: isAuthenticated
            ? classnames(`NewsletterOneClickSignUpButton`)
            : classnames(``)
    };
    const closeModalHandler = () => {
        setShowActionSheet(false);
    };
    if (hideNewletterUnit)
        return React.createElement(React.Fragment, null);
    return (React.createElement(NewsletterWrapper, { variationName: variationName, ContentWrapper: ContentWrapper, hasContentWrapper: hasContentWrapper },
        React.createElement(NewsletterOneClickWrapper, { className: classnames(`newsletter-one-click-wrapper--${variationName}`, isAuthenticated
                ? `newsletter-one-click-wrapper--${variationName}--${isAuthenticated}`
                : '') },
            shouldRenderHed && (React.createElement(NewsletterOneClickHed, { dangerouslySetInnerHTML: { __html: dangerousHed } })),
            !shouldRenderHed && dangerousDek && (React.createElement(NewsletterOneClickDek, { dangerouslySetInnerHTML: { __html: dangerousDek } })),
            isNativeStyledCheckbox && (isAuthenticated || isActionSheet) && (React.createElement(React.Fragment, null,
                React.createElement(NewsletterOneClickNativeCheckbox, { ...nativeInputProps }),
                React.createElement(NewsletterOneClickStyledCheckbox, { inputType: "checkbox" }))),
            shouldRenderHed && (React.createElement(NewsletterOneClickDek, { dangerouslySetInnerHTML: { __html: dangerousDek } })),
            isSignUpButton && isAuthenticated && (React.createElement(NewsletterOneClickSignUpButton, { label: label, inputKind: "submit", shouldUseFullWidth: true, isDisabled: isSubscribed || isRequestInflight, onClickHandler: submitHandler, className: classnames(`NewsletterOneClickSignUpButton`) })),
            !isAuthenticated && !isActionSheet && (React.createElement(NewsletterOneClickFormValidation, { customInvalidityMessages: customInvalidityMessages, onSubmitHandler: submitHandler },
                React.createElement(FormErrorContext.Consumer, null, (validationErrors) => (React.createElement(TextField.SingleLine, { buttonInputKind: "submit", buttonLabel: label, label: "", name: "email", type: "email", isRequired: true, formName: formName, hasAttachedButton: true, isDisabled: isRequestInflight || isSignedup, isNeverStacked: isNeverStacked, isInvalid: validationErrors?.length > 0, errorPosition: "belowButton", errorText: validationErrors && validationErrors.length > 0
                        ? createValidationErrorMessage(validationErrors)
                        : error, buttonClassName: "NewsletterOneClickSignUpButton" }))))),
            !(isAuthenticated || isSubscribed || isActionSheet) && (React.createElement(NewsletterOneClickDisclaimer, null,
                React.createElement("span", { dangerouslySetInnerHTML: { __html: dangerousDisclaimer } }))),
            isAuthenticated && error && (React.createElement(NewsletterOneClickErrorText, null, error)),
            showActionSheet && (React.createElement(StickyBox, null,
                React.createElement(NewsletterOneClickModalWrapper, null,
                    React.createElement(NewsletterOneClickModalCloseButton, { isIconButton: true, role: "button", onClickHandler: closeModalHandler, ButtonIcon: CloseIcon, label: "" }),
                    React.createElement(NewsletterOneClickFormValidation, { customInvalidityMessages: customInvalidityMessages, onSubmitHandler: submitHandler },
                        React.createElement(FormErrorContext.Consumer, null, (validationErrors) => (React.createElement(TextField.SingleLine, { buttonInputKind: "submit", buttonLabel: label, label: "Enter your email", placeholder: "Your email address", name: "email", type: "email", isRequired: true, formName: formName, hasAttachedButton: true, hasAutoFocus: true, isDisabled: isRequestInflight || isSignedup, isNeverStacked: isNeverStacked, isInvalid: validationErrors?.length > 0, errorPosition: "belowButton", errorText: validationErrors && validationErrors.length > 0
                                ? createValidationErrorMessage(validationErrors)
                                : error, buttonClassName: "NewsletterOneClickSignUpButton" })))),
                    React.createElement(NewsletterOneClickDisclaimer, null,
                        React.createElement("span", { dangerouslySetInnerHTML: { __html: dangerousDisclaimer } }))))))));
};
NewsletterOneClick.propTypes = {
    buttonLabel: PropTypes.string.isRequired,
    ContentWrapper: PropTypes.elementType,
    dangerousDek: PropTypes.string.isRequired,
    dangerousDisclaimer: PropTypes.string.isRequired,
    dangerousHed: PropTypes.string,
    formName: PropTypes.string.isRequired,
    newsletterId: PropTypes.string.isRequired,
    sourceCode: PropTypes.string.isRequired,
    user: PropTypes.shape({
        isAuthenticated: PropTypes.bool,
        amguuid: PropTypes.string,
        email: PropTypes.string
    }).isRequired,
    userPlatform: PropTypes.shape({
        siteCode: PropTypes.string,
        userPlatformProxy: PropTypes.string,
        xClientID: PropTypes.string
    }).isRequired,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        isActionSheet: PropTypes.bool,
        isNativeStyledCheckbox: PropTypes.bool,
        isSignUpButton: PropTypes.bool,
        isNeverStacked: PropTypes.bool,
        hasContentWrapper: PropTypes.bool,
        shouldRenderHed: PropTypes.bool
    })
};
NewsletterOneClick.displayName = 'NewsletterOneClick';
module.exports = connector(NewsletterOneClick, {
    keysToPluck: ['user', 'userPlatform']
});
//# sourceMappingURL=NewsletterOneClick.js.map

/***/ }),

/***/ 69413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
/**
 * NewsletterWrapper Component
 *
 * @param {Element} [props.ContentWrapper] - Optional content wrapper component
 * @param {ReactElement} [props.children] - content for NewsletterOneClick
 *
 * @returns <NewsletterWrapper>
 */
const NewsletterWrapper = ({ ContentWrapper, children, hasContentWrapper }) => hasContentWrapper ? (React.createElement(ContentWrapper, null, children)) : (React.createElement(React.Fragment, null, children));
NewsletterWrapper.propTypes = {
    children: PropTypes.node,
    ContentWrapper: PropTypes.elementType,
    hasContentWrapper: PropTypes.bool
};
NewsletterWrapper.displayName = 'NewsletterWrapper';
module.exports = NewsletterWrapper;
//# sourceMappingURL=NewsletterWrapper.js.map

/***/ }),

/***/ 38267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(45853);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 66661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const Button = __webpack_require__(73730);
const { calculateSpacing, getTypographyStyles, getColorStyles, getColorToken, minScreen, maxScreen } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { INTERACTIVE: { timingButtonDefault } } = __webpack_require__(96472);
const FormWithValidation = __webpack_require__(72983);
const { TextFieldButton } = __webpack_require__(60434);
const { UtilityValidationDescriptionErrors, UtilityValidationDescriptionWrapper } = __webpack_require__(69195);
const NewsletterOneClickHed = styled.h3.withConfig({
    displayName: 'NewsletterOneClickHed'
}) `
  ${getTypographyStyles('typography.definitions.utility.heading')};
  margin: 0;
  color: ${getColorToken('colors.interactive.base.black')};
`;
const NewsletterOneClickDek = styled.div.withConfig({
    displayName: 'NewsletterOneClickDek'
}) ``;
const NewsletterOneClickStyledCheckbox = styled.div.withConfig({
    displayName: 'NewsletterOneClickStyledCheckbox'
}) `
  position: relative;
  grid-column-start: 2;
  justify-self: start;
  align-self: center;
  transition-property: background, border;
  transition-duration: ${timingButtonDefault};
  transition-timing-function: ease-in;
  border-width: 2px;
  border-style: solid;
  border-radius: 50%;
  padding: ${calculateSpacing(1.2)};
  width: 2.25rem;
  height: 2.25rem;
  font-weight: bold;
  pointer-events: none;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.white')};
  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.black')};

  &::before,
  &::after {
    position: absolute;
    top: 50%;
    left: 50%;
    transition: transform ${timingButtonDefault} ease-in-out;
    background-color: ${getColorToken('colors.interactive.base.white')};
    width: 2px;
    height: 10px;
    content: '';
  }

  &::before {
    transform: translate(-50%, -50%);
  }

  &::after {
    transform: translate(-50%, -50%) rotate(90deg);
  }
`;
const NewsletterOneClickFormValidation = styled(FormWithValidation).withConfig({
    displayName: 'NewsletterOneClickFormValidation'
}) `
  input:disabled {
    opacity: 0.5;
  }

  ${UtilityValidationDescriptionErrors} {
    display: none;
  }

  ${UtilityValidationDescriptionWrapper} {
    margin-bottom: 0;
    padding: 0;
  }
`;
const applySlideUpAnimation = `
  animation-name: slide-up;
  animation-duration: 300ms;
  animation-timing-function: ease-out;

  @keyframes slide-up {
    0% {
      transform: translateY(100%);
    }
    100% {
      transform: translateY(0);
    }
  }
`;
const NewsletterOneClickModalWrapper = styled('div').withConfig({
    displayName: 'NewsletterOneClickModelWrapper'
}) `
  box-shadow: 0 0 24px 0 rgba(45, 45, 45, 0.16);
  background-color: rgba(255, 255, 255, 1);
  padding: 2.5rem 2rem 1.5rem;
  ${maxScreen(BREAKPOINTS.xl)} {
    ${applySlideUpAnimation};
  }

  ${minScreen(BREAKPOINTS.xl)} {
    border-radius: 8px;
  }
`;
const NewsletterOneClickExtraSlimCommonStyles = `
  display: grid;
  position: relative;
  grid-column-gap: 12px;
  padding: ${calculateSpacing(1.5)} 0;

  input[type='checkbox'] {
    cursor: pointer;
    width: 2.25rem;
    height: 2.25rem;
  }

  input[type='email'] {
    margin-top: 0;
  }

  ${NewsletterOneClickFormValidation} {
    margin: ${calculateSpacing(1.5)} 0 0 0;
  }
`;
const NewsletterOneClickWrapperCommonStyles = `
    ${NewsletterOneClickDek} {
      align-self: center;
      width: fit-content;

      b,
      i,
      em,
      span,
      strong {
        color: ${getColorToken('colors.interactive.base.black')};
      }
    }
`;
const NewsletterOneClickSignUpButton = styled(Button.Utility).withConfig({
    displayName: 'NewsletterOneClickSignUpButton'
}) `
  margin-top: 32px;
`;
const NewsletterOneClickWrapper = styled.div.withConfig({
    displayName: 'NewsletterOneClickWrapper'
}) `
  &.newsletter-one-click-wrapper--Extended {
    ${maxScreen(BREAKPOINTS.md)} {
      margin: ${calculateSpacing(5)} 0 0;
      padding: ${calculateSpacing(6)} ${calculateSpacing(4)};
    }
    ${minScreen(BREAKPOINTS.md)} {
      margin: ${calculateSpacing(2)} 0 0;
      padding: ${calculateSpacing(8)} ${calculateSpacing(4)};
    }

    ${NewsletterOneClickHed} {
      text-align: center;
    }

    ${NewsletterOneClickDek} {
      ${getTypographyStyles('typography.definitions.utility.description')};
      margin: ${calculateSpacing(2)} auto ${calculateSpacing(3)} auto;
      text-align: center;
      color: ${getColorToken('colors.interactive.base.black')};
      @media (min-width: ${BREAKPOINTS.md}) {
        margin-top: ${calculateSpacing(3)};
        margin-bottom: ${calculateSpacing(4)};
      }
    }
  }

  &.newsletter-one-click-wrapper--Slim {
    display: grid;
    position: relative;
    grid-column-gap: 12px;
    border-top: 1px solid ${getColorToken('colors.interactive.base.light')};
    padding: ${calculateSpacing(1.5)} 0 ${calculateSpacing(3)} 0;

    input[type='checkbox'] {
      top: 12px;
      left: auto;
      cursor: pointer;
      width: 2.25rem;
      height: 2.25rem;
    }

    ${NewsletterOneClickHed} {
      ${getTypographyStyles('typography.definitions.utility.card-heading')};
      margin: 0;
      padding-bottom: 12px;
      font-size: 18px;
    }

    ${NewsletterOneClickDek} {
      ${getTypographyStyles('typography.definitions.utility.body')};
      padding-bottom: 12px;
      font-size: 15px;
    }
  }

  &.newsletter-one-click-wrapper--ExtraSlim {
    &--true {
      ${minScreen(BREAKPOINTS.xxl)} {
        grid-template-columns: max-content;
      }
    }
    ${NewsletterOneClickExtraSlimCommonStyles}
    ${NewsletterOneClickWrapperCommonStyles}

    ${NewsletterOneClickDek} {
      ${getTypographyStyles('typography.definitions.consumptionEditorial.description-embed')};
      color: ${getColorToken('colors.interactive.base.dark')};

      b,
      i,
      em,
      span,
      strong {
        color: ${getColorToken('colors.interactive.base.black')};
      }
    }
  }

  &.newsletter-one-click-wrapper--ExtraSlimWithActionSheet {
    ${minScreen(BREAKPOINTS.xxl)} {
      grid-template-columns: max-content;
    }
    ${NewsletterOneClickExtraSlimCommonStyles}
    ${NewsletterOneClickWrapperCommonStyles}

    ${NewsletterOneClickDek} {
      ${getTypographyStyles('typography.definitions.consumptionEditorial.description-embed')};
      color: ${getColorToken('colors.interactive.base.dark')};

      b,
      i,
      em,
      span,
      strong {
        color: ${getColorToken('colors.interactive.base.black')};
      }
    }

    .sticky-box {
      display: grid;
      position: fixed;
      right: 0;
      bottom: 0;
      left: 0;
      z-index: 500;

      ${minScreen(BREAKPOINTS.lg)} {
        margin: auto;
        width: 50%;
      }

      ${minScreen(BREAKPOINTS.xl)} {
        background-color: rgba(0, 0, 0, 0.5);
        width: 100%;
        height: 100%;

        ${TextFieldButton} {
          grid-row: none;
          margin-top: 16px;
        }
      }
    }

    ${NewsletterOneClickModalWrapper} {
      ${minScreen(BREAKPOINTS.xl)} {
        position: relative;
        top: 50%;
        left: 33%;
        width: 33%;
      }
    }
  }

  &.newsletter-one-click-wrapper--SlimOneClick {
    display: grid;
    position: relative;
    grid-column-gap: 12px;
    border-top: 1px solid ${getColorToken('colors.interactive.base.light')};
    padding: ${calculateSpacing(1.5)} 0 ${calculateSpacing(3)} 0;

    ${NewsletterOneClickHed} {
      ${getTypographyStyles('typography.definitions.utility.card-heading')};
      margin: 0;
      padding-bottom: 12px;
      font-size: 18px;
    }

    ${NewsletterOneClickDek} {
      ${getTypographyStyles('typography.definitions.utility.body')};
      padding-bottom: 12px;
      font-size: 15px;
    }

    ${NewsletterOneClickSignUpButton} {
      margin-top: 0;
    }
  }
`;
const NewsletterOneClickDisclaimer = styled.div.withConfig({
    displayName: 'NewsletterOneClickDisclaimer'
}) `
  ${getTypographyStyles('typography.definitions.utility.assistive-text')};
  color: ${getColorToken('colors.interactive.base.dark')};
`;
const selectionControlNativeInput = ({ selectionControlBackgroundColor, theme }) => {
    return `
    &:focus
    {
     + ${NewsletterOneClickStyledCheckbox} {
        outline: 1px solid;
        outline-color: ${getColorToken('colors.interactive.base.black')};
        outline-offset: 1px;
      }
    }
    &:hover
    {
     + ${NewsletterOneClickStyledCheckbox} {
        @media (min-width: ${BREAKPOINTS.md}) {
          ${getColorStyles(theme, 'background-color', 'colors.interactive.base.black')};
          &::before,
          &::after {
            ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
          }
        }
      }
    }
      &:checked,
      &:active {
        + ${NewsletterOneClickStyledCheckbox} {
          
          ${getColorStyles(theme, 'background-color', selectionControlBackgroundColor)};
  
          ${getColorStyles(theme, 'border-color', selectionControlBackgroundColor)};
  
          &::before,
          &::after {
            ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
          }
          &::before {
            transform: translate(55%, -50%) rotate(45deg);
            height: 15px;
            border-width: 8px;
          }
          &::after {
            transform: translate(0, 0) rotate(-50deg);
            height: 8px;
            border-left: 0;
            border-bottom: 0;
            background: white;
            left: 30%;
            top: 45%;
          }
        }
      }
    `;
};
const getNativeInputCommonStyles = ({ theme, disabled }) => {
    return disabled
        ? css `
        ${selectionControlNativeInput({
            selectionControlBackgroundColor: 'colors.interactive.base.deemphasized',
            theme
        })}
      `
        : css `
        ${selectionControlNativeInput({
            selectionControlBackgroundColor: 'colors.interactive.base.black',
            theme
        })}
      `;
};
const NewsletterOneClickNativeCheckbox = styled.input.withConfig({
    displayName: 'NewsletterOneClickNativeCheckbox'
}) `
  position: relative;
  grid-column-start: 2;
  justify-self: start;
  align-self: center;
  ${({ theme, disabled }) => getNativeInputCommonStyles({ theme, disabled })}
`;
const NewsletterOneClickErrorText = styled.div.withConfig({
    displayName: 'NewsletterOneClickErrorText'
}) `
  margin-top: 8px;
  ${getTypographyStyles('typography.definitions.utility.assistive-text')};
  text-align: center;
  color: ${getColorToken('colors.interactive.feedback.invalid-primary')};
  font-size: 12px;
`;
const NewsletterOneClickModalCloseButton = styled(Button.Utility).withConfig({
    displayName: 'NewsletterOneClickModalCloseButton'
}) `
  position: absolute;
  top: ${calculateSpacing(1)};
  right: ${calculateSpacing(1)};
  padding: 0;
  fill: ${getColorToken('colors.discovery.body.light.context-tertiary')};

  &,
  &:focus,
  &:hover {
    border: 0;
    background-color: transparent;
  }
`;
module.exports = {
    NewsletterOneClickWrapper,
    NewsletterOneClickDek,
    NewsletterOneClickHed,
    NewsletterOneClickDisclaimer,
    NewsletterOneClickSignUpButton,
    NewsletterOneClickStyledCheckbox,
    NewsletterOneClickNativeCheckbox,
    NewsletterOneClickFormValidation,
    NewsletterOneClickErrorText,
    NewsletterOneClickModalWrapper,
    NewsletterOneClickModalCloseButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 70759:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    errorMessage: {
        id: 'NewsletterOneClickForm.ErrorMessage',
        defaultMessage: 'Subscription failed',
        description: 'NewsletterOneClickForm component error message'
    },
    typeMismatchMessage: {
        id: 'NewsletterOneClickForm.TypeMismatchMessage',
        defaultMessage: 'Invalid email. Double check and try again.',
        description: 'NewsletterOneClickForm component type mismatch message'
    },
    badResponse: {
        id: 'NewsletterOneClickForm.BadResponse',
        defaultMessage: 'Bad response for signup newsletter',
        description: 'NewsletterOneClickForm component bad response message for signup newsletter'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 45853:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const NewsletterOneClick = __webpack_require__(20104);
NewsletterOneClick.Extended = asVariation(NewsletterOneClick, 'Extended', {
    isNativeStyledCheckbox: false,
    isSignUpButton: true,
    isNeverStacked: false,
    hasContentWrapper: true,
    shouldRenderHed: true
});
NewsletterOneClick.Slim = asVariation(NewsletterOneClick, 'Slim', {
    isNativeStyledCheckbox: true,
    isSignUpButton: false,
    isNeverStacked: true,
    hasContentWrapper: false,
    shouldRenderHed: true
});
NewsletterOneClick.SlimStacked = asVariation(NewsletterOneClick, 'SlimStacked', {
    isNativeStyledCheckbox: false,
    isSignUpButton: true,
    isNeverStacked: false,
    hasContentWrapper: false,
    shouldRenderHed: true
});
NewsletterOneClick.ExtraSlim = asVariation(NewsletterOneClick, 'ExtraSlim', {
    isNativeStyledCheckbox: true,
    isSignUpButton: false,
    isNeverStacked: true,
    hasContentWrapper: false,
    shouldRenderHed: false
});
NewsletterOneClick.ExtraSlimWithActionSheet = asVariation(NewsletterOneClick, 'ExtraSlimWithActionSheet', {
    isActionSheet: true,
    isNativeStyledCheckbox: true,
    isSignUpButton: false,
    isNeverStacked: true,
    hasContentWrapper: false,
    shouldRenderHed: false
});
NewsletterOneClick.SlimOneClick = asVariation(NewsletterOneClick, 'SlimOneClick', {
    isNativeStyledCheckbox: false,
    isSignUpButton: true,
    isNeverStacked: true,
    hasContentWrapper: false,
    shouldRenderHed: true
});
module.exports = NewsletterOneClick;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 87727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const { connector } = __webpack_require__(57744);
const TextField = __webpack_require__(89662);
const FormErrorContext = __webpack_require__(45548);
const { TrackComponentChannel } = __webpack_require__(78788);
const { isUserSubscribedToNewsletter } = __webpack_require__(29727);
const { saveNewsletterSubscriptions } = __webpack_require__(26430);
const { createValidationErrorMessage } = __webpack_require__(88511);
const translations = (__webpack_require__(29364)/* ["default"] */ .A);
const { NewsletterPlpWrapper, NewsletterPlpComponent, NewsletterPlpFormWrapper, NewsletterPlpHed, NewsletterPlpDek, NewsletterPlpFormValidation, NewsletterPlpDisclaimer, NewsletterPlpImage, NewsletterPlpSignUpButton } = __webpack_require__(3714);
const NewsletterPlp = (props) => {
    const { buttonLabel, dangerousDek, dangerousDisclaimer, dangerousHed, formName, newsletterId, sourceCode, imageUrl, user: { isAuthenticated, amguuid, email }, userPlatform: { siteCode, userPlatformProxy, xClientID } } = props;
    const [isSubscribed, setIsSubscribed] = React.useState(false);
    const [isSignedup, setIsSignedUp] = React.useState(false);
    const [isRequestInflight, setIsRequestInflight] = React.useState(false);
    const [label, setLabel] = React.useState(buttonLabel);
    const [hideNewletterUnit, setHideNewletterUnit] = React.useState(false);
    const [error, setError] = React.useState('');
    const { formatMessage } = useIntl();
    const customInvalidityMessages = {
        email: {
            typeMismatch: formatMessage(translations.typeMismatchMessage)
        }
    };
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterPlp'
        });
        if (isAuthenticated) {
            const options = {
                newsletterIds: [newsletterId],
                amgUUID: amguuid,
                userPlatformProxy,
                xClientID,
                provider: 'sailthru'
            };
            isUserSubscribedToNewsletter(options)
                .then((result) => {
                if (result) {
                    setIsSubscribed(true);
                    setHideNewletterUnit(true);
                }
                else {
                    setIsSubscribed(false);
                }
            })
                .catch((error) => {
                console.log('error ', error);
                setError(formatMessage(translations.badResponse));
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const submitHandler = (e) => {
        e?.preventDefault();
        setIsSignedUp(true);
        setIsRequestInflight(true);
        const opts = {
            amgUUID: amguuid,
            siteCode,
            xClientID,
            payload: {
                email: e?.target?.querySelector(`[name=email]`)?.value || email,
                formName,
                sourceCode,
                subscriptions: [
                    {
                        status: 'SUBSCRIBED',
                        newsletterId
                    }
                ]
            }
        };
        Promise.resolve(saveNewsletterSubscriptions(opts))
            .then((result) => {
            if (result.savePreference.success) {
                setIsSubscribed(true);
                setLabel('Signed Up');
            }
            else {
                setError(formatMessage(translations.errorMessage));
                setIsSignedUp(false);
            }
            setIsRequestInflight(false);
        })
            .catch((error) => {
            console.log('NewsletterPlp Error : ', error);
            setError(formatMessage(translations.badResponse));
            setIsRequestInflight(false);
            setIsSignedUp(false);
        });
    };
    const newsletterPlpFormComponent = () => {
        if (isAuthenticated) {
            return (React.createElement(NewsletterPlpSignUpButton, { label: label, inputKind: "submit", shouldUseFullWidth: true, isDisabled: isSubscribed || isRequestInflight, onClickHandler: submitHandler }));
        }
        return (React.createElement(NewsletterPlpFormValidation, { customInvalidityMessages: customInvalidityMessages, onSubmitHandler: submitHandler },
            React.createElement(FormErrorContext.Consumer, null, (validationErrors) => (React.createElement(TextField.SingleLine, { buttonInputKind: "submit", buttonLabel: label, label: "", placeholder: "Enter your email", name: "email", type: "email", isRequired: true, formName: formName, hasAttachedButton: true, hasAttachedButtonForMobile: false, isDisabled: isRequestInflight || isSignedup, isNeverStacked: false, isInvalid: validationErrors?.length > 0, errorPosition: "belowButton", errorText: validationErrors && validationErrors.length > 0
                    ? createValidationErrorMessage(validationErrors)
                    : error, buttonClassName: "NewsletterPlpSignUpButton" })))));
    };
    if (hideNewletterUnit)
        return null;
    return (React.createElement(NewsletterPlpWrapper, null,
        React.createElement(NewsletterPlpComponent, null,
            React.createElement(NewsletterPlpImage, null,
                React.createElement("img", { src: imageUrl, alt: "logo" })),
            React.createElement(NewsletterPlpFormWrapper, null,
                dangerousHed && (React.createElement(NewsletterPlpHed, { dangerouslySetInnerHTML: { __html: dangerousHed } })),
                dangerousDek && (React.createElement(NewsletterPlpDek, { dangerouslySetInnerHTML: { __html: dangerousDek } })),
                newsletterPlpFormComponent(),
                dangerousDisclaimer && (React.createElement(NewsletterPlpDisclaimer, null,
                    React.createElement("span", { dangerouslySetInnerHTML: { __html: dangerousDisclaimer } })))))));
};
NewsletterPlp.propTypes = {
    buttonLabel: PropTypes.string.isRequired,
    dangerousDek: PropTypes.string.isRequired,
    dangerousDisclaimer: PropTypes.string.isRequired,
    dangerousHed: PropTypes.string.isRequired,
    formName: PropTypes.string.isRequired,
    imageUrl: PropTypes.string.isRequired,
    newsletterId: PropTypes.string.isRequired,
    sourceCode: PropTypes.string.isRequired,
    user: PropTypes.shape({
        isAuthenticated: PropTypes.bool,
        amguuid: PropTypes.string,
        email: PropTypes.string
    }).isRequired,
    userPlatform: PropTypes.shape({
        siteCode: PropTypes.string,
        userPlatformProxy: PropTypes.string,
        xClientID: PropTypes.string
    }).isRequired
};
NewsletterPlp.displayName = 'NewsletterPlp';
module.exports = connector(NewsletterPlp, {
    keysToPluck: ['user', 'userPlatform']
});
//# sourceMappingURL=NewsletterPlp.js.map

/***/ }),

/***/ 32334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(87727);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3714:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const Button = __webpack_require__(73730);
const { getTypographyStyles, getColorToken, minScreen, maxScreen } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { TextFieldWrapper, TextFieldButton, TextFieldErrorText } = __webpack_require__(60434);
const { UtilityValidationDescriptionErrors, UtilityValidationDescriptionWrapper } = __webpack_require__(69195);
const FormWithValidation = __webpack_require__(72983);
const NewsletterPlpWrapper = styled.div.withConfig({
    displayName: 'NewsletterPlpWrapper'
}) `
  aspect-ratio: unset;
  text-align: left;
`;
const NewsletterPlpComponent = styled.div.withConfig({
    displayName: 'NewsletterPlpComponent'
}) `
  display: grid;
  ${minScreen(BREAKPOINTS.md)} {
    grid-template-columns: 50% 50%;
  }
  align-items: center;
  justify-items: center;
`;
const NewsletterPlpFormWrapper = styled.div.withConfig({
    displayName: 'NewsletterPlpFormWrapper'
}) `
  padding: 1.5rem 0;
  width: 100%;
  ${minScreen(BREAKPOINTS.md)} {
    margin: 0 auto;
    padding: 4rem 2.5rem;
    width: 100%;
  }
`;
const NewsletterPlpHed = styled.div.withConfig({
    displayName: 'NewsletterPlpHed'
}) `
  ${getTypographyStyles('typography.definitions.consumptionEditorial.subhed-break-secondary')};
  margin-bottom: 0.5rem;
  color: ${getColorToken('colors.interactive.base.black')};
`;
const NewsletterPlpDek = styled.div.withConfig({
    displayName: 'NewsletterPlpDek'
}) `
  ${getTypographyStyles('typography.definitions.discovery.description-page')};
  margin-bottom: 0.75rem;
  color: ${getColorToken('colors.interactive.base.black')};
`;
const NewsletterPlpFormValidation = styled(FormWithValidation).withConfig({
    displayName: 'NewsletterPlpFormValidation'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')};
  width: 100%;
  color: ${getColorToken('colors.interactive.base.black')};

  ${TextFieldWrapper} {
    ${minScreen(BREAKPOINTS.md) && maxScreen(BREAKPOINTS.lg)} {
      grid-template-columns: none;
      margin-bottom: 0;
    }
  }

  ${TextFieldButton} {
    margin-top: 0.75rem;
  }

  ${TextFieldErrorText} {
    ${minScreen(BREAKPOINTS.md)} {
      grid-column: -1 / 1;
    }
  }

  ${UtilityValidationDescriptionErrors} {
    display: none;
  }

  ${UtilityValidationDescriptionWrapper} {
    margin-bottom: 0;
    padding: 0;
  }
`;
const NewsletterPlpDisclaimer = styled.div.withConfig({
    displayName: 'NewsletterPlpDisclaimer'
}) `
  ${getTypographyStyles('typography.definitions.utility.assistive-text')};
  margin-top: 0.75rem;
  color: ${getColorToken('colors.interactive.base.dark')};
`;
const NewsletterPlpImage = styled.div.withConfig({
    displayName: 'NewsletterPlpImage'
}) `
  display: none;
  ${minScreen(BREAKPOINTS.md)} {
    display: block;
  }

  img {
    max-width: 100%;
  }
`;
const NewsletterPlpSignUpButton = styled(Button.Utility).withConfig({
    displayName: 'NewsletterPlpSignUpButton'
}) `
  ${minScreen(BREAKPOINTS.md)} {
    max-width: none;
  }
`;
module.exports = {
    NewsletterPlpWrapper,
    NewsletterPlpComponent,
    NewsletterPlpFormWrapper,
    NewsletterPlpHed,
    NewsletterPlpDek,
    NewsletterPlpFormValidation,
    NewsletterPlpDisclaimer,
    NewsletterPlpImage,
    NewsletterPlpSignUpButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 29364:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    errorMessage: {
        id: 'NewsletterPlpForm.ErrorMessage',
        defaultMessage: 'Subscription failed',
        description: 'NewsletterPlpForm component error message'
    },
    typeMismatchMessage: {
        id: 'NewsletterPlpForm.TypeMismatchMessage',
        defaultMessage: 'Invalid email. Double check and try again.',
        description: 'NewsletterPlpForm component type mismatch message'
    },
    badResponse: {
        id: 'NewsletterPlpForm.BadResponse',
        defaultMessage: 'Bad response for signup newsletter',
        description: 'NewsletterPlpForm component bad response message for signup newsletter'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 49512:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const SelectionControlList = __webpack_require__(10673);
const UtilitySelectionControl = __webpack_require__(67685);
const { NLSecondaryOptionCheckBox } = __webpack_require__(94944);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * NewsletterSecondaryOptins component
 *
 * @param {object} props - React props
 * @param {object} [props.checked] - Optional map with key of optin newsletter ID and value of whether checkbox is checked
 * @param {string} props.dangerousLegend - dangerousLengend
 * @param {string} props.formName - formName
 * @param {boolean} [props.isDefaultChecked] - Optional flag if selction is checked by default
 * @param {boolean} [props.isPending] - Optional flag if submission response isPending
 * @param {Function} [props.onChangeHandler] - Optional handler for change event
 * @param {Array} props.optins - The available list of tenant third-party optin newsletters
 *
 * @returns {ReactElement} <div>
 */
const NewsletterSecondaryOptins = ({ checked, dangerousLegend, formName, isDefaultChecked, isPending, onChangeHandler, optins }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterSecondaryOptins'
        });
    }, []);
    return (React.createElement(SelectionControlList, { dangerousLegend: dangerousLegend, formName: formName, isDisabled: isPending, items: optins }, optins.map((item, index) => {
        return (React.createElement(NLSecondaryOptionCheckBox, { as: UtilitySelectionControl.Checkbox, ...item, assistiveText: item.dangerousDek, formName: formName, key: `${item.name}.${item.value}`, index: index, isChecked: checked ? checked[item.id] : isDefaultChecked, isDisabled: isPending, onChangeHandler: onChangeHandler }));
    })));
};
NewsletterSecondaryOptins.propTypes = {
    checked: PropTypes.object,
    dangerousLegend: PropTypes.string.isRequired,
    formName: PropTypes.string.isRequired,
    isDefaultChecked: PropTypes.bool,
    isPending: PropTypes.bool,
    onChangeHandler: PropTypes.func,
    optins: PropTypes.arrayOf(PropTypes.shape({
        dangerousDek: PropTypes.string,
        name: PropTypes.string,
        newsletterId: PropTypes.number
    })).isRequired
};
module.exports = NewsletterSecondaryOptins;
//# sourceMappingURL=NewsletterSecondaryOptins.js.map

/***/ }),

/***/ 14340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(49512);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NLSecondaryOptionCheckBox = void 0;
const { default: styled } = __webpack_require__(92168);
const utiltySelectionControlSize = '20px';
exports.NLSecondaryOptionCheckBox = styled.div.withConfig({
    displayName: 'NLSecondaryOptionCheckBox'
}) `
  display: ${(props) => (props.isVisible ? 'inline-grid' : 'none')};

  input[type='checkbox'] {
    width: ${utiltySelectionControlSize};
    height: ${utiltySelectionControlSize};
  }
`;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 75719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const { useInView } = __webpack_require__(26855);
const { TrackComponentChannel } = __webpack_require__(78788);
const translations = (__webpack_require__(74398)/* ["default"] */ .A);
const FormWithValidation = __webpack_require__(72983);
const ReCaptcha = __webpack_require__(59376);
const TextField = __webpack_require__(89662);
const Grid = __webpack_require__(86659);
const { googleAnalytics } = __webpack_require__(90090);
const NewsletterSecondaryOptins = __webpack_require__(14340);
const PersistentTop = __webpack_require__(26392);
const PersistentBottom = __webpack_require__(23074);
const CloseIcon = __webpack_require__(80046);
const { NSWrapper, NSHeading, NSDek, NSPrivacy, NSRightContainer, DismissButton } = __webpack_require__(92628);
const { useState } = React;
const NoPersistWrapper = ({ children }) => children;
NoPersistWrapper.displayName = 'NoPersistWrapper';
const getPersistWrapper = (persist) => {
    if (persist) {
        if (persist === 'top') {
            return PersistentTop;
        }
        if (persist === 'bottom') {
            return PersistentBottom;
        }
    }
    return NoPersistWrapper;
};
/**
 * NewsletterSlice component
 *
 * @param {object} props - React props
 * @param {string} props.buttonLabel - Label for button
 * @param {ReactElement} [props.children] - Optional React children
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object} [props.customInvalidityMessages] - Optional custom invalidity messages, which must be nested under form element names.
 *   Ex: { email: { typeMismatch: 'Please enter a valid email' } }
 *   "Email" corresponds to the HTML element with attribute name=email
 *   For a list of all possible invalid properties, please refer to https://developer.mozilla.org/en-US/docs/Web/API/ValidityState.
 * @param {string} [props.dangerousDek] - Optional dangerously set dek
 * @param {string} [props.dangerousDisclaimer] - Optional dangerously set dangerousDisclaimer
 * @param {string} [props.dangerousHed] - Optional dangerously set hed
 * @param {Array} [props.errors] - Optional array of errors to pass to validation
 * @param {string} props.formName - Name of sign up form
 * @param {boolean} [props.hasBeenDismissed] - Whether or not to show the component
 * @param {boolean} props.hasDangerousDisclaimerCheck - Whether or not to show checkbox next to dangerous disclaimer
 * @param {boolean} props.hasSubscribed - Whether or not the user has subscribed successfully
 * @param {boolean} [props.isDismissable] - Display dismiss icon
 * @param {boolean} [props.isEmailInvalid] - Whether form has email error. Should be used in conjunction with `errorText`.
 * @param {boolean} [props.isSubmitDisabled] - Whether form submission should be disabled
 * @param {string | number} [props.newsletterId] - numerical ID used in newsletter config
 * @param {Function} [props.onFocusHandler] - handler for form focus event
 * @param {Function} [props.onSubmitHandler] - Optional submit event handler
 * @param {Function} [props.onDismissed] - Optional dismissed handler
 * @param {string} [props.position] - Optional string identifying where on the page is the NL been rendered, should be uniq on the same page
 * @param {string} [props.placeholder] - Optional placeholder string
 * @param {Function} [props.recaptchaCallback] - Optional recaptcha callback to pass the response from recaptcha service
 * @param {string} [props.recaptchaSiteKey] - brand siteKey for recaptcha
 * @param {Function} [props.setBeaconPostSubmitRenderMarks] - Optional function to set performance marks for time to re-render post-update
 * @param {string} [props.textFieldAssistiveSubtext] - Optional assistive subtext for text field
 * @param {string} props.textFieldLabel - Label for input
 * @param {string} props.textFieldName - Input name
 * @param {string} [props.variations] - Optional variation properties used in rendering the component
 * @param {string} [props.variations.persist] - Persist component top / bottom
 * @param {string} [props.variations.borderTop] - Display top border
 * @param {string} [props.variations.borderBottom] - Display bottom border
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
function NewsletterSlice({ buttonLabel, children, className, customInvalidityMessages, dangerousDek, dangerousDisclaimer, dangerousHed, errors, formName, hasDangerousDisclaimerCheck, hasBeenDismissed = false, hasSubscribed, isDismissable, isEmailInvalid, isSubmitDisabled, newsletterId, onFocusHandler, onSubmitHandler, onDismissed, placeholder, position, recaptchaCallback, recaptchaSiteKey, setBeaconPostSubmitRenderMarks, textFieldAssistiveSubtext, textFieldLabel, textFieldName, variations = {
    persist: false,
    borderBottom: true,
    borderTop: true
}, variationName }) {
    const { borderTop, borderBottom, persist } = variations;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterSlice',
            variation: variationName
        });
    }, [variationName]);
    const intl = useIntl();
    const [isDismissed, setIsDismissed] = useState(hasBeenDismissed);
    const PersistentWrapper = getPersistWrapper(persist);
    if (hasSubscribed && setBeaconPostSubmitRenderMarks) {
        setBeaconPostSubmitRenderMarks();
    }
    // see https://github.com/thebuilder/react-intersection-observer#options
    const [ref, isInView] = useInView({
        threshold: 0.5,
        trackVisibility: true,
        delay: 100,
        triggerOnce: true,
        skip: isDismissed
    });
    if (isInView) {
        googleAnalytics.emitUniqueGoogleTrackingEvent('newsletter-in-view', {
            newsletter: {
                newsletterId: newsletterId || 0,
                newsletterPosition: position || ''
            }
        });
    }
    const onDismiss = () => {
        onDismissed();
        setIsDismissed(true);
    };
    return ((!isDismissed && (React.createElement(PersistentWrapper, null,
        React.createElement(NSWrapper, { ref: ref, className: classnames('newsletter-slice', className), hasBorderBottom: borderBottom, hasBorderTop: borderTop },
            React.createElement(Grid.TwoUp, null,
                React.createElement("div", null,
                    dangerousHed && (React.createElement(NSHeading, { dangerouslySetInnerHTML: { __html: dangerousHed } })),
                    dangerousDek && (React.createElement(NSDek, { dangerouslySetInnerHTML: { __html: dangerousDek } }))),
                React.createElement(NSRightContainer, { isDismissable: isDismissable },
                    React.createElement(FormWithValidation, { shouldHideValidationErrorText: true, customInvalidityMessages: customInvalidityMessages, errors: errors, name: formName, onFocusHandler: onFocusHandler, onSubmitHandler: onSubmitHandler },
                        children,
                        React.createElement(TextField.SingleLine, { ariaDescribedBy: "privacy-text", assistiveSubtext: textFieldAssistiveSubtext, buttonInputKind: "submit", buttonVariation: "Primary", buttonLabel: buttonLabel, formName: formName, isNeverStacked: true, hasAttachedButton: true, hideLabel: true, isDisabled: isSubmitDisabled, isInvalid: isEmailInvalid, isRequired: true, label: textFieldLabel, name: textFieldName, placeholder: placeholder, type: "email" }),
                        dangerousDisclaimer && !hasDangerousDisclaimerCheck && (React.createElement(NSPrivacy, { id: "privacy-text", tabIndex: "-1" },
                            React.createElement("span", { dangerouslySetInnerHTML: { __html: dangerousDisclaimer } }))),
                        dangerousDisclaimer && hasDangerousDisclaimerCheck && (React.createElement(NewsletterSecondaryOptins, { optins: [
                                {
                                    id: `privacy-text${position ? `-${position}` : ''}`,
                                    name: `nl-disclaimer-consent${position ? `-${position}` : ''}`,
                                    dangerousDek: dangerousDisclaimer,
                                    value: 'acceptDisclaimer',
                                    isRequired: true
                                }
                            ], formName: formName, dangerousLegend: intl.formatMessage(translations.newsletterSecondaryOptinsLegend) })),
                        recaptchaSiteKey && (React.createElement(ReCaptcha, { recaptchaCallback: recaptchaCallback, recaptchaSiteKey: recaptchaSiteKey, widgetId: "recaptcha-id-newsletter-slice" }))),
                    isDismissable && (React.createElement(DismissButton, { isIconButton: true, ariaLabel: intl.formatMessage(translations.dismissButton), onClickHandler: onDismiss, ButtonIcon: CloseIcon })))))))) ||
        null);
}
NewsletterSlice.propTypes = {
    buttonLabel: PropTypes.string.isRequired,
    children: PropTypes.node,
    className: PropTypes.string,
    customInvalidityMessages: PropTypes.object,
    dangerousDek: PropTypes.string,
    dangerousDisclaimer: PropTypes.string,
    dangerousHed: PropTypes.string,
    errors: PropTypes.array,
    formName: PropTypes.string.isRequired,
    hasBeenDismissed: PropTypes.bool,
    hasDangerousDisclaimerCheck: PropTypes.bool,
    hasSubscribed: PropTypes.bool,
    isDismissable: PropTypes.bool,
    isEmailInvalid: PropTypes.bool,
    isSubmitDisabled: PropTypes.bool,
    newsletterId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    onDismissed: PropTypes.func,
    onFocusHandler: PropTypes.func,
    onSubmitHandler: PropTypes.func,
    placeholder: PropTypes.string,
    position: PropTypes.string,
    recaptchaCallback: PropTypes.func,
    recaptchaSiteKey: PropTypes.string,
    setBeaconPostSubmitRenderMarks: PropTypes.func,
    textFieldAssistiveSubtext: PropTypes.string,
    textFieldLabel: PropTypes.string.isRequired,
    textFieldName: PropTypes.string.isRequired,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        persist: PropTypes.oneOf(['top', 'bottom', false]),
        borderBottom: PropTypes.bool,
        borderTop: PropTypes.bool
    })
};
NewsletterSlice.displayName = 'NewsletterSlice';
module.exports = NewsletterSlice;
//# sourceMappingURL=NewsletterSlice.js.map

/***/ }),

/***/ 93744:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(__webpack_require__(91924), 'NewsletterSlice');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 92628:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DismissButton = exports.NSRightContainer = exports.NSPrivacy = exports.NSDek = exports.NSHeading = exports.NSWrapper = void 0;
const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const { INTERACTIVE: { timingButtonDefault }, BREAKPOINTS } = __webpack_require__(96472);
const { cssVariablesGrid } = __webpack_require__(1123);
const Button = __webpack_require__(73730);
const { ButtonLabel } = __webpack_require__(18974);
exports.NSWrapper = styled.div.withConfig({ displayName: 'NSWrapper' }) `
  position: relative;
  border: 0 solid
    ${({ theme }) => getColorToken(theme, 'colors.discovery.lead.primary.divider')};
  border-top-width: ${({ hasBorderTop }) => (hasBorderTop ? `1px` : `0`)};
  border-bottom-width: ${({ hasBorderBottom }) => hasBorderBottom ? `1px` : `0`};
  background-color: ${({ theme }) => getColorToken(theme, 'colors.discovery.lead.primary.background')};
  padding: ${calculateSpacing(2)} 0;

  input {
    margin-top: 0;
  }
`;
exports.NSHeading = styled(BaseText).withConfig({
    displayName: 'NSHeading'
}) ``;
exports.NSHeading.defaultProps = {
    as: 'h2',
    bottomSpacing: 1,
    colorToken: 'colors.discovery.lead.primary.hed',
    typeIdentity: 'typography.definitions.consumptionEditorial.subhed-break-secondary'
};
exports.NSDek = styled(BaseText).withConfig({ displayName: 'NSDek' }) ``;
exports.NSDek.defaultProps = {
    as: 'p',
    colorToken: 'colors.discovery.lead.primary.description',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
exports.NSPrivacy = styled(BaseText).withConfig({
    displayName: 'NSPrivacy'
}) ``;
exports.NSPrivacy.defaultProps = {
    as: 'p',
    colorToken: 'colors.interactive.base.dark',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
exports.NSRightContainer = styled.div.withConfig({
    displayName: 'NSRightContainer'
}) `
  ${ButtonLabel} {
    white-space: nowrap;
  }

  ${({ isDismissable }) => isDismissable &&
    `
    @media (min-width: ${BREAKPOINTS.md}) {
     padding-right: ${calculateSpacing(7)};
   }
  `}
`;
exports.DismissButton = styled(Button.Utility).withConfig({
    // this helps to avoid styled-cc componentId collision
    displayName: 'DismissButton'
}) `
  ${cssVariablesGrid()}

  position: absolute;
  top: ${calculateSpacing(1)};
  right: var(--grid-margin);
  transform: scale(0.5);
  transition: opacity ${timingButtonDefault} ease-in;
  margin-right: ${calculateSpacing(-1)};
  padding: 0;

  &,
  &:focus,
  &:hover {
    border: 0;
    background-color: transparent;
  }

  &:focus,
  &:hover {
    opacity: 0.5;
  }
`;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 74398:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    dismissButton: {
        id: 'NewsletterSlice.DismissButton',
        defaultMessage: 'Dismiss Newsletter Slice',
        description: 'ARIA label for the dismiss button'
    },
    newsletterSecondaryOptinsLegend: {
        id: 'NewsletterSlice.NewsletterSecondaryOptinsLegend',
        defaultMessage: 'Consent checks',
        description: 'Legend for different opt ins for newsletters'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 91924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const NewsletterSlice = __webpack_require__(75719);
NewsletterSlice.PersistTop = asVariation(NewsletterSlice, 'NewsletterSliceTop', {
    persist: 'top',
    borderTop: false,
    borderBottom: true
});
NewsletterSlice.PersistBottom = asVariation(NewsletterSlice, 'NewsletterSliceBottom', {
    persist: 'bottom',
    borderTop: true,
    borderBottom: false
});
module.exports = NewsletterSlice;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 26569:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useEffect, useState } = React;
const Check = __webpack_require__(76196);
const ToggleSwitch = __webpack_require__(85253);
const { TrackComponentChannel } = __webpack_require__(78788);
const { NewsletterSlimLoggedInWrapper, NewsletterSlimLoggedInContentWrapper, NewsletterSlimLoggedInTextWrapper, NewsletterSlimLoggedInHed, NewsletterSlimLoggedInDek, NewsletterSlimLoggedInDisclaimer, NewsletterSlimLoggedInToggleWrapper } = __webpack_require__(75116);
/**
 * NewsletterSlimLoggedIn component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dangerousDek] - Optional dangerously set dek
 * @param {string} [props.dangerousDisclaimer] - Optional dangerously set dangerousDisclaimer
 * @param {string} [props.dangerousHed] - Optional dangerously set hed
 * @param {string} [props.dangerousSuccessDisclaimer] - Optional dangerously set disclaimer for the success state
 * @param {string} [props.dangerousSuccessHed] - Optional dangerously set hed for the success state
 * @param {boolean} props.hasSubscribed - Whether or not the user has subscribed successfully
 * @param {Function} [props.onToggleChecked] - Optional toggle onChecked event handler
 * @param {string} props.patternType - Optional string used to render different types of style pattern. Defaults to `consumption`
 *
 * @returns {ReactElement} <div>
 */
const NewsletterSlimLoggedIn = ({ className, dangerousDek, dangerousDisclaimer, dangerousHed, dangerousSuccessDisclaimer, dangerousSuccessHed, hasSubscribed = false, onToggleChecked, patternType = 'consumption' }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterSlimLoggedIn'
        });
    }, []);
    const [isToggleChecked, setToggleChecked] = useState(false);
    const [isUserSubscribed, setUserSubscribed] = useState(false);
    const [isTextTransition, setTextTransition] = useState(false);
    const onToggleChange = (event) => {
        if (event?.detail?.checked) {
            setToggleChecked(true);
        }
    };
    useEffect(() => {
        if (hasSubscribed) {
            if (!isToggleChecked) {
                setToggleChecked(true);
            }
            setUserSubscribed(hasSubscribed);
            setTimeout(() => {
                setTextTransition(true);
            }, 300);
        }
    }, [hasSubscribed, isToggleChecked, setToggleChecked]);
    useEffect(() => {
        if (isToggleChecked && !hasSubscribed) {
            onToggleChecked(new CustomEvent('change'));
        }
    }, [isToggleChecked, hasSubscribed, onToggleChecked]);
    return (React.createElement(NewsletterSlimLoggedInWrapper, { "data-testid": "NewsletterSlimLoggedInWrapper", className: className },
        React.createElement(NewsletterSlimLoggedInContentWrapper, null,
            React.createElement(NewsletterSlimLoggedInTextWrapper, null,
                dangerousHed && (React.createElement(NewsletterSlimLoggedInHed, { className: classnames({
                        'fade-in': isTextTransition
                    }), htmlFor: "switch-desc", dangerouslySetInnerHTML: {
                        __html: isTextTransition && dangerousSuccessHed
                            ? dangerousSuccessHed
                            : dangerousHed
                    }, patternType: patternType })),
                dangerousDek && (React.createElement(NewsletterSlimLoggedInDek, { dangerouslySetInnerHTML: { __html: dangerousDek }, patternType: patternType, hidden: isTextTransition }))),
            React.createElement(NewsletterSlimLoggedInToggleWrapper, null,
                React.createElement(ToggleSwitch, { id: "switch-desc", isChecked: isToggleChecked, isDisabled: isUserSubscribed, isSuccess: isUserSubscribed, onChange: onToggleChange, isControlled: true, describedBy: "privacy-text" },
                    React.createElement(Check, null)))),
        dangerousDisclaimer && (React.createElement(NewsletterSlimLoggedInDisclaimer, { id: "privacy-text" },
            React.createElement("span", { className: classnames({
                    'fade-in': isTextTransition
                }), dangerouslySetInnerHTML: {
                    __html: isTextTransition && dangerousSuccessDisclaimer
                        ? dangerousSuccessDisclaimer
                        : dangerousDisclaimer
                } })))));
};
NewsletterSlimLoggedIn.propTypes = {
    className: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousDisclaimer: PropTypes.string,
    dangerousHed: PropTypes.string,
    dangerousSuccessDisclaimer: PropTypes.string,
    dangerousSuccessHed: PropTypes.string,
    hasSubscribed: PropTypes.bool,
    onToggleChecked: PropTypes.func,
    patternType: PropTypes.oneOf(['consumption', 'utility'])
};
NewsletterSlimLoggedIn.displayName = 'NewsletterSlimLoggedIn';
module.exports = NewsletterSlimLoggedIn;
//# sourceMappingURL=NewsletterSlimLoggedIn.js.map

/***/ }),

/***/ 81704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(__webpack_require__(26569), 'NewsletterSlimLoggedIn');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 75116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getTypographyStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const NewsletterSlimLoggedInTextWrapper = styled.div.withConfig({
    displayName: 'NewsletterSlimLoggedInTextWrapper'
}) `
  width: 100%;

  .fade-in {
    animation-name: fadeInOpacity;
    animation-duration: 0.2s;
    animation-timing-function: ease-in-out;
    animation-iteration-count: 1;
    opacity: 1;
  }

  @keyframes fadeInOpacity {
    0% {
      opacity: 0.4;
    }

    100% {
      opacity: 1;
    }
  }
`;
const NewsletterSlimLoggedInHed = styled.label.withConfig({
    displayName: 'NewsletterSlimLoggedInHed'
}) `
  transition: all 0.2s ease-in-out;

  ${({ patternType }) => getTypographyStyles(patternType === 'utility'
    ? 'typography.definitions.utility.input-core'
    : 'typography.definitions.utility.card-heading')};

  margin-bottom: ${calculateSpacing(0.5)};
`;
NewsletterSlimLoggedInHed.defaultProps = {
    colorToken: 'colors.interactive.base.black'
};
const NewsletterSlimLoggedInDek = styled(BaseText).withConfig({
    displayName: 'NewsletterSlimLoggedInDek'
}) `
  transition: all 0.2s ease-in-out;
  ${({ patternType }) => getTypographyStyles(patternType === 'utility'
    ? 'typography.definitions.utility.input-core'
    : 'typography.definitions.utility.body')};
`;
NewsletterSlimLoggedInDek.defaultProps = {
    colorToken: 'colors.interactive.base.dark'
};
const NewsletterSlimLoggedInDisclaimer = styled(BaseText).withConfig({
    displayName: 'NewsletterSlimLoggedInDisclaimer'
}) `
  transition: all 0.2s ease-in-out;
  border-top: 1px solid ${getColorToken('colors.interactive.base.light')};
  padding-top: ${calculateSpacing(1)};

  span p a,
  a {
    && {
      color: ${getColorToken('colors.interactive.base.dark')};
    }
  }
`;
NewsletterSlimLoggedInDisclaimer.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.dark',
    typeIdentity: 'typography.definitions.utility.label'
};
const NewsletterSlimLoggedInContentWrapper = styled.div.withConfig({
    displayName: 'NewsletterSlimLoggedInContentWrapper'
}) `
  display: flex;
  justify-content: space-between;
  padding: ${calculateSpacing(1)} 0;
  min-height: 86px;
`;
const NewsletterSlimLoggedInWrapper = styled.div.withConfig({
    displayName: 'NewsletterSlimLoggedInWrapper'
}) `
  margin: ${calculateSpacing(7)} 0;
  border-top: 1px solid black;
  padding: 0;
`;
const NewsletterSlimLoggedInToggleWrapper = styled.div.withConfig({
    displayName: 'NewsletterSlimLoggedInToggleWrapper'
}) `
  display: flex;
  align-items: stretch;
  justify-content: flex-end;
  width: 51px;
`;
module.exports = {
    NewsletterSlimLoggedInWrapper,
    NewsletterSlimLoggedInContentWrapper,
    NewsletterSlimLoggedInTextWrapper,
    NewsletterSlimLoggedInHed,
    NewsletterSlimLoggedInDek,
    NewsletterSlimLoggedInDisclaimer,
    NewsletterSlimLoggedInToggleWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 69872:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const ReCaptcha = __webpack_require__(59376);
const TextField = __webpack_require__(89662);
const { googleAnalytics } = __webpack_require__(90090);
const { useViewportObserver } = __webpack_require__(55030);
const NewsletterSecondaryOptins = __webpack_require__(14340);
const FormErrorContext = __webpack_require__(45548);
const Icons = __webpack_require__(97504);
const Button = __webpack_require__(88456);
const Expand = __webpack_require__(84050);
const Check = __webpack_require__(76196);
const { createValidationErrorMessage } = __webpack_require__(88511);
const { WindowEventChannel } = __webpack_require__(51735);
const { TrackComponentChannel } = __webpack_require__(78788);
const { NewsletterSubscribeFormDangerousHed, NewsletterSubscribeFormDek, NewsletterSubscribeFormDisclaimer, NewsletterSubscribeFormValidation, NewsletterSubscribeFormHighImpactContent, NewsletterSubscribeFormHedDekWrapper, NewsletterSubscribeFormInputsWrapper, NewsletterSubscribeFormWrapper, NewsletterSubscribeFormButton } = __webpack_require__(69817);
const translations = (__webpack_require__(17204)/* ["default"] */ .A);
/**
 * NewsletterSubscribeForm component
 *
 * @param {object} props - React props
 * @param {string} props.buttonLabel - Label for button
 * @param {ReactElement} [props.children] - Optional React children
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object} [props.customInvalidityMessages] - Optional custom invalidity messages, which must be nested under form element names.
 *   Ex: { email: { typeMismatch: 'Please enter a valid email' } }
 *   "Email" corresponds to the HTML element with attribute name=email
 *   For a list of all possible invalid properties, please refer to https://developer.mozilla.org/en-US/docs/Web/API/ValidityState.
 * @param {string} [props.dangerousDek] - Optional dangerously set dek
 * @param {string} [props.dangerousDisclaimer] - Optional dangerously set dangerousDisclaimer
 * @param {string} [props.dangerousHed] - Optional dangerously set hed
 * @param {string} [props.dangerousMobileDek] - Optional dangerously set dek for mobile devices
 * @param {string} [props.errorPosition] - Optional flag to determine position of errorMessage
 * @param {Array} [props.errors] - Optional array of errors to pass to validation
 * @param {string} props.formName - Name of sign up form
 * @param {boolean} props.hasAlternateNewsletterStyle - optional have new styling or not
 * @param {boolean} [props.hasAttachedButtonForMobile] - Whether input has a visually attached button for mobile view
 * @param {boolean} [props.hasAttachedButtonForMobile] - Whether input has a visually attached button for mobile view
 * @param {boolean} [props.hasAutoFocus] - Whether email input field should be focused
 * @param {boolean} props.hasBackgroundColor - Whether or not to display background color
 * @param {boolean} props.hasBackgroundColorForSubscribePage - Whether or not to display background color for subscribe page
 * @param {boolean} props.hasCustomBorderTop - Whether or not to show custom border top color
 * @param {boolean} props.hasDangerousDisclaimerCheck - Whether or not to show checkbox next to dangerous disclaimer
 * @param {boolean} [props.hasHighSidePadding] - Optional flag to add side padding in content
 * @param {boolean} [props.hasIcon] - Optional flag enable or disable icon in high impact variation
 * @param {boolean} [props.hasNoBottomPadding] - Optional flag to remove bottom padding in heading
 * @param {boolean} [props.hasSlimAlternateStyle] - Optional flag for alternative styling for slim newsletter
 * @param {boolean} props.hasSubscribed - Whether or not the user has subscribed successfully
 * @param {boolean} [props.hasTopSpacer] - Optional flag to add margin above the newsletter card
 * @param {boolean} [props.hasBottomSpacer] - Optional flag to add margin above the newsletter card
 * @param {boolean} props.hideNewsletter - Optional flag to hide or show newsletter
 * @param {string} [props.iconName] - Optional name of the icon, to be added above the newsletter hed
 * @param {boolean} [props.isEmailInvalid] - Whether form has email error. Should be used in conjunction with `errorText`.
 * @param {boolean} [props.isSubmitDisabled] - Whether form submission should be disabled
 * @param {boolean} [props.isSignedUpUser] - Whether the user has already entered it's email
 * @param {boolean} [props.isTextFieldAlwaysStacked] - Whether text field is always stacked at all breakpoints
 * @param {string | number} [props.newsletterId] - numerical ID used in newsletter config
 * @param {Function} [props.onFocusHandler] - handler for form focus event
 * @param {Function} [props.onSubmitHandler] - Optional submit event handler
 * @param {string} props.patternType - Optional string used to render different types of style pattern. Defaults to `consumption`
 * @param {string} [props.placeholder] - Optional placeholder string
 * @param {Function} [props.recaptchaCallback] - Optional recaptcha callback to pass the response from recaptcha service
 * @param {string} [props.recaptchaSiteKey] - brand siteKey for recaptcha
 * @param {Function} [props.setBeaconPostSubmitRenderMarks] - Optional function to set performance marks for time to re-render post-update
 * @param {string} [props.sourceCode] - Passes the source detail
 * @param {string} [props.shouldApplySpacingForStackedTextField] - optional prop for applying space to the stacked text field
 * @param {string} [props.shouldApplyDarkBackgroundForTextField] - optional prop for applying dark background to the stacked text field
 * @param {string} [props.textAlign] - [`center`, `left`] Optional. Sets the text alignment of textual content block. Defaults to `center`
 * @param {string} [props.textFieldAssistiveSubtext] - Optional assistive subtext for text field
 * @param {string} props.textFieldLabel - Label for input
 * @param {string} props.textFieldName - Input name
 * @param {string} props.bgImageOneForHighImpactVariation - Background image one for high impact newsletter
 * @param {string} props.bgImageTwoForHighImpactVariation - Background image two for high impact newsletter
 * @param {object} [props.variations] - Optional variation properties used in rendering the component
 * @param {string} [props.variations.isAggressive] - Optional variation that determines whether the newsletter is aggressive
 * @param {boolean} [props.variations.isSlim] - Optional variation that determines whether the newsletter is slim
 * @param {boolean} [props.variations.isHighImpact] - Optional variation that determines whether the newsletter is high-impact
 * @param {boolean} [props.variations.newsletterPalette] - Optional variation properties used in rendering the component
 * @param {string} props.siteCode - siteCode for specific variations
 * @param {string} props.textColor - optional color for the text (eg. - hed, dek, etc)
 * @param {string} props.disclaimerColor - optional color for the disclaimer text
 * @param {any} props.marketingPermissions - if marketing permissions component present the render it
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.hasJourneyUniqueButtonName] - this checks whether we have a unique selector to the button
 *
 * @returns {ReactElement} <div>
 */
function NewsletterSubscribeForm({ buttonLabel, children, className, customInvalidityMessages, dangerousDek, dangerousDisclaimer, dangerousHed, dangerousMobileDek, errorPosition = 'belowButton', errors, formName, hasAutoFocus = false, hasAttachedButtonForMobile = false, hasBackgroundColor = false, hasBackgroundColorForSubscribePage = false, hasDangerousDisclaimerCheck, hasAlternateNewsletterStyle = false, hasHighSidePadding = false, hasIcon = true, hasNoBottomPadding = false, hasSlimAlternateStyle = false, hasSubscribed, hasTopSpacer = false, hasCustomBorderTop = false, hasBottomSpacer = false, hideNewsletter = false, iconName, isEmailInvalid, isSubmitDisabled, isSignedUpUser, isTextFieldAlwaysStacked, shouldApplySpacingForStackedTextField = false, shouldApplyDarkBackgroundForTextField = false, newsletterId, onFocusHandler, onSubmitHandler, placeholder, recaptchaCallback, recaptchaSiteKey, setBeaconPostSubmitRenderMarks, sourceCode, textAlign = 'center', textFieldAssistiveSubtext, textFieldLabel, textFieldName, textColor = 'light', disclaimerColor = 'dark', patternType = 'consumption', bgImageOneForHighImpactVariation, bgImageTwoForHighImpactVariation, variations = {
    newsletterPalette: 'standard',
    isAggressive: false,
    isSlim: false,
    isHighImpact: false
}, variationName, marketingPermissions, siteCode, hasJourneyUniqueButtonName = false }) {
    const { formatMessage } = useIntl();
    const { newsletterPalette, isAggressive, isSlim, isHighImpact } = variations;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterSubscribeForm',
            variation: variationName
        });
    }, [variationName]);
    const [isInvalidForm, setIsInvalidForm] = React.useState(false);
    const [isMobile, setIsMobile] = React.useState(false);
    const handleResize = React.useCallback(() => {
        if (window.innerWidth < 1025) {
            setIsMobile(true);
        }
        else {
            setIsMobile(false);
        }
    }, []);
    React.useEffect(() => {
        const resizeSubscription = window.Kendra.WINDOW_EVENT.on(WindowEventChannel.RESIZE_DEBOUNCE, handleResize);
        return () => {
            resizeSubscription && resizeSubscription.off();
        };
    }, [handleResize]);
    const HighImpactIcon = Icons[iconName] || Icons.NewsletterArrow;
    const isTextFieldAlwaysStackedWithErrorMsg = errorPosition === 'belowTextField' ? true : isTextFieldAlwaysStacked;
    const isInvalidFormHandler = (_errors) => {
        if (_errors && _errors.length > 0) {
            return setIsInvalidForm(true);
        }
        return setIsInvalidForm(false);
    };
    if (hasSubscribed && setBeaconPostSubmitRenderMarks) {
        setBeaconPostSubmitRenderMarks();
    }
    useViewportObserver('.newsletter-subscribe-form', undefined, (isInViewport) => {
        if (isInViewport) {
            const newsletterStats = { newsletterId: newsletterId || 0 };
            if (!isSlim)
                newsletterStats.componentPosition = 'bottom';
            const newsletterEventName = isSlim
                ? 'newsletter-in-view-inlineslim'
                : 'newsletter-in-view';
            googleAnalytics.emitUniqueGoogleTrackingEvent(newsletterEventName, {
                newsletterStats
            });
        }
    });
    const onSignedUpUserSubscribed = () => {
        if (!hasSubscribed) {
            onSubmitHandler();
        }
    };
    if (isSignedUpUser) {
        return (React.createElement(NewsletterSubscribeFormButton, { as: Button.Primary, hasSubscribed: hasSubscribed, hasEnableIcon: true, iconPosition: "before", label: !hasSubscribed
                ? formatMessage(translations.signUp)
                : formatMessage(translations.signUpMessage), btnStyle: !hasSubscribed ? 'filled' : 'outlined', onClickHandler: onSignedUpUserSubscribed, ButtonIcon: !hasSubscribed ? Expand : Check }));
    }
    const NewsletterSubscribeFormComp = () => (React.createElement(NewsletterSubscribeFormWrapper, { "data-testid": "NewsletterSubscribeFormWrapper", className: classnames('newsletter-subscribe-form', className), hasBackgroundColor: hasBackgroundColor, hasBackgroundColorForSubscribePage: hasBackgroundColorForSubscribePage, hasSlimAlternateStyle: hasSlimAlternateStyle, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle, sourceCode: sourceCode, hasTopSpacer: hasTopSpacer, hasBottomSpacer: hasBottomSpacer, isAggressive: isAggressive, isAlwaysStacked: isTextFieldAlwaysStacked, isSlim: isSlim, hideNewsletter: hideNewsletter, isHighImpact: isHighImpact, patternType: patternType, isEmailInvalid: isEmailInvalid, isInvalidForm: isInvalidForm, newsletterPalette: newsletterPalette, hasHighSidePadding: hasHighSidePadding, shouldApplySpacingForStackedTextField: shouldApplySpacingForStackedTextField, shouldApplyDarkBackgroundForTextField: shouldApplyDarkBackgroundForTextField, hasCustomBorderTop: hasCustomBorderTop },
        React.createElement(NewsletterSubscribeFormHedDekWrapper, { "data-testid": "NewsletterSubscribeFormHedDekWrapper", isHighImpact: isHighImpact },
            isHighImpact && hasIcon && React.createElement(HighImpactIcon, null),
            dangerousHed && (React.createElement(NewsletterSubscribeFormDangerousHed, { className: classnames({ 'newsletter-subscribe-form__hed': !hasSubscribed }, className), hasSubscribed: hasSubscribed, hasNoBottomPadding: hasNoBottomPadding, textAlign: textAlign, dangerouslySetInnerHTML: { __html: dangerousHed }, newsletterPalette: newsletterPalette, textColor: textColor })),
            dangerousDek && (React.createElement(NewsletterSubscribeFormDek, { className: "newsletter-subscribe-form__dek", dangerouslySetInnerHTML: {
                    __html: isMobile && dangerousMobileDek
                        ? dangerousMobileDek
                        : dangerousDek
                }, textColor: textColor }))),
        React.createElement(NewsletterSubscribeFormInputsWrapper, { "data-testid": "NewsletterSubscribeFormInputsWrapper", isHighImpact: isHighImpact }, !hasSubscribed && (React.createElement(NewsletterSubscribeFormValidation, { customInvalidityMessages: customInvalidityMessages, errors: errors, name: formName, onFocusHandler: onFocusHandler, onSubmitHandler: onSubmitHandler, validationClassName: "newsletter-subscribe-form__validation-description", onInvalidFormHandler: isInvalidFormHandler, onSubmitAttemptHandler: isInvalidFormHandler, errorPosition: errorPosition },
            children,
            isHighImpact || isSlim || errorPosition === 'belowTextField' ? (React.createElement(FormErrorContext.Consumer, null, (validationErrors) => (React.createElement(TextField.SingleLine, { ariaDescribedBy: "privacy-text", assistiveSubtext: textFieldAssistiveSubtext, buttonInputKind: "submit", buttonInverted: newsletterPalette, buttonLabel: buttonLabel, formName: formName, isAlwaysStacked: isTextFieldAlwaysStackedWithErrorMsg, hasAttachedButton: true, hasAutoFocus: hasAutoFocus, isDisabled: isSubmitDisabled, isInvalid: isEmailInvalid || validationErrors?.length > 0, isRequired: true, label: textFieldLabel, name: textFieldName, placeholder: placeholder, type: "email", errorText: validationErrors && validationErrors.length > 0
                    ? createValidationErrorMessage(validationErrors)
                    : null, marketingPermissions: marketingPermissions, errorPosition: errorPosition, shouldEnableErrorSuggestions: true, buttonClassName: hasJourneyUniqueButtonName ? 'JourneyButtonWrapper' : '' })))) : (React.createElement(TextField.SingleLine, { ariaDescribedBy: "privacy-text", assistiveSubtext: textFieldAssistiveSubtext, buttonInputKind: "submit", buttonInverted: newsletterPalette, buttonLabel: buttonLabel, formName: formName, isAlwaysStacked: isTextFieldAlwaysStacked, hasAutoFocus: hasAutoFocus, hasAttachedButton: true, hasAttachedButtonForMobile: hasAttachedButtonForMobile, isDisabled: isSubmitDisabled, isInvalid: isEmailInvalid, isRequired: true, label: textFieldLabel, name: textFieldName, placeholder: placeholder, type: "email", marketingPermissions: marketingPermissions, buttonClassName: hasJourneyUniqueButtonName ? 'JourneyButtonWrapper' : '' })),
            dangerousDisclaimer && !hasDangerousDisclaimerCheck && (React.createElement(NewsletterSubscribeFormDisclaimer, { id: "privacy-text", tabIndex: "-1", textAlign: textAlign, disclaimerColor: disclaimerColor, siteCode: siteCode, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle },
                React.createElement("span", { dangerouslySetInnerHTML: { __html: dangerousDisclaimer } }))),
            dangerousDisclaimer && hasDangerousDisclaimerCheck && (React.createElement(NewsletterSecondaryOptins, { optins: [
                    {
                        id: 'privacy-text',
                        name: 'Disclaimer consent',
                        dangerousDek: dangerousDisclaimer,
                        value: 'acceptDisclaimer',
                        isRequired: true
                    }
                ], formName: formName, dangerousLegend: "Consent checks" })),
            recaptchaSiteKey && (React.createElement(ReCaptcha, { recaptchaCallback: recaptchaCallback, recaptchaSiteKey: recaptchaSiteKey, widgetId: "recaptcha-id-newsletter-subscribe-form" })))))));
    if (isHighImpact) {
        return (React.createElement(NewsletterSubscribeFormHighImpactContent, { "data-testid": "NewsletterSubscribeFormHighImpactContent", bgImageOneForHighImpactVariation: bgImageOneForHighImpactVariation, bgImageTwoForHighImpactVariation: bgImageTwoForHighImpactVariation, isHighImpact: isHighImpact },
            React.createElement(NewsletterSubscribeFormComp, null)));
    }
    return React.createElement(NewsletterSubscribeFormComp, null);
}
NewsletterSubscribeForm.propTypes = {
    bgImageOneForHighImpactVariation: PropTypes.string,
    bgImageTwoForHighImpactVariation: PropTypes.string,
    buttonLabel: PropTypes.string.isRequired,
    children: PropTypes.node,
    className: PropTypes.string,
    customInvalidityMessages: PropTypes.object,
    dangerousDek: PropTypes.string,
    dangerousDisclaimer: PropTypes.string,
    dangerousHed: PropTypes.string,
    dangerousMobileDek: PropTypes.string,
    disclaimerColor: PropTypes.string,
    errorPosition: PropTypes.oneOf(['belowButton', 'belowTextField']),
    errors: PropTypes.array,
    formName: PropTypes.string.isRequired,
    hasAlternateNewsletterStyle: PropTypes.bool,
    hasAttachedButtonForMobile: PropTypes.bool,
    hasAutoFocus: PropTypes.bool,
    hasBackgroundColor: PropTypes.bool,
    hasBackgroundColorForSubscribePage: PropTypes.bool,
    hasBottomSpacer: PropTypes.bool,
    hasCustomBorderTop: PropTypes.bool,
    hasDangerousDisclaimerCheck: PropTypes.bool,
    hasHighSidePadding: PropTypes.bool,
    hasIcon: PropTypes.bool,
    hasJourneyUniqueButtonName: PropTypes.bool,
    hasNoBottomPadding: PropTypes.bool,
    hasSlimAlternateStyle: PropTypes.bool,
    hasSubscribed: PropTypes.bool,
    hasTopSpacer: PropTypes.bool,
    hideNewsletter: PropTypes.bool,
    iconName: PropTypes.string,
    isEmailInvalid: PropTypes.bool,
    isSignedUpUser: PropTypes.bool,
    isSubmitDisabled: PropTypes.bool,
    isTextFieldAlwaysStacked: PropTypes.bool,
    marketingPermissions: PropTypes.func,
    newsletterId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    onFocusHandler: PropTypes.func,
    onSubmitHandler: PropTypes.func,
    patternType: PropTypes.oneOf(['consumption', 'utility']),
    placeholder: PropTypes.string,
    recaptchaCallback: PropTypes.func,
    recaptchaSiteKey: PropTypes.string,
    setBeaconPostSubmitRenderMarks: PropTypes.func,
    shouldApplyDarkBackgroundForTextField: PropTypes.bool,
    shouldApplySpacingForStackedTextField: PropTypes.bool,
    siteCode: PropTypes.string,
    sourceCode: PropTypes.string,
    textAlign: PropTypes.oneOf(['center', 'left']),
    textColor: PropTypes.string,
    textFieldAssistiveSubtext: PropTypes.string,
    textFieldLabel: PropTypes.string.isRequired,
    textFieldName: PropTypes.string.isRequired,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        newsletterPalette: PropTypes.string,
        isAggressive: PropTypes.bool,
        isSlim: PropTypes.bool,
        isHighImpact: PropTypes.bool
    })
};
NewsletterSubscribeForm.displayName = 'NewsletterSubscribeForm';
module.exports = NewsletterSubscribeForm;
//# sourceMappingURL=NewsletterSubscribeForm.js.map

/***/ }),

/***/ 36791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(__webpack_require__(78409), 'NewsletterSubscribeForm');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 69817:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getDecoration, getTypographyStyles, getLinkStyles, getZIndex, styledProperty } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const FormWithValidation = __webpack_require__(72983);
const { TextFieldButton, TextFieldLabel, TextFieldInputContainer, TextFieldControlInput, TextFieldErrorText, TextFieldLabelText, TextFieldWrapper } = __webpack_require__(60434);
const { UtilityBodyTextContent } = __webpack_require__(40437);
const { UtilityValidationDescriptionError, UtilityValidationDescriptionErrors, UtilityValidationDescriptionHeading, UtilityValidationDescriptionWrapper } = __webpack_require__(69195);
const getDefaultDisclaimerTextColor = css `
  ${({ theme, disclaimerColor }) => disclaimerColor
    ? `color: ${getColorToken(theme, `colors.interactive.base.${disclaimerColor}`)}`
    : `${getColorToken('colors.interactive.base.dark')}`};
`;
const NewsletterSubscribeFormValidation = styled(FormWithValidation).withConfig({ displayName: 'NewsletterSubscribeFormValidation' }) `
  ${({ errorPosition }) => errorPosition === 'belowTextField' &&
    css `
      ${UtilityValidationDescriptionErrors} {
        display: none;
      }
      ${UtilityValidationDescriptionWrapper} {
        margin-bottom: 0;
        padding: 0;
      }
    `}
  ${TextFieldWrapper} {
    margin-bottom: ${calculateSpacing(1)};
  }
  ${TextFieldLabelText} {
    color: ${getColorToken('colors.discovery.body.light.heading')};
  }
`;
const newsletterSubscribeFormHedStyles = css `
  ${getTypographyStyles('typography.definitions.utility.heading')};
  margin: ${calculateSpacing(5)} auto auto auto;
  ${({ hasNoBottomPadding }) => hasNoBottomPadding
    ? `padding-bottom: ${calculateSpacing(0)};`
    : `padding-bottom: ${calculateSpacing(2)};`}
  text-align: center;
  color: ${getColorToken('colors.interactive.base.black')};
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-top: ${calculateSpacing(2)};
  }

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.heading')}
`;
const newsletterSubscribeFormSuccessHedStyles = css `
  ${getTypographyStyles('typography.definitions.utility.heading')};
  margin: ${calculateSpacing(4)} auto ${calculateSpacing(1)} auto;
  text-align: center;
  color: ${getColorToken('colors.interactive.base.black')};
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-top: ${calculateSpacing(5)};
    margin-bottom: ${calculateSpacing(5)};
  }
`;
const NewsletterSubscribeFormDisclaimer = styled.div.withConfig({
    displayName: 'NewsletterSubscribeFormDisclaimer'
}) `
  ${getTypographyStyles('typography.definitions.utility.assistive-text')}
  grid-column-start: 2;
  ${getDefaultDisclaimerTextColor}

  a {
    ${getDefaultDisclaimerTextColor}
  }
  ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
      color: ${getColorToken('colors.interactive.base.dark')};

      a {
        ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')};
      }
    `}
  /* TODO: we can remove this brand specific check once we get solution with BI */
  ${({ hasAlternateNewsletterStyle, siteCode }) => hasAlternateNewsletterStyle &&
    ['PITCHFORK'].includes(siteCode) &&
    css `
      && {
        a {
          color: ${getColorToken('colors.interactive.base.dark')};
        }
      }
    `}
`;
const newsletterFormInverted = css `
  color: ${getColorToken('colors.interactive.base.white')};
`;
const NewsletterSubscribeFormDangerousHed = styled.h3.withConfig({
    displayName: 'NewsletterSubscribeFormDangerousHed'
}) `
  ${({ hasSubscribed }) => hasSubscribed
    ? newsletterSubscribeFormSuccessHedStyles
    : newsletterSubscribeFormHedStyles}

  ${({ textAlign, hasSubscribed }) => textAlign &&
    hasSubscribed === false &&
    css `
      text-align: ${textAlign};
    `}
    ${({ newsletterPalette }) => newsletterPalette === 'inverted' ? newsletterFormInverted : ``};
`;
const newsletterSubscribeFormAggressive = css `
  && {
    margin-top: ${calculateSpacing(2)};
    padding: ${({ hasHighSidePadding }) => hasHighSidePadding
    ? `${calculateSpacing(6)} ${calculateSpacing(30)}`
    : `${calculateSpacing(6)} ${calculateSpacing(4)}`};
    @media (max-width: ${BREAKPOINTS.md}) {
      padding: ${calculateSpacing(6)} ${calculateSpacing(5)};
    }
  }

  ${NewsletterSubscribeFormDangerousHed} {
    ${styledProperty('hasSubscribed', true, getTypographyStyles('typography.definitions.discovery.hed-bulletin-secondary'))}
  }

  ${TextFieldWrapper} {
    ${styledProperty('hasAttachedButton', true, ' margin-bottom: 0')}
  }

  ${TextFieldControlInput} {
    &::placeholder {
      color: ${getColorToken('colors.interactive.base.light')};
    }
  }
`;
const NewsletterSubscribeFormDek = styled.div.withConfig({
    displayName: 'NewsletterSubscribeFormDek'
}) `
  ${getTypographyStyles('typography.definitions.utility.description')};
  margin: ${calculateSpacing(2)} auto ${calculateSpacing(3)} auto;
  text-align: center;
  color: ${getColorToken('colors.interactive.base.black')};

  @media (min-width: ${BREAKPOINTS.md}) {
    margin-top: ${calculateSpacing(3)};
    margin-bottom: ${calculateSpacing(4)};
  }
`;
const newsLetterSubscribeFormTextLabelActive = css `
  ${TextFieldControlInput} {
    border-color: ${getColorToken('colors.discovery.body.light.heading')};
  }
`;
const utilityValidationDescriptionWrapperStyle = `
  margin: 0;
  padding: 0;
  text-align: left;

  ul li {
    margin-left: 0;
  }
  display: none;
`;
const newsletterSubscribeFormSlimStyle = css `
  && {
    ${({ hasCustomBorderTop, theme }) => hasCustomBorderTop
    ? `border-top: 1px solid ${getColorToken(theme, 'colors.consumption.lead.standard.divider')};`
    : `border-top: 1px solid black;`}
    margin: ${calculateSpacing(7)} 0;
    padding: 0;
  }

  ${NewsletterSubscribeFormDangerousHed} {
    ${({ patternType }) => patternType === 'utility'
    ? getTypographyStyles('typography.definitions.utility.input-core')
    : getTypographyStyles('typography.definitions.utility.card-heading')}

    margin: 0;
    margin-top: ${calculateSpacing(1)};
    padding: 0;
    height: fit-content;
    text-align: left;
    color: ${getColorToken('colors.interactive.base.black')};
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      width: fit-content;
      height: fit-content;
    }
  }

  ${NewsletterSubscribeFormDek} {
    ${({ patternType }) => patternType === 'utility'
    ? getTypographyStyles('typography.definitions.utility.input-core')
    : getTypographyStyles('typography.definitions.utility.body')};
    margin: 0;
    margin-top: ${calculateSpacing(0.5)};
    padding: 0;
    height: fit-content;
    text-align: left;
    color: ${getColorToken('colors.interactive.base.dark')};
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      width: fit-content;
      height: fit-content;
    }
  }

  ${NewsletterSubscribeFormDisclaimer} {
    ${getTypographyStyles('typography.definitions.utility.label')};
    margin: 0;
    margin-top: ${calculateSpacing(1)};

    a,
    a:not(.button):link,
    a:not(.button):visited {
      color: ${getColorToken('colors.interactive.base.dark')};
    }
    ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
        ${getTypographyStyles('typography.definitions.utility.assistive-text')}
        color: ${getColorToken('colors.interactive.base.dark')};

        a,
        a:not(.button):link,
        a:not(.button):visited {
          ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')};
          text-decoration: none;
        }
      `}
  }

  ${({ hasSubscribed }) => hasSubscribed
    ? ` border-top: 2px solid black;
    padding-top: ${calculateSpacing(2)};
    text-align: left;
    font-size: 20px;`
    : `margin: 0;
    border-top: 2px solid black;
    padding: ${calculateSpacing(1.25)} 0 ${calculateSpacing(0.75)} 0;
    line-height: 16.8px;
    font-size: 14px;`}

  ${UtilityValidationDescriptionWrapper} {
    ${utilityValidationDescriptionWrapperStyle}
  }

  ${TextFieldWrapper} {
    margin-top: ${calculateSpacing(1)};
    margin-bottom: 0;
    ${styledProperty('isAlwaysStacked', true, `gap: ${calculateSpacing(1)};`)}
  }

  ${TextFieldButton} {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')}

    margin-left: ${calculateSpacing(1.25)};
    border: none;
    background-color: ${getColorToken('colors.interactive.base.black')};
    color: ${getColorToken('colors.interactive.base.white')};
    ${styledProperty('isAlwaysStacked', true, 'margin-left: 0;')}

    &:hover {
      background-color: ${getColorToken('colors.interactive.base.brand-primary')};
    }
    @media only screen and (min-device-width: 0) and (max-device-width: 767px) {
      margin-left: 0;
    }
    @media (min-device-width: ${BREAKPOINTS.md}) {
      min-width: 88px;
    }
  }

  ${TextFieldControlInput} {
    ${getTypographyStyles('typography.definitions.utility.input-core')};

    margin: 0;
    border-color: ${(_p) => _p.isEmailInvalid || _p.isInvalidForm
    ? getColorToken('colors.interactive.feedback.invalid-primary')
    : getColorToken('colors.interactive.base.black')};
    padding: ${calculateSpacing(1)} ${calculateSpacing(18.625)}
      ${calculateSpacing(1)} ${calculateSpacing(1.5)};
    color: ${getColorToken('colors.interactive.base.black')};

    &::placeholder {
      color: ${getColorToken('colors.interactive.base.dark')};
    }

    &:active {
      color: ${getColorToken('colors.interactive.base.black')};
    }
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      display: inline;
      padding: ${calculateSpacing(1)};
    }
  }

  ${TextFieldInputContainer} {
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      display: inline-block;
      width: 100%;
    }
  }

  ${TextFieldLabel} {
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      width: 100%;
    }
  }

  ${TextFieldLabelText} {
    ${getTypographyStyles('typography.definitions.utility.assistive-text')};
    position: relative;
    float: left;
    z-index: ${getZIndex('content')};
    margin-bottom: ${calculateSpacing(-1)};
    margin-left: ${calculateSpacing(1.375)};
    background-color: white;
    padding: 0 ${calculateSpacing(0.375)};
    color: ${getColorToken('colors.interactive.base.black')};
  }

  ${TextFieldErrorText} {
    margin-top: ${calculateSpacing(1)};
  }
`;
const newsletterSubscribeFormSlim = css `
  ${newsletterSubscribeFormSlimStyle}
`;
const newsletterSubscribeFormSlimAlternate = css `
  ${newsletterSubscribeFormSlimStyle}

  ${NewsletterSubscribeFormDangerousHed} {
    margin-top: ${calculateSpacing(2)};
  }

  ${TextFieldLabelText} {
    margin-bottom: ${calculateSpacing(1)};
  }

  ${NewsletterSubscribeFormDisclaimer} {
    ${getTypographyStyles('typography.definitions.utility.assistive-text')}
    border-bottom: 1px solid black;
    padding-bottom: ${calculateSpacing(2)};

    a,
    a:not(.button):link,
    a:not(.button):visited {
      text-decoration: underline;
    }
    ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
        ${getTypographyStyles('typography.definitions.utility.assistive-text')}
        color: ${getColorToken('colors.interactive.base.dark')};

        a,
        a:not(.button):link,
        a:not(.button):visited {
          ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')};
        }
      `}

    @media (max-width: ${BREAKPOINTS.md}) {
      margin-top: ${calculateSpacing(1.5)};
    }
  }

  ${NewsletterSubscribeFormDek} {
    color: ${getColorToken('colors.interactive.base.black')};
  }

  ${TextFieldLabelText} {
    ${getTypographyStyles('typography.definitions.utility.label')}
    z-index: 0;
    margin: 0;
    margin-bottom: ${calculateSpacing(1)};
    padding: 0;
  }
`;
const newsletterSubscribeFormInverted = css `
  ${newsletterSubscribeFormHedStyles} {
    color: ${getColorToken('colors.interactive.base.white')};
  }

  ${NewsletterSubscribeFormDek} {
    ${getTypographyStyles('typography.definitions.foundation.title-primary')};
    color: ${getColorToken('colors.interactive.base.brand-secondary')};
    font-size: 14px;
  }
`;
const newsletterSubscribeFormHighImpact = css `
  && {
    .newsletter-subscribe-form__hed {
      margin-top: ${calculateSpacing(2)};
      line-height: 33px;
      font-size: 36px;
    }

    .newsletter-subscribe-form__dek {
      margin-bottom: 0;
    }

    .text-field--error .text-field__control--input {
      border-color: ${getColorToken('colors.interactive.feedback.invalid-primary')};
    }

    .text-field--activated > .button {
      border: none;
      background: ${getColorToken('colors.interactive.base.black')};
    }

    .text-field--activated > .button:hover {
      border: none;
      background: ${getColorToken('colors.interactive.base.brand-primary')};
    }
    display: grid;
    margin: ${calculateSpacing(2)} 0;
    padding: ${calculateSpacing(1.5)} 0;
  }

  ${NewsletterSubscribeFormDangerousHed} {
    ${getTypographyStyles('typography.definitions.consumptionEditorial.subhed-break-primary')};

    grid-column-end: 4;
    grid-column-start: 1;
    margin: ${calculateSpacing(2)} ${calculateSpacing(0)};
    padding: 0;
    text-align: left;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: ${getColorToken('colors.consumption.body.standard.body')};
    font-weight: 500;

    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      margin: ${calculateSpacing(2)} ${calculateSpacing(0)}
        ${calculateSpacing(0)} ${calculateSpacing(0)};
      padding: 0;
      width: fit-content;
      height: fit-content;
      line-height: 33px;
      letter-spacing: 1.5px;
      font-size: 36px;
      font-weight: 500;
    }
  }

  ${NewsletterSubscribeFormDek} {
    ${getTypographyStyles('typography.definitions.consumptionEditorial.description-embed')};

    grid-column-end: 4;
    grid-column-start: 2;
    margin: 0;
    margin-bottom: ${calculateSpacing(0)};
    padding: 0;
    text-align: left;
    line-height: 21px;
    color: ${getColorToken('colors.consumption.body.standard.body')};
    font-size: 15px;
    font-weight: 400;

    @media (min-width: ${BREAKPOINTS.md}) {
      margin-bottom: 0;
    }
  }

  ${NewsletterSubscribeFormDisclaimer} {
    margin-top: ${calculateSpacing(1)};
    color: ${getColorToken('colors.interactive.base.dark')};

    a,
    a:not(.button):link,
    a:not(.button):visited {
      color: ${getColorToken('colors.interactive.base.dark')};
    }

    ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
        ${getTypographyStyles('typography.definitions.utility.assistive-text')}
        color: ${getColorToken('colors.interactive.base.dark')};

        a,
        a:not(.button):link,
        a:not(.button):visited {
          ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')};
        }
      `}
  }

  ${({ hasSubscribed }) => hasSubscribed
    ? `
    padding-top: ${calculateSpacing(2)};
    text-align: left;
    font-size: 20px;`
    : `margin: 0;
    padding: ${calculateSpacing(1.25)} 0 ${calculateSpacing(0.75)} 0;
    line-height: 16.8px;
    font-size: 14px;`}

  ${UtilityValidationDescriptionWrapper} {
    ${utilityValidationDescriptionWrapperStyle}
  }

  ${UtilityValidationDescriptionError} {
    margin-left: 0;
  }

  ${UtilityValidationDescriptionErrors} {
    margin: 0;
    padding: 0 0 ${calculateSpacing(0.75)} 0;
  }

  ${UtilityValidationDescriptionHeading} {
    margin: 0;
  }

  ${TextFieldWrapper} {
    ${styledProperty('hasAttachedButton', true, `
      @media (max-width: ${BREAKPOINTS.md}) {
        display: grid;
        grid-template-columns: repeat(1, 1fr);
        grid-template-rows: repeat(2, 1fr);
      }`)}
  }

  ${TextFieldButton} {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')}

    ${({ shouldApplySpacingForStackedTextField }) => !shouldApplySpacingForStackedTextField
    ? `margin-left: ${calculateSpacing(1.25)};`
    : `margin-top: ${calculateSpacing(2)};`}
    ${({ shouldApplySpacingForStackedTextField }) => !shouldApplySpacingForStackedTextField
    ? `border-color: ${getColorToken('colors.interactive.base.light')};
          background: ${getColorToken('colors.interactive.base.light')};
          background-color: ${getColorToken('colors.interactive.base.light')};`
    : `border-color: ${getColorToken('colors.interactive.base.black')};
          background: ${getColorToken('colors.interactive.base.black')};
          background-color: ${getColorToken('colors.interactive.base.black')};`}
    
    min-width: 100px;

    &:hover {
      border-color: ${getColorToken('colors.interactive.base.black')};
      background-color: ${getColorToken('colors.interactive.base.black')};
    }

    @media (max-width: ${BREAKPOINTS.md}) {
      grid-row-end: 2;
      grid-row-start: 2;
      margin-left: 0;
    }
  }

  ${TextFieldControlInput} {
    margin: 0;
    padding: ${calculateSpacing(1)} ${calculateSpacing(1)}
      ${calculateSpacing(1)} ${calculateSpacing(1)};
    color: ${getColorToken('colors.interactive.base.black')};

    ${getTypographyStyles('typography.definitions.utility.input-core')};

    &::placeholder {
      color: ${getColorToken('colors.interactive.base.light')};
    }

    &:active {
      color: ${getColorToken('colors.discovery.body.light.heading')};
      border-color: ${getColorToken('colors.interactive.base.black')}
        ${TextFieldButton} {
        background: ${getColorToken('colors.interactive.base.light')};
      }
    }
  }

  ${TextFieldInputContainer} {
    width: 100%;
    @media (max-width: ${BREAKPOINTS.md}) {
      grid-row-end: 2;
      grid-row-start: 2;
    }
  }

  ${TextFieldLabel} {
    margin-top: ${calculateSpacing(1.5)};
  }

  ${TextFieldLabel} {
    ${styledProperty('isActivated', true, newsLetterSubscribeFormTextLabelActive)}
  }

  ${TextFieldErrorText} {
    ${TextFieldControlInput} {
      border-color: #eb0000;
    }
  }

  ${TextFieldLabelText} {
    position: relative;
    float: left;
    z-index: ${getZIndex('content')};
    margin-bottom: ${calculateSpacing(-1)};
    margin-left: ${calculateSpacing(1)};
    background-color: white;
    padding: 0 ${calculateSpacing(1)};
    color: ${getColorToken('colors.interactive.base.light')};
    ${getTypographyStyles('typography.definitions.utility.assistive-text')};
  }
`;
const NewsletterSubscribeFormHighImpactContent = styled.div.withConfig({
    displayName: 'NewsletterSubscribeFormHighImpactContent'
}) `
  display: grid;
  justify-content: center;
  @media (max-width: ${BREAKPOINTS.md}) {
    grid-column: 1/-1;
  }
  @media (min-width: ${BREAKPOINTS.lg}) {
    grid-column: 2 / span 6;
  }

  ${({ isHighImpact }) => isHighImpact === true &&
    css `
      grid-column-end: 12;
      grid-column-start: 1;
      margin: ${calculateSpacing(2)} 0;
      padding: ${calculateSpacing(5)} ${calculateSpacing(3)}
        ${calculateSpacing(6)};
      ${({ bgImageOneForHighImpactVariation, bgImageTwoForHighImpactVariation }) => {
        if (bgImageOneForHighImpactVariation &&
            bgImageTwoForHighImpactVariation) {
            return css `
            background-image: url(${bgImageOneForHighImpactVariation}),
              url(${bgImageTwoForHighImpactVariation});
            background-size: 100% 50%, 100% 50%;
            background-repeat: no-repeat;
            background-position: top, bottom;
          `;
        }
        else if (bgImageOneForHighImpactVariation) {
            return css `
            background-image: url(${bgImageOneForHighImpactVariation});
            background-size: cover;
          `;
        }
        else if (bgImageTwoForHighImpactVariation) {
            return css `
            background-image: url(${bgImageTwoForHighImpactVariation});
            background-size: cover;
          `;
        }
        return '';
    }}
      @media (min-width: ${BREAKPOINTS.md}) {
        align-items: center;
        height: 600px;
        ${({ bgImageOneForHighImpactVariation, bgImageTwoForHighImpactVariation }) => {
        if (bgImageOneForHighImpactVariation &&
            bgImageTwoForHighImpactVariation) {
            return css `
              background-image: url(${bgImageOneForHighImpactVariation}),
                url(${bgImageTwoForHighImpactVariation});
              background-repeat: no-repeat;
              background-position: left, right;
              background-size: 50% 100%, 50% 100%;
            `;
        }
        else if (bgImageOneForHighImpactVariation) {
            return css `
              background-image: url(${bgImageOneForHighImpactVariation});
              background-size: cover;
            `;
        }
        else if (bgImageTwoForHighImpactVariation) {
            return css `
              background-image: url(${bgImageTwoForHighImpactVariation});
              background-size: cover;
            `;
        }
        return '';
    }}
      }
    `}
`;
const NewsletterSubscribeFormHedDekWrapper = styled.div.withConfig({
    displayName: 'NewsletterSubscribeFormHedDekWrapper'
}) `
  ${({ isHighImpact }) => !isHighImpact &&
    css `
      > :first-child {
        margin-top: 0;
      }
    `};
  ${({ isHighImpact }) => isHighImpact === true &&
    css `
      grid-column-end: 4;
      grid-column-end: 12;
      grid-column-start: 1;
      grid-column-start: 1;
      grid-row-end: 1;
      grid-row-start: 1;
      margin: ${calculateSpacing(5)} ${calculateSpacing(3)}
        ${calculateSpacing(3)} ${calculateSpacing(3)};
      padding: 0;
      @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
        grid-column-end: 1;
        grid-column-start: 1;
        grid-row-end: 1;
        grid-row-start: 1;
        margin: ${calculateSpacing(4)} ${calculateSpacing(2)}
          ${calculateSpacing(5)} ${calculateSpacing(4)};
      }
      @media (min-width: 1025px) {
        grid-column-end: 1;
        grid-column-start: 1;
        grid-row-end: 1;
        grid-row-start: 1;
        margin: ${calculateSpacing(7)} ${calculateSpacing(2)}
          ${calculateSpacing(8)} ${calculateSpacing(4)};
      }
    `}
`;
const NewsletterSubscribeFormInputsWrapper = styled.div.withConfig({
    displayName: 'NewsletterSubscribeFormInputsWrapper'
}) `
  ${({ isHighImpact }) => isHighImpact === true &&
    css `
      grid-column-end: 12;
      grid-column-start: 1;
      grid-row-end: 2;
      grid-row-start: 2;
      margin: ${calculateSpacing(0)} ${calculateSpacing(3)}
        ${calculateSpacing(6)} ${calculateSpacing(3)};
      padding: 0;
      @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
        grid-column-end: 2;
        grid-column-start: 2;
        grid-row-end: 1;
        grid-row-start: 1;
        align-self: center;
        margin: ${calculateSpacing(4)} ${calculateSpacing(4)}
          ${calculateSpacing(5)} ${calculateSpacing(2)};
      }
      @media (min-width: 1025px) {
        grid-column-end: 2;
        grid-column-start: 2;
        grid-row-end: 1;
        grid-row-start: 1;
        align-self: center;
        margin: ${calculateSpacing(7)} ${calculateSpacing(4)}
          ${calculateSpacing(8)} ${calculateSpacing(2)};
      }
    `}
`;
const NewsletterSubscribeFormWrapper = styled.div.withConfig({
    displayName: 'NewsletterSubscribeFormWrapper'
}) `
  ${newsletterSubscribeFormHedStyles} {
    ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
        text-align: left;
      `}
  }

  ${TextFieldButton} {
    ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
        margin-left: ${calculateSpacing(0)};
      `}
  }

  ${({ isHighImpact }) => isHighImpact === false &&
    css `
      > :first-child {
        margin-top: 0;
      }

      > :last-child {
        margin-bottom: 0;
      }
    `}

  margin-top: ${({ hasTopSpacer }) => hasTopSpacer ? `${calculateSpacing(2)}` : 'none'};

  margin-bottom: ${({ hasBottomSpacer }) => hasBottomSpacer ? `${calculateSpacing(4)}` : 'none'};

  padding: ${calculateSpacing(4)} 0;

  ${({ theme }) => getDecoration(theme, 'backgroundImagePrimary')};

  @media (min-width: ${BREAKPOINTS.md}) {
    padding: ${calculateSpacing(4)} 0;
  }

  ${UtilityBodyTextContent} {
    color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.light.description')};

    a {
      color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.light.description')};
    }
  }

  ${({ isAggressive }) => isAggressive ? newsletterSubscribeFormAggressive : ``};

  ${({ isSlim, hasSlimAlternateStyle }) => {
    if (isSlim) {
        if (hasSlimAlternateStyle)
            return newsletterSubscribeFormSlimAlternate;
        return newsletterSubscribeFormSlim;
    }
    return ``;
}}

  ${({ isHighImpact }) => isHighImpact ? newsletterSubscribeFormHighImpact : ``};

  ${({ newsletterPalette }) => newsletterPalette === 'inverted' ? newsletterSubscribeFormInverted : ``};

  ${({ hasBackgroundColor, hasBackgroundColorForSubscribePage, sourceCode }) => hasBackgroundColorForSubscribePage && sourceCode === 'subscribe-page'
    ? css `
          background: ${getColorToken('colors.discovery.body.light.background')};
        `
    : hasBackgroundColor &&
        css `
          background: ${getColorToken('colors.discovery.body.light.background')};
        `}

  ${({ isHighImpact }) => isHighImpact === true &&
    css `
      && {
        margin: 0;
        background: ${getColorToken('colors.discovery.body.white.background')};
        padding: 0;
        justify-self: center;
        @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
          grid-template-columns: 1fr 1fr;
          margin: 0;
          padding: 0;
          width: 600px;
          justify-self: center;
        }
        @media (min-width: 1025px) {
          grid-template-columns: 1fr 1fr;
          margin: 0;
          padding: 0;
          max-width: 930px;
          justify-self: center;
        }
      }
    `}
    ${({ hideNewsletter }) => hideNewsletter &&
    `display: none;
    `}
`;
const NewsletterSubscribeFormButton = styled.button.withConfig({
    displayName: 'NewsletterSubscribeFormButton'
}) `
  margin-top: 0;
  border-radius: 4px;
  font-size: 1rem;

  .button__icon-container {
    fill: ${getColorToken('colors.interactive.base.white')};
  }

  ${({ hasSubscribed }) => hasSubscribed &&
    css `
      .button__icon-container {
        fill: ${getColorToken('colors.interactive.base.brand-primary')};
      }

      &:hover {
        background-color: ${getColorToken('colors.interactive.base.white')};
        color: ${getColorToken('colors.interactive.base.brand-primary')};
      }
    `}
`;
module.exports = {
    newsletterSubscribeFormAggressive,
    NewsletterSubscribeFormDangerousHed,
    NewsletterSubscribeFormDek,
    NewsletterSubscribeFormDisclaimer,
    NewsletterSubscribeFormValidation,
    newsletterSubscribeFormHedStyles,
    newsletterSubscribeFormInverted,
    newsletterSubscribeFormSlim,
    NewsletterSubscribeFormHedDekWrapper,
    NewsletterSubscribeFormInputsWrapper,
    newsletterSubscribeFormHighImpact,
    NewsletterSubscribeFormHighImpactContent,
    NewsletterSubscribeFormWrapper,
    NewsletterSubscribeFormButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 78409:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const NewsletterSubscribeForm = __webpack_require__(69872);
NewsletterSubscribeForm.NLSubscribeInverted = asVariation(NewsletterSubscribeForm, 'NLSubscribeInverted', {
    newsletterPalette: 'inverted'
});
NewsletterSubscribeForm.Aggressive = asVariation(NewsletterSubscribeForm, 'Aggressive', {
    isAggressive: true
}, {
    textAlign: 'left',
    hasBackgroundColor: true
});
NewsletterSubscribeForm.Slim = asVariation(NewsletterSubscribeForm, 'Slim', {
    isSlim: true
}, {
    textAlign: 'left',
    hasBackgroundColor: false
});
NewsletterSubscribeForm.HighImpact = asVariation(NewsletterSubscribeForm, 'HighImpact', {
    isHighImpact: true
}, {
    textAlign: 'left',
    hasBackgroundColor: false
});
NewsletterSubscribeForm.AggressiveCenter = asVariation(NewsletterSubscribeForm, 'AggressiveCenter', {
    isAggressive: true
}, {
    textAlign: 'center',
    hasBackgroundColor: false
});
module.exports = NewsletterSubscribeForm;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 27487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const UtilityLede = __webpack_require__(50829);
const Button = __webpack_require__(88456);
const { NewsletterCardAlertBadge } = __webpack_require__(20970);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNewsletterEvent } = __webpack_require__(14307);
const { NewsletterSubscribePageFormContainer, NewsletterSubscribePageFormGrid, NewsletterSubscribePageFrequencyBadge, NewsletterSubscribePageHeaderImage, NewsletterSubscribePageHeaderImageContainer, NewsletterSubscribePageLede, NewsletterSubscribePagePreviewContainerHed, NewsletterSubscribePagePreviewContainer, NewsletterSubscribeComingSoonContainer, NewsletterSubscribeComingSoonHed, NewsletterSubscribePagePreviewWrapper, NewsletterSubscribePageSignUpBtn, NewsletterSubscribePageSignedUpBtn, NewsletterSubscribePageSignUpForm } = __webpack_require__(7739);
const { checkIsSubscriberOnly } = __webpack_require__(81404);
/**
 * NewsletterSubscribeSubscrptionOnly component
 *
 * @param {object} props - React props
 * @param {string} props.buttonLabel - Label for button
 * @param {string} [props.brand] - Brand code for specific css styles of functionality
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} props.dangerousDek - HTML dek
 * @param {string} [props.dangerousDisclaimer] - Optional HTML disclaimer text
 * @param {string} props.dangerousHed - HTML hed
 * @param {string} props.dangerousSuccessDek - HTML success dek
 * @param {string} props.dangerousSuccessLinkDek - HTML success dek for custom link
 * @param {string} props.dangerousSuccessHed - HTML success hed
 * @param {string} [props.frequencyBadge] - frequency Badge for the newletter
 * @param {string} [props.frequencyPrefix] - frequency Prefix for frequency badge prefix for the newsletter
 * @param {string} props.formName - Name of sign up form
 * @param {boolean} [props.hasSignedUp] - Whether user has been hasSignedUp to  subscribe
 * @param {boolean} [props.hasSubscribed] - Whether user has been successfully subscribed
 * @param {boolean} [props.hideModel] - Optional hide the sign up model box
 * @param {boolean} [props.hideTextField] - Optional hide text field
 * @param {boolean} props.hasAlternateNewsletterStyle - optional have new styling or not
 * @param {object} [props.image] - Optional image object
 * @param {boolean} [props.isImageFullBleed] - Optional flag for horizontal image in a full viewport
 * @param {string | number} newsletterId - Newsletter ID to subscribe to
 * @param {Function} [props.onModelCloseBtnHandler] - optional handle model close btn action
 * @param {Function} [props.onSignedUpHandler] - Optional submit event handler
 * @param {Function} [props.onSubmitHandler] - Optional submit event handler
 * @param {Function} [props.handleEscButtonForModal] - Escape button press close sign-up modal
 * @param {Function} [props.onSuccessHandler] - Optional success handler
 * @param {string} [props.placeholder] - Optional placeholder string
 * @param {string} [props.newsletterTemplateUrl] - Optional preview Latest Link string
 * @param {string} [props.provider] - Optional newsletter subscriptions service provider
 * @param {string} [props.recaptchaSiteKey] - brand siteKey for recaptcha
 * @param {boolean} [props.shouldHaveExtraPadding] - Optional to add extra padding on the lede text, defauts to false
 * @param {string} props.siteCode - brand site code
 * @param {string} [props.sourceCode] - the newsletter component placement tracking code
 * @param {string} [props.sourceCodeForCheckingReCaptcha] - the newsletter component for checking reCaptcha
 * @param {string} props.textFieldLabel - Label for input
 * @param {string} props.textFieldName - Input name
 * @param {string} props.continueUrlParamName - name of the query params needs to be filtered in URI
 * @param {string} props.userPlatformProxy - brand upg proxy server url
 * @param {object} [props.variations] - Variation properties used in rendering the component.
 * @param {string} props.xClientID - brand upg x-client request header
 * @param {string} props.userEmail - optional email of the user
 * @param {string} props.newsletterId - newsletterId
 * @param {string} props.variations.isFullViewPort - isFullViewPort
 * @param {string} props.variations.stackedSubscribeForm - stackedSubscribeForm
 * @param {string} props.variations.shouldUseAlternativeLedeStyle - shouldUseAlternativeLedeStyle
 * @param {string} props.variations.utilityLedeVariation - utilityLedeVariation
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.alertBadge] - Component alertBadge for newsletter
 * @param {string} [props.signUpSuccessDek] - Success Message after user sign up to newsletter
 * @param {string} [props.imageAltText] - imageAltText for image
 
 *
 * @returns {ReactElement} <div>
 */
// eslint-disable-next-line complexity
function NewsletterSubscribeSubscrptionOnly({ dangerousDek, dangerousHed, frequencyBadge, formName, hasSubscribed, hasAlternateNewsletterStyle, newsletterId, sourceCode, userEmail, variationName, imageUrl, isFullViewPort, alertBadge, utilityLedeVariation, shouldHaveExtraPadding, shouldUseAlternativeLedeStyle, frequencyPrefix, isAuthenticated, hasSignedUp, buttonLabel, onSubmitHandler, textFieldLabel, textFieldName, provider, siteCode, sourceCodeForCheckingReCaptcha, subscribeButtonURL, recaptchaSiteKey, userPlatformProxy, xClientID, brand, translationsPreviewText, newsletterTemplateUrl, dangerousDisclaimer, isStackedSubscribeForm, onSuccessHandler, placeholder, isImageFullBleed, handleNewsletterIdFromJourney, imageAltText }) {
    const [isSubscriberOnly, setIsSubscriberOnly] = React.useState(false);
    const { formatMessage } = useIntl();
    const imageUrlObj = { url: imageUrl };
    const smObj = { sm: imageUrlObj };
    const image = { altText: imageAltText, sources: smObj };
    const UtilityLedeComponent = utilityLedeVariation === 'default'
        ? UtilityLede
        : UtilityLede[utilityLedeVariation];
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterSubscribeSubscrptionOnly',
            variation: variationName
        });
    }, [variationName]);
    React.useEffect(() => {
        // check if the user is subscriber only by checking the CN_access token
        if (isAuthenticated) {
            setIsSubscriberOnly(checkIsSubscriberOnly());
        }
    }, [isAuthenticated]);
    React.useEffect(() => {
        trackNewsletterEvent({
            type: 'impression',
            newsletter_id: String(newsletterId),
            newsletter_title: dangerousHed || null,
            cadence: frequencyBadge || null,
            subject: sourceCode
        });
    }, [newsletterId, dangerousHed, frequencyBadge, sourceCode]);
    React.useEffect(() => {
        handleNewsletterIdFromJourney(newsletterId);
    }, [newsletterId, handleNewsletterIdFromJourney]);
    return (React.createElement(React.Fragment, null,
        React.createElement(NewsletterSubscribePageFormGrid, { hasAlternateNewsletterStyle: hasAlternateNewsletterStyle },
            React.createElement(NewsletterSubscribePageFormContainer, null,
                image && (React.createElement(NewsletterSubscribePageHeaderImageContainer, { isFullViewPort: isFullViewPort },
                    React.createElement(NewsletterSubscribePageHeaderImage, { ...image, isFullViewPort: isFullViewPort, isImageFullBleed: isImageFullBleed }))),
                alertBadge && (React.createElement(NewsletterCardAlertBadge, { dangerouslySetInnerHTML: { __html: alertBadge } })),
                React.createElement(NewsletterSubscribePageLede, { as: UtilityLedeComponent, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle, shouldHaveExtraPadding: shouldHaveExtraPadding, shouldUseAlternativeStyle: shouldUseAlternativeLedeStyle, dangerousDek: dangerousDek, dangerousHed: dangerousHed }),
                hasAlternateNewsletterStyle && (React.createElement(React.Fragment, null,
                    frequencyBadge && (React.createElement(NewsletterSubscribePageFrequencyBadge, { dangerouslySetInnerHTML: {
                            __html: `${frequencyPrefix} ${frequencyBadge}`
                        } })),
                    !isAuthenticated && !userEmail && (React.createElement(NewsletterSubscribePageSignUpBtn, { as: Button.Primary, label: "SUBSCRIBE", btnStyle: !hasSignedUp ? 'filled' : 'outlined', hasSignedUp: hasSignedUp, hasEnableIcon: true, iconPosition: "before", dangerousHed: dangerousHed, frequencyBadge: frequencyBadge, href: subscribeButtonURL, rel: "nofollow noopener noreferrer", target: "_blank", "aria-label": "Opens in a new window", inputKind: "link" })),
                    (isAuthenticated || userEmail) && !isSubscriberOnly && (React.createElement(NewsletterSubscribePageSignUpBtn, { as: Button.Primary, label: "SUBSCRIBE", btnStyle: !hasSignedUp ? 'filled' : 'outlined', hasSignedUp: hasSignedUp, hasEnableIcon: true, iconPosition: "before", dangerousHed: dangerousHed, frequencyBadge: frequencyBadge, href: subscribeButtonURL, rel: "nofollow noopener noreferrer", target: "_blank", "aria-label": "Opens in a new window", inputKind: "link" })),
                    (isAuthenticated || userEmail) && isSubscriberOnly && (React.createElement(NewsletterSubscribePageSignedUpBtn, { hasSubscribed: hasSubscribed, buttonLabel: buttonLabel, formName: formName, onSubmitHandler: onSubmitHandler, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle, isSignedUpUser: true, textFieldLabel: textFieldLabel, textFieldName: textFieldName, newsletterId: newsletterId, provider: provider, siteCode: siteCode, sourceCode: sourceCode, dangerousHed: dangerousHed, frequencyBadge: frequencyBadge }))))),
            hasAlternateNewsletterStyle && (React.createElement(NewsletterSubscribePagePreviewWrapper, { brand: brand },
                React.createElement(NewsletterSubscribePagePreviewContainerHed, { dangerouslySetInnerHTML: {
                        __html: formatMessage(translationsPreviewText, {
                            symbol: ''
                        })
                    } }),
                !newsletterTemplateUrl && (React.createElement(NewsletterSubscribeComingSoonContainer, null,
                    React.createElement(NewsletterSubscribeComingSoonHed, { dangerouslySetInnerHTML: { __html: '<i>Coming Soon</i>' } }))),
                newsletterTemplateUrl && (React.createElement(NewsletterSubscribePagePreviewContainer, null,
                    React.createElement("iframe", { src: newsletterTemplateUrl, title: "Newsletter Preview" })))))),
        !hasSubscribed && !hasAlternateNewsletterStyle && (React.createElement(React.Fragment, null,
            React.createElement(NewsletterSubscribePageSignUpForm, { buttonLabel: buttonLabel, dangerousDisclaimer: dangerousDisclaimer, formName: formName, isTextFieldAlwaysStacked: isStackedSubscribeForm, isFullViewPort: isFullViewPort, newsletterId: newsletterId, onSubmitHandler: onSubmitHandler, onSuccessHandler: onSuccessHandler, placeholder: placeholder, provider: provider, recaptchaSiteKey: recaptchaSiteKey, siteCode: siteCode, sourceCode: sourceCode, sourceCodeForCheckingReCaptcha: sourceCodeForCheckingReCaptcha, textFieldLabel: textFieldLabel, textFieldName: textFieldName, userPlatformProxy: userPlatformProxy, xClientID: xClientID, isSubmitDisabled: true, dangerousHed: dangerousHed, frequencyBadge: frequencyBadge })))));
}
NewsletterSubscribeSubscrptionOnly.propTypes = {
    alertBadge: PropTypes.string,
    brand: PropTypes.string,
    buttonLabel: PropTypes.string,
    dangerousDek: PropTypes.string.isRequired,
    dangerousDisclaimer: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    formName: PropTypes.string,
    frequencyBadge: PropTypes.string,
    frequencyPrefix: PropTypes.string,
    handleNewsletterIdFromJourney: PropTypes.func,
    hasAlternateNewsletterStyle: PropTypes.bool,
    hasSignedUp: PropTypes.bool,
    hasSubscribed: PropTypes.bool,
    imageAltText: PropTypes.string,
    imageUrl: PropTypes.string.isRequired,
    isAuthenticated: PropTypes.bool,
    isFullViewPort: PropTypes.bool,
    isImageFullBleed: PropTypes.bool,
    isStackedSubscribeForm: PropTypes.bool,
    newsletterId: PropTypes.string.isRequired,
    newsletterTemplateUrl: PropTypes.string,
    onSubmitHandler: PropTypes.func,
    onSuccessHandler: PropTypes.func,
    placeholder: PropTypes.string,
    provider: PropTypes.string,
    recaptchaSiteKey: PropTypes.string,
    shouldHaveExtraPadding: PropTypes.bool,
    shouldUseAlternativeLedeStyle: PropTypes.bool,
    siteCode: PropTypes.string,
    sourceCode: PropTypes.string,
    sourceCodeForCheckingReCaptcha: PropTypes.string,
    subscribeButtonURL: PropTypes.string,
    textFieldLabel: PropTypes.string,
    textFieldName: PropTypes.string,
    translationsPreviewText: PropTypes.object,
    userEmail: PropTypes.string,
    userPlatformProxy: PropTypes.string,
    utilityLedeVariation: PropTypes.string,
    variationName: PropTypes.string,
    xClientID: PropTypes.string
};
NewsletterSubscribeSubscrptionOnly.displayName =
    'NewsletterSubscribeSubscrptionOnly';
module.exports = NewsletterSubscribeSubscrptionOnly;
//# sourceMappingURL=NewsletterSubscribeSubscriptionOnly.js.map

/***/ }),

/***/ 29105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(27487);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7739:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorToken, minScreen, minMaxScreen, getTypographyStyles } = __webpack_require__(26865);
const NewsletterSecondaryOptins = __webpack_require__(14340);
const { maxThresholds } = __webpack_require__(99906);
const { ButtonWrapper } = __webpack_require__(18974);
const ConnectedNewsletterSubscribeForm = __webpack_require__(577);
const Grid = __webpack_require__(86659);
const { NewsletterSubscribeFormWrapper } = __webpack_require__(69817);
const ResponsiveAsset = __webpack_require__(73275);
const ResponsiveImagePicture = __webpack_require__(7228);
const UtilityBodyText = __webpack_require__(27755);
const UtilityCard = __webpack_require__(60521);
const { GridItem } = __webpack_require__(40653);
const { UtilityLedeHedText, UtilityLedeDekText } = __webpack_require__(79055);
const { NewsletterCardAlertBadge } = __webpack_require__(20970);
const NewsletterSubscribePageBodyText = styled(UtilityBodyText.ContentLeft).withConfig({
    displayName: 'NewsletterSubscribePageBodyText'
}) `
  padding: ${calculateSpacing(5)} 0 ${calculateSpacing(1)};
  ${minScreen(BREAKPOINTS.md)} {
    padding: ${calculateSpacing(6)} 0 ${calculateSpacing(9)};
  }
`;
const NewsletterSubscribePageSignUpForm = styled(ConnectedNewsletterSubscribeForm).withConfig({
    displayName: 'NewsletterSubscribePageSignUpForm'
}) `
  && {
    padding: ${calculateSpacing(4)} ${calculateSpacing(4)};
  }
  ${({ isFullViewPort }) => isFullViewPort &&
    css `
      &&& {
        background-color: ${getColorToken('colors.discovery.body.white.background')};
        padding-bottom: ${calculateSpacing(6)};
        @media (max-width: ${maxThresholds.md}px) {
          padding-bottom: ${calculateSpacing(5)};
        }
      }
    `}
`;
const NewsletterSubscribePageForm = styled(UtilityCard).withConfig({
    displayName: 'NewsletterSubscribePageForm'
}) `
  && {
    border: 0;
    background-color: ${getColorToken('colors.discovery.body.light.background')};
  }
  ${ButtonWrapper} {
    margin-top: ${calculateSpacing(1)};
    margin-left: auto;
    width: 100%;
  }
  ${NewsletterSubscribeFormWrapper} {
    background-color: ${getColorToken('colors.discovery.body.light.background')};
  }
  ${NewsletterCardAlertBadge} {
    margin: ${calculateSpacing(2)} auto 0;
  }
`;
const NewsletterSubscribePageLede = styled.div.withConfig({
    displayName: 'NewsletterSubscribePageLede'
}) `
  padding: ${calculateSpacing(2)} 0 ${calculateSpacing(4)};
  ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
      padding: 0;
      ${UtilityLedeHedText} {
        ${getTypographyStyles('typography.definitions.utility.heading')}
        color: ${getColorToken('colors.interactive.base.black')};
      }
      ${UtilityLedeDekText} {
        ${getTypographyStyles('typography.definitions.utility.description')}
      }
    `}
  ${minScreen(BREAKPOINTS.md)} {
    padding: ${calculateSpacing(9)} 0 ${calculateSpacing(6)};
    ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
        padding: 0;
      `}
  }
  ${({ shouldHaveExtraPadding }) => shouldHaveExtraPadding &&
    ` 
  padding-right: ${calculateSpacing(2)};
  padding-left: ${calculateSpacing(2)};
  ${minScreen(BREAKPOINTS.md)} {
    padding-right: ${calculateSpacing(3)};
    padding-left: ${calculateSpacing(3)};
  }`}
`;
const NewsletterSubscribePageGrid = styled(Grid.NoMargins).withConfig({
    displayName: 'NewsletterSubscribePageGrid'
}) `
  > ${GridItem}:first-child {
    grid-column: 1 / -1;
    ${minScreen(BREAKPOINTS.md)} {
      grid-column: span 6;
    }
    ${minScreen(BREAKPOINTS.lg)} {
      grid-column: span 4;
    }
  }
  > ${GridItem}:last-child {
    grid-column: 7 / span 6;
    ${minScreen(BREAKPOINTS.lg)} {
      grid-column: 5 / span 8;
    }
  }

  && {
    grid-gap: 0;
  }
  min-height: ${calculateSpacing(50)};
  ${minScreen(BREAKPOINTS.md)} {
    min-height: ${calculateSpacing(75)};
  }
`;
const NewsletterSubscribePageImageContainer = styled(BaseText).withConfig({
    displayName: 'NewsletterSubscribePageImageContainer'
}) `
  position: relative;
  background-color: ${getColorToken('colors.discovery.body.light.background')};
  height: 100%;
  overflow: hidden;
  ${minScreen(BREAKPOINTS.md)} {
    display: flex;
  }

  img {
    object-fit: cover;
    min-width: 100%;
    height: 100%;
  }
`;
NewsletterSubscribePageImageContainer.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.background'
};
const NewsletterSubscribePageResponsiveImage = styled(ResponsiveAsset).withConfig({
    displayName: 'NewsletterSubscribePageResponsiveImage'
}) `
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  height: 100%;
  ${ResponsiveImagePicture} {
    height: 100%;
  }
`;
const NewsletterSubscribePageHeaderImageContainer = styled.div.withConfig({
    displayName: 'NewsletterSubscribePageHeaderImageContainer'
}) `
  grid-column: 1/-1;
  ${({ isFullViewPort }) => isFullViewPort &&
    css `
      background-color: ${getColorToken('colors.discovery.body.white.background')};
      padding-top: ${calculateSpacing(6)};
      @media (max-width: ${maxThresholds.md}px) {
        padding-top: ${calculateSpacing(5)};
      }
      ${minMaxScreen(0, BREAKPOINTS.sm)} {
        padding-top: ${calculateSpacing(4)};
      }
    `}
`;
const NewsletterSubscribePageHeaderImage = styled(ResponsiveAsset).withConfig({
    displayName: 'NewsletterSubscribePageHeaderImage'
}) `
  ${({ isFullViewPort }) => isFullViewPort &&
    `margin: auto;
    width: 150px;
    height: 150px;`}
  ${({ isImageFullBleed }) => isImageFullBleed &&
    `width: auto;
     height: auto;
   `}
`;
const NewsletterSubscribePageFormContainer = styled.div.withConfig({
    displayName: 'NewsletterSubscribePageFormContainer'
}) ``;
const NewsletterSubscribePageFormGrid = styled.div.withConfig({
    displayName: 'NewsletterSubscribePageFormGrid'
}) `
  ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
      background-color: ${getColorToken('colors.discovery.body.white.background')};
      text-align: center;
      ${NewsletterSubscribePageHeaderImage} {
        margin-bottom: ${calculateSpacing(1)};
        width: 96px;
        height: 96px;
      }
      ${minScreen(BREAKPOINTS.lg)} {
        display: grid;
        grid-template-columns: repeat(12, 1fr);
      }
      ${NewsletterSubscribePageFormContainer} {
        ${minScreen(BREAKPOINTS.lg)} {
          grid-column: 3 / span 8;
        }
      }
    `}
`;
const NewsletterSubscribePageFrequencyBadge = styled(BaseText).withConfig({
    displayName: 'NewsletterSubscribePageFrequencyBadge'
}) `
  padding: ${calculateSpacing(2)} 0 ${calculateSpacing(1)};
`;
NewsletterSubscribePageFrequencyBadge.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.deemphasized',
    typeIdentity: 'typography.definitions.foundation.link-primary'
};
const NewsletterSubscribePageSignedUpBtn = styled(ConnectedNewsletterSubscribeForm).withConfig({
    displayName: 'NewsletterSubscribePageSignedUpBtn'
}) ``;
const NewsletterSubscribePageSignUpBtn = styled.button.withConfig({
    displayName: 'NewsletterSubscribePageSignUpBtn'
}) `
  margin-top: 0;
  border-radius: 4px;
  font-size: 1rem;

  .button__icon-container {
    fill: ${getColorToken('colors.interactive.base.white')};
  }

  .icon-expand {
    width: 24px;
    height: 24px;
  }
  ${({ hasSignedUp }) => hasSignedUp &&
    css `
      .button__icon-container {
        fill: ${getColorToken('colors.interactive.base.brand-primary')};
      }

      &:hover {
        background-color: ${getColorToken('colors.interactive.base.white')};
        color: ${getColorToken('colors.interactive.base.brand-primary')};
      }
    `}
`;
const NewsletterSubscribePagePreviewContainerHed = styled(BaseText).withConfig({
    displayName: 'NewsletterSubscribePagePreviewContainerHed'
}) `
  padding: ${calculateSpacing(1)} 0 ${calculateSpacing(2)};
`;
NewsletterSubscribePagePreviewContainerHed.defaultProps = {
    as: 'p',
    colorToken: 'colors.interactive.base.body',
    typeIdentity: 'typography.definitions.utility.landing-description'
};
const NewsletterSubscribePagePreviewContainer = styled.div.withConfig({
    displayName: 'NewsletterSubscribePagePreviewContainer'
}) `
  margin-bottom: ${calculateSpacing(4)};
  height: 100vh;

  iframe {
    border: none;
    width: 100%;
    height: 100%;
  }
`;
const NewsletterSubscribeComingSoonHed = styled(BaseText).withConfig({
    displayName: 'NewsletterSubscribeComingSoonHed'
}) ``;
NewsletterSubscribeComingSoonHed.defaultProps = {
    as: 'p',
    colorToken: 'colors.interactive.base.body',
    typeIdentity: 'typography.definitions.utility.card-heading'
};
const NewsletterSubscribeComingSoonContainer = styled.div.withConfig({
    displayName: 'NewsletterSubscribeComingSoonContainer'
}) `
  margin-bottom: ${calculateSpacing(4)};
  background: #f0f0f0;
  padding-top: ${calculateSpacing(6)};
  min-height: 300px;
`;
const NewsletterSubscribePagePreviewWrapper = styled.div.withConfig({
    displayName: 'NewsletterSubscribePagePreviewWrapper'
}) `
  margin-top: ${calculateSpacing(6)};
  ${({ brand }) => ['GQ'].includes(brand)
    ? css `
          border-top: ${calculateSpacing(1 / 2)} solid;
        `
    : css `
          border-top: ${calculateSpacing(1 / 8)} solid;
        `}
  border-color: ${getColorToken('colors.interactive.base.body')};
  ${minScreen(BREAKPOINTS.lg)} {
    grid-column: 1/-1;
  }
`;
const NewsletterSubscribePageModelTextLinkContainer = styled('div').withConfig({
    displayName: 'NewsletterSubscribePageModelTextLinkContainer'
}) `
  display: flex;
  align-items: center;
  border-top: 1px solid ${getColorToken('colors.discovery.body.brand.divider')};
  padding-top: ${calculateSpacing(2.2)};
`;
const NewsletterSubscribePageModelTextLinkContainerText = styled('a').withConfig({
    displayName: 'NewsletterSubscribePageModelTextLinkContainerText'
}) `
  ${getTypographyStyles('typography.definitions.utility.modal-body')};
  text-decoration: underline;
  color: ${getColorToken('colors.foundation.expanded-utility.nav-link.default')};
  font-size: 1.12rem;
  ${({ brand }) => ['CNT'].includes(brand) &&
    css `
      color: ${getColorToken('colors.interactive.base.brand-primary')};
    `}
`;
const NewsletterSubscribePageModelTextLinkContainerIcon = styled('div').withConfig({
    displayName: 'NewsletterSubscribePageModelTextLinkContainerIcon'
}) `
  border: none;
  background: transparent;
  padding: 0;

  .button__icon-container {
    fill: ${getColorToken('colors.foundation.expanded-utility.nav-link.default')};
  }

  &:hover {
    border-width: unset;
    border-style: none;
    border-color: inherit;
    background-color: inherit;
  }
`;
const NewsLetterSubscribePagePreferencesSecondaryOptins = styled(NewsletterSecondaryOptins).withConfig({
    displayName: 'NewsLetterSubscribePagePreferencesSecondaryOptins'
}) `
  margin-top: ${calculateSpacing(4)};
  border-top: 1px solid ${getColorToken('colors.discovery.body.white.divider')};
  padding-top: ${calculateSpacing(4)};
`;
module.exports = {
    NewsletterSubscribePageBodyText,
    NewsletterSubscribePageForm,
    NewsletterSubscribePageFormContainer,
    NewsletterSubscribePageFormGrid,
    NewsletterSubscribePageFrequencyBadge,
    NewsletterSubscribePageGrid,
    NewsletterSubscribePageHeaderImage,
    NewsletterSubscribePageHeaderImageContainer,
    NewsletterSubscribePageImageContainer,
    NewsletterSubscribePageLede,
    NewsletterSubscribePagePreviewContainerHed,
    NewsletterSubscribePagePreviewContainer,
    NewsletterSubscribeComingSoonContainer,
    NewsletterSubscribePagePreviewWrapper,
    NewsletterSubscribeComingSoonHed,
    NewsletterSubscribePageResponsiveImage,
    NewsletterSubscribePageSignUpBtn,
    NewsletterSubscribePageSignedUpBtn,
    NewsletterSubscribePageSignUpForm,
    NewsletterSubscribePageModelTextLinkContainer,
    NewsletterSubscribePageModelTextLinkContainerText,
    NewsletterSubscribePageModelTextLinkContainerIcon,
    NewsLetterSubscribePagePreferencesSecondaryOptins
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 81404:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkIsSubscriberOnly = void 0;
const jwt_decode_1 = __importDefault(__webpack_require__(6765));
const cookie_1 = __webpack_require__(56892);
const cookies_1 = __importDefault(__webpack_require__(53788));
const getSubscriptionsFromToken = (accessCookieValue) => {
    const payload = (0, jwt_decode_1.default)(accessCookieValue);
    const fct = payload?.fct || {};
    return Object.values(fct).flat();
};
const checkIsSubscriberOnly = () => {
    const accessCookieValue = (0, cookie_1.getCookie)(cookies_1.default.accessCookie);
    if (!accessCookieValue)
        return false;
    const subscribedProducts = getSubscriptionsFromToken(accessCookieValue);
    if (!subscribedProducts?.length)
        return false;
    const isSubscriberOnly = subscribedProducts.some((subscribedUserProduct) => subscribedUserProduct.includes('wired.com'));
    return isSubscriberOnly;
};
exports.checkIsSubscriberOnly = checkIsSubscriberOnly;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 23058:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const NewsletterCard = __webpack_require__(85430);
const { NewsletterSubscriptionOnlyWrapper, NewsletterSectionHed, NewsletterSectionWrapper, NewsletterCardWrapper, NewsletterCardAsset, NewsletterCardAlertBadge, NewsletterCardHed, NewsletterCardDek, NewsletterCardPreviewWrapper, NewsletterCardPreviewFrequencyBadge, NewsletterCardPreviewLink, NewsletterCardButton, NewsletterCardButtonSmall, NewsletterCardToaster } = __webpack_require__(57908);
const { checkIsSubscriberOnly } = __webpack_require__(12361);
const { saveNewsletterSubscriptions } = __webpack_require__(26430);
const MessageBanner = __webpack_require__(62282);
const translations = (__webpack_require__(52510)/* ["default"] */ .A);
const NewsletterSubscriptionOnly = ({ Newsletters, isAuthenticated, userSubscribedNewsletterIds = [], amguuid, siteCode, xClientID, email }) => {
    const [isSubscriberOnly, setIsSubscriberOnly] = React.useState(false);
    const [subscribedIds, setSubscribedIds] = React.useState([
        ...userSubscribedNewsletterIds
    ]);
    const [isToasterOpen, setIsToasterOpen] = React.useState(false);
    const [toasterTitle, setToasterTitle] = React.useState('');
    React.useEffect(() => {
        // check if the user is subscriber only by checking the CN_access token
        if (isAuthenticated) {
            setIsSubscriberOnly(checkIsSubscriberOnly());
        }
    }, [isAuthenticated]);
    const { formatMessage } = useIntl();
    const onChangeHandler = (event, newsletterId) => {
        event.preventDefault();
        setTimeout(() => {
            setIsToasterOpen(true);
            setToasterTitle(Newsletters.find((newsletter) => {
                return newsletter.newsletterId === newsletterId;
            }).dangerousHed);
            setSubscribedIds([...subscribedIds, newsletterId]);
        });
        const opts = {
            amgUUID: amguuid,
            siteCode,
            xClientID,
            payload: {
                email,
                formName: 'newsletter-subscription-only',
                sourceCode: 'newsletter-subscription-only',
                subscriptions: [
                    {
                        status: 'SUBSCRIBED',
                        newsletterId
                    }
                ]
            }
        };
        Promise.resolve(saveNewsletterSubscriptions(opts))
            .then((result) => {
            if (result.savePreference.success) {
                setTimeout(() => {
                    setIsToasterOpen(false);
                }, 3000);
            }
        })
            .catch((error) => {
            console.log(error);
            setSubscribedIds(subscribedIds.filter((id) => id !== newsletterId));
        });
    };
    return (React.createElement(NewsletterSubscriptionOnlyWrapper, { className: "NewsletterSubscriptionOnlyWrapper" },
        React.createElement(NewsletterSectionHed, null, formatMessage(translations.sectionHed)),
        React.createElement(NewsletterSectionWrapper, null,
            isSubscriberOnly &&
                Newsletters.map((newsletter, index) => {
                    return (React.createElement(NewsletterCard, { ...newsletter, alertBadge: newsletter.alertBadge, frequencyBadge: newsletter.frequencyBadge, image: {
                            altText: newsletter.imageAltText,
                            sources: { sm: { url: newsletter.imageUrl } }
                        }, key: index, dangerousHed: newsletter.dangerousHed, formName: "manage", index: index, isChecked: subscribedIds.includes(newsletter.newsletterId) ||
                            userSubscribedNewsletterIds.includes(newsletter.newsletterId), isAuthenticated: isAuthenticated, name: newsletter.dangerousHed, value: newsletter.dangerousHed, onChangeHandler: (event) => {
                            onChangeHandler(event, newsletter.newsletterId);
                        }, previewURL: `/newsletter/exclusive/${newsletter.slug}` }));
                }),
            !isSubscriberOnly &&
                Newsletters.map((newsletter, index) => {
                    return (React.createElement(NewsletterCardWrapper, { hasOnlyTwoItems: Newsletters.length === 2, key: index },
                        React.createElement(NewsletterCardAsset, { altText: newsletter.imageAltText, sources: { sm: { url: newsletter.imageUrl } } }),
                        React.createElement(NewsletterCardButton, { inputKind: "link", label: formatMessage(translations.buttonLabel), href: newsletter.subscribeButtonURL, rel: "nofollow noopener noreferrer", target: "_blank", "aria-label": "Opens in a new window" }),
                        React.createElement(NewsletterCardAlertBadge, { dangerouslySetInnerHTML: { __html: newsletter.alertBadge } }),
                        React.createElement(NewsletterCardHed, { dangerouslySetInnerHTML: { __html: newsletter.dangerousHed } }),
                        React.createElement(NewsletterCardDek, { badge: newsletter.alertBadge, dangerouslySetInnerHTML: { __html: newsletter.dangerousDek } }),
                        React.createElement(NewsletterCardPreviewWrapper, null,
                            React.createElement(NewsletterCardPreviewFrequencyBadge, { dangerouslySetInnerHTML: {
                                    __html: newsletter.frequencyBadge
                                } }),
                            React.createElement(NewsletterCardPreviewLink, { href: `/newsletter/exclusive/${newsletter.slug}`, rel: "nofollow noopener noreferrer", target: "_blank", "aria-label": "Opens in a new window", dangerouslySetInnerHTML: {
                                    __html: formatMessage(translations.previewLabel)
                                } }),
                            React.createElement(NewsletterCardButtonSmall, { inputKind: "link", label: formatMessage(translations.buttonLabel), href: newsletter.subscribeButtonURL, rel: "nofollow noopener noreferrer", target: "_blank", "aria-label": "Opens in a new window" }))));
                })),
        isToasterOpen && (React.createElement(NewsletterCardToaster, null,
            React.createElement(MessageBanner, { contentAlign: "center", isFixed: true, delayDuration: 3000, title: toasterTitle },
                React.createElement("p", { dangerouslySetInnerHTML: {
                        __html: formatMessage(translations.signedUpPopUpMessage)
                    } }))))));
};
NewsletterSubscriptionOnly.propTypes = {
    amguuid: PropTypes.string,
    email: PropTypes.string,
    isAuthenticated: PropTypes.bool,
    Newsletters: PropTypes.arrayOf(PropTypes.shape({
        alertBadge: PropTypes.string.isRequired,
        dangerousDek: PropTypes.string.isRequired,
        dangerousHed: PropTypes.string.isRequired,
        frequencyBadge: PropTypes.string.isRequired,
        imageAltText: PropTypes.string.isRequired,
        imageUrl: PropTypes.string.isRequired,
        name: PropTypes.string.isRequired,
        newsletterId: PropTypes.string.isRequired,
        newsletterTemplateUrl: PropTypes.string.isRequired,
        slug: PropTypes.string.isRequired,
        subscribeButtonURL: PropTypes.string.isRequired
    })),
    siteCode: PropTypes.string,
    userSubscribedNewsletterIds: PropTypes.array,
    xClientID: PropTypes.string
};
module.exports = NewsletterSubscriptionOnly;
//# sourceMappingURL=NewsletterSubscriptionOnly.js.map

/***/ }),

/***/ 83344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(23058);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(76955);
const Button = __webpack_require__(73730);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorStyles, getColorToken, getTypographyStyles, maxScreen, minScreen } = __webpack_require__(26865);
const ResponsiveAsset = __webpack_require__(86157);
const { MessageBannerWrapper, MessageBannerTitle, MessageBannerContent } = __webpack_require__(8070);
const NewsletterSubscriptionOnlyWrapper = styled.div.withConfig({
    displayName: 'NewsletterSubscriptionOnlyWrapper'
}) ``;
const NewsletterSectionHed = styled(BaseText).withConfig({
    displayName: 'NewsletterSectionHed'
}) `
  display: block;
  grid-column: 1/2;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.body')};
  border-top: ${calculateSpacing(1 / 8)} solid;
  padding-top: ${calculateSpacing(1)};
  padding-bottom: ${calculateSpacing(2)};
`;
NewsletterSectionHed.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.body',
    typeIdentity: 'typography.definitions.discovery.subhed-section-collection'
};
const NewsletterSectionWrapper = styled.div.withConfig({
    displayName: 'NewsletterSectionWrapper'
}) `
  padding-bottom: ${calculateSpacing(4)};
  ${maxScreen(BREAKPOINTS.md)} {
    display: grid;
    grid-gap: ${calculateSpacing(2)};
  }

  ${minScreen(BREAKPOINTS.md)} {
    display: grid;
    position: relative;
    grid-gap: ${calculateSpacing(2)};
    grid-template-areas: 'discovery-selection-control';
    grid-template-columns: repeat(2, 1fr);
    margin: 0 auto;
    padding-right: 0;
    padding-left: 0;
  }

  ${minScreen(BREAKPOINTS.lg)} {
    grid-template-columns: repeat(3, 1fr);
  }
`;
const NewsletterCardWrapper = styled.div.withConfig({
    displayName: 'NewsletterCardWrapper'
}) `
  display: grid;
  position: relative;
  grid-auto-rows: min-content;
  grid-template-columns: 1fr auto;
  border: 1px solid ${getColorToken('colors.foundation.menu.dividers')};
  padding: ${calculateSpacing(1.5)};
  gap: ${calculateSpacing(1.5)};
`;
const NewsletterCardAsset = styled(ResponsiveAsset).withConfig({
    displayName: 'NewsletterCardAsset'
}) `
  width: 4rem;

  img {
    max-width: 100%;
    height: auto;
    aspect-ratio: 1/1;
    object-fit: cover;
  }

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    grid-column: 2 / -1;
    grid-row: 1 / 4;
  }
`;
const NewsletterCardAlertBadge = styled(BaseText).withConfig({
    displayName: 'NewsletterCardAlertBadge'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid ${getColorToken('colors.interactive.base.border')};
  border-radius: ${calculateSpacing(3.5)};
  padding: ${calculateSpacing(0.5)} ${calculateSpacing(1)};
  max-width: fit-content;
  @media (min-width: ${BREAKPOINTS.md}) {
    grid-column: 1 / span 2;
  }
`;
NewsletterCardAlertBadge.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.deemphasized',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const NewsletterCardHed = styled(BaseText).withConfig({
    displayName: 'NewsletterCardHed'
}) `
  @media (min-width: ${BREAKPOINTS.md}) {
    grid-column: 1 / span 2;
  }
`;
NewsletterCardHed.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.black',
    typeIdentity: 'typography.definitions.utility.card-heading'
};
const NewsletterCardDek = styled(BaseText).withConfig({
    displayName: 'NewsletterCardDek'
}) `
  @media (min-width: ${BREAKPOINTS.md}) {
    grid-column: 1 / span 2;
    margin-bottom: ${calculateSpacing(4)};
  }
  @media (max-width: ${BREAKPOINTS.md}) {
    ${({ badge }) => badge.length < 1 &&
    css `
        grid-column: 1/2;
      `}
  }
`;
NewsletterCardDek.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.body',
    typeIdentity: 'typography.definitions.utility.body'
};
const NewsletterCardPreviewWrapper = styled.div.withConfig({
    displayName: 'NewsletterCardPreviewWrapper'
}) `
  display: flex;

  grid-column: 1/3;
  align-items: center;
  gap: ${calculateSpacing(1.2)};

  @media (min-width: ${BREAKPOINTS.md}) {
    position: absolute;
    bottom: 0;
    grid-column: 1/-1;
    margin: ${calculateSpacing(0.5)} 0 ${calculateSpacing(1)};
  }
`;
const NewsletterCardPreviewFrequencyBadge = styled(BaseText).withConfig({
    displayName: 'NewsletterCardPreviewFrequencyBadge'
}) `
  &::after {
    border-right: 1px solid ${getColorToken('colors.interactive.base.border')};
    padding-right: ${calculateSpacing(1.3)};
    content: '';
  }
`;
NewsletterCardPreviewFrequencyBadge.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.deemphasized',
    typeIdentity: 'typography.definitions.utility.button-bulletin'
};
const NewsletterCardPreviewLink = styled(BaseText).withConfig({
    displayName: 'NewsletterCardPreviewLink'
}) `
  flex: 1;
  outline-color: ${getColorToken('colors.interactive.base.brand-secondary')};
  text-decoration: none;
`;
NewsletterCardPreviewLink.defaultProps = {
    as: 'a',
    colorToken: 'colors.interactive.base.brand-primary',
    typeIdentity: 'typography.definitions.utility.button-bulletin'
};
const NewsletterCardButton = styled(Button.Primary).withConfig({
    displayName: 'NewsletterCardButton'
}) `
  display: none;
  grid-column: 3;
  margin-top: ${calculateSpacing(1.5)};
  margin-bottom: ${calculateSpacing(1.5)};
  height: ${calculateSpacing(4)};
  @media (min-width: ${BREAKPOINTS.md}) {
    display: flex;
    grid-column: 2;
    margin-top: 0;
    min-width: 50%;
  }

  @supports (-webkit-hyphens: none) {
    @media (min-width: ${BREAKPOINTS.md}) {
      min-width: 0;
    }
  }
`;
const NewsletterCardButtonSmall = styled(Button.Primary).withConfig({
    displayName: 'NewsletterCardButtonSmall'
}) `
  display: none;
  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    display: flex;
    height: ${calculateSpacing(4)};
  }
`;
const NewsletterCardToaster = styled('div').withConfig({
    displayName: 'NewsletterCardToaster'
}) `
  display: grid;
  position: fixed;
  bottom: 0;
  left: 50%;
  grid-template-columns: repeat(12, 1fr);
  justify-content: center;
  transform: translate(-50%, -25%);
  z-index: 999;
  width: 100%;

  ${MessageBannerWrapper} {
    grid-column: 1 / -1;
    border-radius: 8px;
    box-shadow: 0 0 24px 0 rgba(45, 45, 45, 0.16);
    padding: ${calculateSpacing(2)} ${calculateSpacing(3)}
      ${calculateSpacing(3)};

    ${MessageBannerTitle} {
      padding-top: 0;

      ${getTypographyStyles('typography.definitions.discovery.hed-core-primary')};
    }

    ${MessageBannerContent} {
      color: ${getColorToken('colors.interactive.base.body')};
      ${getTypographyStyles('typography.definitions.foundation.meta-primary')};
    }

    ${maxScreen(BREAKPOINTS.md)} {
      margin: 0 ${calculateSpacing(3)};
    }

    @media (min-width: calc(${BREAKPOINTS.md})) and (max-width: calc(${BREAKPOINTS.lg} - 1px)) {
      grid-column: 4 / span 6;
    }

    ${minScreen(BREAKPOINTS.lg)} {
      grid-column: 5 / span 4;
    }
  }
`;
module.exports = {
    NewsletterSubscriptionOnlyWrapper,
    NewsletterSectionWrapper,
    NewsletterSectionHed,
    NewsletterCardWrapper,
    NewsletterCardAsset,
    NewsletterCardAlertBadge,
    NewsletterCardHed,
    NewsletterCardDek,
    NewsletterCardPreviewWrapper,
    NewsletterCardPreviewFrequencyBadge,
    NewsletterCardPreviewLink,
    NewsletterCardButton,
    NewsletterCardButtonSmall,
    NewsletterCardToaster
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 52510:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    sectionHed: {
        id: 'NewsletterSubscriptionOnly.SectionHed',
        defaultMessage: 'SUBSCRIBER ONLY',
        description: 'Subscriber Only Hed'
    },
    buttonLabel: {
        id: 'NewsletterSubscriptionOnly.ButtonLabel',
        defaultMessage: 'Subscribe',
        description: 'Subscribe button label'
    },
    previewLabel: {
        id: 'NewsletterSubscriptionOnly.PreviewLabel',
        defaultMessage: 'Preview',
        description: 'Preview button label'
    },
    signedUpPopUpMessage: {
        id: 'NewsletterSubscriptionOnly.signedUpPopUpMessage',
        defaultMessage: 'Youre signed up to this newsletter.',
        description: 'Youre signed up to this newsletter message'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 12361:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkIsSubscriberOnly = void 0;
const jwt_decode_1 = __importDefault(__webpack_require__(6765));
const cookie_1 = __webpack_require__(56892);
const cookies_1 = __importDefault(__webpack_require__(53788));
const getSubscriptionsFromToken = (accessCookieValue) => {
    const payload = (0, jwt_decode_1.default)(accessCookieValue);
    const fct = payload?.fct || {};
    // Ensure fct is an object before calling Object.values
    if (typeof fct !== 'object' || fct === null || Array.isArray(fct)) {
        return [];
    }
    return Object.values(fct).flat();
};
const checkIsSubscriberOnly = () => {
    const accessCookieValue = (0, cookie_1.getCookie)(cookies_1.default.accessCookie);
    if (!accessCookieValue)
        return false;
    const subscribedProducts = getSubscriptionsFromToken(accessCookieValue);
    if (!subscribedProducts?.length)
        return false;
    const isSubscriberOnly = subscribedProducts.some((subscribedUserProduct) => subscribedUserProduct.includes('wired'));
    return isSubscriberOnly;
};
exports.checkIsSubscriberOnly = checkIsSubscriberOnly;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 46733:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseClickable = void 0;
const styled_components_1 = __importDefault(__webpack_require__(92168));
/** Reset Anchor tag styles. */
exports.BaseClickable = styled_components_1.default.a.withConfig({
    displayName: 'BaseClickable'
}) `
  cursor: pointer;
  user-select: none;
  padding: 0;
  margin: 0;
  border: none;
  background: transparent;
  color: inherit;
  font-size: inherit;
  font-weight: inherit;
  font-family: inherit;
  line-height: inherit;
  text-align: inherit;
  overflow: hidden;
  border-radius: 0;
  appearance: none;
  white-space: nowrap;
  vertical-align: middle;
  box-sizing: border-box;
  text-decoration: none;
  position: relative;
  outline: none;

  &:hover,
  &:focus,
  &:active {
    text-decoration: none;
  }

  /** Will be used for "focus-visible" styles.
      Using "outline" the outline lines will go out of the clickable width and it is not fully visible.
      */

  &:after {
    content: '';
    display: block;
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: transparent;
    transition-timing-function: linear;
    transition-duration: 0.2s;
    transition-property: background-color, color, border-color;
    border: none;
    box-sizing: border-box;
  }
`;
//# sourceMappingURL=BaseClickable.js.map

/***/ }),

/***/ 3922:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseClickable = void 0;
var BaseClickable_1 = __webpack_require__(46733);
Object.defineProperty(exports, "BaseClickable", ({ enumerable: true, get: function () { return BaseClickable_1.BaseClickable; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57867:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavDrawerTextClickable = void 0;
const react_1 = __importDefault(__webpack_require__(96540));
const styles_1 = __webpack_require__(35932);
const types_1 = __webpack_require__(76066);
function NavDrawerTextClickable({ url, label }) {
    return (react_1.default.createElement(styles_1.TextClickableStyled, { component: types_1.Component.TEXT_CLICKABLE, action: null, isActive: false, states: { default: { label } }, target: types_1.TargetType.BLANK, href: url, designSettings: {
            type: types_1.ClickableType.TERTIARY_TEXT,
            scalable: true
        }, layout: types_1.LayoutType.TRIGGERABLE_RIGHT, tabIndex: 0 },
        react_1.default.createElement(styles_1.TextClickableLabelBlock, { areaName: types_1.GridPositionValue.START, hasGap: false },
            react_1.default.createElement(styles_1.TextClickableLabel, null, label))));
}
exports.NavDrawerTextClickable = NavDrawerTextClickable;
//# sourceMappingURL=NavDrawerTextClickable.js.map

/***/ }),

/***/ 35932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateBaseStyles = exports.TextClickableLabelBlock = exports.TextClickableLabel = exports.TextClickableStyled = void 0;
const styled_components_1 = __importStar(__webpack_require__(92168));
const types_1 = __webpack_require__(76066);
const BaseClickable_1 = __webpack_require__(3922);
const utils_1 = __webpack_require__(26865);
const utils_2 = __webpack_require__(66593);
const design_1 = __webpack_require__(75163);
exports.TextClickableStyled = (0, styled_components_1.default)(BaseClickable_1.BaseClickable).withConfig({
    displayName: 'TextClickableStyled',
    shouldForwardProp: (prop) => !['designSettings', 'isActive', 'stateIcon', 'isHighlighted'].includes(prop)
}) `
  display: grid;
  align-items: center;
  grid-template-areas: ${`'${types_1.GridPositionValue.START} ${types_1.GridPositionValue.CENTER} ${types_1.GridPositionValue.END}'`};
  grid-template-columns: ${({ designSettings }) => designSettings?.gridPosition?.gridColumns};
  gap: ${({ label, stateIcon }) => label != null && stateIcon != null ? (0, utils_1.calculateSpacing)(0.5) : 0};

  min-height: ${(0, utils_1.calculateSpacing)(4)};

  @media ${utils_2.mediaQueries.lg} {
    min-height: ${(0, utils_1.calculateSpacing)(5)};
  }

  padding: ${(0, utils_1.calculateSpacing)(1.5)} ${(0, utils_1.calculateSpacing)(1)};

  ${({ designSettings, isActive, isHighlighted }) => getStylesForType(designSettings?.type ?? types_1.ClickableType.PRIMARY_TEXT, designSettings?.scalable ?? false, isActive, isHighlighted)};
`;
exports.TextClickableLabel = styled_components_1.default.span.withConfig({
    displayName: 'TextClickableLabel'
}) `
  position: relative;
  ${({ theme }) => (0, utils_1.textBoxTrimMixin)(theme)}
`;
exports.TextClickableLabelBlock = styled_components_1.default.span.withConfig({
    displayName: 'TextClickableLabelBlock',
    shouldForwardProp: (prop) => !['badgePosition', 'areaName', 'hasGap'].includes(prop)
}) `
  display: flex;
  grid-area: ${({ areaName }) => areaName};
  justify-self: ${({ areaName }) => areaName};
  gap: 0 ${({ hasGap }) => (hasGap ? (0, utils_1.calculateSpacing)(1) : 0)};

  align-items: center;

  ${({ badgePosition }) => {
    if (badgePosition === types_1.GridPositionValue.END) {
        return (0, styled_components_1.css) `
        flex-direction: row-reverse;
      `;
    }
    return '';
}}
`;
// Combines all styles for the TextClickable component
const getStylesForType = (type, scalable, isActive, isHighlighted) => (0, styled_components_1.css) `
  width: ${scalable ? '100%' : 'auto'};
  ${(0, exports.generateBaseStyles)(type, isHighlighted)} /* Update the third param to be a CSS variable */
  ${generateStateStyles(type, isActive, isHighlighted)}
`;
// Generates base styles for different clickable types
const generateBaseStyles = (type, isHighlighted) => {
    return (0, styled_components_1.css) `
    ${generateTypographyStyles(type)};
    color: ${isHighlighted
        ? `var(${design_1.Design.Color.TextNavigationAccent})`
        : getColorForType(type, 'default')};
    background-color: ${getBackgroundColor(type)};

    ${type === types_1.ClickableType.TERTIARY_TEXT &&
        (0, styled_components_1.css) `
      ${exports.TextClickableLabel} {
        &::before {
          content: '';
          position: absolute;
          width: 0;
          background: var(${design_1.Design.Color.TextNavigation});
          bottom: -2px;
          left: 0;
          height: 1px;

          @media (prefers-reduced-motion: no-preference) {
            transition: width 150ms cubic-bezier(0.61, 1, 0.88, 1),
              left 150ms cubic-bezier(0.61, 1, 0.88, 1);
          }
          @media (prefers-reduced-motion: reduce) {
            width: 100%;
            left: 0;
            opacity: 0;
            transition: opacity 150ms cubic-bezier(0.37, 0, 0.63, 1);
          }
        }
      }
    `};
  `;
};
exports.generateBaseStyles = generateBaseStyles;
// Generates typography styles based on the type
const generateTypographyStyles = (type) => {
    const [base] = type.split('-');
    return (0, utils_1.getTypographyStyles)(`typography.definitions.navigation.text-${base}`);
};
// Utility to get color tokens based on the type and state
const getColorForType = (type, state) => {
    const [_, style] = type.split('-');
    const colorMapping = {
        text: {
            default: style === 'filled' ? 'TextNavigationFeature' : 'TextNavigation',
            hover: 'SurfaceHover',
            pressed: 'SurfacePressed',
            active: 'BorderNavigationActive',
            disabled: 'TextDisabled'
        },
        filled: {
            default: style === 'filled' ? 'TextNavigationFeature' : 'TextNavigation',
            hover: 'SurfaceNavigationFeatureBrandHover',
            pressed: 'SurfaceNavigationFeatureBrandPressed',
            active: 'BorderNavigationActive',
            disabled: 'TextNavigationFeature'
        }
    };
    return `var(${design_1.Design.Color[colorMapping[style][state]]})`;
};
// Utility to get background color based on the type
const getBackgroundColor = (type) => {
    if (type.includes('text'))
        return 'transparent';
    if (type.includes('primary')) {
        return `var(${design_1.Design.Color.TextNavigationBrand})`;
    }
    return `var(${design_1.Design.Color.TextNavigationAccent})`;
};
// Generates state styles for hover, focus, active, and disabled, including animations
const generateStateStyles = (type, isActive, isHighlighted) => (0, styled_components_1.css) `
  /* only apply hover styles on devices that support hover */
  @media (hover: hover) {
    &:hover {
      background-color: ${getColorForType(type, 'hover')};
    }
  }

  /* remove hover styles on touch devices */
  @media (hover: none) {
    &:hover {
      /* Reset any hover styles */
      background-color: transparent;
    }
  }

  &:focus-visible {
    &:after {
      border: 2px solid var(${design_1.Design.Color.BorderFocus});
    }
  }

  &:active {
    background-color: ${getColorForType(type, 'pressed')};
  }

  /* ensure active state doesn't persist for touch devices */
  @media (hover: none) {
    transition: background-color 0.1s ease-out;
    -webkit-tap-highlight-color: transparent;
    &:active {
      /* Use a short animation to reset the background */
      animation: resetActiveState 0.3s forwards;
    }
  }

  /* add keyframes for resetting active state */
  @keyframes resetActiveState {
    0% {
      background-color: ${getColorForType(type, 'pressed')};
    }
    100% {
      background-color: transparent;
    }
  }

  &:hover,
  &:active {
    ${type === types_1.ClickableType.TERTIARY_TEXT &&
    (0, styled_components_1.css) `
      ${exports.TextClickableLabel}::before {
        @media (prefers-reduced-motion: no-preference) {
          width: 100%;
          transition: width 200ms cubic-bezier(0.12, 0, 0.39, 0);
        }

        @media (prefers-reduced-motion: reduce) {
          opacity: 1;
          transition: none;
        }
      }
    `};
  }

  ${generateActiveStateStyles(type, isActive)};

  &.disabled {
    pointer-events: none;
    background-color: ${type.includes('filled')
    ? `var(${design_1.Design.Color.TextDisabled})`
    : 'transparent'};
    color: ${isHighlighted
    ? `var(${design_1.Design.Color.TextNavigationAccent})`
    : getColorForType(type, 'disabled')};

    svg path {
      fill: ${getColorForType(type, 'disabled')};
    }
  }
`;
// Active state styles generator, when the current url path is equal the url of the anchor tag
const generateActiveStateStyles = (type, isActive) => (0, styled_components_1.css) `
  position: relative;

  // The active border should exist for all, we add color only when the text clickable is active.
  // This prevent misalignment of active and not active text clickables
  ${({ layout }) => {
    switch (layout) {
        case types_1.LayoutType.TRIGGERABLE_RIGHT:
        case types_1.LayoutType.TRIGGERABLE_LEFT:
            return (0, styled_components_1.css) `
          border-left: 2px solid transparent;
        `;
        case types_1.LayoutType.HORIZONTAL:
            return (0, styled_components_1.css) `
          border-bottom: 2px solid transparent;
        `;
        default:
            return '';
    }
}};

  ${({ layout }) => {
    if (!isActive) {
        return '';
    }
    if (type === types_1.ClickableType.TERTIARY_TEXT) {
        return (0, styled_components_1.css) `
        text-decoration: underline;
      `;
    }
    switch (layout) {
        case types_1.LayoutType.TRIGGERABLE_RIGHT:
        case types_1.LayoutType.TRIGGERABLE_LEFT:
            return (0, styled_components_1.css) `
          border-color: ${getColorForType(type, 'active')};
        `;
        case types_1.LayoutType.HORIZONTAL:
            return (0, styled_components_1.css) `
          border-color: ${getColorForType(type, 'active')};
        `;
        default:
            return '';
    }
}};
`;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 7304:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchClickableType = exports.OneNavTheme = exports.AreaType = exports.TransformerFunction = exports.ActionType = exports.TargetType = exports.ClickableStatus = exports.RowType = exports.IdentityUnitType = exports.LayoutType = exports.ClickableType = exports.Breakpoints = exports.Component = exports.Alignment = void 0;
var Alignment;
(function (Alignment) {
    Alignment["START"] = "start";
    Alignment["CENTER"] = "center";
    Alignment["END"] = "end";
})(Alignment = exports.Alignment || (exports.Alignment = {}));
var Component;
(function (Component) {
    Component["TEXT_CLICKABLE"] = "text-clickable";
    Component["LOGO_CLICKABLE"] = "logo-clickable";
    Component["JOURNEY_UNITS"] = "journey-units";
    Component["CURATION_BANNER"] = "curation-banner";
    Component["RIBBON_BANNER"] = "ribbon-banner";
    Component["IDENTITY_UNITS"] = "identity-units";
    Component["ACCORDION"] = "accordion";
    Component["STICKY_HERO_AD"] = "sticky-hero-ad";
    Component["NOTIFICATION_BANNER"] = "notification-banner";
    Component["SEARCH_CLICKABLE"] = "search-clickable";
    /** REMOVE AFTER CURATION BANNER EXPERIMENT IS DONE */
    Component["FAKE_CURATION_BANNER"] = "fake-curation-banner";
})(Component = exports.Component || (exports.Component = {}));
var Breakpoints;
(function (Breakpoints) {
    Breakpoints["SM"] = "sm";
    Breakpoints["MD"] = "md";
    Breakpoints["LG"] = "lg";
    Breakpoints["XL"] = "xl";
    Breakpoints["XXL"] = "xxl";
    Breakpoints["XXXL"] = "xxxl";
})(Breakpoints = exports.Breakpoints || (exports.Breakpoints = {}));
var ClickableType;
(function (ClickableType) {
    ClickableType["PRIMARY_FILLED"] = "primary-filled";
    ClickableType["PRIMARY_TEXT"] = "primary-text";
    ClickableType["SECONDARY_FILLED"] = "secondary-filled";
    ClickableType["SECONDARY_TEXT"] = "secondary-text";
    ClickableType["TERTIARY_TEXT"] = "tertiary-text";
    ClickableType["LABEL_TEXT"] = "label-text";
})(ClickableType = exports.ClickableType || (exports.ClickableType = {}));
var LayoutType;
(function (LayoutType) {
    LayoutType["HORIZONTAL"] = "horizontal";
    LayoutType["TRIGGERABLE_TOP"] = "triggerable-top";
    LayoutType["TRIGGERABLE_LEFT"] = "triggerable-left";
    LayoutType["TRIGGERABLE_RIGHT"] = "triggerable-right";
})(LayoutType = exports.LayoutType || (exports.LayoutType = {}));
var IdentityUnitType;
(function (IdentityUnitType) {
    IdentityUnitType["DROPDOWN_TRIGGER"] = "dropdown_trigger";
    IdentityUnitType["DROPDOWN"] = "dropdown";
    IdentityUnitType["DRAWER_LINKS"] = "drawer_links";
})(IdentityUnitType = exports.IdentityUnitType || (exports.IdentityUnitType = {}));
var RowType;
(function (RowType) {
    RowType["DEFAULT"] = "default";
    RowType["HERO_AD"] = "heroAd";
    RowType["NO_STYLE"] = "no-style";
})(RowType = exports.RowType || (exports.RowType = {}));
var ClickableStatus;
(function (ClickableStatus) {
    ClickableStatus["ACTIVE"] = "active";
    ClickableStatus["DISABLED"] = "disabled";
    ClickableStatus["DEFAULT"] = "default";
})(ClickableStatus = exports.ClickableStatus || (exports.ClickableStatus = {}));
var TargetType;
(function (TargetType) {
    TargetType["BLANK"] = "_blank";
    TargetType["SELF"] = "_self";
})(TargetType = exports.TargetType || (exports.TargetType = {}));
var ActionType;
(function (ActionType) {
    ActionType["LINK"] = "link";
    ActionType["TRIGGER"] = "trigger";
    ActionType["ACCORDION"] = "accordion";
    ActionType["SEQ_LEVEL"] = "seq-level";
    ActionType["TRIGGER_AND_SEQ_LEVEL"] = "trigger-and-seq-level";
})(ActionType = exports.ActionType || (exports.ActionType = {}));
var TransformerFunction;
(function (TransformerFunction) {
    TransformerFunction["TRANSFORM_NAVIGATION_LINKS"] = "transformNavigationLinks";
    TransformerFunction["TRANSFORM_SEQUENTIAL_LEVELS"] = "transformSeqLevels";
})(TransformerFunction = exports.TransformerFunction || (exports.TransformerFunction = {}));
var AreaType;
(function (AreaType) {
    AreaType["HEADER"] = "header";
    AreaType["CTA"] = "cta";
    AreaType["DEFAULT"] = "default";
})(AreaType = exports.AreaType || (exports.AreaType = {}));
var OneNavTheme;
(function (OneNavTheme) {
    OneNavTheme["STANDARD"] = "standard";
    OneNavTheme["INVERTED"] = "inverted";
    OneNavTheme["SOFTLINEN"] = "soft-linen";
})(OneNavTheme = exports.OneNavTheme || (exports.OneNavTheme = {}));
var SearchClickableType;
(function (SearchClickableType) {
    SearchClickableType["DRAWER"] = "drawer";
    SearchClickableType["TOP_NAVBAR"] = "top_navbar";
})(SearchClickableType = exports.SearchClickableType || (exports.SearchClickableType = {}));
//# sourceMappingURL=enums.js.map

/***/ }),

/***/ 76066:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(7304), exports);
__exportStar(__webpack_require__(6463), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6463:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GridPositionValue = void 0;
/** Clickables */
var GridPositionValue;
(function (GridPositionValue) {
    GridPositionValue["START"] = "start";
    GridPositionValue["CENTER"] = "center";
    GridPositionValue["END"] = "end";
})(GridPositionValue = exports.GridPositionValue || (exports.GridPositionValue = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 86485:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnowplowEvent = void 0;
const snowplow_tracking_1 = __webpack_require__(14307);
const types_1 = __webpack_require__(35435);
class SnowplowEvent {
    static trackClickable(data, schema) {
        const { subject = null, label = null, event, isWithoutContentData, trackingStatus } = data;
        const items = SnowplowEvent.getClickableContentData(event, isWithoutContentData);
        const type = SnowplowEvent.getClickableTrackingType(trackingStatus);
        switch (schema) {
            case types_1.TrackingSchemaType.USER_ACCOUNT_EVENT:
                return (0, snowplow_tracking_1.trackUserAccountEvent)({
                    subject,
                    label,
                    type
                });
            default:
                return (0, snowplow_tracking_1.trackNavigationEvent)({
                    subject,
                    label,
                    type,
                    items,
                    placement: SnowplowEvent.POSITION_TOP
                });
        }
    }
    static getClickableContentData(event, isWithoutContentData) {
        if (isWithoutContentData) {
            return undefined;
        }
        const target = event.currentTarget;
        const contentTitle = target.querySelector(SnowplowEvent.SNOWPLOW_ITEM_ATTRIBUTE)?.textContent;
        return [
            {
                content_title: contentTitle,
                content_url: target?.href
            }
        ];
    }
    static getClickableTrackingType(trackingStatus) {
        if (typeof trackingStatus === 'boolean') {
            /** Note: The trackingType is set to 'close' when the status is true.
             This is because the trackingType represents the upcoming action:
             When the tracking item is currently open and about to be closed,
             we prepare to track this future 'close' event. */
            return trackingStatus ? types_1.TrackingType.CLOSE : types_1.TrackingType.OPEN;
        }
        return types_1.TrackingType.CLICK;
    }
    static trackBannerClick(data) {
        const { subject, label, content_url, index, total_index } = data;
        (0, snowplow_tracking_1.trackNavigationEvent)({
            subject,
            label: String(label),
            type: types_1.TrackingType.CLICK,
            total_index,
            index,
            items: [
                {
                    content_title: label,
                    content_url,
                    content_type: 'link'
                }
            ],
            placement: SnowplowEvent.POSITION_TOP
        });
    }
}
SnowplowEvent.SNOWPLOW_ITEM_ATTRIBUTE = '[data-snowplow-event-label]';
SnowplowEvent.POSITION_TOP = 'top';
exports.SnowplowEvent = SnowplowEvent;
//# sourceMappingURL=SnowplowEvent.js.map

/***/ }),

/***/ 64886:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnowplowEvent = void 0;
var SnowplowEvent_1 = __webpack_require__(86485);
Object.defineProperty(exports, "SnowplowEvent", ({ enumerable: true, get: function () { return SnowplowEvent_1.SnowplowEvent; } }));
__exportStar(__webpack_require__(35435), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 35435:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrackingSchemaType = exports.TrackingType = exports.BannerTrackingSubject = exports.ClickableTrackingSubject = void 0;
var ClickableTrackingSubject;
(function (ClickableTrackingSubject) {
    ClickableTrackingSubject["LOGO_CLICKABLE"] = "LogoClickable";
    ClickableTrackingSubject["TEXT_CLICKABLE"] = "TextClickable";
    ClickableTrackingSubject["ACCORDION"] = "hamburger_menu_submenu";
    ClickableTrackingSubject["SEQ_LEVEL"] = "hamburger_menu_chevron";
    ClickableTrackingSubject["SEQ_LEVEL_CTA"] = "hamburger_menu_chevron_submenu";
})(ClickableTrackingSubject = exports.ClickableTrackingSubject || (exports.ClickableTrackingSubject = {}));
var BannerTrackingSubject;
(function (BannerTrackingSubject) {
    BannerTrackingSubject["BANNER_CURATION"] = "banner_curation";
    BannerTrackingSubject["BANNER_PROMOTION"] = "banner_promotion";
    BannerTrackingSubject["BANNER_EVENT"] = "banner_event";
})(BannerTrackingSubject = exports.BannerTrackingSubject || (exports.BannerTrackingSubject = {}));
var TrackingType;
(function (TrackingType) {
    TrackingType["OPEN"] = "open";
    TrackingType["CLOSE"] = "close";
    TrackingType["CLICK"] = "click";
    TrackingType["IMPRESSION"] = "impression";
})(TrackingType = exports.TrackingType || (exports.TrackingType = {}));
var TrackingSchemaType;
(function (TrackingSchemaType) {
    TrackingSchemaType["USER_ACCOUNT_EVENT"] = "user_account_event";
})(TrackingSchemaType = exports.TrackingSchemaType || (exports.TrackingSchemaType = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 75254:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.minThresholds = exports.mediaQueries = exports.breakpointSizes = void 0;
const types_1 = __webpack_require__(76066);
const breakpoints_1 = __importDefault(__webpack_require__(55058));
exports.breakpointSizes = {
    [types_1.Breakpoints.SM]: breakpoints_1.default.minThresholds.sm,
    [types_1.Breakpoints.MD]: breakpoints_1.default.minThresholds.md,
    [types_1.Breakpoints.LG]: breakpoints_1.default.minThresholds.lg,
    [types_1.Breakpoints.XL]: breakpoints_1.default.minThresholds.xl,
    [types_1.Breakpoints.XXL]: breakpoints_1.default.minThresholds.xxl,
    [types_1.Breakpoints.XXXL]: breakpoints_1.default.minThresholds.xxxl // 1600 and above
};
exports.mediaQueries = {
    [types_1.Breakpoints.SM]: `(min-width: ${exports.breakpointSizes[types_1.Breakpoints.SM]}px)`,
    [types_1.Breakpoints.MD]: `(min-width: ${exports.breakpointSizes[types_1.Breakpoints.MD]}px)`,
    [types_1.Breakpoints.LG]: `(min-width: ${exports.breakpointSizes[types_1.Breakpoints.LG]}px)`,
    [types_1.Breakpoints.XL]: `(min-width: ${exports.breakpointSizes[types_1.Breakpoints.XL]}px)`,
    [types_1.Breakpoints.XXL]: `(min-width: ${exports.breakpointSizes[types_1.Breakpoints.XXL]}px)`,
    [types_1.Breakpoints.XXXL]: `(min-width: ${exports.breakpointSizes[types_1.Breakpoints.XXXL]}px)` // from 1600px up
};
exports.minThresholds = {
    sm: exports.breakpointSizes[types_1.Breakpoints.SM],
    md: exports.breakpointSizes[types_1.Breakpoints.MD],
    lg: exports.breakpointSizes[types_1.Breakpoints.LG],
    xl: exports.breakpointSizes[types_1.Breakpoints.XL],
    xxl: exports.breakpointSizes[types_1.Breakpoints.XXL],
    xxxl: exports.breakpointSizes[types_1.Breakpoints.XXXL]
};
//# sourceMappingURL=breakpoints.js.map

/***/ }),

/***/ 70346:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useIsCSR = void 0;
const react_1 = __webpack_require__(96540);
/**
 * Directly using the `window` object to check whether we are in CSR (Client-Side Rendering)
 * or SSR (Server-Side Rendering) causes additional rendering in the Base Page, which leads to issues
 * with the Ad component.
 *
 * To address this, we use a state variable.
 */
function useIsCSR() {
    const [isCSR, setIsCSR] = (0, react_1.useState)(false);
    (0, react_1.useEffect)(() => {
        setIsCSR(true);
    }, []);
    return isCSR;
}
exports.useIsCSR = useIsCSR;
//# sourceMappingURL=hooks.js.map

/***/ }),

/***/ 66593:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useIsCSR = void 0;
__exportStar(__webpack_require__(75254), exports);
__exportStar(__webpack_require__(64886), exports);
var hooks_1 = __webpack_require__(70346);
Object.defineProperty(exports, "useIsCSR", ({ enumerable: true, get: function () { return hooks_1.useIsCSR; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 66045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(16718)/* ["default"] */ .A);
const { trackNavigationEvent } = __webpack_require__(14307);
const { ItemCount, PaginationContent, PaginationButtonWrapper, PageSummary, PaginationWrapper } = __webpack_require__(51908);
const Button = __webpack_require__(73730);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Renders the controls for pagination
 *
 * @param {object} props - React props
 * @param {Array} props.additionalParams - Optional array of additional query params required in pagination
 * @param {string} props.buttonVariation - Props to get the pagination button variations
 * @param {string} props.btnStyle - styling button variations
 * @param {string} props.filter - The page filter
 * @param {string} props.content - The current page we are on
 * @param {number} props.currentPage - The current page we are on
 * @param {number} props.limit - The number of items per page
 * @param {string} [props.nextPageURL] - Optional next page url utilized in triggering the useEffect hook to update links
 * @param {string} [props.previousPageUrl] - Optional previous page url
 * @param {string} props.query - Optional query param
 * @param {string} [props.searchTerm] - Optional searched word in query
 * @param {boolean} props.shouldDisplayItemCount - Option to show/hide item count
 * @param {string} props.sort - The page sort
 * @param {number} props.totalResults - The total number of items that we can paginate through
 */
const PaginationModal = ({ additionalParams = [], btnStyle = 'filled', buttonVariation = 'Primary', content, currentPage, filter, limit, nextPageURL, previousPageUrl, query, searchTerm, shouldDisplayItemCount = true, sort, totalResults }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'PaginationModal'
        });
    }, []);
    const [prevButtonLink, setPrevButtonLink] = React.useState('');
    const [nextButtonLink, setNextButtonLink] = React.useState('');
    const { formatMessage } = useIntl();
    const totalPages = Math.ceil(totalResults / limit);
    const loadedPage = currentPage < 1 || currentPage > totalPages ? 1 : currentPage;
    React.useEffect(() => {
        if (true) {
            const path = window?.location?.pathname;
            const urlSearchParams = new URLSearchParams(window.location.search);
            const params = [];
            additionalParams.forEach((key) => {
                const queryValue = urlSearchParams.get(key);
                if (queryValue)
                    params.push(`${key}=${queryValue}`);
            });
            if (searchTerm) {
                params.push(`q=${searchTerm}`);
            }
            if (filter) {
                params.push(`filter=${filter}`);
            }
            if (sort) {
                params.push(`sort=${sort}`);
            }
            if (query) {
                params.push(`query=${query}`);
            }
            if (content) {
                params.push(`content=${content}`);
            }
            const prevParams = [...params];
            if (loadedPage - 1 > 1) {
                prevParams.push(`page=${loadedPage - 1}`);
            }
            if (path) {
                setPrevButtonLink(`${path}${prevParams.length > 0 ? `?${prevParams.join('&')}` : ''}`);
            }
            if (nextPageURL) {
                setNextButtonLink(nextPageURL);
                return;
            }
            const nextParams = [...params, `page=${loadedPage + 1}`];
            setNextButtonLink(`?${nextParams.join('&')}`);
        }
    }, [
        additionalParams,
        loadedPage,
        filter,
        sort,
        nextPageURL,
        searchTerm,
        content,
        query
    ]);
    if (!currentPage || !limit || !totalResults)
        return null;
    const DisablePreviousButton = loadedPage < 2;
    const DisableNextButton = loadedPage * limit >= totalResults;
    const nextBtnStyle = DisableNextButton ? 'text' : btnStyle;
    const prevBtnStyle = DisablePreviousButton ? 'text' : btnStyle;
    const NextButtonComponent = DisableNextButton
        ? Button.Utility
        : Button[buttonVariation];
    const PreviousButtonComponent = DisablePreviousButton
        ? Button.Utility
        : Button[buttonVariation];
    const pageStartingItem = (loadedPage - 1) * limit + 1;
    const pageLastItem = loadedPage < totalPages ? loadedPage * limit : totalResults;
    if (loadedPage > totalPages) {
        return null;
    }
    const trackSnowplowEvent = (e) => {
        const eventData = {
            type: 'click',
            label: e.target.innerText,
            subject: 'pagination',
            placement: 'bottom'
        };
        trackNavigationEvent(eventData);
    };
    return (React.createElement(PaginationWrapper, null,
        shouldDisplayItemCount && (React.createElement(ItemCount, null,
            pageStartingItem,
            "-",
            pageLastItem,
            " of ",
            totalResults,
            " items")),
        totalPages > 1 && (React.createElement(PaginationContent, null,
            React.createElement(PaginationButtonWrapper, { isDisabled: DisablePreviousButton }, loadedPage - 1 === 0 ? (React.createElement(PreviousButtonComponent, { btnStyle: prevBtnStyle, inputKind: "link", isLinkDisabled: DisablePreviousButton, label: formatMessage(translations.previousPage), onClickHandler: trackSnowplowEvent })) : (React.createElement(PreviousButtonComponent, { btnStyle: prevBtnStyle, inputKind: "link", isLinkDisabled: DisablePreviousButton, href: previousPageUrl || prevButtonLink, label: formatMessage(translations.previousPage), onClickHandler: trackSnowplowEvent }))),
            React.createElement(PageSummary, null,
                loadedPage,
                " of ",
                totalPages),
            React.createElement(PaginationButtonWrapper, { isDisabled: DisableNextButton },
                React.createElement(NextButtonComponent, { btnStyle: nextBtnStyle, inputKind: DisableNextButton ? 'button' : 'link', isLinkDisabled: DisableNextButton, href: nextButtonLink || nextPageURL, label: formatMessage(translations.nextPage), onClickHandler: trackSnowplowEvent }))))));
};
PaginationModal.propTypes = {
    additionalParams: PropTypes.array,
    btnStyle: PropTypes.string,
    buttonVariation: PropTypes.string,
    content: PropTypes.string,
    currentPage: PropTypes.number.isRequired,
    filter: PropTypes.string,
    limit: PropTypes.number.isRequired,
    nextPageURL: PropTypes.string,
    previousPageUrl: PropTypes.string,
    query: PropTypes.string,
    searchTerm: PropTypes.string,
    shouldDisplayItemCount: PropTypes.bool,
    sort: PropTypes.string,
    totalResults: PropTypes.number.isRequired
};
module.exports = PaginationModal;
//# sourceMappingURL=PaginationModal.js.map

/***/ }),

/***/ 49312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PaginationModal = __webpack_require__(66045);
module.exports = PaginationModal;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 51908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const { BaseWrap } = __webpack_require__(76955);
const PaginationWrapper = styled(BaseWrap).withConfig({
    displayName: 'PaginationWrapper'
}) ``;
const ItemCount = styled.div.withConfig({
    displayName: 'ItemCount'
}) `
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  margin: 0 0 ${calculateSpacing(4)};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.label')};
`;
const PaginationContent = styled.div.withConfig({
    displayName: 'PaginationContent'
}) `
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
  margin-top: ${calculateSpacing(1)};
`;
const disabledStyles = ({ theme }) => {
    return css `
    cursor: default;
    pointer-events: none;

    a,
    button {
      ${getColorStyles(theme, 'background', 'colors.interactive.base.light')};
      ${getColorStyles(theme, 'color', 'colors.interactive.base.white')};
      ${getTypographyStyles(theme, 'typography.definitions.utility.button-core')};
    }
  `;
};
const PaginationButtonWrapper = styled.div.withConfig({
    displayName: 'PaginationButtonWrapper'
}) `
  ${({ isDisabled, theme }) => isDisabled && disabledStyles({ theme })};
`;
const PageSummary = styled.div
    .withConfig({
    displayName: 'PageSummary'
})
    .attrs({ 'data-testid': 'page-summary' }) `
    margin: 0 ${calculateSpacing(2.5)};
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.label')};
`;
module.exports = {
    ItemCount,
    PaginationContent,
    PaginationButtonWrapper,
    PageSummary,
    PaginationWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 16718:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    nextPage: {
        id: 'PaginationModal.NextPage',
        defaultMessage: 'Next',
        description: 'The button label'
    },
    previousPage: {
        id: 'PaginationModal.PreviousPage',
        defaultMessage: 'Previous',
        description: 'The button label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 98531:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { connect: connectToStore } = __webpack_require__(67851);
const { useIntl } = __webpack_require__(46984);
const ViewportMonitor = __webpack_require__(3990);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const RecircListTextOverlay = __webpack_require__(69122);
const RecircListDefaultOverlay = __webpack_require__(92932);
const { googleAnalytics } = __webpack_require__(90090);
const translations = (__webpack_require__(4149)/* ["default"] */ .A);
const { attemptAdInjection } = __webpack_require__(1184);
const { getTitle, getPageSize, checkIsSmallScreen, getSummaryItemVariation, addPropsFromConfig, getSubjectVersion } = __webpack_require__(49380);
const { HandleRecommendations } = __webpack_require__(74147);
const { useResizeObserver } = __webpack_require__(70251);
const RecircListExtendedOverlay = __webpack_require__(13643);
const { RecircListWrapper } = __webpack_require__(8851);
const SkeletonLoader = __webpack_require__(87623);
const useClientRequest = __webpack_require__(77314);
/**
 * RecircList component
 *
 * @param {object} props - React props
 * @param {string} [props.bylineVariation] - Optional variation of byline
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.heading] - Optional heading text
 * @param {object} [props.customHeading] - Optional. If defined, indicates categories where to use custom heading.
 * @param {string} [props.customHeading.heading] - Custom heading.
 * @param {Array} [props.customHeading.categoriesURL] - Categories where to use custom heading.
 * @param {object} [props.experimentData] - GrowthBook experiment data.
 * @param {string} [props.experimentName] - Name of the enabled experiment.
 * @param {object} [props.experimentRelated] - An object containing a key with the experiment name and a value that is a list of items related to the experiment.
 * @param {boolean} [props.hasItemsRule] - Optional. Show or should hide the decorative rule on SummaryItem(s).
 * @param {number} [props.pageSize] - Optional page size
 * @param {number} [props.mobilePageSize] - Optional mobile device page size
 * @param {Array} [props.recircRelated] - Optional list to show bottom recirc unit data
 * @param {Array} [props.recircRelatedCrossBrand] - Optional list to show bottom recirc unit data with cross brand recommendations
 * @param {Array<Related>} [props.related] - Array of related recirculated articles, can be empty, in which case we request recommendations via the API on client side
 * @param {boolean} [props.shouldDisableReadMoreAd] - Optional flag to disable sponsored content from recirc list
 * @param {boolean} [props.shouldHideBylines] - Optional flag to hide bylines
 * @param {boolean} [props.shouldHideIcon] - Optional flag to hide icon on item
 * @param {boolean} [props.shouldHideRubric] - Optional shouldHideRubric component setting
 * @param {string} [props.showHeadTagAsForRecirc] - Optional heading tag setting for recirc units
 * @param {boolean} [props.shouldReduceHedSpacingInDense] - Optional flag to reduce the space between the hed and rubric in the dense layout of the SummaryItem component.
 * @param {string} [props.shouldUseDiscoveryHedToken] - Optional to use discovery token for SummaryItemHed
 * @param {string} [props.shouldUseDiscoveryColorToken] - Optional to use discovery color token for subHed
 * @param {object} [props.variations] - Variation properties used in rendering the component.
 * @param {string} [props.strategy] - Optional strategy
 * @param {string} [props.summaryItemVariation] - Optional prop to control summary item variation, defaults value would depend on "isLayoutTextOverlay" setting
 * @param {boolean} [props.variations.hasBackground] - Optional. Specifies that component should have a background
 * @param {boolean} [props.variations.hasAdBottomMargin] -  Has bottom padding of 2rem to Ad
 * @param {string} [props.variations.layout] - Optional. Specifies that component should use four up or text-overlay treatment
 * @param {boolean} [props.variations.shouldLazyLoadImages] - Optional should lazy load images
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.dividerColor] - Optional prop to get divider color for article page from copilot
 * @param {bool} [props.shouldDisplayImageCount] - Optional boolean to display image slide count in recirc unit (default to false)
 * @param {boolean} [props.hasBottomSpacing] - Add bottom spacing to the individual content
 * @param {boolean} [props.hasTopAndBottomPadding] - Add top and bottom spacing to the individual content
 * @param {boolean} [props.hasMobileItemSpacing] - Add spacing to the individual content
 * @param {string} [props.mobileSummaryItemVariation] - Optional prop to control summary item variation on tablet and mobile, defaults will be summaryItemVariation
 * @param {boolean} [props.isRecircExtendedEnabled] - Optional boolean to display recirclist extended overlay component
 * @param {string} [props.extendedStrategyLayout] - Optional string to display RecircListExtendedOverlay based on the strategy
 * @param {boolean} [props.hasNoBottomTitleSpacing] - removes bottom space from the title
 * @param {boolean} [props.isSimilaritySplitEnabled] - Optional boolean to display recirclist extended overlay component with similarity split
 * @param {object} [props.recommended] - Recommended object
 * @param {boolean} [props.shouldHideMetadataSecondary] - Optional boolean to hide MetadataSecondary
 * @param {boolean} [props.shouldChangeBiTokenMsExp] - Optional boolean will change the BI token to subhed-section-primary (only for the experiment , do not use this for anything else)
 * @param {number} [props.textOverlayExperiment.gridColumnCount] - Optional provides number of columns for the recirclistTextOverlay grid layout (only for the textoverlay experiment , do not use this for anything else)
 * @param {boolean} [props.textOverlayExperiment.isEnabled] - Optional provides boolean value that determines if the experiment is enabled (only for the textoverlay experiment , do not use this for anything else)
 * @param {number} [props.sectionTitleFontSize] - Optional fontsize for the section title (only for the experiment , do not use this for anything else)
 * @param {string} [props.summaryItemAlignment] - Optional alignment of the summary Item content(only for the experiment , do not use this for anything else)
 * @param {boolean} [props.hasDividerAbove] - Optional boolean determines if a divider is displayed above the header (only for the experiment , do not use this for anything else)
 * @param {boolean} [props.hasDividerBelow] - Optional boolean determines if a divider is displayed below the header (only for the experiment , do not use this for anything else)
 * @param {object} [props.recircRenditions] - Optional renditions object for recirc list
 * @param {object} [props.recircListTextOverlayRenditions] - Optional renditions object for recirc list text overlay
 * @param {object} [props.recircListConfig] - Optional recirc list config object
 * @param {object} [props.recircListExtendedOverlayConfig] - Optional recirc list extended overlay config object
 * @param {string} [props.vulcanUrl] - Optional vulcan url
 * @param {string} [props.contentID] - Optional content id
 * @param {string} [props.contentType] - Optional content type
 * @param {string} [props.recommendationsApiUrl] - Optional recommendations API URL
 * @param {string} [props.brandSlug] - Optional brand slug
 * @param {string} [props.canonicalUrl] - Optional canonical URL
 * @param {string} [props.language] - Optional language
 * @param {boolean} [props.shouldUseTrailingSlash] - Optional trailing slash
 * @param {Array} [props.copilotExperimentRelated] - Array of related recirculated articles, can be empty, in which case we request recommendations via the API on client side
 * @param {boolean} [props.isOneToOneImageVariant] - Optional boolean to use image one to one ratio for recirc data
 * @param {number} [gridColumnCount] - Optional provides number of columns for the recirclistTextOverlay grid layout
 *
 * @returns {ReactElement} <div>
 */
const RecircList = (props) => {
    const { bylineVariation, className, experimentData, experimentName = '', experimentRelated = {}, hasItemsRule = true, heading, customHeading, mobilePageSize, recommended, shouldEnableFullArticleInverted, shouldDisableReadMoreAd = false, shouldHideBylines, shouldHideIcon, shouldHideRubric = false, shouldDisplayImageCount = false, shouldReduceHedSpacingInDense = false, shouldUseDiscoveryHedToken = false, shouldUseDiscoveryColorToken = false, showHeadTagAsForRecirc, dividerColor, mobileSummaryItemVariation, variations = {
        hasBackground: false,
        layout: 'four-up',
        shouldLazyLoadImages: true
    }, variationName, categoriesMap, hasBottomSpacing = false, // Cross-brand recommendation experiment
    hasTopAndBottomPadding = true, hasMobileItemSpacing = false, shouldHideDangerousDek = false, isRecircExtendedEnabled = false, extendedStrategyLayout = '', hasNoBottomTitleSpacing = false, isSimilaritySplitEnabled = false, shouldHideMetadataSecondary = false, shouldChangeBiTokenMsExp = true, sectionTitleFontSize, summaryItemAlignment, hasDividerAbove = true, hasDividerBelow = true, vulcanUrl, contentID, contentType, recircListConfig, recircListExtendedOverlayConfig, recommendationsApiUrl, brandSlug, canonicalUrl, language, shouldUseTrailingSlash, recircRenditions, extendedRecircRightRailRenditions, isOneToOneImageVariant = false, shouldEnableCSRFeature, // From Verso settings,
    gridColumnCount } = props;
    const [isSmallScreen, setIsSmallScreen] = React.useState(false);
    /** CSR  - Client side rendering */
    const csrProps = {
        vulcanUrl,
        contentID,
        contentType,
        recommendationsApiUrl,
        brandSlug,
        language,
        isSmallScreen,
        canonicalUrl,
        shouldUseTrailingSlash,
        photoConfig: recircRenditions
    };
    const { recircClientLoading = false, recircListClientData = [], extendedRecircClientData = [] } = useClientRequest(shouldEnableCSRFeature === true
        ? {
            ...csrProps,
            ...(recircListConfig?.settings || {}),
            isExtendedRecirc: isRecircExtendedEnabled && extendedStrategyLayout,
            extendedRecircItemsConfig: recircListExtendedOverlayConfig?.settings || {},
            ...(extendedStrategyLayout === 'DesktopSideRail'
                ? { extendedRecircRightRailRenditions }
                : {})
        }
        : {});
    /** End CSR  - Client side rendering */
    // Note :we have a techdev ticket where all these experiment related props will be moved to the config
    // https://cnissues.atlassian.net/jira/software/c/projects/CG/boards/1016/backlog?selectedIssue=CG-4525
    const defaultTextOverlayExperimentProp = {
        gridColumnCount: null,
        isEnabled: false
    };
    const textOverlayExperimentConfig = {
        ...defaultTextOverlayExperimentProp,
        ...(props.textOverlayExperiment || {})
    };
    // Update device type on window resize
    useResizeObserver(() => setIsSmallScreen(checkIsSmallScreen()));
    // Update device type on initial component mount
    React.useEffect(() => {
        setIsSmallScreen(checkIsSmallScreen());
    }, [props.pageSize, mobilePageSize]);
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'RecircList',
            variation: variationName
        });
    }, [variationName]);
    const pageSize = getPageSize(isSmallScreen, mobilePageSize, props.pageSize);
    const subjectVersion = getSubjectVersion(isSmallScreen);
    const summaryItemVariation = getSummaryItemVariation(isSmallScreen, mobileSummaryItemVariation, props.summaryItemVariation);
    // Related items mapped in Copilot, slicing the array if the count exceeds `pageSize`.
    const related = React.useMemo(() => {
        const items = props.related ?? [];
        if (items.length > pageSize) {
            return items?.slice(0, pageSize);
        }
        return items;
    }, [pageSize, props.related]);
    // Related items mapped in Copilot, slicing the array if the count exceeds `pageSize`.
    const copilotExperimentRelated = React.useMemo(() => {
        const items = props.copilotExperimentRelated ?? [];
        if (items.length > pageSize) {
            return items?.slice(0, pageSize);
        }
        return items;
    }, [pageSize, props.copilotExperimentRelated]);
    // Both transformers return the same data; only the image rendition differs.
    // The experimental data source happens to use 1:1 ratio images.
    const copilotRecircData = isOneToOneImageVariant && textOverlayExperimentConfig.isEnabled
        ? copilotExperimentRelated
        : related;
    let finalRecircData;
    if (shouldEnableCSRFeature) {
        finalRecircData = recircListClientData;
    }
    else {
        finalRecircData = props.recircRelated;
    }
    // Items from the Recommendation API, adjusted to fill the remaining space based on `pageSize` and `related` length.
    const recircRelated = React.useMemo(() => {
        const recircData = experimentName && experimentRelated[experimentName]?.length
            ? experimentRelated[experimentName]
            : finalRecircData;
        return new HandleRecommendations({
            pageSize,
            related: copilotRecircData
        }).prepareData(recircData);
    }, [
        experimentName,
        experimentRelated,
        finalRecircData,
        pageSize,
        copilotRecircData
    ]);
    const { formatMessage } = useIntl();
    const trackEvent = googleAnalytics.emitUniqueGoogleTrackingEvent;
    const isLayoutTextOverlay = variations.layout === 'text-overlay';
    // tell the ads lib to check again for ad placeholders that are eligible
    React.useEffect(() => {
        if (recircRelated && recircRelated.length) {
            attemptAdInjection('read_more');
        }
    }, [recircRelated]);
    const title = getTitle(heading || formatMessage(translations.readMore), customHeading, categoriesMap, recommended, recircRelated);
    const getSectionTitleText = () => {
        if (isRecircExtendedEnabled && extendedStrategyLayout) {
            return heading || formatMessage(translations.moreLikeThis);
        }
        return title;
    };
    const callSnowplowEvent = (item, index, totalItems) => {
        const recircItemData = {
            type: 'click',
            label: getSectionTitleText(),
            subject: 'recirc_unit',
            strategy: extractStrategyFromURL(item.url),
            placement: 'bottom_recirc',
            subject_version: subjectVersion,
            items: [
                {
                    content_id: item.contentId,
                    content_title: item.dangerousHed,
                    content_type: item.contentType.toLowerCase(),
                    content_url: item.url
                }
            ],
            index,
            total_index: totalItems
        };
        trackNavigationEvent(recircItemData);
    };
    /**
     * addClickEventHandlerToRelatedItems adds click handler event to related items
     *
     * @param {Array<objects>} items - list of related items
     * @param {string} type - value of `recirc-curation` type to send to GA
     * @returns {undefined} - nothing
     */
    function addClickEventHandlerToRelatedItems(type, items = []) {
        return items.map((item, index) => {
            return {
                ...item,
                clickHandler: () => {
                    trackEvent('recirc-endof-click', {
                        'gtm.elementUrl': item.url,
                        'recirc-variation': variations.layout,
                        'recirc-curation': type
                    });
                    callSnowplowEvent(item, index, items.length);
                }
            };
        });
    }
    const onIntersectionViewport = (isInViewport, unobserveIntersection) => {
        if (!isInViewport) {
            return;
        }
        unobserveIntersection();
        trackEvent('recirc-endof-impression', {
            'recirc-variation': variations.layout
        });
    };
    const currentExtendedStrategyLayout = isRecircExtendedEnabled
        ? extendedStrategyLayout
        : '';
    const consolidatedRecircItems = [...copilotRecircData, ...recircRelated].map((item) => addPropsFromConfig(item, shouldHideRubric, variations));
    let recircItems = isSimilaritySplitEnabled
        ? consolidatedRecircItems.slice(0, 4)
        : consolidatedRecircItems;
    recircItems = [...addClickEventHandlerToRelatedItems('', recircItems)];
    const componentProps = {
        className,
        heading: getSectionTitleText(),
        hasBackground: variations.hasBackground,
        hasAdBottomMargin: variations.hasAdBottomMargin || false,
        hasItemsRule,
        layout: variations.layout,
        shouldDisableReadMoreAd,
        shouldHideBylines,
        shouldHideIcon,
        shouldDisplayImageCount,
        showHeadTagAsForRecirc,
        summaryItemVariation,
        hasBottomSpacing,
        hasTopAndBottomPadding,
        hasMobileItemSpacing,
        experimentData,
        shouldHideDangerousDek,
        shouldHideMetadataSecondary
    };
    const handleSummaryCollectionGridVariation = () => {
        let variation = 'FourColumns';
        if (isRecircExtendedEnabled) {
            switch (extendedStrategyLayout) {
                case 'DesktopSideRail':
                    variation = !isSmallScreen ? 'ThreeColumns' : 'FourColumns';
                    break;
                default:
                    variation = 'FourColumns';
            }
        }
        return variation;
    };
    if (recircClientLoading) {
        return React.createElement(SkeletonLoader, null);
    }
    const componentToRender = isLayoutTextOverlay ? (React.createElement(RecircListTextOverlay, { ...componentProps, items: recircItems, sectionTitleLabel: getSectionTitleText(), subjectVersion: subjectVersion, gridColumnCount: gridColumnCount, isExperimentEnabled: textOverlayExperimentConfig.isEnabled })) : (React.createElement(RecircListWrapper, { extendedStrategyLayout: currentExtendedStrategyLayout, shouldChangeBiTokenMsExp: shouldChangeBiTokenMsExp, sectionTitleFontSize: sectionTitleFontSize, summaryItemAlignment: summaryItemAlignment, hasDividerAbove: hasDividerAbove, hasDividerBelow: hasDividerBelow },
        React.createElement(RecircListDefaultOverlay, { ...componentProps, items: recircItems, bylineVariation: bylineVariation, dividerColor: dividerColor, shouldEnableFullArticleInverted: shouldEnableFullArticleInverted, shouldUseDiscoveryHedToken: shouldUseDiscoveryHedToken, shouldUseDiscoveryColorToken: shouldUseDiscoveryColorToken, shouldReduceHedSpacingInDense: shouldReduceHedSpacingInDense, summaryItemVariationOverride: summaryItemVariation, extendedStrategyLayout: currentExtendedStrategyLayout, className: isRecircExtendedEnabled ? `${className} default-overlay` : className, heading: getSectionTitleText(), hasNoBottomTitleSpacing: hasNoBottomTitleSpacing, summaryCollectionGridVariation: handleSummaryCollectionGridVariation(), sectionTitleLabel: getSectionTitleText(), subjectVersion: subjectVersion }),
        isRecircExtendedEnabled && extendedStrategyLayout && (React.createElement(RecircListExtendedOverlay, { ...componentProps, recircItems: consolidatedRecircItems.slice(4), bylineVariation: bylineVariation, dividerColor: dividerColor, shouldEnableFullArticleInverted: shouldEnableFullArticleInverted, shouldUseDiscoveryHedToken: shouldUseDiscoveryHedToken, shouldUseDiscoveryColorToken: shouldUseDiscoveryColorToken, shouldReduceHedSpacingInDense: shouldReduceHedSpacingInDense, summaryItemVariation: summaryItemVariation, hasNoBottomTitleSpacing: hasNoBottomTitleSpacing, shouldHideRubric: shouldHideRubric, extendedStrategyLayout: currentExtendedStrategyLayout, isSimilaritySplitEnabled: isSimilaritySplitEnabled, ...(shouldEnableCSRFeature ? { extendedRecircClientData } : {}), shouldDisableReadMoreAd: currentExtendedStrategyLayout === 'DesktopSideRail' }))));
    return (React.createElement(ViewportMonitor, { onIntersectionViewport: onIntersectionViewport, observerOptions: { rootMargin: '500px' }, className: "recirc-list-wrapper" }, recircItems && recircItems.length > 0 && componentToRender));
};
RecircList.propTypes = {
    brandSlug: PropTypes.string,
    bylineVariation: PropTypes.string,
    canonicalUrl: PropTypes.string,
    categoriesMap: PropTypes.array,
    className: PropTypes.string,
    contentID: PropTypes.string,
    contentType: PropTypes.string,
    copilotExperimentRelated: PropTypes.array,
    customHeading: PropTypes.object,
    dividerColor: PropTypes.string,
    experimentData: PropTypes.object,
    experimentName: PropTypes.string,
    experimentRelated: PropTypes.object,
    extendedRecircRightRailRenditions: PropTypes.object,
    extendedStrategyLayout: PropTypes.string,
    gridColumnCount: PropTypes.number,
    hasBottomSpacing: PropTypes.bool,
    hasDividerAbove: PropTypes.bool,
    hasDividerBelow: PropTypes.bool,
    hasItemsRule: PropTypes.bool,
    hasMobileItemSpacing: PropTypes.bool,
    hasNoBottomTitleSpacing: PropTypes.bool,
    hasTopAndBottomPadding: PropTypes.bool,
    heading: PropTypes.string,
    isOneToOneImageVariant: PropTypes.bool,
    isRecircExtendedEnabled: PropTypes.bool,
    isSimilaritySplitEnabled: PropTypes.bool,
    language: PropTypes.string,
    mobilePageSize: PropTypes.number,
    mobileSummaryItemVariation: PropTypes.string,
    pageSize: PropTypes.number,
    recircListConfig: PropTypes.object,
    recircListExtendedOverlayConfig: PropTypes.object,
    recircListTextOverlayRenditions: PropTypes.object,
    recircRelated: PropTypes.array,
    recircRenditions: PropTypes.object,
    recommendationsApiUrl: PropTypes.string,
    recommended: PropTypes.object,
    related: PropTypes.array,
    sectionTitleFontSize: PropTypes.number,
    shouldChangeBiTokenMsExp: PropTypes.bool,
    shouldDisableReadMoreAd: PropTypes.bool,
    shouldDisplayImageCount: PropTypes.bool,
    shouldEnableCSRFeature: PropTypes.bool,
    shouldEnableFullArticleInverted: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideDangerousDek: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHideMetadataSecondary: PropTypes.bool,
    shouldHideRubric: PropTypes.bool,
    shouldReduceHedSpacingInDense: PropTypes.bool,
    shouldUseDiscoveryColorToken: PropTypes.bool,
    shouldUseDiscoveryHedToken: PropTypes.bool,
    shouldUseTrailingSlash: PropTypes.bool,
    showHeadTagAsForRecirc: PropTypes.string,
    summaryItemAlignment: PropTypes.string,
    summaryItemVariation: PropTypes.string,
    textOverlayExperiment: PropTypes.shape({
        gridColumnCount: PropTypes.number,
        isEnabled: PropTypes.bool
    }),
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        hasAdBottomMargin: PropTypes.bool,
        hasBackground: PropTypes.bool,
        layout: PropTypes.oneOf(['four-up', 'high-density', 'text-overlay']),
        shouldLazyLoadImages: PropTypes.bool
    }),
    vulcanUrl: PropTypes.string
};
const mapStateToProps = ({ config: { contentSystem, recommendations }, useTrailingSlash: shouldUseTrailingSlash, experimentData, experimentRelated, extendedRecircItems, renditions, componentConfig, appConfig, coreDataLayer, 'head.contentID': contentID, 'head.pageType': contentType, 'head.canonicalUrl': canonicalUrl, copilotExperimentRelated }) => {
    const vulcanUrl = contentSystem?.mediaDomain
        ? `https://${contentSystem?.mediaDomain}`
        : '';
    return {
        experimentData,
        experimentRelated,
        extendedRecircItems,
        vulcanUrl,
        contentID,
        contentType,
        recircRenditions: renditions?.recircList || {},
        recircListTextOverlayRenditions: renditions?.recircListTextOverlay || {},
        extendedRecircRightRailRenditions: renditions?.extendedRecircRightRail || {},
        recircListConfig: componentConfig.RecircList,
        recircListExtendedOverlayConfig: componentConfig.RecircListExtendedOverlay,
        recommendationsApiUrl: recommendations?.personalisedApiUrl || '',
        brandSlug: appConfig?.brandSlug,
        canonicalUrl,
        language: coreDataLayer?.content?.contentLang,
        shouldUseTrailingSlash,
        copilotExperimentRelated,
        shouldEnableCSRFeature: recommendations?.bottomRecirc?.enableClientSideRender || false
    };
};
RecircList.displayName = 'RecircList';
module.exports = connectToStore(mapStateToProps, {})(RecircList);
//# sourceMappingURL=RecircList.js.map

/***/ }),

/***/ 92932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Row = __webpack_require__(66657);
const { RecircListDefaultOverlaySummaryCollectionGrid } = __webpack_require__(8851);
/**
 * RecircListDefaultOverlay component
 *
 * @param {object} props - React props
 * @param {string} [props.bylineVariation] - Optional variation of byline
 * @param {string} [props.className] - Optional top-level class to add
 * @param {boolean} [props.hasBackground] - Optional. This specifies if the component will have a background.
 * @param {boolean} [props.hasItemsRule] - Optional. Show or should hide the decrorative rule on SummaryItem(s).
 * @param {string} [props.heading] - heading text
 * @param {Array<SummaryItem>} [props.items] - Array containing objects that each have data which is used to render a SummaryItem component
 * @param {string} [props.layout] - Optional variation of byline
 * @param {boolean} [props.shouldDisableReadMoreAd] - Optional flag to disable sponsored content in recirc list
 * @param {boolean} [props.shouldHideBylines] - Optional flag to hide bylines
 * @param {boolean} [props.shouldHideIcon] - Optional flag to hide icon on item
 * @param {boolean} [props.shouldReduceHedSpacingInDense] - Optional flag to reduce the space between the hed and rubric in the dense layout of the SummaryItem component.
 * @param {string} [props.showHeadTagAsForRecirc] - Optional heading tag setting for recirc units
 * @param {string} [props.summaryItemVariation] - Optional prop to control summary item variation, defaults to `OverlayCenter`
 * @param {string} [props.summaryItemVariationOverride] - Optional variation of SummaryItem to override
 * @param {string} [props.dividerColor] - Optional prop to get divider color for article page from copilot
 * @param {bool} [props.shouldDisplayImageCount] - Optional boolean to display image slide count in recirc unit (default to false)
 * @param {boolean} [props.hasBottomSpacing] - Add bottom spacing to the individual content
 * @param {boolean} [props.hasTopAndBottomPadding] - Add top and bottom spacing to the individual content
 * @param {boolean} [props.hasMobileItemSpacing] - Add spacing to the individual content
 * @param {boolean} [props.hasAdBottomMargin] - Has bottom padding of 2rem to Ad
 * @param {string} [props.extendedStrategyLayout] - Optional string to display RecircListExtendedOverlay based on the strategy
 * @param {boolean} [props.hasNoBottomTitleSpacing] - removes bottom space from the title
 * @param {string} [props.summaryCollectionGridVariation] - Optional string variation of summaryCollectionGrid to be used
 * @param {boolean} [props.shouldHideMetadataSecondary] - Optional boolean to hide MetadataSecondary
 * @param {string} [props.sectionTitleLabel] - section title value
 * @param {string} [props.subjectVersion] - subject versions are `default/mobile_dense`. `default` is for Desktop
 * @returns {ReactElement} <Row>
 */
const RecircListDefaultOverlay = (props) => {
    const { bylineVariation, className, heading, hasBackground, hasItemsRule, shouldReduceHedSpacingInDense, items, layout, shouldDisableReadMoreAd, shouldEnableFullArticleInverted, shouldHideBylines, shouldHideIcon, shouldDisplayImageCount, shouldUseDiscoveryHedToken, shouldUseDiscoveryColorToken, showHeadTagAsForRecirc, dividerColor, summaryItemVariation = 'TextBelowLeft', hasBottomSpacing, hasTopAndBottomPadding, hasMobileItemSpacing, summaryItemVariationOverride, shouldHideDangerousDek, hasAdBottomMargin, extendedStrategyLayout = '', hasNoBottomTitleSpacing = false, summaryCollectionGridVariation = 'FourColumns', shouldHideMetadataSecondary = false, sectionTitleLabel, subjectVersion } = props;
    const isFourUp = layout === 'four-up';
    const isHighDensity = layout === 'high-density';
    return (React.createElement(Row, { className: className, hasBackground: hasBackground },
        React.createElement(RecircListDefaultOverlaySummaryCollectionGrid, { isFourUp: isFourUp, isHighDensity: isHighDensity, bylineVariation: bylineVariation, className: "recirc-list__items", dangerousHed: heading, hasItemsRule: hasItemsRule, itemHedTag: "div", items: items, isRecirc: true, sectionTitleVariation: "LineAboveLineBelowTextCenter", shouldDisableReadMoreAd: shouldDisableReadMoreAd, shouldEnableFullArticleInverted: shouldEnableFullArticleInverted, shouldHideBylines: shouldHideBylines, shouldHideIcon: shouldHideIcon, shouldDisplayImageCount: shouldDisplayImageCount, shouldReduceHedSpacingInDense: shouldReduceHedSpacingInDense, shouldUseDiscoveryColorToken: shouldUseDiscoveryColorToken, shouldUseDiscoveryHedToken: shouldUseDiscoveryHedToken, showHeadTagAsForRecirc: showHeadTagAsForRecirc, summaryItemVariation: summaryItemVariation, dividerColor: dividerColor, titleHedTag: "header", hasBottomSpacing: hasBottomSpacing, hasTopAndBottomPadding: hasTopAndBottomPadding, hasMobileItemSpacing: hasMobileItemSpacing, summaryItemVariationOverride: summaryItemVariationOverride, shouldHideDangerousDek: shouldHideDangerousDek, hasAdBottomMargin: hasAdBottomMargin, summaryCollectionGridVariation: summaryCollectionGridVariation, hasNoBottomTitleSpacing: hasNoBottomTitleSpacing, extendedStrategyLayout: extendedStrategyLayout, sectionTitleLabel: sectionTitleLabel, subjectVersion: subjectVersion, shouldHideMetadataSecondary: shouldHideMetadataSecondary })));
};
RecircListDefaultOverlay.propTypes = {
    bylineVariation: PropTypes.string,
    className: PropTypes.string,
    dividerColor: PropTypes.string,
    extendedStrategyLayout: PropTypes.string,
    hasAdBottomMargin: PropTypes.bool,
    hasBackground: PropTypes.bool,
    hasBottomSpacing: PropTypes.bool,
    hasItemsRule: PropTypes.bool,
    hasMobileItemSpacing: PropTypes.bool,
    hasNoBottomTitleSpacing: PropTypes.bool,
    hasTopAndBottomPadding: PropTypes.bool,
    heading: PropTypes.string,
    items: PropTypes.array,
    layout: PropTypes.string,
    sectionTitleLabel: PropTypes.string,
    shouldDisableReadMoreAd: PropTypes.bool,
    shouldDisplayImageCount: PropTypes.bool,
    shouldEnableFullArticleInverted: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideDangerousDek: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHideMetadataSecondary: PropTypes.bool,
    shouldReduceHedSpacingInDense: PropTypes.bool,
    shouldUseDiscoveryColorToken: PropTypes.bool,
    shouldUseDiscoveryHedToken: PropTypes.bool,
    showHeadTagAsForRecirc: PropTypes.string,
    subjectVersion: PropTypes.string,
    summaryCollectionGridVariation: PropTypes.string,
    summaryItemVariation: PropTypes.string,
    summaryItemVariationOverride: PropTypes.string
};
module.exports = RecircListDefaultOverlay;
//# sourceMappingURL=RecircListDefaultOverlay.js.map

/***/ }),

/***/ 69122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Row = __webpack_require__(66657);
const SummaryItem = __webpack_require__(74992);
const { PaymentGateway } = __webpack_require__(92807);
const Ad = __webpack_require__(19607);
const { useOnAdFilled } = __webpack_require__(1184);
const { RecircListTextOverlayWrapper, RecircListTextOverlayHeading, RecircListTextOverlayItems, RecircListTextOverlayItem } = __webpack_require__(8851);
const connect = __webpack_require__(34967);
/**
 * RecircListTextOverlay component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {boolean} [props.hasItemsRule] - Optional. Show or should hide the decrorative rule on SummaryItem(s).
 * @param {object} [props.adsSettings] - ads configuration settings
 * @param {number} [props.adsSettings.nativeAdIndex] - Optional VS lever. Index for native ads.
 * @param {string} [props.heading] - heading text
 * @param {Array<SummaryItem>} [props.items] - Array containing objects that each have data which is used to render a SummaryItem component
 * @param {string} [props.layout] - Optional variation of byline
 * @param {string} [props.summaryItemVariation] - Optional prop to control summary item variation, defaults to `OverlayCenter`
 * @param {string} [props.sectionTitleLabel] - section title value
 * @param {string} [props.subjectVersion] -  subject versions are `default/mobile_dense`. `default` is for Desktop
 * @param {number} [props.gridColumnCount] - Optional provides number of columns for the grid layout
 * @param {boolean} [props.isExperimentEnabled] - Optional provides boolean value if the textoverlay experiment is enabled.
 *
 * @returns {ReactElement} <Row>
 */
const RecircListTextOverlay = (props) => {
    const { className, heading, hasItemsRule, items, layout, summaryItemVariation, sectionTitleLabel, subjectVersion, gridColumnCount, isExperimentEnabled, adsSettings: { nativeAdIndex } } = props;
    const [, readMoreAdVisibilityClass, onReadMoreAdFilled] = useOnAdFilled('read-more-ad');
    const isTextOverlay = layout === 'text-overlay';
    const SummaryItemComponent = SummaryItem[summaryItemVariation || 'OverlayCenter'];
    return (React.createElement(Row, null,
        React.createElement(RecircListTextOverlayWrapper, { className: className },
            React.createElement("div", { className: "recirc-list__container" },
                heading && (React.createElement(RecircListTextOverlayHeading, { isTextOverlay: isTextOverlay, gridColumnCount: gridColumnCount, isExperimentEnabled: isExperimentEnabled }, heading)),
                React.createElement(RecircListTextOverlayItems, { className: classnames('recirc-list__items', readMoreAdVisibilityClass), isTextOverlay: isTextOverlay, gridColumnCount: gridColumnCount, isExperimentEnabled: isExperimentEnabled }, items.map((item, index) => {
                    const isSponsored = index === nativeAdIndex;
                    return (React.createElement(React.Fragment, { key: index },
                        isSponsored && (React.createElement(PaymentGateway, { group: "ads" },
                            React.createElement(Ad, { position: "read-more", onFilled: onReadMoreAdFilled }))),
                        React.createElement(RecircListTextOverlayItem, { key: item.url, isTextOverlay: isTextOverlay, gridColumnCount: gridColumnCount, isExperimentEnabled: isExperimentEnabled },
                            React.createElement(SummaryItemComponent, { ...item, hasRule: hasItemsRule, hedTag: "div", isRecircListItem: true, totalItems: items.length, recircPlacement: "bottom_recirc", recircId: index + 1, shouldHandleOverlayForLongHed: true, shouldDisableGradientContentBlock: true, sectionTitleLabel: sectionTitleLabel, subjectVersion: subjectVersion }))));
                }))))));
};
RecircListTextOverlay.propTypes = {
    adsSettings: PropTypes.shape({
        nativeAdIndex: PropTypes.number
    }),
    className: PropTypes.string,
    gridColumnCount: PropTypes.number,
    hasItemsRule: PropTypes.bool,
    heading: PropTypes.string,
    isExperimentEnabled: PropTypes.bool,
    items: PropTypes.array,
    layout: PropTypes.string,
    sectionTitleLabel: PropTypes.string,
    subjectVersion: PropTypes.string,
    summaryItemVariation: PropTypes.string
};
module.exports = connect(RecircListTextOverlay, {
    keysToPluck: ['adsSettings']
});
//# sourceMappingURL=RecircListTextOverlay.js.map

/***/ }),

/***/ 1338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const { connect: connectToStore } = __webpack_require__(67851);
const { RecircListExtendedOverlayWrapper } = __webpack_require__(34110);
const RecircListDefaultOverlay = __webpack_require__(92932);
const translations = (__webpack_require__(4149)/* ["default"] */ .A);
const { maxThresholds } = __webpack_require__(99906);
const { useResizeObserver } = __webpack_require__(70251);
const { getPageSize, checkIsSmallScreen, getSummaryItemVariation, addPropsFromConfig, getSubjectVersion } = __webpack_require__(49380);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
/**
 *
 * @param {object} props - component props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {number} [props.pageSize] - Optional page size
 * @param {number} [props.mobilePageSize] - Optional mobile device page size
 * @param {boolean} [props.shouldHideDangerousDekDesktop] - Optional boolean to hide dangerousDek on desktop for extended overlay only greater than 1024px
 * @param {string} [props.mobileSummaryItemVariation] - Optional prop to control summary item variation on tablet and mobile, defaults will be summaryItemVariation
 * @param {boolean} [props.shouldHideRubric] - Optional shouldHideRubric component setting
 * @param {object} [props.variations] - Variation properties used in rendering the component.
 * @param {boolean} [props.shouldHideIcon] - Optional flag to hide icon on item
 * @param {string} [props.bylineVariation] - Optional variation of byline
 * @param {boolean} [props.hasItemsRule] - Optional. Show or should hide the decrorative rule on SummaryItem(s).
 * @param {string} [props.extendedStrategyLayout] - Optional string to display RecircListExtendedOverlay based on the strategy
 * @param {boolean} [props.variations.hasAdBottomMargin] -  Has bottom margin of 2rem to Ad
 * @param {boolean} [props.variations.hasBackground] -  Has background color
 * @param {string} [props.variations.layout] -  Layout of the component
 * @param {boolean} [props.variations.shouldLazyLoadImages] -  Lazy load images
 * @param {boolean} [props.hasNoBottomTitleSpacing] - Optional boolean to remove bottom spacing from title
 * @param {Array} [props.recircItems] - Optional items to display
 * @param {string} [props.summaryItemVariation] - Optional prop to control summary item variation
 * @param {boolean} [props.isSimilaritySplitEnabled] - Optional boolean to enable similarity split
 * @param {boolean} [props.shouldDisableReadMoreAd] - Optional flag to disable sponsored content from extended recirc list
 * @param {Array} [props.extendedRecircItems] - Optional items to display
 * @param {Array} [props.extendedRecircRightRailItems] - Optional right rail items to display
 * @param {boolean} [props.shouldHideMetadataSecondary] - Optional boolean to hide MetadataSecondary
 * @param {string} [props.sectionTitle] - Optional string custom title
 *
 * @returns {JSX.Element} - RecircListExtendedOverlay component
 */
const RecircListExtendedOverlay = (props) => {
    const { extendedRecircItems, extendedRecircRightRailItems, className, extendedStrategyLayout = '', shouldHideDangerousDekDesktop = false, hasNoBottomTitleSpacing = false, mobilePageSize, mobileSummaryItemVariation, shouldHideRubric = false, shouldHideIcon, bylineVariation, hasItemsRule = true, recircItems = [], isSimilaritySplitEnabled = false, variations = {
        hasBackground: false,
        layout: 'four-up',
        shouldLazyLoadImages: true,
        hasAdBottomMargin: false
    }, shouldDisableReadMoreAd = false, shouldHideMetadataSecondary = false, sectionTitle = '', extendedRecircClientData } = props;
    const [isSmallScreen, setIsSmallScreen] = React.useState(false);
    const extendedStrategyListItems = () => extendedRecircClientData ||
        (extendedStrategyLayout === 'DesktopSideRail'
            ? extendedRecircRightRailItems
            : extendedRecircItems);
    let extendedListItems = isSimilaritySplitEnabled
        ? recircItems
        : extendedStrategyListItems();
    // Update device type on window resize
    useResizeObserver(() => setIsSmallScreen(checkIsSmallScreen(maxThresholds.lg)));
    React.useEffect(() => {
        setIsSmallScreen(checkIsSmallScreen(maxThresholds.lg));
    }, []);
    const pageSize = getPageSize(isSmallScreen, mobilePageSize, props.pageSize);
    const subjectVersion = getSubjectVersion(isSmallScreen);
    const { formatMessage } = useIntl();
    const title = sectionTitle || formatMessage(translations.trendingStories);
    const summaryItemVariation = getSummaryItemVariation(isSmallScreen, mobileSummaryItemVariation, props.summaryItemVariation);
    const callSnowplowEvent = (item, index, totalItems) => {
        const recircItemData = {
            type: 'click',
            label: title,
            subject: 'recirc_unit',
            strategy: extractStrategyFromURL(item.url),
            placement: 'bottom_recirc',
            subject_version: subjectVersion,
            items: [
                {
                    content_id: item.contentId,
                    content_title: item.dangerousHed,
                    content_type: item.contentType.toLowerCase(),
                    content_url: item.url
                }
            ],
            index,
            total_index: totalItems
        };
        trackNavigationEvent(recircItemData);
    };
    if (extendedListItems.length === 0) {
        return null;
    }
    extendedListItems = extendedListItems
        .map((item, index) => {
        return {
            ...addPropsFromConfig(item, shouldHideRubric, variations),
            clickHandler: () => callSnowplowEvent(item, index, extendedListItems.length)
        };
    })
        .slice(0, pageSize);
    return (React.createElement(RecircListExtendedOverlayWrapper, { "data-testid": "recirclistextendedoverlay-wrapper", as: RecircListDefaultOverlay, summaryItemVariationOverride: summaryItemVariation, shouldHideDangerousDekDesktop: shouldHideDangerousDekDesktop, className: `${className} extended-overlay`, extendedStrategyLayout: extendedStrategyLayout, hasNoBottomTitleSpacing: hasNoBottomTitleSpacing, bylineVariation: bylineVariation, hasBackground: variations.hasBackground, hasAdBottomMargin: variations.hasAdBottomMargin || false, items: extendedListItems, layout: variations.layout, heading: title, shouldHideIcon: shouldHideIcon, hasItemsRule: hasItemsRule, sectionTitleLabel: title, subjectVersion: subjectVersion, shouldDisableReadMoreAd: shouldDisableReadMoreAd, shouldHideMetadataSecondary: shouldHideMetadataSecondary }));
};
RecircListExtendedOverlay.propTypes = {
    bylineVariation: PropTypes.string,
    className: PropTypes.string,
    extendedRecircClientData: PropTypes.array,
    extendedRecircItems: PropTypes.array,
    extendedRecircRightRailItems: PropTypes.array,
    extendedStrategyLayout: PropTypes.string,
    hasItemsRule: PropTypes.bool,
    hasNoBottomTitleSpacing: PropTypes.bool,
    isSimilaritySplitEnabled: PropTypes.bool,
    mobilePageSize: PropTypes.number,
    mobileSummaryItemVariation: PropTypes.string,
    pageSize: PropTypes.number,
    recircItems: PropTypes.array,
    sectionTitle: PropTypes.string,
    shouldDisableReadMoreAd: PropTypes.bool,
    shouldHideDangerousDekDesktop: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHideMetadataSecondary: PropTypes.bool,
    shouldHideRubric: PropTypes.bool,
    summaryItemVariation: PropTypes.string,
    variations: PropTypes.shape({
        hasAdBottomMargin: PropTypes.bool,
        hasBackground: PropTypes.bool,
        layout: PropTypes.oneOf(['four-up', 'high-density', 'text-overlay']),
        shouldLazyLoadImages: PropTypes.bool
    })
};
const mapStateToProps = ({ extendedRecircItems, extendedRecircRightRailItems }) => {
    return {
        extendedRecircItems,
        extendedRecircRightRailItems
    };
};
module.exports = connectToStore(mapStateToProps, {})(RecircListExtendedOverlay);
//# sourceMappingURL=RecircListExtendedOverlay.js.map

/***/ }),

/***/ 13643:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RecircListExtendedOverlay = __webpack_require__(1338);
const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(RecircListExtendedOverlay, 'RecircListExtendedOverlay');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 34110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getTypographyStyles, getColorStyles } = __webpack_require__(26865);
const { SummaryItemHedBase } = __webpack_require__(36211);
const { SummaryItemContent, SummaryItemHedLink, SummaryItemWrapper, SummaryItemAssetContainer, SummaryItemDek } = __webpack_require__(68116);
const { SummaryCollectionGridSectionTitle, SummaryCollectionGridContent } = __webpack_require__(4534);
const { SummaryCollectionGridItems } = __webpack_require__(4534);
const { GridWrapper } = __webpack_require__(40653);
const { AspectRatioContainer } = __webpack_require__(7044);
const { SummaryItemBaseByline } = __webpack_require__(277);
const { BylineWrapper } = __webpack_require__(74423);
const { ResponsiveImagePicture } = __webpack_require__(7228);
const { RubricWrapper } = __webpack_require__(6613);
const RecircListExtendedOverlayWrapper = styled.div.withConfig({
    displayName: 'RecircListExtendedOverlayWrapper'
}) `
  ${({ extendedStrategyLayout }) => extendedStrategyLayout === 'DesktopSideRail' &&
    css `
      @media (min-width: ${BREAKPOINTS.lg}) {
        ${RubricWrapper} {
          margin-left: 0;
        }
        ${SummaryItemContent} {
          text-align: left;
        }

        grid-column: 10 / -1;

        && {
          ${BylineWrapper} {
            margin-top: 0;
            text-align: left;
          }
        }
        ${GridWrapper} {
          ${SummaryCollectionGridSectionTitle} {
            margin-bottom: ${calculateSpacing(2)};
          }
          grid-gap: 0;
          ${SummaryCollectionGridContent} {
            ${SummaryCollectionGridItems} {
              grid-template-columns: repeat(3, 1fr);
              ${SummaryItemWrapper}:nth-child(n):not(:last-child) {
                border-bottom: 1px solid;
                ${({ theme }) => `
                  ${getColorStyles(theme, 'border-bottom-color', 'colors.discovery.body.white.border')};
                `};
              }
            }
          }
        }

        ${SummaryItemWrapper} {
          display: flex;
          grid-column: 1 / -1;
          flex-direction: row-reverse;
          gap: ${calculateSpacing(2)};
          margin-bottom: 0;
          padding: ${calculateSpacing(2)} 0;

          ${SummaryItemAssetContainer} {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: ${calculateSpacing(10)};
            height: 100%;
            ${ResponsiveImagePicture} {
              max-height: ${calculateSpacing(10)};
            }
          }
          ${AspectRatioContainer} {
            &::before {
              display: inline;
            }

            div {
              position: static;
            }
          }
          ${SummaryItemContent} {
            padding-top: 0;
            padding-bottom: 0;
            width: 100%;
            ${SummaryItemBaseByline} {
              margin-bottom: 0;
            }
            ${SummaryItemDek} {
              ${({ shouldHideDangerousDekDesktop }) => {
        return (shouldHideDangerousDekDesktop &&
            css `
                    display: none;
                  `);
    }}
            }
            ${SummaryItemHedLink} {
              ${SummaryItemHedBase} {
                margin-bottom: ${calculateSpacing(1)};
                ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-primary')};
              }
            }
            ${SummaryItemAssetContainer} {
              display: none;
            }
          }
        }
      }
    `};

  ${({ extendedStrategyLayout }) => extendedStrategyLayout === 'stacked' &&
    css `
      margin-top: 0;
      ${GridWrapper} {
        ${SummaryCollectionGridSectionTitle} {
          margin-top: 0;
        }
      }
    `};
`;
module.exports = {
    RecircListExtendedOverlayWrapper
};
//# sourceMappingURL=style.js.map

/***/ }),

/***/ 74147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { mapChannelName } = __webpack_require__(39104);
class HandleRecommendations {
    constructor({ pageSize, related = [] }) {
        this.pageSize = pageSize;
        this.related = related;
    }
    prepareData(data = []) {
        try {
            return data
                .filter((item) => this.notRelatedDuplicate(item))
                .slice(0, Math.max(0, this.pageSize - this.related.length))
                .map((item) => this.transformItem(item));
        }
        catch (error) {
            return [];
        }
    }
    notRelatedDuplicate(item) {
        return !this.related.find((r) => item.url.includes(r.url));
    }
    transformItem(item) {
        return {
            ...item,
            rubric: this.shouldHideRubric
                ? null
                : mapChannelName(item.rubric, this.channelMap),
            image: item.image ? { ...item.image, isLazy: true } : item.image,
            shouldHideDangerousDek: true,
            maxHedLines: 3
        };
    }
}
module.exports = {
    HandleRecommendations
};
//# sourceMappingURL=handleRecommendations.js.map

/***/ }),

/***/ 10281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const VariedRecircList = __webpack_require__(3703);
module.exports = asConfiguredComponent(VariedRecircList, 'RecircList');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { css, default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText, BaseWrap } = __webpack_require__(76955);
const { calculateSpacing, getTypographyStyles, minScreen, getColorToken, getColorStyles, minMaxScreen, maxScreen } = __webpack_require__(26865);
const { ResponsiveClipWrapper } = __webpack_require__(91783);
const { maxThresholds, minThresholds } = __webpack_require__(99906);
const { SummaryItemHedBase, SummaryItemSubHedBase } = __webpack_require__(36211);
const { SummaryItemContent, SummaryItemHedLink, SummaryItemWrapper, SummaryItemAssetContainer, SummaryItemDek } = __webpack_require__(68116);
const { SectionTitleHed } = __webpack_require__(33500);
const { OverlaySummaryItemWrapper, OverlayItemContentWrapper, OverlaySummaryItemHed } = __webpack_require__(3265);
const { SummaryCollectionGridSectionTitle, SummaryCollectionGridSummaryItem } = __webpack_require__(4534);
const SummaryCollectionGrid = __webpack_require__(91706);
const { SummaryCollectionGridItems, SummaryCollectionGridComponent, SummaryCollectionGridContent } = __webpack_require__(4534);
const { GridWrapper } = __webpack_require__(40653);
const { SummaryItemImageLink } = __webpack_require__(14207);
const { SummaryItemBaseByline } = __webpack_require__(277);
const { BylineWrapper } = __webpack_require__(74423);
const { RubricName, RubricWrapper } = __webpack_require__(6613);
const { BylinesWrapper } = __webpack_require__(15384);
const { RowWrapper } = __webpack_require__(20139);
const { AdWrapper } = __webpack_require__(36185);
const RecircListTextOverlayItem = styled.li.withConfig({
    displayName: 'RecircListTextOverlayItem'
}) `
  ${({ isTextOverlay, theme }) => isTextOverlay &&
    `
      &:nth-child(even) ${OverlaySummaryItemWrapper} {
        background-color: ${getColorToken(theme, 'colors.interactive.base.light')};
      }

      ${minScreen(BREAKPOINTS.md)} {
        /* undo the mobile  */
        &:nth-child(even) ${OverlaySummaryItemWrapper} {
          background-color: ${getColorToken(theme, 'colors.interactive.base.dark')};
        }

        /* then treat each as a 2x2 grid to create the checker pattern  */
        &:nth-child(4n + 2) ${OverlaySummaryItemWrapper},
        &:nth-child(4n + 3) ${OverlaySummaryItemWrapper} {
          background-color: ${getColorToken(theme, 'colors.interactive.base.light')};
        }
      }
    `};

  ${({ isTextOverlay, gridColumnCount, theme }) => isTextOverlay &&
    gridColumnCount &&
    `
    &&& {
      ${OverlayItemContentWrapper} {
        padding: 0 ${calculateSpacing(3)} ${calculateSpacing(3)};
      }
    } 

    ${RubricWrapper} {
      ${RubricName} {
        ${getColorStyles(theme, 'color', 'colors.interactive.base.white')}};
      }
    }
             
    ${OverlaySummaryItemHed} {
      ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
      ${getColorStyles(theme, 'color', 'colors.interactive.base.white')};
      margin-top:${calculateSpacing(1)} ;
    }

    ${BylinesWrapper} {
       margin-top:${calculateSpacing(1)} ;
       text-align:left;
    }
    ${BylineWrapper}{
        margin-top:0
    }

    ${minScreen(BREAKPOINTS.lg)} {
      grid-column: span calc(12/${gridColumnCount}); 
    }
    `};
`;
const RecircListTextOverlayWrapper = styled.aside.withConfig({
    displayName: 'RecircListTextOverlayWrapper'
}) `
  margin: ${calculateSpacing(9)} auto 0;
  width: 100%;
  max-width: ${BREAKPOINTS.xxl};

  ${RecircListTextOverlayItem} {
    margin-top: 0;
    list-style-type: none;
  }

  /* Ad visibility controls  */
  .hide-read-more-ad .ad--read-more {
    display: none;
  }

  .show-read-more-ad {
    .ad--read-more {
      display: block;
    }

    ${RecircListTextOverlayItem}:last-of-type {
      display: none;
    }
  }
`;
const RecircListTextOverlayHeading = styled(BaseText).withConfig({
    displayName: 'RecircListTextOverlayHeading'
}) `
  ${({ isTextOverlay, gridColumnCount, theme }) => isTextOverlay &&
    gridColumnCount &&
    `
      ${getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
      ${getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-primary')}
        &&&{
            margin-left:  ${calculateSpacing(8)};
            margin-right:   ${calculateSpacing(8)};
        }
        ${maxScreen(`calc(${BREAKPOINTS.lg} - 1px)`)} {
                &&&{
                  margin-left:  ${calculateSpacing(3)};
                  margin-right:  ${calculateSpacing(3)};
                }
              }
   `};
  margin: 0 0 ${calculateSpacing(4)};
  text-align: center;

  ${({ isTextOverlay, theme }) => isTextOverlay &&
    `margin: 0;
        border-top: 1px solid ${getColorToken(theme, 'colors.consumption.lead.standard.divider')};
        border-bottom: 1px solid ${getColorToken(theme, 'colors.consumption.lead.standard.divider')};
        padding: ${calculateSpacing(2)} 0;
        margin-bottom: ${calculateSpacing(4)};`};
`;
RecircListTextOverlayHeading.defaultProps = {
    as: 'header',
    typeIdentity: 'typography.definitions.discovery.subhed-section-collection'
};
const RecircListTextOverlayItems = styled.ul.withConfig({
    displayName: 'RecircListTextOverlayItems'
}) `
  ${({ isTextOverlay }) => isTextOverlay &&
    `
      display: grid;
      grid-column-gap: 0;
      grid-template-columns: 1fr;
      grid-row-gap: 0;
      margin: 0;
      padding: 0;

      ${minScreen(BREAKPOINTS.md)} {
        grid-template-columns: 1fr 1fr;
      }

      ${minScreen(BREAKPOINTS.lg)} {
        grid-template-columns: repeat(2, 1fr);
      }
    `};
  ${({ isTextOverlay, gridColumnCount }) => isTextOverlay &&
    gridColumnCount &&
    `
             grid-gap:${calculateSpacing(2)};
             padding-left:${calculateSpacing(3)};
             padding-right:${calculateSpacing(3)};
            ${minScreen(BREAKPOINTS.lg)} {
              grid-template-columns: repeat(12, 1fr);
              padding-left:${calculateSpacing(8)};
              padding-right:${calculateSpacing(8)};
                ${AdWrapper}{
               grid-column: span calc(12/${gridColumnCount});
                }
            }
            ${maxScreen(`calc(${BREAKPOINTS.lg} - 1px)`)} {
              padding-left:${calculateSpacing(2)};
              padding-right:${calculateSpacing(2)};
            }
        `};
`;
const RecircListDefaultOverlaySummaryCollectionGrid = styled(({ summaryCollectionGridVariation, ...props }) => {
    const Component = SummaryCollectionGrid[summaryCollectionGridVariation];
    return React.createElement(Component, { ...props });
}).withConfig({ displayName: 'RecircListDefaultOverlaySummaryCollectionGrid' }) `
  ${SummaryCollectionGridSectionTitle} {
    margin-top: ${calculateSpacing(9)};
  }

  .summary-item__dek--isCneVideo {
    /* stylelint-disable-next-line value-no-vendor-prefix */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;

    ${minScreen(BREAKPOINTS.sm)} {
      padding-bottom: 0;
    }
  }

  ${SummaryItemHedBase} {
    ${minMaxScreen(BREAKPOINTS.sm, BREAKPOINTS.md)} {
      ${({ theme, shouldUseDiscoveryHedToken }) => shouldUseDiscoveryHedToken &&
    getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
    }
    ${({ theme, shouldUseDiscoveryHedToken }) => shouldUseDiscoveryHedToken &&
    getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
  }
  ${SummaryItemSubHedBase} {
    ${({ theme, shouldUseDiscoveryColorToken }) => shouldUseDiscoveryColorToken &&
    getColorStyles(theme, 'color', 'colors.discovery.body.white.description')};
  }

  ${({ isFourUp }) => isFourUp &&
    `
      .summary-item--has-border {
        border-bottom: none;
      }
    `};

  ${SummaryItemAssetContainer} {
    ${SummaryItemImageLink} {
      .responsive-asset {
        ${ResponsiveClipWrapper} {
          margin-bottom: 0;
        }
      }
    }
  }

  ${({ isHighDensity }) => {
    if (isHighDensity) {
        return css `
        ${SummaryCollectionGridSectionTitle} {
          margin-bottom: ${calculateSpacing(3)};
          border-top: 1px solid
            ${getColorToken('colors.interactive.base.light')};
        }

        ${SectionTitleHed} {
          ${getTypographyStyles('typography.definitions.discovery.hed-core-secondary')};
          padding: ${calculateSpacing(1)} ${calculateSpacing(1)} 0 0;
          text-transform: uppercase;
        }
      `;
    }
    return '';
}};

  ${({ dividerColor }) => {
    if (dividerColor) {
        return css `
        ${SummaryCollectionGridSectionTitle} {
          border-top-color: #${dividerColor};
          border-bottom-color: #${dividerColor};
        }
      `;
    }
    return '';
}};

  ${({ hasBottomSpacing }) => hasBottomSpacing &&
    css `
      &&&& {
        ${SummaryItemContent} {
          padding-bottom: ${calculateSpacing(4)};

          ${minMaxScreen(0, BREAKPOINTS.lg)} {
            padding-bottom: ${calculateSpacing(4)};
          }
        }
      }
    `};

  ${({ hasTopAndBottomPadding }) => hasTopAndBottomPadding &&
    css `
      &&&& {
        ${SummaryItemContent} {
          ${minMaxScreen(0, `${maxThresholds.lg}px`)} {
            padding-top: ${calculateSpacing(2)};
            padding-bottom: ${calculateSpacing(2)};
          }
        }
      }
    `};

  ${({ summaryItemVariation, shouldReduceHedSpacingInDense }) => summaryItemVariation === 'DenseDesktopStack' &&
    shouldReduceHedSpacingInDense
    ? css `
          ${SummaryItemHedLink} {
            ${minMaxScreen(BREAKPOINTS.sm, `${maxThresholds.lg}px`)} {
              padding-top: 0;
            }
            ${maxScreen(BREAKPOINTS.sm)} {
              padding-top: 0;
            }
          }
        `
    : ''};

  ${({ summaryItemVariation, hasMobileItemSpacing }) => summaryItemVariation === 'SideBySideMobileOnlyThirdsImageRight' &&
    hasMobileItemSpacing
    ? css `
          &&&& {
            ${SummaryItemWrapper} {
              ${minMaxScreen(0, `${maxThresholds.lg}px`)} {
                margin-bottom: 0;
              }
            }
            ${SummaryItemContent} {
              padding-bottom: 0;
              ${minMaxScreen(0, `${maxThresholds.lg}px`)} {
                margin-bottom: ${calculateSpacing(3)};
              }
            }
          }
        `
    : ''};

  ${({ extendedStrategyLayout }) => {
    extendedStrategyLayout === 'DesktopSideRail' &&
        css `
        @media (min-width: ${BREAKPOINTS.lg}) {
          ${SectionTitleHed} {
            width: 100%;
          }

          ${SummaryCollectionGridItems} {
            grid-gap: ${calculateSpacing(4)};
          }
        }
      `;
}};
`;
const RecircListWrapper = styled.div.withConfig({
    displayName: 'RecircListWrapper'
}) `
  ${({ extendedStrategyLayout, shouldChangeBiTokenMsExp, sectionTitleFontSize, hasDividerAbove, hasDividerBelow }) => extendedStrategyLayout === 'DesktopSideRail' &&
    css `
      @media (min-width: ${BREAKPOINTS.xxl}) {
        && {
          margin: auto;
          max-width: ${calculateSpacing(200)};
        }
      }
      @media (min-width: ${BREAKPOINTS.lg}) {
        ${BaseWrap} {
          margin-top: 0;
        }

        &&& {
          ${SectionTitleHed} {
            font-size: ${sectionTitleFontSize}px;
          }
        }

        display: grid;
        grid-template-columns: repeat(12, 1fr);
        gap: ${calculateSpacing(4)};
        margin: ${calculateSpacing(7)} ${calculateSpacing(8)}
          ${calculateSpacing(5)} ${calculateSpacing(8)};
        ${GridWrapper} {
          padding: 0;
        }
        ${SummaryCollectionGridSectionTitle} {
          margin-top: 0;
          padding-top: ${hasDividerAbove ? calculateSpacing(2) : 0};
          padding-bottom: ${hasDividerBelow ? calculateSpacing(2) : 0};
        }
        ${SectionTitleHed} {
          text-align: start;
          ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
          ${({ theme }) => getTypographyStyles(theme, shouldChangeBiTokenMsExp
        ? 'typography.definitions.discovery.subhed-section-primary'
        : 'typography.definitions.discovery.subhed-section-tertiary')};
        }

        &&&& {
          ${SummaryItemContent} {
            padding-bottom: 0;
            ${SummaryItemHedLink} {
              ${SummaryItemHedBase} {
                ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
              }
            }
          }
        }
        ${SectionTitleHed} {
          width: 100%;
        }

        .default-overlay {
          grid-column: 1 / 10;

          ${SummaryCollectionGridItems} {
            grid-gap: ${calculateSpacing(4)};
            ${SummaryItemAssetContainer} {
              margin-top: 0;
            }
          }
          ${SummaryItemContent} {
            ${SummaryItemDek} {
              margin-bottom: ${calculateSpacing(1)};
            }
            padding-bottom: 0;
            ${SummaryItemBaseByline} {
              margin-bottom: 0;
            }

            ${SummaryItemHedLink} {
              ${SummaryItemHedBase} {
                margin-bottom: ${calculateSpacing(1)};
                ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')};
              }
            }
          }
        }
      }
    `};

  ${({ extendedStrategyLayout, hasDividerAbove, hasDividerBelow }) => extendedStrategyLayout === 'carousel' &&
    css `
      ${maxScreen(`${maxThresholds.lg}px`)} {
        ${BaseWrap} {
          margin-top: 0;
        }
        ${BylineWrapper} {
          margin-top: 0;
        }
        ${SummaryCollectionGridContent} {
          ${SummaryCollectionGridItems} {
            ${SummaryItemWrapper} {
              padding-top: 0;
              padding-bottom: 0;
            }
            display: flex;
            gap: ${calculateSpacing(3)};

            ${SummaryCollectionGridSummaryItem} {
              ${minMaxScreen(0, `${maxThresholds.md}px`)} {
                flex: 1 0 70%;
              }
              ${minMaxScreen(`${minThresholds.lg}px`, `${maxThresholds.lg}px`)} {
                flex: 1 0 38%;
              }
              margin-bottom: ${calculateSpacing(3)};
              ${SummaryItemContent} {
                ${SummaryItemBaseByline} {
                  margin-bottom: 0;
                }
                ${SummaryItemHedBase}, ${SummaryItemDek} {
                  margin-bottom: ${calculateSpacing(1)};
                }
                padding-bottom: 0;
              }
            }
          }
        }
        ${SummaryCollectionGridSectionTitle} {
          margin: ${calculateSpacing(4)} auto;
          padding-top: ${hasDividerAbove ? calculateSpacing(2) : 0};
          padding-bottom: ${hasDividerBelow ? calculateSpacing(2) : 0};
          width: calc(100% - ${calculateSpacing(6)});
          ${minMaxScreen(`${minThresholds.lg}px`, `${maxThresholds.lg}px`)} {
            width: calc(100% - ${calculateSpacing(12)});
          }
        }
        ${SummaryCollectionGridComponent} {
          padding-right: 0;
          padding-left: 0;
        }
      }
    `}

  ${({ extendedStrategyLayout }) => extendedStrategyLayout === 'stacked' &&
    css `
      ${GridWrapper} {
        ${SummaryCollectionGridSectionTitle} {
          margin-top: ${calculateSpacing(2)};
        }
      }
      ${minMaxScreen(0, `${maxThresholds.lg}px`)} {
        ${GridWrapper} {
          ${SummaryCollectionGridSectionTitle} {
            margin-top: ${calculateSpacing(5)};
          }
        }
        margin-top: 0;
        ${RowWrapper} {
          margin-top: 0;
        }
        ${GridWrapper} {
          ${SummaryCollectionGridItems} {
            ${SummaryItemWrapper} {
              margin-bottom: 0;
              padding-top: 0;
              padding-bottom: 0;
              ${SummaryItemContent} {
                padding-top: ${calculateSpacing(2)};
                padding-bottom: ${calculateSpacing(4)};
                ${SummaryItemBaseByline} {
                  margin-bottom: 0;
                }
              }
            }
          }
        }

        .default-overlay {
          padding-bottom: ${calculateSpacing(2)};
        }
      }
      @media (min-width: ${BREAKPOINTS.lg}) {
        ${GridWrapper} {
          ${SummaryItemBaseByline} {
            margin-bottom: 0;
          }
        }
        ${SummaryItemContent} {
          padding-bottom: ${calculateSpacing(4)};
        }
      }
    `};
`;
module.exports = {
    RecircListTextOverlayWrapper,
    RecircListTextOverlayHeading,
    RecircListTextOverlayItems,
    RecircListTextOverlayItem,
    RecircListDefaultOverlaySummaryCollectionGrid,
    RecircListWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 4149:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    readMore: {
        id: 'RecircList.ReadMore',
        defaultMessage: 'Read More',
        description: 'Call to action for user to...read more'
    },
    alsoOn: {
        id: 'RecircList.AlsoOn',
        defaultMessage: 'Also On {brandName}',
        description: 'Also more recirc items on the website'
    },
    trendingStories: {
        id: 'RecircList.extendedOverlayheading',
        defaultMessage: 'Trending',
        description: 'Call to action for user to...trending stories'
    },
    moreLikeThis: {
        id: 'RecircList.MoreLikeThis',
        defaultMessage: 'More Like This',
        description: 'Call to action for user to...more like this'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 49380:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSubjectVersion = exports.addPropsFromConfig = exports.getSummaryItemVariation = exports.checkIsSmallScreen = exports.getPageSize = exports.getTitle = void 0;
const { maxThresholds } = __webpack_require__(99906);
const getTitle = (heading, customHeading, categoriesMap, recommended, items = []) => {
    const hasCustomHeading = recommended?.customHeading &&
        categoriesMap &&
        Object.values(categoriesMap)?.some((category) => recommended?.categoriesToMatch?.includes(category.url));
    if (hasCustomHeading) {
        return recommended?.customHeading;
    }
    if (!customHeading || !items.length) {
        return heading;
    }
    let shouldUpdateHeading = false;
    if (Object.values(categoriesMap).length &&
        customHeading?.categoriesURL &&
        customHeading?.heading) {
        shouldUpdateHeading = Object.values(categoriesMap)?.some((category) => customHeading?.categoriesURL?.includes(category.url));
    }
    if (shouldUpdateHeading) {
        return customHeading.heading;
    }
    return heading;
};
exports.getTitle = getTitle;
/* getPageSize provides the pageSize based on the screensize
 *
 * @param {boolean} isSmallScreen - related item
 * @param {number} mobilePageSize - mobile device page size
 * @param {number} pageSize -  page size
 * @returns {string} - required summary item variation
 */
const getPageSize = (isSmallScreen, mobilePageSize, pageSize) => {
    return isSmallScreen ? mobilePageSize || pageSize : pageSize;
};
exports.getPageSize = getPageSize;
/* checkIsSmallScreen checks for small screen
 *
 * @returns {boolean} - true/false based on screen size
 */
const checkIsSmallScreen = () => {
    if (true) {
        const media = window.matchMedia(`(max-width: ${maxThresholds.lg}px)`);
        return Boolean(media?.matches);
    }
    return false;
};
exports.checkIsSmallScreen = checkIsSmallScreen;
/* getSummaryItemVariation provides the summaryItemVariation based on the screensize
 *
 * @param {boolean} isSmallScreen - related item
 * @param {string} mobileSummaryItemVariation - control summary item variation on tablet and mobile
 * @param {string} summaryItemVariation -  controls summary item variation
 * @returns {string} - required summary item variation
 */
const getSummaryItemVariation = (isSmallScreen, mobileSummaryItemVariation, summaryItemVariation) => {
    return isSmallScreen
        ? mobileSummaryItemVariation || summaryItemVariation
        : summaryItemVariation;
};
exports.getSummaryItemVariation = getSummaryItemVariation;
/* addPropsFromConfig adds addtional props to related item object
 *
 * @param {object} item - related item
 * @param {boolean} shouldHideRubric - hide/show rubric
 * @param {object} variations - Variation properties used in rendering the component.
 * @returns {object} - related item with additional props from config
 */
function addPropsFromConfig(item, shouldHideRubric, variations) {
    return {
        ...item,
        rubric: shouldHideRubric ? null : item.rubric,
        isLazy: variations?.shouldLazyLoadImages,
        shouldHideDangerousDek: true,
        maxHedLines: 3
    };
}
exports.addPropsFromConfig = addPropsFromConfig;
/* getSubjectVersion use to get the subject version based on the screen type
 *
 * @param {boolean} isSmallScreen - flag true for small screen else false for big screen
 * @returns {string} - return subject version mobile_dense/default
 */
const getSubjectVersion = (isSmallScreen) => {
    return isSmallScreen ? 'mobile_dense' : 'default';
};
exports.getSubjectVersion = getSubjectVersion;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 3703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { asVariation } = __webpack_require__(81372);
const RecircList = __webpack_require__(98531);
RecircList.PopinVendor = asVariation(styled('div').withConfig({ displayName: 'PopinVendorRecircList' }) ``, 'PopinVendor', null, {
    id: '_popIn_recommend_2'
});
RecircList.FourUp = asVariation(RecircList, 'FourUp', {
    layout: 'four-up',
    hasAdBottomMargin: true
});
RecircList.FourUpWithOutLazyLoad = asVariation(RecircList, 'FourUpWithOutLazyLoad', {
    layout: 'four-up',
    shouldLazyLoadImages: false
});
RecircList.HighDensity = asVariation(RecircList, 'HighDensity', {
    layout: 'high-density'
});
RecircList.TextOverlay = asVariation(RecircList, 'TextOverlay', {
    layout: 'text-overlay'
});
RecircList.FourUpCard = asVariation(RecircList, 'FourUpCard', {
    layout: 'four-up',
    hasBackground: true
});
module.exports = RecircList;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 41160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const { connector } = __webpack_require__(57744);
const SummaryItem = __webpack_require__(74992);
const { googleAnalytics } = __webpack_require__(90090);
const Rubric = __webpack_require__(34187);
const { PaymentGateway } = __webpack_require__(92807);
const Ad = __webpack_require__(19607);
const { useOnAdFilled } = __webpack_require__(1184);
const translations = (__webpack_require__(34472)/* ["default"] */ .A);
const { TrackComponentChannel } = __webpack_require__(78788);
const { WindowEventChannel } = __webpack_require__(51735);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const { checkIsSmallScreen, getSubjectVersion } = __webpack_require__(49380);
const { AsideAdListItem, RecircMostPopularWrapper, RecircMostPopularContiner, RecircMostPopularHeading, RecircMostPopularHeadingLogo, RecircMostPopularItems, RecircMostPopularFooter, RecircMostPopularFooterLink, RecircMostPopularSummaryItem } = __webpack_require__(16302);
const recircMostPopularId = {};
const registerMostPopularId = (applicationId) => {
    const appId = applicationId || 'default';
    const prev = recircMostPopularId[appId] || 0;
    recircMostPopularId[appId] = prev + 1;
    return recircMostPopularId[appId];
};
/**
 * RecircMostPopular component
 *
 * @param {object} props - React props
 * @param {number} [props.adPosition] - ad position
 * @param {string} [props.applicationID] - application Id
 * @param {string} [props.bylineVariation] - byline variation
 * @param {Array} [props.categories] - categories
 * @param {object} categoriesMap - Categories of the item.
 * @param {string} [props.contentTypes] - content types
 * @param {string} [props.counterSuffix] - optional string to append to the numbered css counter, e.g. counterSuffix='.' returns 1. 2. 3.
 * @param {Array} [props.excludeCategories] - categories to exclude
 * @param {bool} [props.hasAd] - should display ad
 * @param {bool} [props.hasDiscoveryBodyNumbers] - should disaply discovery body numbers
 * @param {bool} [props.hasNoBorderHeading] - should display heading border
 * @param {bool} [props.hasRubricHeading] - should display heading
 * @param {bool} [props.hasRule] - has rule
 * @param {bool} [props.hasThinBorderHeading] - should display thin heading broder
 * @param {bool} [props.hideSummaryItemBorder] - hide SummaryItem border
 * @param {bool} [props.isVisible] - is visible
 * @param {Array} [props.items] - items to display
 * @param {object} [props.landingPageLink] - landing page link
 * @param {number} [props.numberOfDays] - number of days
 * @param {Func} [props.onIntersectionViewportCallback] -  onIntersection Viewport Callback function
 * @param {number} [props.pageSize] - page size
 * @param {object} [props.renditions] - renditions
 * @param {object} [props.seriesLogos] - series logos
 * @param {string} [props.seriesLogoToUse] - seriesLogo to use
 * @param {string} [props.showHeadTagAsForRecirc] - Optional heading tag setting for recirc units
 * @param {bool} [props.shouldHideRubric] - should hide rubric
 * @param {bool} [props.shouldUseSubHedRecircToken] - should use discovery type token for subhed
 * @param {string} [props.shouldUseDiscoveryColorToken] - Optional to use discovery color token for subHed
 * @param {bool} [props.shouldUseDiscoveryHedToken] - optional to use discovery token for Hed
 * @param {bool} [props.showVerticalBorders] - optional boolean to show vertical borders between the count/image and the summary content
 * @param {string} [props.sidebarSectionTitle] - sidebar section title
 * @param {string} [props.strategy] - strategy
 * @param {object} [props.variations] - variations
 * @param {boolean} [props.useTrailingSlash] - Optional urls require trailing slash
 * @param {string} [props.dividerColor] - Optional prop to get divider color for article page from copilot
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
const RecircMostPopular = (props) => {
    const { applicationID, bylineVariation, categories, recommended, categoriesMap, contentTypes, counterSuffix = '.', excludeCategories, hasAd = true, hasDiscoveryBodyNumbers = false, hasNoBorderHeading = false, hasRubricHeading = false, hasRule = false, hasThinBorderHeading = false, shouldHideRubric = false, shouldHideSubHed, shouldUseDiscoveryColorToken = false, shouldUseDiscoveryHedToken = false, shouldUseSubHedRecircToken = false, hideSummaryItemBorder = false, index, isVisible = true, items = [], landingPageLink, adPosition = 99, numberOfDays, onIntersectionViewportCallback, pageSize, renditions, seriesLogos, seriesLogoToUse, showHeadTagAsForRecirc, showVerticalBorders = false, sidebarSectionTitle, dividerColor, strategy, useTrailingSlash, variations = {
        hasListNumber: false,
        hasListNumberBySummary: false
    }, variationName } = props;
    const { hasListNumber, hasListNumberBySummary } = variations;
    const [isSmallScreen, setIsSmallScreen] = React.useState(false);
    // Update device type on window resize
    React.useEffect(() => {
        const handleResize = () => {
            setIsSmallScreen(checkIsSmallScreen());
        };
        const resizeSubscription = window.Kendra.WINDOW_EVENT.on(WindowEventChannel.RESIZE_DEBOUNCE, handleResize);
        return () => {
            resizeSubscription && resizeSubscription.off();
        };
    }, []);
    // Update device type on initial component mount
    React.useEffect(() => {
        setIsSmallScreen(checkIsSmallScreen());
    }, []);
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'RecircMostPopular',
            variation: variationName
        });
    }, [variationName]);
    const { formatMessage } = useIntl();
    const [instanceId] = React.useState(() => registerMostPopularId(applicationID));
    const [hasEmittedAnalyticsImpression, setEmittedAnalyticsImpression] = React.useState(false);
    const [hasCalledViewPortObserver, setHasCalledViewPortObserver] = React.useState(false);
    const subjectVersion = getSubjectVersion(isSmallScreen);
    const googleAnalyticsVars = React.useMemo(() => ({ instance: { instance: instanceId } }), [instanceId]);
    const hasCustomHeading = recommended?.customHeading &&
        categoriesMap &&
        Object.values(categoriesMap)?.some((category) => recommended?.categoriesToMatch?.includes(category.url));
    const title = hasCustomHeading
        ? recommended?.customHeading
        : sidebarSectionTitle || formatMessage(translations.sectionTitle);
    /*
      Some layouts include this component but don't have most popular items thus showing nothing
      This should only emit impressions if and only if the component is seen, component has
      items to display and hasn't emitted an impression.
      This manages the flow of async events between ViewportMonitor, fetching data, and emitting impressions
      The view port monitor asyncronously emits events if the component is in view, which triggers
      the async loading of items to display which then needs to trigger emitting a google
      analytics event.
    */
    React.useEffect(() => {
        const shouldEmitEvent = hasCalledViewPortObserver &&
            items.length > 0 &&
            !hasEmittedAnalyticsImpression;
        if (shouldEmitEvent) {
            googleAnalytics.emitUniqueGoogleTrackingEvent('recirc-most_popular-impression', googleAnalyticsVars);
            setEmittedAnalyticsImpression(true);
        }
    }, [
        hasEmittedAnalyticsImpression,
        hasCalledViewPortObserver,
        items,
        googleAnalyticsVars
    ]);
    const callSnowplowEvent = (eventName, item, index) => {
        const recircItemData = {
            type: eventName,
            subject: 'recirc_unit',
            label: title,
            strategy: extractStrategyFromURL(item.url),
            placement: 'right_rail',
            subject_version: subjectVersion,
            items: [
                {
                    content_id: item.contentId,
                    content_title: item.dangerousHed,
                    content_type: item.contentType.toLowerCase(),
                    content_url: item.url
                }
            ],
            index,
            total_index: items.length
        };
        trackNavigationEvent(recircItemData);
    };
    const [, asideAdVisibilityClass, onAsideAdFilled] = useOnAdFilled('aside-ad');
    if (!isVisible) {
        return null;
    }
    const SummaryItemVariation = hasListNumber
        ? SummaryItem.TextBelowLeft
        : SummaryItem.SideBySideThirds;
    const trackingStoryClickEvent = (item, index) => () => {
        googleAnalytics.emitGoogleTrackingEvent('recirc-most_popular-click', {
            ...googleAnalyticsVars,
            'gtm.elementUrl': item.url
        });
        callSnowplowEvent('click', item, index);
    };
    const onIntersectionViewport = (isInViewport, unsubscribeCallback) => {
        if (isInViewport && typeof onIntersectionViewportCallback === 'function') {
            onIntersectionViewportCallback({
                applicationID,
                categories,
                contentTypes,
                excludeCategories,
                numberOfDays,
                pageSize,
                renditions,
                strategy,
                useTrailingSlash
            });
            setHasCalledViewPortObserver(true);
            unsubscribeCallback();
            if (window && window.cnBus && window.cnBus.emit) {
                window.cnBus.emit(`aside${instanceId}.componentDidUpdate`);
            }
        }
    };
    const componentItems = items.map((item, index) => (React.createElement("li", { key: item.url },
        hasRubricHeading && (React.createElement(Rubric.Item, { ...item.rubric, className: "summary-item__rubric" })),
        React.createElement(RecircMostPopularSummaryItem, { bylineVariation: bylineVariation, clickHandler: trackingStoryClickEvent(item, index), contentType: item.contentType, contributors: item.contributors, dangerousHed: item.dangerousHed, ratingValue: item.ratingValue, hasBorder: !hideSummaryItemBorder, hasRule: hasRule, hedTag: "div", image: hasListNumber ? null : item.image, maxHedLines: 3, recircId: index + 1, rubric: shouldHideRubric ? null : item.rubric, url: item.url, as: SummaryItemVariation, isRecircListItem: true, totalItems: items.length, recircPlacement: "right_rail", showHeadTagAsForRecirc: showHeadTagAsForRecirc, dividerColor: dividerColor, subHed: shouldHideSubHed ? null : item.subHed, shouldUseDiscoveryColorToken: shouldUseDiscoveryColorToken, shouldUseDiscoveryHedToken: shouldUseDiscoveryHedToken, shouldUseSubHedRecircToken: shouldUseSubHedRecircToken, hasListNumberBySummary: hasListNumberBySummary, sectionTitleLabel: title, subjectVersion: subjectVersion, contentId: item.contentId }))));
    const asideAd = (React.createElement(AsideAdListItem, { className: asideAdVisibilityClass, hasDiscoveryBodyNumbers: hasDiscoveryBodyNumbers, key: "aside" },
        React.createElement(PaymentGateway, { group: "ads" },
            React.createElement(RecircMostPopularSummaryItem, { position: "aside", onFilled: onAsideAdFilled, hasMobileOnlyBorder: !hideSummaryItemBorder, dividerColor: dividerColor, as: Ad, index: index }))));
    if (items.length && hasAd) {
        // if the adPosition is 0 it was probably intended to be the first item in the list, so set it to 0
        // otherwise treat it like a page number, like the prop pageSize
        const asideAdIndex = adPosition - 1 >= 0 ? adPosition - 1 : 0;
        componentItems.splice(asideAdIndex, 0, asideAd);
    }
    const showLandingPageLink = landingPageLink && landingPageLink.url && landingPageLink.label;
    const seriesLogo = seriesLogos && seriesLogos[seriesLogoToUse];
    return (React.createElement(RecircMostPopularWrapper, { onIntersectionViewport: onIntersectionViewport, observerOptions: {
            rootMargin: '300px'
        }, className: "recirc-most-popular-wrapper" }, componentItems.length > 0 && (React.createElement(RecircMostPopularContiner, { className: "recirc-most-popular-sparrow-tracking", "data-most-popular-id": `mod-most-popular-${instanceId}` },
        React.createElement(RecircMostPopularHeading, { hasThinBorderHeading: hasThinBorderHeading, hasNoBorderHeading: hasNoBorderHeading, alignCenter: hasCustomHeading, hasListNumberBySummary: hasListNumberBySummary }, seriesLogo ? (React.createElement(RecircMostPopularHeadingLogo, { ...seriesLogo })) : (title)),
        React.createElement(RecircMostPopularItems, { counterSuffix: counterSuffix, hasListNumberBySummary: hasListNumberBySummary, hasDiscoveryBodyNumbers: hasDiscoveryBodyNumbers, shouldHideSubHed: shouldHideSubHed, showVerticalBorders: showVerticalBorders }, componentItems),
        React.createElement(RecircMostPopularFooter, { dividerColor: dividerColor, hasListNumberBySummary: hasListNumberBySummary }, showLandingPageLink && (React.createElement(RecircMostPopularFooterLink, { href: landingPageLink.url }, landingPageLink.label)))))));
};
RecircMostPopular.propTypes = {
    adPosition: PropTypes.number,
    applicationID: PropTypes.string,
    bylineVariation: PropTypes.string,
    categories: PropTypes.array,
    categoriesMap: PropTypes.array,
    contentTypes: PropTypes.string,
    counterSuffix: PropTypes.oneOf(['', '.']),
    dividerColor: PropTypes.string,
    excludeCategories: PropTypes.array,
    hasAd: PropTypes.bool,
    hasDiscoveryBodyNumbers: PropTypes.bool,
    hasNoBorderHeading: PropTypes.bool,
    hasRubricHeading: PropTypes.bool,
    hasRule: PropTypes.bool,
    hasThinBorderHeading: PropTypes.bool,
    hideSummaryItemBorder: PropTypes.bool,
    index: PropTypes.number,
    isVisible: PropTypes.bool,
    items: PropTypes.arrayOf(PropTypes.shape(SummaryItem.SideBySideThirds.PropTypes)),
    landingPageLink: PropTypes.object,
    numberOfDays: PropTypes.number,
    onIntersectionViewportCallback: PropTypes.func,
    pageSize: PropTypes.number,
    recommended: PropTypes.object,
    renditions: PropTypes.object,
    seriesLogos: PropTypes.object,
    seriesLogoToUse: PropTypes.string,
    shouldHideRubric: PropTypes.bool,
    shouldHideSubHed: PropTypes.bool,
    shouldUseDiscoveryColorToken: PropTypes.bool,
    shouldUseDiscoveryHedToken: PropTypes.bool,
    shouldUseSubHedRecircToken: PropTypes.bool,
    showHeadTagAsForRecirc: PropTypes.string,
    showVerticalBorders: PropTypes.bool,
    sidebarSectionTitle: PropTypes.string,
    strategy: PropTypes.string,
    useTrailingSlash: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        hasListNumber: PropTypes.bool,
        hasListNumberBySummary: PropTypes.bool
    })
};
RecircMostPopular.displayName = 'RecircMostPopular';
module.exports = connector(RecircMostPopular, {
    keysToPluck: [
        'renditions',
        'seriesLogos',
        'landingPageLink',
        'useTrailingSlash'
    ]
});
//# sourceMappingURL=RecircMostPopular.js.map

/***/ }),

/***/ 69234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RecircMostPopularVariations = __webpack_require__(16234);
const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(RecircMostPopularVariations, 'RecircMostPopular');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 16302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseLink } = __webpack_require__(76955);
const { calculateSpacing, getColorToken, getTypographyStyles, getLinkStyles, getColorStyles, getDecoration } = __webpack_require__(26865);
const { INTERACTIVE, BREAKPOINTS } = __webpack_require__(96472);
const ViewportMonitor = __webpack_require__(3990);
const ResponsiveImage = __webpack_require__(43608);
const { applyMobileOnlyBorder } = __webpack_require__(6528);
const { SummaryItemFloatingReviewIcon } = __webpack_require__(14207);
const { applyCustomBorderTopColor } = __webpack_require__(1123);
const { BylinesWrapper } = __webpack_require__(15384);
const RecircMostPopularWrapper = styled(ViewportMonitor).withConfig({
    displayName: 'RecircMostPopularWrapper'
}) `
  width: 300px;

  @media (min-width: ${BREAKPOINTS.xl}) {
    width: 370px;
  }
`;
const RecircMostPopularContiner = styled.div.withConfig({
    displayName: 'RecircMostPopularContiner'
}) `
  display: flex;
  flex-direction: column;
  justify-content: center;
  margin: ${calculateSpacing(2)} auto;
`;
const RecircMostPopularHeading = styled.div.withConfig({
    displayName: 'RecircMostPopularHeading'
}) `
  ${getTypographyStyles('typography.definitions.discovery.subhed-section-tertiary')};
  margin: ${calculateSpacing(2)} 0 0;
  border-top: 2px solid ${getColorToken('colors.discovery.body.white.heading')};
  border-bottom: 2px solid
    ${getColorToken('colors.discovery.body.white.heading')};
  padding: ${calculateSpacing(2)} 0;

  ${({ hasThinBorderHeading, theme }) => hasThinBorderHeading &&
    `
    border-top: 1px solid ${getColorToken(theme, 'colors.consumption.body.standard.divider')};
    border-bottom: 1px solid ${getColorToken(theme, 'colors.consumption.body.standard.divider')};
    padding: ${calculateSpacing(2)} 0;
    `}

  ${({ alignCenter }) => alignCenter &&
    `
    text-align: center;
  `}  
  ${({ hasNoBorderHeading }) => hasNoBorderHeading &&
    `
    margin-top: 0;
    border-top: none;
    padding-top: 0;
    `}
  ${({ hasListNumberBySummary, theme }) => hasListNumberBySummary &&
    `
    padding-top: ${calculateSpacing(2.5)};
    padding-bottom: ${calculateSpacing(2.5)};
    border-bottom: ${getDecoration(theme, 'dividerWidth')} solid ${getColorToken(theme, 'colors.discovery.body.white.border')};
    border-top: none;
    `}
`;
const RecircMostPopularHeadingLogo = styled(ResponsiveImage).withConfig({
    displayName: 'RecircMostPopularHeadingLogo'
}) `
  line-height: ${calculateSpacing(2)};
`;
const RecircMostPopularSummaryItem = styled.div.withConfig({
    displayName: 'RecircMostPopularSummaryItem'
}) `
  && {
    grid-column-gap: ${calculateSpacing(3)};
    grid-template-columns: 75px auto;
    align-items: flex-start;
    border-top: 1px solid ${getColorToken('colors.discovery.body.white.border')};
    border-bottom: none;
    padding: ${calculateSpacing(2)} 0;

    .rubric.summary-item__rubric {
      ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')};

      display: block;
      margin-bottom: ${calculateSpacing(1)};

      &:not(.rubric--with-bg) {
        color: ${getColorToken('colors.discovery.body.white.heading')};
        ${({ hasListNumberBySummary }) => hasListNumberBySummary &&
    css `
            color: ${getColorToken('colors.discovery.body.white.context-signature')};
          `};
      }
    }

    .summary-item__content {
      padding: 0;
    }

    .summary-item__hed {
      ${getTypographyStyles('typography.definitions.discovery.hed-bulletin-primary')};
      transition: color ${INTERACTIVE.timingLinkDefault} ease;
      margin-bottom: ${calculateSpacing(1)};
      ${({ theme, shouldUseDiscoveryHedToken }) => shouldUseDiscoveryHedToken &&
    getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
      ${({ theme, hasListNumberBySummary }) => hasListNumberBySummary &&
    getColorStyles(theme, 'color', 'colors.discovery.body.light.heading')};
    }

    .summary-item__sub-hed {
      ${({ theme, shouldUseSubHedRecircToken }) => shouldUseSubHedRecircToken &&
    getTypographyStyles(theme, 'typography.definitions.discovery.description-feature')};
      ${({ theme, shouldUseDiscoveryColorToken }) => shouldUseDiscoveryColorToken &&
    getColorStyles(theme, 'color', 'colors.discovery.body.white.description')};
    }

    .summary-item__byline {
      margin-bottom: 0;
    }

    .summary-item__byline-authors {
      &.byline,
      &.byline__preamble,
      &.byline__name,
      &.byline__name-link,
      &.byline__social-link {
        ${getTypographyStyles('typography.definitions.globalEditorial.accreditation-core')};
        color: ${getColorToken('colors.discovery.body.white.heading')};
      }
    }

    .summary-item__byline__content {
      ${BylinesWrapper},
      .byline__preamble,
      .byline__name,
      .byline__social-link,
      .byline__name-link:link,
      .byline__name-link:visited {
        ${({ theme, hasListNumberBySummary }) => hasListNumberBySummary &&
    getColorStyles(theme, 'color', 'colors.discovery.body.light.accreditation')};
      }
    }
    ${({ dividerColor }) => dividerColor &&
    `
        ${applyCustomBorderTopColor(dividerColor)};
      `}
    ${applyMobileOnlyBorder}
  }
`;
const AsideAdListItem = styled.li.withConfig({
    displayName: 'AsideAdListItem'
}) `
  &.hide-aside-ad {
    display: none;
  }

  &.show-aside-ad {
    display: grid;

    .ad--aside {
      ${({ hasDiscoveryBodyNumbers }) => hasDiscoveryBodyNumbers && `grid-area: content;`}

      ${({ dividerColor }) => {
    const width = '1px';
    const color = dividerColor
        ? applyCustomBorderTopColor(dividerColor)
        : getColorToken('colors.discovery.body.white.border');
    return `border-top: ${width} solid ${color}`;
}}
    }
  }
`;
const RecircMostPopularItems = styled.ul.withConfig({
    displayName: 'RecircMostPopularItems'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.numerical-large')};
  margin: 0;
  padding: 0;
  list-style: none;

  ${SummaryItemFloatingReviewIcon} {
    top: ${calculateSpacing(-0.05)};
    right: ${calculateSpacing(-1.45)};

    svg {
      width: 70%;
      height: 70%;
    }
  }

  &&& {
    .summary-item__content,
    .ad__slot--aside {
      ${({ showVerticalBorders, theme }) => showVerticalBorders &&
    `
        border-left: ${getDecoration(theme, 'dividerWidth')} solid
        ${getColorToken(theme, 'colors.discovery.body.white.border')};
        padding-left: ${calculateSpacing(2)};

        .ad__slot--aside {
          margin: ${calculateSpacing(2)} 0;
        }
      `}
    }
  }

  li:first-of-type .summary-item--has-border:first-of-type {
    border: none;
  }

  ${({ counterSuffix, hasDiscoveryBodyNumbers, theme }) => hasDiscoveryBodyNumbers &&
    `
    li {
      display: grid;
      grid-template-areas: 
        '. header' 
        'counter content';
      grid-template-columns: min-content auto;
      align-items: center;
      counter-increment: inst;
    }

    li::before {
      grid-area: counter;
      color: ${getColorToken(theme, 'colors.discovery.body.white.heading')};
      content: counter(inst) '${counterSuffix} ';
      padding-right: ${calculateSpacing(2)};
    }

    .rubric.summary-item__rubric {
      grid-area: header;
    }

    .summary-item {
      grid-area: content;
    }
  `}

  ${({ hasListNumberBySummary, theme }) => hasListNumberBySummary &&
    `
        clear: both;
        margin-left: ${calculateSpacing(2)};
    
        .rubric.summary-item__rubric {
            margin-bottom: ${calculateSpacing(0.5)};
        }
    
        ${RecircMostPopularSummaryItem} {
            padding: ${calculateSpacing(2)} 0 ${calculateSpacing(2)} ${calculateSpacing(2)};
        }
    
        .summary-item__hed {
            margin-bottom: ${calculateSpacing(0.5)};
        }
        li {
            display: block;
            position: relative;
            counter-increment: inst;
        }
        li::before {
          ${getTypographyStyles('typography.definitions.globalEditorial.numerical-large')};
          position: absolute;
          margin-left: ${calculateSpacing(-2)};
          top: 50%;
          transform: translateY(-50%);
          color: ${getColorToken(theme, 'colors.discovery.body.white.heading')};
          content: counter(inst) ' ';     
        } 
    `}
`;
const RecircMostPopularFooter = styled.div.withConfig({
    displayName: 'RecircMostPopularFooter'
}) `
  ${({ hasListNumberBySummary }) => !hasListNumberBySummary &&
    `
    border-top: ${({ theme }) => getDecoration(theme, 'dividerWidth')} solid ${getColorToken('colors.discovery.body.white.border')};
    `}

  ${({ dividerColor }) => dividerColor &&
    css `
      ${applyCustomBorderTopColor(dividerColor)};
    `}
  padding-top: ${calculateSpacing(1)};
`;
const RecircMostPopularFooterLink = styled(BaseLink).withConfig({
    displayName: 'RecircMostPopularFooterLink'
}) `
  ${getTypographyStyles('typography.definitions.foundation.link-primary')};
  ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.utility-link.default', 'colors.foundation.collapsed-menu.utility-link.hover', 'navigation')};
`;
module.exports = {
    AsideAdListItem,
    RecircMostPopularWrapper,
    RecircMostPopularContiner,
    RecircMostPopularHeading,
    RecircMostPopularHeadingLogo,
    RecircMostPopularItems,
    RecircMostPopularFooter,
    RecircMostPopularFooterLink,
    RecircMostPopularSummaryItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 34472:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    sectionTitle: {
        id: 'RecircMostPopular.SectionTitle',
        defaultMessage: 'Most Popular',
        description: 'Section title for most popular recirculation items'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 16234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const RecircMostPopular = __webpack_require__(41160);
RecircMostPopular.MainPattern = asVariation(RecircMostPopular, 'MainPattern', {
    hasListNumber: false
});
RecircMostPopular.NumberedList = asVariation(RecircMostPopular, 'NumberedList', {
    hasListNumber: true
}, { hasDiscoveryBodyNumbers: true });
RecircMostPopular.NumberedListBySummary = asVariation(RecircMostPopular, 'NumberedListBySummary', {
    hasListNumber: true,
    hasListNumberBySummary: true
}, { showVerticalBorders: true });
module.exports = RecircMostPopular;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 51066:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RibbonUnitCountDown = void 0;
const react_1 = __importStar(__webpack_require__(96540));
const moment_1 = __importDefault(__webpack_require__(95093));
const react_intl_1 = __webpack_require__(46984);
const utils_1 = __webpack_require__(17282);
const RibbonUnit_1 = __webpack_require__(53267);
const translations = (__webpack_require__(14675)/* ["default"] */ .A);
const RibbonUnitCountDown = ({ buttonLabel, buttonLabelLive, buttonLabelAfter, countDownStartTime, dangerousDek, dangerousDekCountdown, dangerousDekAfter, landingPageURL, landingPageURLLive, liveIndicator, landingPageURLAfter, eventStartTime, eventEndTime }) => {
    const [countDownStarted, setCountedStarted] = (0, react_1.useState)(false);
    const [showLiveIndicator, setShowLiveIndicator] = (0, react_1.useState)(false);
    const [appendDangerousDek, setAppendDangerousDek] = (0, react_1.useState)('');
    const [displayButtonLabel, setDisplayButtonLabel] = (0, react_1.useState)(buttonLabel);
    const [displayLandingPageURL, setDisplayLandingPageURL] = (0, react_1.useState)(landingPageURL);
    const [displayHours, setDisplayHours] = (0, react_1.useState)('');
    const [displayMinutes, setDisplayMinutes] = (0, react_1.useState)('');
    const [displaySeconds, setDisplaySeconds] = (0, react_1.useState)('');
    const [displayDays, setDisplayDays] = (0, react_1.useState)('');
    const [displayDate, setDisplayDate] = (0, react_1.useState)('');
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const { formatMessage } = (0, react_intl_1.useIntl)();
    (0, react_1.useEffect)(() => {
        if ((0, utils_1.isInFuture)(eventStartTime) && (0, utils_1.wasInPast)(countDownStartTime)) {
            const duration = (0, utils_1.getDuration)(eventStartTime);
            if (duration > 0) {
                const { days: daysRemaining } = (0, utils_1.calculateTime)(duration);
                if (Number(daysRemaining) >= 12) {
                    setAppendDangerousDek(dangerousDek);
                    setDisplayDate(`${(0, moment_1.default)(eventStartTime).utc().format('MMMM D')}`);
                }
                if (Number(daysRemaining) < 12 && Number(daysRemaining) >= 2) {
                    const daysLeft = (0, utils_1.getDayDiff)(eventStartTime);
                    setAppendDangerousDek(`${dangerousDekCountdown}`);
                    setDisplayDays(`${Number(daysLeft)} ${formatMessage(translations.days)}`);
                }
                if (Number(daysRemaining) < 2) {
                    setAppendDangerousDek(dangerousDekCountdown);
                    setCountedStarted(true);
                }
            }
        }
        if (!(0, utils_1.isInFuture)(eventStartTime)) {
            setAppendDangerousDek(dangerousDek);
            setDisplayButtonLabel(buttonLabelLive);
            setDisplayLandingPageURL(landingPageURLLive);
            setShowLiveIndicator(true);
        }
        if (!(0, utils_1.isInFuture)(eventEndTime)) {
            setShowLiveIndicator(false);
            setDisplayButtonLabel(buttonLabelAfter);
            setAppendDangerousDek(dangerousDekAfter);
            setDisplayLandingPageURL(landingPageURLAfter);
        }
    }, [
        eventStartTime,
        eventEndTime,
        countDownStartTime,
        dangerousDek,
        buttonLabel,
        buttonLabelAfter,
        buttonLabelLive,
        landingPageURLLive,
        landingPageURLAfter,
        dangerousDekCountdown,
        dangerousDekAfter,
        formatMessage
    ]);
    (0, react_1.useEffect)(() => {
        if (countDownStarted) {
            const countDownInterval = setInterval(() => {
                const duration = (0, utils_1.getDuration)(eventStartTime);
                if (duration > 0) {
                    const { days, hours, mins, secs } = (0, utils_1.calculateTime)(duration);
                    const daysRemaining = Number(days);
                    let remainingHours = Number(hours);
                    if (daysRemaining === 1) {
                        remainingHours = 24 + Number(hours);
                    }
                    setAppendDangerousDek(dangerousDekCountdown);
                    setDisplayHours(`${remainingHours}`);
                    setDisplayMinutes(`${mins}`);
                    setDisplaySeconds(`${secs}`);
                }
                else {
                    clearInterval(countDownInterval);
                }
            }, 1000);
        }
    }, [countDownStarted, dangerousDekCountdown, eventStartTime]);
    return (react_1.default.createElement(RibbonUnit_1.RibbonUnit, { buttonLabel: displayButtonLabel, dangerousDek: appendDangerousDek, landingPageURL: displayLandingPageURL, liveIndicator: liveIndicator && showLiveIndicator, displayHours: displayHours, displayMinutes: displayMinutes, displaySeconds: displaySeconds, displayDays: displayDays, displayDate: displayDate }));
};
exports.RibbonUnitCountDown = RibbonUnitCountDown;
//# sourceMappingURL=RibbonUnitCountDown.js.map

/***/ }),

/***/ 95959:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const RibbonUnitCountDown_1 = __webpack_require__(51066);
exports.A = RibbonUnitCountDown_1.RibbonUnitCountDown;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 14675:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    days: {
        id: 'Ribbon.days',
        defaultMessage: 'days',
        description: 'Ribbon days'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 17282:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.calculateTime = exports.getDayDiff = exports.getDuration = exports.wasInPast = exports.isInFuture = void 0;
const padStart = __webpack_require__(52037);
const isInFuture = (timeStamp) => new Date(timeStamp).valueOf() > new Date().valueOf();
exports.isInFuture = isInFuture;
const wasInPast = (timeStamp) => new Date(timeStamp).valueOf() < new Date().valueOf();
exports.wasInPast = wasInPast;
const getDuration = (timeStamp) => {
    return new Date(timeStamp) - new Date();
};
exports.getDuration = getDuration;
const getDayDiff = (timeStamp) => {
    const startDate = new Date(timeStamp);
    const today = new Date();
    // Normalize to midnight
    startDate.setHours(0, 0, 0, 0);
    today.setHours(0, 0, 0, 0);
    const diffInMs = startDate - today;
    const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
    return diffInDays;
};
exports.getDayDiff = getDayDiff;
const getFormatedNumber = (number) => padStart(number, 2, '0');
const calculateTime = (duration) => {
    let secs = Math.floor((duration / 1000) % 60);
    let mins = Math.floor((duration / (1000 * 60)) % 60);
    let hours = Math.floor((duration / (1000 * 60 * 60)) % 24);
    let days = Math.floor(duration / (1000 * 60 * 60 * 24));
    hours = getFormatedNumber(hours);
    mins = getFormatedNumber(mins);
    secs = getFormatedNumber(secs);
    days = getFormatedNumber(days);
    return { days, hours, mins, secs };
};
exports.calculateTime = calculateTime;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 53267:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RibbonUnit = void 0;
const react_1 = __importDefault(__webpack_require__(96540));
const classnames_1 = __importDefault(__webpack_require__(32485));
const styles_1 = __webpack_require__(95063);
const getLiveIndicator = () => {
    return (react_1.default.createElement(styles_1.RibbonUnitLiveIndicatorContainer, null,
        react_1.default.createElement(styles_1.RibbonUnitLiveIndicator, null,
            react_1.default.createElement(styles_1.RibbonUnitLiveIndicatorAnimation, null))));
};
const getTimerWithColon = (displayTime, shouldApplyPadding) => {
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(styles_1.TimerValueContainer, { shouldApplyPadding: shouldApplyPadding },
            react_1.default.createElement("span", { className: "notranslate" }, displayTime)),
        react_1.default.createElement(styles_1.TimerColon, null,
            react_1.default.createElement("span", { className: "notranslate" }, ":"))));
};
const getTimer = (displayTime) => {
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(styles_1.TimerValueContainer, null,
            react_1.default.createElement("span", { className: "notranslate" }, displayTime))));
};
const getDays = (displayDays) => {
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(styles_1.DaysValueContainer, null,
            react_1.default.createElement("span", { className: "notranslate" }, displayDays))));
};
const getDate = (displayDate) => {
    return (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(styles_1.DateValueContainer, null,
            react_1.default.createElement("span", { className: "notranslate" }, displayDate))));
};
const RibbonUnit = ({ buttonLabel, dangerousDek, landingPageURL, liveIndicator, displayHours = '', displayMinutes = '', displaySeconds = '', displayDays = '', displayDate = '' }) => {
    return (react_1.default.createElement(styles_1.RibbonUnitWrapper, { href: landingPageURL, className: (0, classnames_1.default)('NewsletterRibbonComponent') },
        react_1.default.createElement(styles_1.RibbonUnitContentWrapper, null,
            react_1.default.createElement(styles_1.RibbonUnitDangerousDek, { dangerouslySetInnerHTML: { __html: dangerousDek } }),
            displayHours !== '' && getTimerWithColon(displayHours, true),
            displayMinutes !== '' && getTimerWithColon(displayMinutes, false),
            displaySeconds !== '' && getTimer(displaySeconds),
            displayDays !== '' && getDays(displayDays),
            displayDate !== '' && getDate(displayDate),
            react_1.default.createElement(styles_1.RibbonUnitButtonWrapper, null,
                liveIndicator && getLiveIndicator(),
                react_1.default.createElement(styles_1.RibbonUnitButton, { dangerouslySetInnerHTML: { __html: buttonLabel } })))));
};
exports.RibbonUnit = RibbonUnit;
//# sourceMappingURL=RibbonUnit.js.map

/***/ }),

/***/ 35989:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const RibbonUnit_1 = __webpack_require__(53267);
exports.A = RibbonUnit_1.RibbonUnit;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 95063:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RibbonUnitLiveIndicatorAnimation = exports.RibbonUnitLiveIndicator = exports.RibbonUnitLiveIndicatorContainer = exports.RibbonUnitButton = exports.RibbonUnitButtonWrapper = exports.TimerColon = exports.DateValueContainer = exports.DaysValueContainer = exports.TimerValueContainer = exports.RibbonUnitDangerousDek = exports.RibbonUnitContentWrapper = exports.RibbonUnitWrapper = void 0;
const { default: styled } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles, calculateSpacing } = __webpack_require__(26865);
exports.RibbonUnitWrapper = styled.a.withConfig({
    displayName: 'RibbonUnitWrapper'
}) `
  display: grid;
  background-color: ${getColorToken('colors.interactive.base.white')};
  color: ${getColorToken('colors.interactive.base.black')};
  border-bottom: ${calculateSpacing(0.125)} solid
    ${getColorToken('colors.interactive.base.black')};
  text-align: center;
  text-decoration: none;
  padding: 0.5rem;
  align-items: center;
`;
exports.RibbonUnitContentWrapper = styled.div.withConfig({
    displayName: 'RibbonUnitContentWrapper'
}) `
  display: inline-flex;
  justify-content: center;
`;
exports.RibbonUnitDangerousDek = styled.div.withConfig({
    displayName: 'RibbonUnitDangerousDek'
}) `
  ${getTypographyStyles('typography.definitions.utility.body')};
  text-align: right;
  text-transform: none;
`;
exports.TimerValueContainer = styled.div.withConfig({
    displayName: 'TimerValueContainer'
}) `
  ${getTypographyStyles('typography.definitions.utility.body')};
  align-items: center;
  width: 1.25rem;
  text-align: center;
  ${({ shouldApplyPadding }) => shouldApplyPadding && `padding-left: 0.125rem;`}
`;
exports.DaysValueContainer = styled.div.withConfig({
    displayName: 'DaysValueContainer'
}) `
  ${getTypographyStyles('typography.definitions.utility.body')};
  padding-left: 0.25rem;
`;
exports.DateValueContainer = styled.div.withConfig({
    displayName: 'DateValueContainer'
}) `
  ${getTypographyStyles('typography.definitions.utility.body')};
  padding-left: 0.5rem;
`;
exports.TimerColon = styled.div.withConfig({
    displayName: 'TimerColon'
}) `
  ${getTypographyStyles('typography.definitions.utility.body')};
`;
exports.RibbonUnitButtonWrapper = styled.div.withConfig({
    displayName: 'RibbonUnitButtonWrapper'
}) `
  display: inline-flex;
  align-items: center;
  padding-left: 1.5rem;
`;
exports.RibbonUnitButton = styled.div.withConfig({
    displayName: 'RibbonUnitButton'
}) `
  ${getTypographyStyles('typography.definitions.utility.button-core')};
  text-decoration: underline;
  text-align: left;
  text-transform: none;
`;
exports.RibbonUnitLiveIndicatorContainer = styled.div.withConfig({
    displayName: 'RibbonUnitLiveIndicatorContainer'
}) `
  position: relative;
  align-items: center;
  padding-right: 0.5rem;
`;
exports.RibbonUnitLiveIndicator = styled.div.withConfig({
    displayName: 'RibbonUnitLiveIndicator'
}) `
  border-radius: 50%;
  background-color: ${getColorToken('colors.interactive.feedback.invalid-primary')};
  width: 0.5rem;
  height: 0.5rem;
`;
exports.RibbonUnitLiveIndicatorAnimation = styled.div.withConfig({
    displayName: 'RibbonUnitLiveIndicatorAnimation'
}) `
  position: absolute;
  animation: pulsate 2.5s ease-in-out;
  animation-iteration-count: infinite;
  opacity: 0;
  border: 3px solid;
  border-radius: 50%;
  border-color: ${getColorToken('colors.interactive.feedback.invalid-primary')};
  background-color: ${getColorToken('colors.interactive.feedback.invalid-primary')};
  width: 0.5rem;
  height: 0.5rem;

  @keyframes pulsate {
    0% {
      transform: scale(0.1, 0.1);
      opacity: 0;
    }

    35% {
      opacity: 1;
    }

    75% {
      transform: scale(3, 3);
      opacity: 0;
    }
  }
`;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 22509:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.doCloseModal = exports.doDisplayModal = exports.setModalDispatcher = void 0;
let dispatch;
const actionKey = 'signInModalConfig';
const setModalDispatcher = (dispatchIn) => {
    dispatch = dispatchIn;
};
exports.setModalDispatcher = setModalDispatcher;
const _showHideModal = (isVisible, modalState) => {
    if (!dispatch) {
        console.error('Dispatcher not found for SignInModal actions');
        return;
    }
    dispatch({
        type: 'MERGE_KEY',
        key: actionKey,
        value: {
            ...modalState,
            isVisible
        }
    });
};
const doDisplayModal = (modalState) => {
    _showHideModal(true, modalState);
};
exports.doDisplayModal = doDisplayModal;
const doCloseModal = () => {
    _showHideModal(false);
};
exports.doCloseModal = doCloseModal;
//# sourceMappingURL=SignInModalActions.js.map

/***/ }),

/***/ 18550:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OverlayNavigationSecondaryLink = exports.OverlayNavigationSecondaryLinks = exports.OverlayNavigationSecondaryListItem = exports.OverlayNavigationPrimaryLink = exports.OverlayNavigationPrimaryListItem = exports.OverlayNavigationPrimaryLinks = exports.OverlayNavigationUtilityLink = exports.OverlayNavigationUtilityListItem = exports.OverlayNavigationUtilityLinks = exports.OverlayNavigationSocialHeading = exports.OverlayNavigationSocialLinks = exports.OverlayNavigationButton = exports.OverlayNavigationBottom = exports.OverlayNavigationUtility = exports.OverlayNavigationLogo = exports.OverlayNavigationTop = exports.OverlayNavigationWrapper = void 0;
const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getZIndex } = __webpack_require__(26865);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const { BaseText, BaseLink } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const { resolveMenuKey, isInverted } = __webpack_require__(70698);
const { SiteHeaderStickyWrapper, SiteHeaderTopRule, SiteHeaderTop, SiteHeaderTopStatic, SiteHeaderLogo, SiteHeaderUtility, SiteHeaderButton } = __webpack_require__(27985);
const { SocialIconsWrapper } = __webpack_require__(51000);
const { AppDownloadLinksWrapper } = __webpack_require__(9580);
exports.OverlayNavigationWrapper = styled(SiteHeaderStickyWrapper).withConfig({ displayName: 'OverlayNavigationWrapper' }) `
  display: ${({ isVisible }) => (isVisible ? 'block' : 'none')};
  position: fixed;
  ${({ hasTopRule, topRuleAdditionalCSS }) => hasTopRule && topRuleAdditionalCSS ? topRuleAdditionalCSS : `top: 0;`};
  right: 0;
  bottom: 0;
  left: 0;
  z-index: ${getZIndex('hyperstitialLayer')};
  border-top-color: transparent;
  box-shadow: none;
  overflow-y: scroll;

  ${({ shouldShowOverlayTop }) => !shouldShowOverlayTop &&
    `@media (max-width: ${BREAKPOINTS.md}) {
      top: 3.5rem;
    }`}
`;
exports.OverlayNavigationWrapper.defaultProps = {
    topRuleAdditionalCSS: SiteHeaderTopRule
};
exports.OverlayNavigationTop = styled(SiteHeaderTop).withConfig({
    displayName: 'OverlayNavigationTop'
}) `
  border-bottom-color: transparent;
`;
exports.OverlayNavigationTop.defaultProps = {
    additionalCSS: SiteHeaderTopStatic
};
exports.OverlayNavigationLogo = styled(SiteHeaderLogo).withConfig({
    displayName: 'OverlayNavigationLogo'
}) `
  @media not all and (min-resolution: 0.001dpcm) {
    & > a {
      outline: 0;
    }
  }
`;
exports.OverlayNavigationUtility = styled(SiteHeaderUtility).withConfig({
    displayName: 'OverlayNavigationUtility'
}) ``;
exports.OverlayNavigationBottom = styled.div.withConfig({
    displayName: 'OverlayNavigationBottom'
}) `
  ${cssVariablesGrid()}
  display: grid;
  column-gap: var(--grid-gap);
  ${applyGridSpacing('padding')};

  @media (min-width: ${BREAKPOINTS.md}) {
    grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
  }

  ${AppDownloadLinksWrapper} {
    border-top: 1px solid ${getColorToken('colors.foundation.menu.dividers')};
  }
`;
exports.OverlayNavigationButton = styled(SiteHeaderButton).withConfig({
    displayName: 'OverlayNavigationButton'
}) `
  .icon-close {
    padding: 8px;
  }
`;
exports.OverlayNavigationSocialLinks = styled.div.withConfig({
    displayName: 'OverlayNavigationSocialLinks'
}) `
  border-top: 1px solid
    ${({ theme }) => getColorToken(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.menu.dividers')};
  padding-bottom: ${calculateSpacing(7)};

  a {
    transition: all 0.2s cubic-bezier(0, 0, 0, 0.8) 0s;
    margin-top: ${calculateSpacing(1.5)};
    border: 1px solid
      ${({ theme }) => getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default'))};
    border-radius: 50%;

    &:hover,
    &:focus {
      border-color: ${({ theme }) => getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.hover'))};
    }
  }

  ${SocialIconsWrapper} svg.icon path {
    fill: ${({ theme }) => getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default'))};
  }
`;
exports.OverlayNavigationSocialHeading = styled(BaseText)
    .withConfig({
    displayName: 'OverlayNavigationSocialHeading'
})
    .attrs(({ theme }) => ({
    colorToken: resolveMenuKey(theme, isInverted(theme)
        ? 'colors.consumption.lead.inverted.link'
        : 'colors.foundation.collapsed-menu.nav-link.default')
})) `
  opacity: 0.6;
  margin: 0;
  padding-top: ${calculateSpacing(1)};
  font-size: 12px;
`;
exports.OverlayNavigationSocialHeading.defaultProps = {
    typeIdentity: 'typography.definitions.foundation.title-primary'
};
exports.OverlayNavigationUtilityLinks = styled.ul.withConfig({
    displayName: 'OverlayNavigationUtilityLinks'
}) `
  display: flex;
  flex-direction: column;
  margin: 0;
  padding: 0;
  white-space: nowrap;
`;
exports.OverlayNavigationUtilityListItem = styled.li.withConfig({
    displayName: 'OverlayNavigationUtilityListItem'
}) `
  display: flex;
  position: relative;
  align-items: center;
  padding: ${calculateSpacing(1)} 0;

  &::before {
    position: absolute;
    top: 0;
    border-top: 1px solid
      ${({ theme }) => getColorToken(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.menu.dividers')};
    width: 100%;
    height: 1px;
    content: '';
  }

  &:first-child::before {
    border-color: ${({ theme }) => getColorToken(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
  }

  &:last-child {
    margin-bottom: ${calculateSpacing(3)};
  }
`;
exports.OverlayNavigationUtilityLink = styled(BaseLink)
    .withConfig({
    displayName: 'OverlayNavigationUtilityLink'
})
    .attrs(({ theme }) => ({
    colorSecondaryLinkToken: resolveMenuKey(theme, isInverted(theme)
        ? 'colors.consumption.lead.inverted.link'
        : 'colors.foundation.collapsed-menu.nav-link.hover'),
    colorStaticLinkToken: resolveMenuKey(theme, isInverted(theme)
        ? 'colors.consumption.lead.inverted.link'
        : 'colors.foundation.collapsed-menu.nav-link.default')
})) `
      display: block;
      padding: ${calculateSpacing(1)} 0;
      width: 100%;
      overflow: hidden;
      text-decoration: none;
      text-overflow: ellipsis;
      line-height: ${calculateSpacing(4)};
      word-break: normal;
      white-space: normal;

        &:hover,
        &:focus {
        text-decoration: none;
      }
  ${({ isSubscribeButton, isColorTokenInverted, theme }) => isSubscribeButton &&
    `
    && {
      color: ${getColorToken(theme, resolveMenuKey(theme, isColorTokenInverted
        ? 'colors.consumption.body.inverted.link'
        : 'colors.foundation.collapsed-menu.nav-link.hover'))};
    }
  `}
`;
exports.OverlayNavigationUtilityLink.defaultProps = {
    linkStyle: 'navigation',
    typeToken: 'typography.definitions.foundation.link-primary'
};
exports.OverlayNavigationPrimaryLinks = styled(exports.OverlayNavigationUtilityLinks).withConfig({ displayName: 'OverlayNavigationPrimaryLinks' }) ``;
exports.OverlayNavigationPrimaryListItem = styled(exports.OverlayNavigationUtilityListItem).withConfig({ displayName: 'OverlayNavigationPrimaryListItem' }) ``;
exports.OverlayNavigationPrimaryLink = styled(exports.OverlayNavigationUtilityLink).withConfig({ displayName: 'OverlayNavigationPrimaryLink' }) `
  ${({ shouldOverridePrimaryLinkBISize }) => shouldOverridePrimaryLinkBISize &&
    `
      line-height: ${calculateSpacing(6)};
      font-size: 32px;

      @media (min-width: ${BREAKPOINTS.lg}) {
        padding: ${calculateSpacing(1.5)} 0;
        font-size: 48px;
      }
    `}
`;
exports.OverlayNavigationPrimaryLink.defaultProps = {
    typeToken: 'typography.definitions.foundation.link-feature'
};
exports.OverlayNavigationSecondaryListItem = styled(exports.OverlayNavigationUtilityListItem).withConfig({ displayName: 'OverlayNavigationSecondaryListItem' }) ``;
exports.OverlayNavigationSecondaryLinks = styled(exports.OverlayNavigationUtilityLinks).withConfig({ displayName: 'OverlayNavigationSecondaryLinks' }) ``;
exports.OverlayNavigationSecondaryLink = styled(exports.OverlayNavigationUtilityLink).withConfig({ displayName: 'OverlayNavigationSecondaryLink' }) ``;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 27985:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SiteHeaderTopStatic = exports.SiteHeaderTopSticky = exports.SiteHeaderTopRule = exports.SiteHeaderButton = exports.SiteHeaderUtility = exports.SiteHeaderTop = exports.SiteHeaderLogo = exports.SiteHeaderNavLeft = exports.SiteHeaderStickyEmpty = exports.HiddenStickyWrapper = exports.VisibleStickyWrapper = exports.SiteHeaderStickyWrapper = exports.SITE_HEADER_TOP_STICKY_HEIGHT_LG = exports.SITE_HEADER_TOP_STICKY_HEIGHT_MD = exports.SITE_HEADER_TOP_HEIGHT = exports.SiteHeaderWrapper = void 0;
const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getZIndex } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const { resolveMenuKey, isInverted } = __webpack_require__(70698);
const Button = __webpack_require__(73730);
const { BaseWrap } = __webpack_require__(76955);
exports.SiteHeaderWrapper = styled.header.withConfig({
    displayName: 'SiteHeaderWrapper'
}) `
  position: sticky;
  top: 0;
  right: 0;
  left: 0;
  transition: all 500ms ease;
  z-index: ${getZIndex('persistentTopLayer')};
  background-color: ${({ theme }) => getColorToken(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.background'
    : 'colors.background.adContainer.special')};
  ${({ hasContentHeaderLogo, additionalCSS }) => !hasContentHeaderLogo
    ? additionalCSS
    : `
      top: 0px;
      `}
`;
exports.SITE_HEADER_TOP_HEIGHT = '64px';
exports.SITE_HEADER_TOP_STICKY_HEIGHT_MD = '112px';
exports.SITE_HEADER_TOP_STICKY_HEIGHT_LG = '136px';
// StickyWrapper
exports.SiteHeaderStickyWrapper = styled.div.withConfig({
    displayName: 'SiteHeaderStickyWrapper'
}) `
  ${({ hasSEOSupport }) => hasSEOSupport &&
    `
    position: relative;
    z-index: 999; `}
  transition: all 500ms ease;
  border-top: ${({ hasTopRule, theme }) => hasTopRule
    ? `${calculateSpacing(0.5)} solid ${getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
        ? 'colors.consumption.lead.inverted.background'
        : 'colors.foundation.menu-bg.collapsed'))}}`
    : 'none'};
  box-shadow: ${({ shouldHideShadow }) => shouldHideShadow ? 'none' : '-2px 2px 5px rgba(0, 0, 0, 0.1);'};
  background-color: ${({ theme }) => getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.background'
    : 'colors.foundation.menu-bg.collapsed'))};
  width: 100%;
  ${(props) => props.topRuleAdditionalCSS};
`;
exports.VisibleStickyWrapper = css `
  top: 0;
`;
exports.HiddenStickyWrapper = css `
  top: ${(props) => -(props.headerHeight + 5)}px;
`;
exports.SiteHeaderStickyEmpty = styled.div.withConfig({
    displayName: 'SiteHeaderStickyEmpty'
}) `
  height: ${(props) => props.headerHeight}px;
`;
exports.SiteHeaderNavLeft = styled.div.withConfig({
    displayName: 'SiteHeaderNavLeft'
}) `
  display: flex;
  grid-area: nav-left;
  justify-self: self-start;
  align-items: center;
`;
// Logo
exports.SiteHeaderLogo = styled(BaseWrap).withConfig({
    displayName: 'SiteHeaderLogo'
}) `
  grid-area: logo;
  justify-self: self-start;
  align-self: center;
  transition: all 500ms ease;
  width: 100%;
  height: 100%;

  @media (min-width: ${BREAKPOINTS.md}) {
    ${({ isCenteredOnDesktop }) => isCenteredOnDesktop &&
    `
      /** 
       * Making this span the entire width of the viewport
       * minus the padding applied for the SiteHeaderTop
       * to center align it irrespective of the utility links or market switcher being present
      */ 
      width: calc(100vw - calc(2 * var(--grid-margin)));
      text-align: center;
      transition: all 500ms ease, width 0s ease, text-align 0s ease;
    `}
  }

  a {
    display: inline-block;
    height: 100%;
  }

  .responsive-asset,
  .responsive-asset picture {
    height: 100%;
  }

  .responsive-asset {
    overflow: visible;
  }

  img {
    object-fit: contain;
    height: 100%;
  }
`;
exports.SiteHeaderTop = styled.div.withConfig({
    displayName: 'SiteHeaderTop'
}) `
  ${cssVariablesGrid()}
  display: grid;
  position: relative;
  grid-template-areas: 'logo utility';
  grid-template-columns: minmax(${calculateSpacing(17)}, 1fr) auto;
  grid-template-rows: ${calculateSpacing(5)};
  gap: ${calculateSpacing(2)};
  ${exports.SiteHeaderNavLeft} {
    display: none;
  }
  @media (max-width: ${BREAKPOINTS.md}) {
    gap: ${calculateSpacing(1)};
  }
  @media (min-width: ${BREAKPOINTS.lg}) {
    gap: ${calculateSpacing(1)};
    grid-template-areas: 'nav-left logo utility';
    grid-template-columns: min-content auto ${calculateSpacing(34)};

    ${exports.SiteHeaderNavLeft} {
      display: flex;
    }

    ${exports.SiteHeaderLogo} {
      grid-column-end: -1;
      grid-column-start: 1;
    }
  }
  align-content: center;
  align-items: center;
  transition: all 500ms ease;
  border-bottom: ${({ theme }) => `1px solid ${getColorToken(theme, 'colors.foundation.menu.dividers')}`};
  height: ${exports.SITE_HEADER_TOP_HEIGHT};
  ${applyGridSpacing('padding')};
  ${({ hasContentHeaderLogo, additionalCSS }) => !hasContentHeaderLogo
    ? additionalCSS
    : `
  `}

  /* This is done to add proper color to Close icon in Utility Navigation in Site Header */
  .icon-close > g {
    stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.light')};
  }
`;
// Utility
exports.SiteHeaderUtility = styled.div.withConfig({
    displayName: 'SiteHeaderUtility'
}) `
  display: flex;
  grid-area: utility;
  justify-self: self-end;
  align-items: center;
  align-self: start;
`;
// Button
exports.SiteHeaderButton = styled(Button.Utility).withConfig({
    displayName: 'SiteHeaderButton'
}) `
  z-index: 1;
  margin-right: -${calculateSpacing(1)};
  margin-left: ${calculateSpacing(1)};
  cursor: pointer;
  padding: 0;
  height: ${calculateSpacing(5)};
  line-height: 0;

  &,
  &:active,
  &:hover,
  &:focus {
    border: 0;
    background-color: transparent;
  }

  svg {
    fill: ${({ theme }) => getColorToken(theme, resolveMenuKey(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default'))};

    &:active,
    &:focus,
    &:hover {
      fill: ${({ theme }) => getColorToken(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
    }
  }
`;
/**
 *
 * Additional CSS
 *
 */
exports.SiteHeaderTopRule = css `
  ${({ hasTopRule }) => hasTopRule &&
    `
      @media (min-width: ${BREAKPOINTS.md}) {
        border-top-width: ${calculateSpacing(1)};
      }

      @media (min-width: ${BREAKPOINTS.lg}) {
        border-top-width: ${calculateSpacing(1.5)};
      }
    `}
`;
exports.SiteHeaderTopSticky = css `
  grid-template-rows: ${calculateSpacing(5)};
`;
exports.SiteHeaderTopStatic = css `
  @media (min-width: ${BREAKPOINTS.md}) {
    grid-template-rows: ${calculateSpacing(7)};
    height: ${exports.SITE_HEADER_TOP_STICKY_HEIGHT_MD};
  }

  @media (min-width: ${BREAKPOINTS.lg}) {
    grid-template-rows: ${calculateSpacing(9)};
    height: ${exports.SITE_HEADER_TOP_STICKY_HEIGHT_LG};
  }
`;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 70698:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveMenuKey = exports.isInverted = exports.getStateWithHeaderHeight = exports.computeScroll = exports.INITIAL_STATE = void 0;
const THRESHOLD_PIXELS = 100;
const SCROLL_UP = 'up';
const SCROLL_DOWN = 'down';
const SCROLL_NONE = 'none';
exports.INITIAL_STATE = {
    direction: SCROLL_NONE,
    pageYOffset: 0,
    showSticky: true,
    clippedMenu: false
};
const getPageYOffset = () => {
    try {
        return window?.pageYOffset || 0;
    }
    catch (e) {
        return 0;
    }
};
const computeScrollDirection = (currentPageYOffset, previousPageYOffset) => {
    const pageYOffsetDiff = currentPageYOffset - previousPageYOffset;
    if (pageYOffsetDiff === 0) {
        return SCROLL_NONE;
    }
    return pageYOffsetDiff < 0 ? SCROLL_UP : SCROLL_DOWN;
};
const isToChangeHeader = (direction, currentPageYOffset, changeDirectionPageYOffset) => {
    switch (direction) {
        case SCROLL_DOWN:
            return (currentPageYOffset >= changeDirectionPageYOffset + THRESHOLD_PIXELS);
        case SCROLL_UP:
            return (currentPageYOffset <= changeDirectionPageYOffset - THRESHOLD_PIXELS);
        default:
            return false;
    }
};
const computeScroll = (prevState) => {
    const currentPageYOffset = getPageYOffset();
    if (currentPageYOffset === 0) {
        return { ...prevState, ...exports.INITIAL_STATE };
    }
    const direction = computeScrollDirection(currentPageYOffset, prevState.pageYOffset);
    const changeDirectionPageYOffset = prevState.direction !== direction
        ? currentPageYOffset
        : prevState.changeDirectionPageYOffset;
    const changeHeader = isToChangeHeader(direction, currentPageYOffset, changeDirectionPageYOffset);
    let { showSticky, clippedMenu } = prevState;
    if (changeHeader) {
        showSticky = direction === SCROLL_UP;
    }
    clippedMenu =
        direction === SCROLL_UP || (clippedMenu && direction === SCROLL_DOWN);
    return {
        ...prevState,
        direction,
        pageYOffset: currentPageYOffset,
        changeDirectionPageYOffset,
        showSticky,
        clippedMenu
    };
};
exports.computeScroll = computeScroll;
const getStateWithHeaderHeight = (prevState, headerRef) => {
    const headerHeight = headerRef?.current?.getBoundingClientRect()?.height || 0;
    return { ...prevState, headerHeight };
};
exports.getStateWithHeaderHeight = getStateWithHeaderHeight;
const isInverted = ({ palette }) => palette === 'inverted';
exports.isInverted = isInverted;
const resolveMenuKey = (theme, key) => {
    if ((0, exports.isInverted)(theme)) {
        if (/\.collapsed/.exec(key))
            return key.replace('.collapsed', '.expanded');
        if (/\.expanded/.exec(key))
            return key.replace('.expanded', '.collapsed');
    }
    return key;
};
exports.resolveMenuKey = resolveMenuKey;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 94060:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useCarouselDots = void 0;
const React = __webpack_require__(96540);
const noop = () => null;
function useResizeObserver(callback, { observe }) {
    const ref = React.useRef(null);
    React.useEffect(() => {
        const element = ref?.current;
        if (!element || !observe) {
            return noop;
        }
        const observer = new ResizeObserver((entries) => {
            callback(element, entries[0]);
        });
        observer.observe(element);
        return () => observer.disconnect();
    }, [observe, callback, ref]);
    return ref;
}
const useCarouselDots = ({ itemsLength, listen = false }) => {
    const [carouselDots, setCarouselDots] = React.useState(1);
    const [selectedDot, setSelectedDot] = React.useState(0);
    const ref = useResizeObserver((_, entry) => {
        const { scrollWidth, clientWidth } = entry.target;
        const approxChildWidth = scrollWidth / itemsLength;
        const childPerScreen = Math.round(clientWidth / approxChildWidth);
        const numberOfDots = Math.ceil(itemsLength / childPerScreen);
        setCarouselDots(numberOfDots);
    }, { observe: listen });
    const handleScroll = (event) => {
        const { scrollWidth, scrollLeft } = event.target;
        const eachDotContentWidth = scrollWidth / carouselDots;
        const currentDot = Math.ceil(scrollLeft / eachDotContentWidth);
        setSelectedDot(currentDot);
    };
    return {
        ref,
        handleScroll: listen ? handleScroll : noop,
        selectedDot,
        carouselDots
    };
};
exports.useCarouselDots = useCarouselDots;
//# sourceMappingURL=use-carousel-dots.js.map

/***/ }),

/***/ 28003:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Rubric = __webpack_require__(51330);
const { asConfiguredComponent } = __webpack_require__(12892);
const { TrackComponentChannel } = __webpack_require__(78788);
const QUICKREAD = 'quickRead';
const LONGFORM = 'longform';
/**
 * StoryAssurance component
 *
 * @param {object} props - React props
 * @param {object} [props.assuranceConfig] - Optional to get the story Assurance, config of the brand
 * @param {boolean} [props.hasStoryAssurance] -  Optional to show/hide the story assurance, and return the default
 * @param {Element} [props.rubric] -  Optional renders passed in component
 * @param {number} [props.wordCount] - Optional word count of an article
 *
 * @returns {ReactElement} <reactElement>
 */
const StoryAssurance = ({ assuranceConfig, hasStoryAssurance, rubric, wordCount }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'StoryAssurance'
        });
    }, []);
    if (!wordCount || !assuranceConfig || !hasStoryAssurance)
        return rubric;
    const quickReadWordCount = assuranceConfig?.quickRead?.wordCount;
    const longFormWordCount = assuranceConfig?.longform?.wordCount;
    const getAssurance = (word_count) => {
        if (word_count <= quickReadWordCount)
            return QUICKREAD;
        else if (word_count >= longFormWordCount)
            return LONGFORM;
        return '';
    };
    const assuranceType = getAssurance(wordCount);
    return assuranceType ? (React.createElement(Rubric, { ...assuranceConfig[assuranceType] })) : (rubric);
};
StoryAssurance.propTypes = {
    assuranceConfig: PropTypes.object,
    hasStoryAssurance: PropTypes.bool,
    rubric: PropTypes.element,
    wordCount: PropTypes.number
};
module.exports = asConfiguredComponent(StoryAssurance, 'StoryAssurance');
//# sourceMappingURL=StoryAssurance.js.map

/***/ }),

/***/ 75013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(28003);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const get = __webpack_require__(58156);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { connector } = __webpack_require__(57744);
const { asConfiguredComponent } = __webpack_require__(12892);
const { componentTracking } = __webpack_require__(90090);
const { useOnAdFilled } = __webpack_require__(1184);
const Ad = __webpack_require__(19607);
const { PaymentGateway } = __webpack_require__(92807);
const ArrowIcon = __webpack_require__(42361);
const Button = __webpack_require__(73730);
const Grid = __webpack_require__(86659);
const SectionTitle = __webpack_require__(35864);
const SummaryItem = __webpack_require__(74992);
const StickyBox = __webpack_require__(28433);
const StackedRatingsCard = __webpack_require__(97111);
const PaginationModal = __webpack_require__(49312);
const { getVariationNames } = __webpack_require__(81372);
const { getAltTextForSeo } = __webpack_require__(27287);
const { TrackComponentChannel } = __webpack_require__(78788);
const { SummaryCollectionGridAdRail, SummaryCollectionGridButton, SummaryCollectionGridComponent, SummaryCollectionGridContent, SummaryCollectionGridDek, SummaryCollectionGridHeader, SummaryCollectionGridItem, SummaryCollectionGridItems, SummaryCollectionGridSectionTitle, SummaryCollectionGridSummaryItem, SummaryCollectionGridToActionWrapper, SummaryCollectionGridItemsFooter } = __webpack_require__(4534);
const ResponsiveAsset = __webpack_require__(86157);
const CarouselFooter = __webpack_require__(87797);
const { useCarouselDots } = __webpack_require__(94060);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const getSectionTitleLink = ({ dangerousDek, landingPageLink, shouldUseDangerousDekAsLink }) => {
    if (shouldUseDangerousDekAsLink && dangerousDek) {
        return { html: dangerousDek };
    }
    else if (landingPageLink) {
        return landingPageLink;
    }
    return null;
};
const hasSectionTitleProps = ({ dangerousHed, image, link }) => {
    return dangerousHed || image || link;
};
/**
 * Based on the featuredFooter properties, get the link and label for CallToAction
 *
 * @param  {boolean} shouldUseFeaturedFooter - flag to check if featured footer is enabled
 * @param  {object} featuredFooter - featured data {link and label} for call to action button
 * @param  {string} link - link for call to action
 * @param  {string} label - label for call to action
 * @returns {object} the link and label for CallToAction
 *
 */
const getCallToActionProps = ({ shouldUseFeaturedFooter, featuredFooter, link, label, nextPage }) => {
    if (shouldUseFeaturedFooter) {
        return {
            link: featuredFooter?.link || link || nextPage || '',
            label: featuredFooter?.label || label
        };
    }
    return {
        link: link || nextPage || '',
        label
    };
};
function getSectionTitleImage({ seriesLogos, seriesLogoToUse, image, shouldShowSectionTitleImage }) {
    let sectionTitleImage;
    if (seriesLogos) {
        sectionTitleImage = seriesLogos[seriesLogoToUse];
    }
    if (!sectionTitleImage && shouldShowSectionTitleImage) {
        sectionTitleImage = image;
    }
    return sectionTitleImage;
}
/**
 * SummaryCollectionGrid component
 *
 * @param {object} props - React props
 * @param {boolean} [props.alphabetizeItems] - Properties for alphabetizing items
 * @param {boolean} [props.alphabetizeItems.shouldSortItemsByKeyName] - Optional flag to alphabetize items by key name
 * @param {boolean} [props.alphabetizeItems.keyNameToSort] - Optional key name in items to be used in sorting
 * @param {string} [props.buttonType] - Button type for call to action
 * @param {string} [props.buttonVariation] - Optional variation of Button to use
 * @param {string} [props.btnStyle] - Prop used to apply styling to a button
 * @param {string} [props.bylineVariation] - Optional variation of byline
 * @param {number} [props.chunkSize] - Optional number of items per chunk
 * @param {string} [props.className] - Optional top-level class to add
 * @param {number} [props.currentPage] - Current page number
 * @param {Function} [props.clickFunction] - Optional click handler for call to action
 * @param {number} [props.columnAmountForMobile] - Option to set the number of columns to show in mobile devices
 * @param {number} [props.columnAmountForTablet] - Option to set the number of columns to show in tablet devices
 * @param {string} [props.dangerousDek] - Optional dek for section dek
 * @param {string} [props.dangerousHed] - Optional hed for section title
 * @param {object} [props.featuredFooter] - Optional data {link and label} for call to action button
 * @param {boolean} [props.hasAdditionalMargin] - Optional add additional margin settings
 * @param {boolean} [props.hasBackgroundSecondary] - Optional. Set background with secondary token
 * @param {boolean} [props.hasBorder] - Optional. Show item bottom line
 * @param {boolean} [props.hasBorderOnMobileAndTabletOnly] - Optional show border on Mobile and Tablet view only
 * @param {boolean} [props.hasBorderOnMobileOnly] - Optional show border only on mobile view
 * @param {boolean} [props.hasBottomBorderOnLargeScreen] - Optional show border bottom on large screens (1024+)
 * @param {boolean} [props.hasNoBottomSpace] - Optional to have no border on sm screen
 * @param {boolean} [props.hasNoBottomTitleSpacing] - Optional to have no space below title
 * @param {boolean} [props.hasBottomBorderLargeMargin] - Optional show larger bottom margin on border
 * @param {boolean} [props.hasCustomMargin] - Optional. Margin to show if dek is absent
 * @param {boolean} [props.hasIncreasedTitleSpacing] - Optional add extra spacing to the title
 * @param {boolean} [props.hasItemsRule] - Optional. Show or should hide the decrorative rule on SummaryItem(s).
 * @param {boolean} [props.hasLinkOnSectionTitle] - Optional. It will add the link on section titles from primary searchcriteria.
 * @param {object} [props.columnsHasUnderlineHed] - Optional. Show or should hide underline on SummaryItem(s) for specified variation.
 * @param {boolean} [props.hasMinimalMargin] - Optional. Does this have smaller margins?
 * @param {boolean} [props.hasModerateBottomPadding] - Optional to have moderate bottom spacing under grid dek.
 * @param {boolean} [props.hasNoPaddingOnGridDek] - optional flag to remove padding bottom from summarycollectiongrid dek
 * @param {boolean} [props.hasReducedTitleMargins] - Optional. Does the section title have smaller margins?
 * @param {boolean} [props.hasRowGap] - Optional. Does the SummaryCollectionGridItems have row gap?
 * @param {boolean} [props.hasSummaryItemAssetSpacing] - Optional. Adds space around summary item asset
 * @param {boolean} [props.hasMoreItems] - Optional, whether the main list has more items
 * @param {boolean} [props.hasTopSpacing] - [`bool`] Optional. Set `true` to add extra spacing on top for larger device.
 * @param {boolean} [props.hasTopSpacingOnMobile] - Optional. Set 'true' to add extra spacing on top for mobile device
 * @param {boolean} [props.hasTwoColumnOnMobile] - Optional. Set 'true' to add two column design on mobile
 * @param {boolean} [props.hideIssueDate] - Show or hide the issue date
 * @param {boolean} [props.hideRubricItemSummary] - Show or hide rubrics in summary items
 * @param {boolean} [props.hideRubrics] - Assign value for hideRubricItemSummary property by columnAmount property
 * @param {boolean} [props.isLastChunk] - Flag which determines whether the river is rendering last chunk of items
 * @param {boolean} [props.isLoading] - Optional value to indicate loading status, default false
 * @param {boolean} [props.isRecirc] - Optional. Is this a recirc unit?
 * @param {boolean} [props.isInverted] - Optional apply the inverted theme
 * @param {string} [props.itemHedTag] - Optional hed tag for item
 * @param {object} [props.image] - image props for use in the section title
 * @param {Array} props.items - Items to display in the grid that map to the summary item pattern
 * @param {string} props.label - Label for call to action
 * @param {object} [props.landingPageLink] - Landing page link for SectionTitle
 * @param {string} [props.link] - Optional link for call to action
 * @param {object} [props.adsSettings] - ads configuration settings
 * @param {number} [props.adsSettings.nativeAdIndex] - Optional VS lever index where to inject a native ad
 * @param {string} [props.nextPage] - Optional url of next page
 * @param {string} [props.parentSlug] - Optional parentSlug url
 * @param {string} [props.previousPageUrl] - Optional url of previous page
 * @param {Array} [props.queryParamsForPagination] - Optional prop to pass query params required in pagination
 * @param {string} [props.recircRiver] - Optional title for Sparrow tracking
 * @param {string} [props.searchesCriteria] - Optional title for getiitng the search /filter object
 * @param {string} [props.searchTerm] - Optional searched word in query
 * @param {string} [props.sectionTitleVariation] - Optional variation of SectionTitle to use
 * @param {string} [props.seriesLogos] - Object of optional series logos for brand subchannels specified in the tenant config
 * @param {string} [props.seriesLogoToUse] - Optional string representing the key in the seriesLogos object of the image props to pass to section title. the presence of the string is essentially the boolean confirmation youd like to use this setting
 * @param {boolean} [props.shouldApplyEventStyle] - Optional prop to enable event related css in grid item.
 * @param {boolean} [props.shouldLeftAlignDangerousDek] - Optional flag to left align the dangerousDek
 * @param {boolean} [props.shouldAppendReadMoreLinkForDek] - Optional flag to ensure read more copy is present during dek truncation
 * @param {boolean} [props.shouldConsiderSummaryCollectionGrid] - Optional shouldConsiderSummaryCollectionGrid
 * @param {boolean} [props.shouldDisableReadMoreAd] - Disable Ad slot in grid items.
 * @param {boolean} [props.shouldEmbedCneVideoInCollectionGrid] - embed cne video
 * @param {boolean} [props.shouldEnableBundleComponentAnalytics] - Optional. feature flag to append data-section-title attribute for analytics
 * @param {boolean} [props.shouldEnableFullArticleInverted] - Optional to enable full article inverted
 * @param {boolean} [props.shouldUseDynamicGridRow] - Optional for enabling a dynamic value for gridRowForLastChild
 * @param {boolean} [props.shouldHaveBorderBottomOnLastItem] - Optional boolean to check whether we need border bottom or not on last item
 * @param {boolean} [props.shouldHaveBorderRightOnItem] - Optional boolean to check whether we need border right or not
 * @param {boolean} [props.shouldHideBylines] - Optional flag to hide bylines
 * @param {boolean} [props.shouldHideContributors] - To hide Contributors in byline
 * @param {boolean} [props.shouldTreatTabletLikeMobile] - Optional flag to use mobile grid rules up to bp--lg (defaults to false)
 * @param {boolean} [props.shouldHideDangerousHedOfSummaryItem] - Optional flag to hide hed of summary item
 * @param {Array} [props.shouldLimitSavingToContentTypes] - flag to determine if saving should be enabled only on certain content types
 * @param {boolean} [props.isCategoryFeatureContainer] - Optional flag identify category feature component
 * @param {boolean} [props.shouldHideDangerousDek] - Optional boolean to hide dangerousDek
 * @param {boolean} [props.shouldHideDangerousDekMobileOnly] - Hide dangerousDek on Mobile only
 * @param {boolean} [props.shouldHideIcon] - Optional flag to hide icon on item
 * @param {string} [props.showHeadTagAsForRecirc] - Optional heading tag setting for recirc units
 * @param {boolean} [props.shouldHideMetadataSecondary] - Optional flag to hide secondary metadata on summary items
 * @param {boolean} [props.shouldHidePublishDate] - To hide published date
 * @param {boolean} [props.shouldHideVideoDek] - Optional flag to hide video dek
 * @param {boolean} [props.shouldReduceGridGap] - Optional flag to reduce grid gap
 * @param {boolean} [props.shouldShowAllContentWhenDense] - isDense floats the image right but also hides content
 * on some viewports. This shows it all, always.
 * @param {boolean} [props.shouldOverrideTypeToken] - Optional flag used for applying brand specfic typography
 * @param {boolean} [props.shouldRemoveSummaryItemBorder] - Optional flag to add border in small screens
 * @param {string} [props.shouldShowButton] - Optional flag to show or hide Button
 * @param {string} [props.shouldShowDangerousDek] - Optional flag to show or hide dangerousDek
 * @param {string} [props.shouldShowRailAd] - Optional flag to add a rail Ad container
 * @param {boolean} [props.shouldShowStackedRatingsCard] - Optional flag to show StackedRatingsCard instead of SummaryItem
 * @param {boolean} [props.shouldShowSectionTitleImage] - Should pass image to section title
 * @param {boolean} [props.shouldShowBottomBorderOnAllItems] - Optional flag to show border bottom on large screens (1024+) for all items
 * @param {boolean} [props.shouldUseArrowIconInCallToAction] - Optional flag to add arrow icon in CallToAction
 * @param {boolean} [props.shouldUseArrowIconInSummaryItemDek] - Optional boolean to add arrow icon to SummaryItem dek
 * @param {string} [props.shouldUseDangerousDekAsLink] - Optional use dangerous dek as SectionTitle link
 * @param {boolean} [props.shouldUseFeaturedFooter] - Optional flag to enable featured footer
 * @param {boolean} [props.shouldUseFlexGrow] - Optional flag which aligns bylines flexibly relative to the content
 * @param {boolean} [props.shouldUseMediumBreakpoint] - Optional setting to enable medium breakpoint for image srcSet
 * @param {string} [props.shouldUseSecondaryItemHedStyle] - Optional to have secondary styling summary item hed
 * @param {boolean} [props.shouldUseTitleFullWidth] - Optional setting to set section title as full width with ads
 * @param {boolean} [props.showButtonForCallToActionLink] - Optional setting to show button for callToAction even it has link
 * @param {string} [props.summaryItemClassName] - Optional className for SummaryItem to use
 * @param {string} [props.summaryItemRubricVariation] - Optional rubric variation to use for the SummaryItem
 * @param {string} [props.summaryItemVariation] - Optional variation of SummaryItem to use
 * @param {string} [props.summaryItemVariationOverride] - Optional variation of SummaryItem to override
 * @param {string} [props.summaryItemFirstItemVariation] - variation of SummaryItem to use for first item in the list.
 * @param {string} [props.titleHedTag] - Optional hed tag for section title
 * @param {number} [props.totalResults] - Optional prop to the total number of items
 * @param {string} [props.trackingNamespace] - Optional override the base namespace of data-section-title for component tracking
 * @param {boolean} [props.isTruncateDek] - Optional to display truncated dek
 * @param {boolean} [props.shouldCenterAlignContributorName] - Optional to align contributor name center, when image is not present
 * @param {string} [props.variations] - Variation properties used in rendering the component
 * @param {number} [props.variations.columnAmount] - Adds a modifier class signaling columns to display
 * @param {boolean} [props.variation.lastItemIsAd] - Replaces last item to ad.
 * @param {object} [props.user] - user object
 * @param {string} [props.sideBySideVerticalAlign] - [`center`, `top`] Vertical alignment of content when placed side by side.
 * @param {string} [props.filter] - The page filter
 * @param {string} [props.sort] - The page sort
 * @param {string} [props.content] - The page content
 * @param {boolean} [props.shouldTrackItemImpressionForSnowplow] - optional prop that enables impression tracking
 * @param {boolean} [props.isSectionTitleHasAlternateColor] - Optional flag to show title with alternate color
 * @param {boolean} [props.isSectionTitlePrimary] - Optional flag to show title with primary typography
 * @param {boolean} [props.showImageFullWidth] - Optional showImageFullWidth - To have full image on medium screen
 * @param {number} [props.summaryItemContentGridCol] - Optional SummaryItemContentGridCol - To have specified col span for summary item content grid
 * @param {number} [props.templateColumnForMobile] - Optional templateColumnForMobile - To have specified grid template column for summary colletion sumary Item
 * @param {boolean} [props.shouldDisplayImageCount] - Optional boolean to display image slide count in recirc unit (default to false)
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {Function} [props.clickItem] - Optional click item handler for call to action
 * @param {Function} [props.onMoreClick] - Optional click item handler for 'More'
 * @param {boolean} [props.shouldShowSourceTagName] - Optional to show the source tag names for the recipe in place of rubric
 * @param {boolean} [props.shouldEnableCardLevelBookmark] - flag to show the utility bookmark option
 * @param {boolean} [props.shouldEnableCommentsCount] - flag to show the comments count
 * @param {boolean} [props.shouldUseBookmarkV3] - Feature flag to define whether to use bookmark v3
 * @param {boolean} [props.hasConsistentSpacing] - defines whether the consistent spacing is needed or not
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - flag to enable bookmark drawer functionality
 * @param {boolean} [props.isDenseDesktopVariation] - displays denseDesktop variation (this prop is only for experiment do not use it for any other purpose)
 * @param {boolean} [props.isOverRideHedStyleExp] - overrides the header style (this prop is only for experiment do not use it for any other purpose)
 * @param {boolean} [props.hasNoTitleBorder] - overrides the Title border style
 * @param {boolean} [props.hasNoTitleTopPadding] - overrides the Title padding top style
 * @param {boolean} [props.hasAdBottomMargin] - Has bottom padding of 2rem to Ad
 * @param {string} [props.sectionTitleLabel] - sectionTitle
 * @param {string} [props.subjectVersion] - subject versions are `default/mobile_dense`. `default` is for Desktop
 * @param {string} [props.extendedStrategyLayout] - Optional string to display footer based on the strategy layout
 * @param {boolean} [props.isMobile] - Flag indicating if the component is being rendered on a mobile device
 *
 * @returns {ReactElement} <div>
 */
// eslint-disable-next-line complexity
const SummaryCollectionGrid = ({ adsSettings: { nativeAdIndex }, alphabetizeItems = { shouldSortItemsByKeyName: false, keyNameToSort: '' }, btnStyle = 'text', buttonType = 'more', buttonVariation = 'Utility', bylineVariation, chunkSize = 4, className, clickFunction, clickItem = () => { }, columnAmountForMobile = 1, columnAmountForTablet, content, shouldTrackItemImpressionForSnowplow = false, currentPage, dangerousDek, dangerousHed, featuredFooter, filter, itemHedTag, items = [], image, hasAdditionalMargin = false, hasBackgroundSecondary, hasBorder = false, hasBorderOnMobileAndTabletOnly, hasBorderOnMobileOnly = false, hasBottomBorderOnLargeScreen, hasBottomBorderLargeMargin, hasConsistentSpacing, hasCustomMargin, hasIncreasedTitleSpacing = false, hasItemsRule = true, hasLinkOnSectionTitle = false, hasMinimalMargin = false, hasModerateBottomPadding, hasMoreItems, hasNoBottomSpace = false, hasNoBottomTitleSpacing = false, hasNoPaddingOnGridDek = false, hasReducedTitleMargins = false, hasRowGap = false, hasSummaryItemAssetSpacing, hasTopSpacing = false, hasTopSpacingOnMobile = false, hasTwoColumnOnMobile = false, columnsHasUnderlineHed, hideIssueDate = true, hideRubricItemSummary, hideRubrics = {
    hideRubricFor2Col: false,
    hideRubricFor3Col: false,
    hideRubricFor4Col: false
}, isInverted = false, isSectionTitleHasAlternateColor = false, isSectionTitlePrimary = false, isLoading = false, isRecirc = false, isLastChunk, label, landingPageLink, link, nextPage, onMoreClick = () => { }, recircRiver, searchesCriteria, parentSlug, previousPageUrl, queryParamsForPagination, searchTerm, sectionTitleVariation = 'LineAboveLineBelowTextCenter', seriesLogos = {}, seriesLogoToUse, shouldApplyEventStyle = false, shouldLeftAlignDangerousDek = false, shouldAppendReadMoreLinkForDek = false, shouldEmbedCneVideoInCollectionGrid = false, shouldEnableBundleComponentAnalytics, shouldEnableFullArticleInverted, shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark, shouldEnableCommentsCount, shouldLimitSavingToContentTypes, shouldUseBookmarkV3, shouldHaveBorderBottomOnLastItem = false, shouldHaveBorderRightOnItem, shouldHideBylines, shouldHideContributors = false, shouldHideDangerousDek, shouldHideDangerousDekMobileOnly, shouldHideIcon, showHeadTagAsForRecirc, shouldHideMetadataSecondary, shouldDisplayImageCount = false, shouldHidePublishDate = true, shouldHideVideoDek = false, shouldShowButton = true, shouldShowDangerousDek = true, shouldShowSectionTitleImage = false, shouldDisableReadMoreAd, shouldReduceGridGap = false, shouldShowAllContentWhenDense, shouldShowRailAd = false, shouldShowStackedRatingsCard = false, shouldShowBottomBorderOnAllItems = false, shouldShowSourceTagName = false, shouldTreatTabletLikeMobile = false, shouldUseArrowIconInCallToAction = false, shouldUseDangerousDekAsLink = false, shouldUseDynamicGridRow = false, shouldUseArrowIconInSummaryItemDek = false, shouldUseFlexGrow, shouldUseFeaturedFooter = false, shouldUseMediumBreakpoint = false, shouldUseSecondaryItemHedStyle = false, shouldUseTitleFullWidth = false, shouldCenterAlignContributorName = false, shouldHideDangerousHedOfSummaryItem = false, shouldOverrideTypeToken = false, shouldRemoveSummaryItemBorder = false, showButtonForCallToActionLink = false, sort, sideBySideVerticalAlign = 'center', summaryItemClassName = '', summaryItemRubricVariation, summaryItemVariation = 'TextBelowLeft', summaryItemVariationOverride, summaryItemFirstItemVariation, titleHedTag = 'h2', totalResults, trackingNamespace, isCategoryFeatureContainer = false, isTruncateDek = false, shouldConsiderSummaryCollectionGrid = false, showImageFullWidth = false, summaryItemContentGridCol = 0, templateColumnForMobile = 0, user = {}, variations = { columnAmount: undefined, lastItemIsAd: false }, variationName, isDenseDesktopVariation = false, isOverRideHedStyleExp = false, hasNoTitleBorder = false, hasNoTitleTopPadding = false, hasAdBottomMargin = false, // Will revert once testing is complete
sectionTitleLabel = '', subjectVersion = 'default', extendedStrategyLayout = '', isMobile = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SummaryCollectionGrid',
            variation: variationName
        });
    }, [variationName]);
    const { shouldSortItemsByKeyName, keyNameToSort } = alphabetizeItems;
    const { columnAmount, lastItemIsAd } = variations;
    const summaryItemHasUnderlineHed = get(columnsHasUnderlineHed, `hasUnderlineHedForColumnAmount${columnAmount}`);
    const hedTag = itemHedTag || (dangerousHed ? 'h3' : 'h2');
    const [, readMoreAdVisibilityClass, onReadMoreAdFilled] = useOnAdFilled('read-more-ad');
    const sectionTitleImageProps = getSectionTitleImage({
        seriesLogos,
        seriesLogoToUse,
        image,
        shouldShowSectionTitleImage
    });
    const { link: callToActionLink, label: callToActionLabel } = getCallToActionProps({
        shouldUseFeaturedFooter,
        featuredFooter,
        link,
        label,
        nextPage
    });
    const showMoreItemsButton = shouldShowButton && isLastChunk && (hasMoreItems || callToActionLink);
    if (shouldSortItemsByKeyName && items.length) {
        items.sort((first, next) => first[keyNameToSort].localeCompare(next[keyNameToSort]));
    }
    const showCallToAction = () => {
        return callToActionLabel && showMoreItemsButton;
    };
    const removeHtmlTags = (inputString) => {
        return inputString.replace(/<\/?[^>]+(>|$)/g, '');
    };
    // Add a tracking mechanism to prevent duplicate impressions
    const trackSnowplowEvent = (eventType, item, index, placement = 'mid-content') => {
        if (!shouldTrackItemImpressionForSnowplow)
            return;
        // Skip if this item has already had an impression tracked
        if (eventType === 'impression' && item._impressionTracked) {
            return;
        }
        const eventData = {
            type: eventType,
            label: dangerousHed,
            subject: 'summary_collection_grid',
            items: [
                {
                    content_title: removeHtmlTags(item.dangerousHed),
                    content_id: item.copilotID,
                    content_type: item.contentType,
                    content_url: new URL(item.url, window.location.origin)
                }
            ],
            ...(extractStrategyFromURL(item.url) && {
                strategy: extractStrategyFromURL(item.url)
            }),
            placement,
            index,
            total_index: items.length,
            subject_version: isMobile ? 'mobile_dense' : 'default'
        };
        trackNavigationEvent(eventData);
        // Mark this item as having had its impression tracked
        if (eventType === 'impression') {
            item._impressionTracked = true;
        }
    };
    // Create a click handler that ONLY fires on actual clicks
    const createClickHandler = (itemProps) => () => {
        trackSnowplowEvent('click', itemProps, itemProps.itemIndex, 'mid-content');
    };
    // Create a reusable impression handler function
    const createImpressionHandler = (itemProps) => () => {
        trackSnowplowEvent('impression', itemProps, itemProps.itemIndex, 'mid-content');
    };
    const getFirstItem = (itemProps) => {
        const FirstItemComponent = SummaryItem[summaryItemFirstItemVariation];
        if (itemProps.itemIndex === 0 && FirstItemComponent) {
            return [
                React.createElement(SummaryCollectionGridSummaryItem, { ...itemProps, showOnLargeScreens: true, key: "0-large", impressionHandler: createImpressionHandler(itemProps), clickItem: createClickHandler(itemProps) }),
                React.createElement(SummaryCollectionGridSummaryItem, { ...itemProps, as: FirstItemComponent, showOnSmallScreens: true, key: "0-small", impressionHandler: createImpressionHandler(itemProps), clickItem: createClickHandler(itemProps) })
            ];
        }
        return (React.createElement(SummaryCollectionGridSummaryItem, { ...itemProps, impressionHandler: createImpressionHandler(itemProps), clickItem: createClickHandler(itemProps) }));
    };
    const ItemComponent = shouldShowStackedRatingsCard
        ? StackedRatingsCard
        : SummaryItem[summaryItemVariationOverride || summaryItemVariation];
    const itemsGrid = items.map((item, index) => {
        const seoAltText = getAltTextForSeo(item.dangerousHed) || item.image?.altText;
        if (item.image?.altText !== undefined) {
            item.image.altText = seoAltText;
        }
        const isSponsored = index === nativeAdIndex;
        const analyticsDataAttribute = componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, trackingNamespace || dangerousHed, item.index || index);
        const embedCneVideo = Boolean(shouldEmbedCneVideoInCollectionGrid &&
            item.contentType === 'cnevideo' &&
            item?.image?.scriptUrl);
        let hideRubric = hideRubricItemSummary;
        const { hideRubricFor2Col, hideRubricFor3Col, hideRubricFor4Col } = hideRubrics;
        if ((columnAmount === 2 && hideRubricFor2Col) ||
            (columnAmount === 3 && hideRubricFor3Col) ||
            (columnAmount === 4 && hideRubricFor4Col)) {
            hideRubric = true;
        }
        let stackedRatingsCardProps = {};
        if (shouldShowStackedRatingsCard) {
            const showAuthorTitle = ['article'].includes(item.contentType);
            const contributor = item.contributors?.author?.items?.[0];
            const authorName = showAuthorTitle ? contributor?.name : '';
            const hasIcon = ['gallery', 'cnevideo'].includes(item.contentType);
            const hasRubric = ['article', 'gallery', 'recipe'].includes(item.contentType);
            const ratingMethod = item.contentType === 'recipe' ? 'starRating' : '';
            stackedRatingsCardProps = {
                authorName,
                hasIcon,
                hasRubric,
                isLoading,
                maxDekLines: 3,
                maxHedLines: 3,
                ratingMethod,
                showAuthorTitle,
                shouldShowSourceTagName,
                isDenseDesktopVariation
            };
        }
        const itemProps = {
            ...item,
            ...stackedRatingsCardProps,
            shouldRemoveSummaryItemBorder,
            as: ItemComponent,
            shouldTreatTabletLikeMobile,
            shouldHideDangerousHed: shouldHideDangerousHedOfSummaryItem,
            shouldHideDangerousHedOfSummaryItem,
            columnAmount,
            columnAmountForMobile,
            columnAmountForTablet,
            bylineVariation,
            className: summaryItemClassName,
            analyticsDataAttribute,
            key: index,
            hasBorder,
            lastItemIsAd,
            parentDangerousHed: dangerousHed,
            hasBorderOnMobileAndTabletOnly,
            hasBorderOnMobileOnly,
            hasBottomBorderOnLargeScreen,
            hasBottomBorderLargeMargin,
            hasRoundedBorder: false,
            hasRule: hasItemsRule,
            hasSummaryItemAssetSpacing,
            hasTwoColumnOnMobile,
            hasUnderlineHed: summaryItemHasUnderlineHed,
            hedTag,
            hideIssueDate,
            hideRubricItemSummary: hideRubric,
            shouldHideDangerousDekMobileOnly,
            recircId: isRecirc ? index + 1 : undefined,
            isRecircListItem: isRecirc,
            isCategoryFeatureContainer,
            recircPlacement: 'bottom_recirc',
            sectionTitleLabel,
            subjectVersion,
            totalItems: items.length,
            recircRiver,
            rubricVariation: summaryItemRubricVariation,
            shouldAppendReadMoreLinkForDek,
            shouldApplyEventStyle,
            shouldHaveBorderBottomOnLastItem,
            shouldHideBylines,
            shouldUseFlexGrow,
            shouldHideDangerousDek,
            shouldHideIcon,
            shouldHideMetadataSecondary,
            shouldDisplayImageCount,
            shouldUseMediumBreakpoint,
            shouldHidePublishDate,
            shouldUseSecondaryItemHedStyle,
            shouldHideVideoDek,
            isTruncateDek,
            isInverted,
            shouldEmbedCneVideo: embedCneVideo,
            shouldConsiderSummaryCollectionGrid,
            showImageFullWidth,
            isSectionTitleHasAlternateColor,
            isSectionTitlePrimary,
            summaryItemContentGridCol,
            shouldCenterAlignContributorName,
            itemIndex: index,
            isAuthenticated: user.isAuthenticated,
            shouldHideContributors,
            shouldShowAllContentWhenDense,
            sideBySideVerticalAlign,
            showHeadTagAsForRecirc,
            shouldTrackItemImpressionForSnowplow,
            shouldOverrideTypeToken,
            clickItem,
            shouldShowBottomBorderOnAllItems,
            shouldUseArrowIconInDek: shouldUseArrowIconInSummaryItemDek,
            shouldEnableBookmarkDrawers,
            shouldEnableCardLevelBookmark,
            shouldEnableCommentsCount,
            shouldUseBookmarkV3,
            shouldLimitSavingToContentTypes
        };
        return (React.createElement(React.Fragment, { key: index },
            getFirstItem(itemProps),
            !shouldDisableReadMoreAd && isSponsored && (React.createElement(PaymentGateway, { group: "ads" },
                React.createElement(SummaryCollectionGridSummaryItem, { as: Ad, className: summaryItemClassName, columnAmount: columnAmount, columnAmountForMobile: columnAmountForMobile, columnAmountForTablet: columnAmountForTablet, hasBorderOnMobileAndTabletOnly: hasBorderOnMobileAndTabletOnly, hasBorderOnMobileOnly: hasBorderOnMobileOnly, hasBottomBorderOnLargeScreen: hasBottomBorderOnLargeScreen, shouldConsiderSummaryCollectionGrid: shouldConsiderSummaryCollectionGrid, shouldTreatTabletLikeMobile: shouldTreatTabletLikeMobile, lastItemIsAd: lastItemIsAd, onFilled: onReadMoreAdFilled, position: "read-more", hasTwoColumnOnMobile: hasTwoColumnOnMobile, hasAdBottomMargin: hasAdBottomMargin })))));
    });
    const { handleScroll, carouselDots, selectedDot, ref: contentRef } = useCarouselDots({
        itemsLength: items.length,
        listen: true
    });
    const getItemsLayout = () => {
        return (React.createElement(React.Fragment, null,
            React.createElement(SummaryCollectionGridItems, { className: readMoreAdVisibilityClass, hasRowGap: hasRowGap, templateColumnForMobile: templateColumnForMobile, shouldEnableFullArticleInverted: shouldEnableFullArticleInverted, isInverted: isInverted, "data-testid": "SummaryCollectionGridItems", shouldHaveBorderRightOnItem: shouldHaveBorderRightOnItem, shouldReduceGridGap: shouldReduceGridGap, hasTwoColumnOnMobile: hasTwoColumnOnMobile, hasConsistentSpacing: hasConsistentSpacing, ref: extendedStrategyLayout ? contentRef : null, onScroll: extendedStrategyLayout ? handleScroll : null, extendedStrategyLayout: extendedStrategyLayout },
                itemsGrid,
                lastItemIsAd && (React.createElement(SummaryCollectionGridItem, null,
                    React.createElement(StickyBox, null,
                        React.createElement(PaymentGateway, { group: "ads" },
                            React.createElement(SummaryCollectionGridAdRail, { position: "rail" })))))),
            extendedStrategyLayout && (React.createElement(SummaryCollectionGridItemsFooter, { extendedStrategyLayout: extendedStrategyLayout },
                React.createElement(CarouselFooter, { className: "summarycollectiongrid__footer", dotLength: carouselDots, selectedDotIndex: selectedDot, onDotClick: () => null })))));
    };
    const GridVariant = shouldShowRailAd
        ? Grid.ContentWithAdRail
        : Grid.WithMargins;
    const sectionTitleLink = getSectionTitleLink({
        dangerousDek,
        landingPageLink,
        shouldUseDangerousDekAsLink
    });
    const hasSectionTitle = hasSectionTitleProps({
        dangerousHed,
        image: sectionTitleImageProps,
        link: sectionTitleLink
    });
    let modifiedDangerousHed;
    if (hasLinkOnSectionTitle &&
        searchesCriteria?.length > 0 &&
        dangerousHed.indexOf('<a ', 2) < 0) {
        modifiedDangerousHed = `<a href=/${parentSlug}/${searchesCriteria[0]?.filters.slug}>${dangerousHed}</a>`;
    }
    else
        modifiedDangerousHed = dangerousHed;
    const sectionTitle = () => {
        return (React.createElement(React.Fragment, null,
            hasSectionTitle && (React.createElement(SummaryCollectionGridSectionTitle, { as: SectionTitle[sectionTitleVariation], dangerousHed: modifiedDangerousHed, hasBackgroundSecondary: hasBackgroundSecondary, hasReducedMargins: hasReducedTitleMargins, hasIncreasedTitleSpacing: hasIncreasedTitleSpacing, hasNoBottomSpace: hasNoBottomSpace, hasNoBottomTitleSpacing: hasNoBottomTitleSpacing, hedTag: titleHedTag, image: sectionTitleImageProps, link: sectionTitleLink, isInverted: isInverted, isSectionTitlePrimary: isSectionTitlePrimary, shouldEnableFullArticleInverted: shouldEnableFullArticleInverted, shouldUseAlternateHedColor: isSectionTitleHasAlternateColor, hasDangerousDek: shouldShowDangerousDek && dangerousDek, hasCustomMargin: hasCustomMargin, hasConsistentSpacing: hasConsistentSpacing, isOverRideHedStyleExp: isOverRideHedStyleExp, hasNoTitleTopPadding: hasNoTitleTopPadding, hasNoTitleBorder: hasNoTitleBorder })),
            shouldShowDangerousDek && dangerousDek && (React.createElement(SummaryCollectionGridDek, { className: "summary-collection-grid__dek", dangerouslySetInnerHTML: { __html: dangerousDek }, isInverted: isInverted, shouldLeftAlignDangerousDek: shouldLeftAlignDangerousDek, hasNoPaddingOnGridDek: hasNoPaddingOnGridDek, hasModerateBottomPadding: hasModerateBottomPadding, hasCustomMargin: hasCustomMargin, hasConsistentSpacing: hasConsistentSpacing }))));
    };
    const determineButtonType = () => {
        switch (buttonType) {
            case 'more':
                return (React.createElement(SummaryCollectionGridButton, { as: Button[buttonVariation], btnStyle: btnStyle, href: callToActionLink, inputKind: callToActionLink ? 'link' : 'button', label: callToActionLabel, onClickHandler: clickFunction || onMoreClick, rel: hasMoreItems ? 'next' : undefined, shouldUseFeaturedFooter: shouldUseFeaturedFooter, showButtonForCallToActionLink: showButtonForCallToActionLink, ...(shouldUseArrowIconInCallToAction && {
                        ButtonIcon: ArrowIcon
                    }) }));
            case 'pagination':
                return (React.createElement(PaginationModal, { additionalParams: queryParamsForPagination, currentPage: currentPage, limit: chunkSize, shouldDisplayItemCount: false, totalResults: totalResults, filter: filter, sort: sort, content: content, searchTerm: searchTerm, nextPageURL: nextPage, previousPageUrl: previousPageUrl }));
            default:
                return null;
        }
    };
    const ctaButton = determineButtonType();
    let gridRowForLastChild = 4;
    if (shouldShowStackedRatingsCard || shouldUseDynamicGridRow) {
        gridRowForLastChild = chunkSize / 3 + 1;
    }
    return (React.createElement(SummaryCollectionGridComponent, { className: classnames('summary-collection-grid', className, {
            'summary-collection-grid--three-columns-and-ad-section': lastItemIsAd,
            'summary-collection-grid--four-columns': columnAmount === 4,
            'summary-collection-grid__tablet-single-column': shouldTreatTabletLikeMobile
        }, `summary-collection-grid--${summaryItemVariationOverride || summaryItemVariation}`), as: GridVariant, columnAmount: columnAmount, gridRowForLastChild: gridRowForLastChild, lastItemIsAd: lastItemIsAd, hasBackgroundSecondary: hasBackgroundSecondary, hasMinimalMargin: hasMinimalMargin, hasAdditionalMargin: hasAdditionalMargin, shouldShowRailAd: shouldShowRailAd, shouldTreatTabletLikeMobile: shouldTreatTabletLikeMobile, shouldUseTitleFullWidth: shouldUseTitleFullWidth, shouldUseWithIcon: (summaryItemVariationOverride || summaryItemVariation) === 'WithIcon', hasTopSpacing: hasTopSpacing, hasTopSpacingOnMobile: hasTopSpacingOnMobile, hasTwoColumnOnMobile: hasTwoColumnOnMobile },
        shouldUseTitleFullWidth && (React.createElement(SummaryCollectionGridHeader, { hasDangerousDek: shouldShowDangerousDek && dangerousDek, hasCustomMargin: hasCustomMargin }, sectionTitle())),
        React.createElement(SummaryCollectionGridContent, { nativeAdIndex: nativeAdIndex, hasDangerousDek: shouldShowDangerousDek && dangerousDek, hasCustomMargin: hasCustomMargin },
            !shouldUseTitleFullWidth && sectionTitle(),
            getItemsLayout(),
            React.createElement(SummaryCollectionGridToActionWrapper, { shouldUseFeaturedFooter: shouldUseFeaturedFooter, showButtonForCallToActionLink: showButtonForCallToActionLink }, showCallToAction() && ctaButton)),
        shouldShowRailAd && (React.createElement(StickyBox, { className: "sticky-ad" },
            React.createElement(PaymentGateway, { group: "ads" },
                React.createElement(SummaryCollectionGridAdRail, { position: "rail" }))))));
};
SummaryCollectionGrid.propTypes = {
    adsSettings: PropTypes.shape({ nativeAdIndex: PropTypes.number }),
    alphabetizeItems: PropTypes.shape({
        shouldSortItemsByKeyName: PropTypes.bool,
        keyNameToSort: PropTypes.oneOf(['dangerousHed', 'dangerousDek'])
    }),
    btnStyle: PropTypes.oneOf(['filled', 'outlined', 'text']),
    buttonType: PropTypes.oneOf(['more', 'pagination']),
    buttonVariation: PropTypes.oneOf(['Primary', 'Utility', 'UtilityInverted']),
    bylineVariation: PropTypes.string,
    chunkSize: PropTypes.number,
    className: PropTypes.string,
    clickFunction: PropTypes.func,
    clickItem: PropTypes.func,
    columnAmountForMobile: PropTypes.oneOf([1, 2]),
    columnAmountForTablet: PropTypes.oneOf([1, 2, 3, 4]),
    columnsHasUnderlineHed: PropTypes.shape({
        hasUnderlineHedForColumnAmount2: PropTypes.bool,
        hasUnderlineHedForColumnAmount3: PropTypes.bool,
        hasUnderlineHedForColumnAmount4: PropTypes.bool
    }),
    content: PropTypes.string,
    currentPage: PropTypes.number,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string,
    extendedStrategyLayout: PropTypes.string,
    featuredFooter: PropTypes.shape({
        link: PropTypes.string,
        label: PropTypes.string
    }),
    filter: PropTypes.string,
    hasAdBottomMargin: PropTypes.bool,
    hasAdditionalMargin: PropTypes.bool,
    hasBackgroundSecondary: PropTypes.bool,
    hasBorder: PropTypes.bool,
    hasBorderOnMobileAndTabletOnly: PropTypes.bool,
    hasBorderOnMobileOnly: PropTypes.bool,
    hasBottomBorderLargeMargin: PropTypes.bool,
    hasBottomBorderOnLargeScreen: PropTypes.bool,
    hasConsistentSpacing: PropTypes.bool,
    hasCustomMargin: PropTypes.bool,
    hasIncreasedTitleSpacing: PropTypes.bool,
    hasItemsRule: PropTypes.bool,
    hasLinkOnSectionTitle: PropTypes.bool,
    hasMinimalMargin: PropTypes.bool,
    hasModerateBottomPadding: PropTypes.bool,
    hasMoreItems: PropTypes.bool,
    hasNoBottomSpace: PropTypes.bool,
    hasNoBottomTitleSpacing: PropTypes.bool,
    hasNoPaddingOnGridDek: PropTypes.bool,
    hasNoTitleBorder: PropTypes.bool,
    hasNoTitleTopPadding: PropTypes.bool,
    hasReducedTitleMargins: PropTypes.bool,
    hasRowGap: PropTypes.bool,
    hasSummaryItemAssetSpacing: PropTypes.bool,
    hasTopSpacing: PropTypes.bool,
    hasTopSpacingOnMobile: PropTypes.bool,
    hasTwoColumnOnMobile: PropTypes.bool,
    hideIssueDate: PropTypes.bool,
    hideRubricItemSummary: PropTypes.bool,
    hideRubrics: PropTypes.shape({
        hideRubricFor2Col: PropTypes.bool,
        hideRubricFor3Col: PropTypes.bool,
        hideRubricFor4Col: PropTypes.bool
    }),
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    isCategoryFeatureContainer: PropTypes.bool,
    isDenseDesktopVariation: PropTypes.bool,
    isInverted: PropTypes.bool,
    isLastChunk: PropTypes.bool,
    isLoading: PropTypes.bool,
    isMobile: PropTypes.bool,
    isOverRideHedStyleExp: PropTypes.bool,
    isRecirc: PropTypes.bool,
    isSectionTitleHasAlternateColor: PropTypes.bool,
    isSectionTitlePrimary: PropTypes.bool,
    isTruncateDek: PropTypes.bool,
    itemHedTag: PropTypes.string,
    items: PropTypes.arrayOf(PropTypes.shape(SummaryItem.propTypes)).isRequired,
    label: PropTypes.string,
    landingPageLink: PropTypes.shape({
        url: PropTypes.string,
        label: PropTypes.string
    }),
    link: PropTypes.string,
    nextPage: PropTypes.string,
    onMoreClick: PropTypes.func,
    parentSlug: PropTypes.string,
    previousPageUrl: PropTypes.string,
    queryParamsForPagination: PropTypes.array,
    recircRiver: PropTypes.string,
    searchesCriteria: PropTypes.array,
    searchTerm: PropTypes.string,
    sectionTitleLabel: PropTypes.string,
    sectionTitleVariation: PropTypes.oneOf(getVariationNames(SectionTitle)),
    seriesLogos: PropTypes.object,
    seriesLogoToUse: PropTypes.string,
    shouldAppendReadMoreLinkForDek: PropTypes.bool,
    shouldApplyEventStyle: PropTypes.bool,
    shouldCenterAlignContributorName: PropTypes.bool,
    shouldConsiderSummaryCollectionGrid: PropTypes.bool,
    shouldDisableReadMoreAd: PropTypes.bool,
    shouldDisplayImageCount: PropTypes.bool,
    shouldEmbedCneVideoInCollectionGrid: PropTypes.bool,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldEnableCardLevelBookmark: PropTypes.bool,
    shouldEnableCommentsCount: PropTypes.bool,
    shouldEnableFullArticleInverted: PropTypes.bool,
    shouldHaveBorderBottomOnLastItem: PropTypes.bool,
    shouldHaveBorderRightOnItem: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideContributors: PropTypes.bool,
    shouldHideDangerousDek: PropTypes.bool,
    shouldHideDangerousDekMobileOnly: PropTypes.bool,
    shouldHideDangerousHedOfSummaryItem: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHideMetadataSecondary: PropTypes.bool,
    shouldHidePublishDate: PropTypes.bool,
    shouldHideVideoDek: PropTypes.bool,
    shouldLeftAlignDangerousDek: PropTypes.bool,
    shouldLimitSavingToContentTypes: PropTypes.array,
    shouldOverrideTypeToken: PropTypes.bool,
    shouldReduceGridGap: PropTypes.bool,
    shouldRemoveSummaryItemBorder: PropTypes.bool,
    shouldShowAllContentWhenDense: PropTypes.bool,
    shouldShowBottomBorderOnAllItems: PropTypes.bool,
    shouldShowButton: PropTypes.bool,
    shouldShowDangerousDek: PropTypes.bool,
    shouldShowRailAd: PropTypes.bool,
    shouldShowSectionTitleImage: PropTypes.bool,
    shouldShowSourceTagName: PropTypes.bool,
    shouldShowStackedRatingsCard: PropTypes.bool,
    shouldTrackItemImpressionForSnowplow: PropTypes.bool,
    shouldTreatTabletLikeMobile: PropTypes.bool,
    shouldUseArrowIconInCallToAction: PropTypes.bool,
    shouldUseArrowIconInSummaryItemDek: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    shouldUseDangerousDekAsLink: PropTypes.bool,
    shouldUseDefaultItemHedStyle: PropTypes.bool,
    shouldUseDynamicGridRow: PropTypes.bool,
    shouldUseFeaturedFooter: PropTypes.bool,
    shouldUseFlexGrow: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    shouldUseSecondaryItemHedStyle: PropTypes.bool,
    shouldUseTitleFullWidth: PropTypes.bool,
    showButtonForCallToActionLink: PropTypes.bool,
    showHeadTagAsForRecirc: PropTypes.string,
    showImageFullWidth: PropTypes.bool,
    sideBySideVerticalAlign: PropTypes.oneOf(['top', 'center']),
    sort: PropTypes.string,
    subjectVersion: PropTypes.string,
    summaryItemClassName: PropTypes.string,
    summaryItemContentGridCol: PropTypes.number,
    summaryItemFirstItemVariation: PropTypes.oneOf(getVariationNames(SummaryItem)),
    summaryItemRubricVariation: PropTypes.string,
    summaryItemVariation: PropTypes.oneOf(getVariationNames(SummaryItem)),
    summaryItemVariationOverride: PropTypes.oneOf(getVariationNames(SummaryItem)),
    templateColumnForMobile: PropTypes.number,
    titleHedTag: PropTypes.string,
    totalResults: PropTypes.number,
    trackingNamespace: PropTypes.string,
    user: PropTypes.object,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        columnAmount: PropTypes.oneOf([2, 3, 4]),
        lastItemIsAd: PropTypes.bool
    })
};
SummaryCollectionGrid.displayName = 'SummaryCollectionGrid';
const connectedSummaryCollectionGrid = connector(SummaryCollectionGrid, {
    keysToPluck: [
        'seriesLogos',
        'landingPageLink',
        'user',
        'hasConsistentSpacing',
        'adsSettings'
    ]
});
module.exports = asConfiguredComponent(connectedSummaryCollectionGrid, 'SummaryCollectionGrid');
//# sourceMappingURL=SummaryCollectionGrid.js.map

/***/ }),

/***/ 91706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(8466);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4534:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const Ad = __webpack_require__(19607);
const { BaseText } = __webpack_require__(76955);
const { cssVariablesCollage, findLastRow, universalGridCore } = __webpack_require__(89085);
const { calculateSpacing, getColorToken, getLinkStyles, getColorStyles, getTypographyStyles, minScreen, maxScreen, minMaxScreen } = __webpack_require__(26865);
const { BREAKPOINTS, BREAKPOINTS_RANGE } = __webpack_require__(96472);
const { cssVariablesGrid } = __webpack_require__(1123);
const { getSectionSpacingStyling } = __webpack_require__(16800);
const { maxThresholds } = __webpack_require__(99906);
const { GridItem } = __webpack_require__(40653);
const { StackedRatingsCardWrapper, StackedRatingsCardSkeletonWrapper } = __webpack_require__(1817);
const { BylineNamesWrapper } = __webpack_require__(74423);
const { BylinesWrapper } = __webpack_require__(15384);
const { SectionTitleHed, SectionTitleDivider } = __webpack_require__(33500);
const { SummaryItemHedLink, SummaryItemDek, SummaryItemWrapper } = __webpack_require__(68116);
const { BylineName, BylinePreamble } = __webpack_require__(74423);
const { RubricName } = __webpack_require__(6613);
const applyGridTemplateStylingForMobile = ({ templateColumnForMobile, hasTwoColumnOnMobile }) => {
    if (templateColumnForMobile >= 1 && !hasTwoColumnOnMobile) {
        return `grid-template-columns: repeat(${templateColumnForMobile},1fr);`;
    }
    return '';
};
const applyGridStylingForMobile = ({ columnAmountForMobile }) => {
    switch (columnAmountForMobile) {
        case 1:
            return `grid-column: 1 / -1;`;
        case 2:
            return `grid-column: span 2;`;
        default:
            return ``;
    }
};
const applyGridStylingForTablet = ({ columnAmountForTablet }) => {
    switch (columnAmountForTablet) {
        case 1:
            return `grid-column: 1 / -1;`;
        case 2:
            return `grid-column: span 6;`;
        case 3:
            return `grid-column: span 4;`;
        case 4:
            return `grid-column: span 3;`;
        default:
            return ``;
    }
};
const SummaryCollectionGridContent = styled.div.withConfig({
    displayName: 'SummaryCollectionGridContent'
}) `
  /* Ad visibility controls  */
  .hide-read-more-ad .ad--read-more {
    display: none;
  }

  .show-read-more-ad {
    .ad--read-more {
      display: block;
    }

    ${({ nativeAdIndex }) => {
    const child = nativeAdIndex + 1;
    return `
          div.summary-item:nth-child(${child}) {
            display: none;
          }
        `;
}}
  }
  ${({ hasDangerousDek, hasCustomMargin }) => !hasDangerousDek && hasCustomMargin
    ? `
 ${SectionTitleDivider} {
    margin-bottom: ${calculateSpacing(5)};
    }
`
    : `
${SectionTitleDivider} {
   margin-bottom: ${calculateSpacing(0)};
   }
`}
`;
const SummaryCollectionGridHeader = styled.div.withConfig({
    displayName: 'SummaryCollectionGridHeader'
}) `
  grid-column: 1 / -1;
  ${({ hasDangerousDek, hasCustomMargin }) => !hasDangerousDek && hasCustomMargin
    ? `
 ${SectionTitleDivider} {
    margin-bottom: ${calculateSpacing(5)};
    }
`
    : `
${SectionTitleDivider} {
   margin-bottom: ${calculateSpacing(0)};
   }
`}
`;
const SummaryCollectionGridSectionTitle = styled.div.withConfig({
    displayName: 'SummaryCollectionGridSectionTitle'
}) `
  ${({ hasBackgroundSecondary, hasReducedMargins, hasConsistentSpacing, theme }) => {
    const marginValue = hasReducedMargins ? 3 : 4;
    const margins = [`margin-bottom: ${calculateSpacing(marginValue)};`];
    if (hasBackgroundSecondary) {
        return hasConsistentSpacing &&
            getSectionSpacingStyling(theme, 'gap-sm') !== '0px'
            ? margins.push(`margin-top: ${calculateSpacing(0)};`)
            : margins.push(`margin-top: ${calculateSpacing(marginValue)};`);
    }
    return margins.join('\n');
}}

  ${({ shouldEnableFullArticleInverted, theme }) => shouldEnableFullArticleInverted &&
    `
  ${SectionTitleHed} {
      color:  ${getColorToken(theme, 'colors.discovery.body.black.heading')};
      }
  `}
  
  ${({ hasIncreasedTitleSpacing }) => {
    if (hasIncreasedTitleSpacing) {
        return `
        margin-bottom: ${calculateSpacing(4)};
        padding-top: ${({ hasConsistentSpacing, theme }) => {
            return hasConsistentSpacing &&
                getSectionSpacingStyling(theme, 'gap-md') !== '0px'
                ? '0'
                : calculateSpacing(4);
        }};
      `;
    }
    return '';
}}
    ${({ hasNoBottomSpace }) => {
    if (hasNoBottomSpace) {
        return `${maxScreen(BREAKPOINTS.md)} { 
            margin-bottom: ${calculateSpacing(0)} 
          }`;
    }
    return '';
}}
  ${({ hasNoTitleTopPadding }) => {
    if (hasNoTitleTopPadding) {
        return ` { 
            padding-top: ${calculateSpacing(0)}; 
          }`;
    }
    return '';
}}

  ${({ hasNoTitleBorder }) => {
    if (hasNoTitleBorder) {
        return ` { 
            border: ${calculateSpacing(0)};
          }`;
    }
    return '';
}}

  ${({ isSectionTitlePrimary }) => {
    if (isSectionTitlePrimary) {
        return css `
        ${SectionTitleHed} {
          ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-primary')};
        }
      `;
    }
    return '';
}}

  ${({ isOverRideHedStyleExp }) => {
    if (isOverRideHedStyleExp) {
        return css `
        ${SectionTitleHed} {
          display: block;
          width: 100%;
          ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-collection')};

          ${({ theme }) => `
                border-top: var(--divider-width, 1px) solid ${getColorToken(theme, 'colors.consumption.lead.standard.divider')};
                border-bottom: var(--divider-width, 1px) solid ${getColorToken(theme, 'colors.consumption.lead.standard.divider')};
                padding: ${calculateSpacing(2)} 0;
                margin: 0 0 ${calculateSpacing(4)}`};
        }
      `;
    }
    return '';
}}




  ${({ isInverted, theme }) => {
    if (isInverted) {
        return css `
        ${SectionTitleHed} {
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')}
        }
      `;
    }
    return '';
}}

  ${({ hasNoBottomTitleSpacing }) => {
    if (hasNoBottomTitleSpacing) {
        return ` { 
            margin-bottom: ${calculateSpacing(0)};
            padding-bottom: ${calculateSpacing(0)}; 
          }`;
    }
    return '';
}}
  ${({ hasDangerousDek, hasCustomMargin }) => !hasDangerousDek &&
    hasCustomMargin &&
    `
  margin-bottom: ${calculateSpacing(0)};
`}


  ${({ hasConsistentSpacing, theme, hasDangerousDek }) => {
    if (hasConsistentSpacing &&
        getSectionSpacingStyling(theme, 'gap-md') !== '0px' &&
        hasDangerousDek)
        return `margin-bottom: ${calculateSpacing(0)};`;
    return null;
}}
`;
const SummaryCollectionGridDek = styled(BaseText).withConfig({
    displayName: 'SummaryCollectionGridDek'
}) `
  grid-column: 1 / -1;
  margin: revert;
  ${({ hasConsistentSpacing, theme }) => {
    if (hasConsistentSpacing &&
        getSectionSpacingStyling(theme, 'gap-md') !== '0px')
        return `padding-bottom: ${calculateSpacing(0)};`;
    return `padding-bottom: ${calculateSpacing(5)};`;
}}
  text-align: center;

  ${({ hasModerateBottomPadding, hasCustomMargin }) => {
    if (hasCustomMargin && hasModerateBottomPadding) {
        return `padding-bottom: ${calculateSpacing(3)} ;
      margin-top: ${calculateSpacing(2)};
      margin-bottom: ${calculateSpacing(2)};
      `;
    }
    return (hasModerateBottomPadding && `padding-bottom: ${calculateSpacing(1.5)} ;`);
}}

  ${({ hasNoPaddingOnGridDek }) => {
    return (hasNoPaddingOnGridDek &&
        `
        padding-bottom: 0px;
      `);
}}

  ${({ shouldLeftAlignDangerousDek }) => {
    return (shouldLeftAlignDangerousDek &&
        ` &&& {
        text-align: left;
      }
      `);
}}

  ${({ isInverted, theme }) => {
    return (isInverted &&
        `
    ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')}
    `);
}}
`;
SummaryCollectionGridDek.defaultProps = {
    typeIdentity: 'typography.definitions.discovery.description-page'
};
const SummaryCollectionGridMoreStoriesLink = css `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
  margin: 0 0 24px 0;
  text-decoration: none;
  line-height: 30px;
  color: ${getColorToken('colors.discovery.lead-primary.link')};
  font-size: 16px;
  font-weight: 100;

  &:hover {
    color: ${getColorToken('colors.discovery.lead-primary-link-hover')};
  }
`;
const SummaryCollectionGridMoreStories = css `
  ${minScreen(BREAKPOINTS.md)} {
    margin: 13px 0;
    text-align: right;
  }
  ${SummaryCollectionGridMoreStoriesLink}
`;
const SummaryCollectionGridItem = styled.div.withConfig({
    displayName: 'SummaryCollectionGridItem'
}) `
  &:last-of-type {
    ${maxScreen(BREAKPOINTS.md)} {
      margin-bottom: 0;
      border-bottom: none;
      padding-bottom: 0;
    }
  }

  ${minScreen(BREAKPOINTS.md)} {
    margin-bottom: 0;
  }

  &.summary-item--high-density {
    margin-bottom: 0;

    ${minScreen(BREAKPOINTS_RANGE.md)} {
      margin-bottom: 0;

      &.summary-item--has-border {
        padding-bottom: ${calculateSpacing(0.5)};
      }

      .summary-item__content {
        padding-top: 0;
      }

      .summary-item__hed {
        margin-bottom: 0;
      }

      &.summary-item--has-border {
        padding-bottom: 0;
      }
    }
  }
`;
const SummaryCollectionGridItemLargeScreenBorder = css `
  &:nth-child(-n + 5) {
    ${({ hasBottomBorderLargeMargin, shouldShowBottomBorderOnAllItems }) => {
    if (!shouldShowBottomBorderOnAllItems) {
        return `
      ${minScreen(BREAKPOINTS.lg)} {
        margin-bottom: ${hasBottomBorderLargeMargin ? calculateSpacing(4) : calculateSpacing(2)};
        border-bottom: var(--divider-width, 1px) solid
        ${getColorToken('colors.discovery.body.white.divider')};
    }
  `;
    }
    return '';
}}

    .summary-item__content {
      ${minScreen(BREAKPOINTS.lg)} {
        padding-bottom: ${calculateSpacing(2)};
      }
    }
  }
`;
const SummaryCollectionGridItemLargeScreenNoBorder = css `
  ${minScreen(BREAKPOINTS.lg)} {
    border-bottom: 0;
  }
`;
const SummaryCollectionGridItemsFooter = styled.div.withConfig({
    displayName: 'SummaryCollectionGridItemsFooter'
}) `
  .summarycollectiongrid__footer {
    display: none;
  }
  ${({ extendedStrategyLayout }) => extendedStrategyLayout === 'carousel' &&
    css `
      ${maxScreen(`${maxThresholds.lg}px`)} {
        .summarycollectiongrid__footer {
          display: block;
          margin-top: 0;
        }
      }
    `}
`;
// 1. set breakpoint boundaries for the ad column
// 2. 40.2% = equivalent of 5 columns
// 3. 31.9% = equivalent of 4 columns
const SummaryCollectionGridItems = styled.div.withConfig({
    displayName: 'SummaryCollectionGridItems'
}) `
  ${({ extendedStrategyLayout }) => extendedStrategyLayout === 'carousel' &&
    css `
      ${maxScreen(`${maxThresholds.lg}px`)} {
        padding-right: ${calculateSpacing(3)};
        padding-left: ${calculateSpacing(3)};
        ${minMaxScreen(BREAKPOINTS.md, BREAKPOINTS.lg)} {
          padding-right: ${calculateSpacing(6)};
          padding-left: ${calculateSpacing(6)};
        }
        overflow-x: scroll;
      }
    `}
  ${({ hasRowGap }) => hasRowGap && ` && {row-gap: var(--grid-gap);}`}
  ${cssVariablesCollage()};
  ${universalGridCore(false)};

  ${({ shouldReduceGridGap }) => shouldReduceGridGap &&
    css `
      @media (min-width: ${BREAKPOINTS.sm}) {
        --grid-gap: ${calculateSpacing(3)};
      }
    `}

  ${minScreen(BREAKPOINTS.lg)} {
    ${({ shouldHaveBorderRightOnItem }) => shouldHaveBorderRightOnItem &&
    css `
        grid-gap: 1rem;

        .summary-item__asset-container {
          border-right: 1px solid #e5e5e5;
          padding-right: ${calculateSpacing(2)};
        }

        div:nth-last-of-type(1) .summary-item__asset-container {
          border-right: 0;
        }
      `}
  }

  @media (max-width: ${maxThresholds.md}px) {
    .summary-item--has-mobile-border {
      padding: ${calculateSpacing(2)} 0;

      .summary-item__content {
        padding-bottom: 0;
      }

      :first-child {
        padding-top: 0;
      }
    }
  }

  ${({ shouldEnableFullArticleInverted, theme }) => shouldEnableFullArticleInverted &&
    `
${SummaryItemHedLink} {
    color: ${getColorToken(theme, 'colors.discovery.body.black.heading')};
    }
    ${SummaryItemDek} {
      color: ${getColorToken(theme, 'colors.discovery.body.black.description')};
      }
      ${BylineName}, ${BylinePreamble} {
        color: ${getColorToken(theme, 'colors.discovery.body.black.accreditation')};
        }
        ${RubricName} {
          color: ${getColorToken(theme, 'colors.discovery.body.black.context-signature')};
        }
      `}

  ${maxScreen(`calc(${BREAKPOINTS.md} - 1px)`)} {
    ${SummaryItemWrapper} {
      ${applyGridTemplateStylingForMobile}
    }
  }
  ${minScreen(BREAKPOINTS.sm)} {
    ${SummaryItemWrapper} {
      ${({ hasConsistentSpacing, theme }) => {
    if (hasConsistentSpacing &&
        getSectionSpacingStyling(theme, 'gap-md') !== '0px')
        return `margin-bottom: ${calculateSpacing(0)};`;
    return `margin-bottom: ${calculateSpacing(2)};`;
}}
    }
  }
  ${StackedRatingsCardWrapper},
  ${StackedRatingsCardSkeletonWrapper} {
    grid-column: span 2;
    border-bottom: var(--border-width, 1px);
    border-color: ${getColorToken('colors.interactive.base.light')};
    ${minMaxScreen(BREAKPOINTS.md, BREAKPOINTS.lg)} {
      grid-column: span 4;
    }
    ${minScreen(BREAKPOINTS.lg)} {
      grid-column: span 3;
    }
  }

  ${({ isInverted, theme }) => {
    return (isInverted &&
        `${SummaryItemHedLink},${BylinesWrapper},
    ${BylineNamesWrapper},
    .byline__preamble,
      .byline__name,
      .byline__social-link,
      .byline__name-link:link,
      .byline__name-link:visited,
      .summary-item__publish-date  {
      ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')}
    }`);
}}
`;
const summaryCollectionItemHeadDek = css `
  &.summary-item--layout-placement-text-below-desktop-only.summary-item--layout-proportions-33-66,
  &.summary-item--layout-placement-text-below-desktop-only-thumbnail.summary-item--layout-proportions-33-66,
  &.summary-item--layout-placement-text-below.summary-item--text-align-center,
  &.summary-item--layout-placement-text-below.summary-item--text-align-left {
    .summary-item__hed {
      ${minScreen(BREAKPOINTS.md)} {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
      }
    }

    &.summary-item--discovery-hed-consumption-dek {
      .summary-item__hed {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')};
      }
    }
  }
`;
const SummaryCollectionGridMinimalMargin = css `
  ${SummaryCollectionGridItem} {
    margin-bottom: 0;
  }

  ${SummaryCollectionGridSectionTitle} {
    margin-bottom: 0;
  }

  ${SummaryCollectionGridItems} {
    ${minScreen(BREAKPOINTS.md)} {
      margin: ${calculateSpacing(2)} 0;
    }
  }
`;
const SummaryCollectionGridAdditionalMargin = css `
  ${SummaryCollectionGridItem} {
    margin-bottom: 0;
  }

  ${SummaryCollectionGridSectionTitle} {
    margin-bottom: 0;
  }

  ${SummaryCollectionGridDek} {
    ${maxScreen(BREAKPOINTS.md)} {
      margin-top: ${calculateSpacing(1)};
    }

    margin: ${calculateSpacing(2)} 0;
  }

  ${SummaryCollectionGridItems} {
    ${maxScreen(BREAKPOINTS.md)} {
      margin-top: ${calculateSpacing(2)};
    }
    ${minMaxScreen(BREAKPOINTS.md, BREAKPOINTS.lg)} {
      margin-top: ${calculateSpacing(4)};
    }

    margin: ${calculateSpacing(2)} 0;
    margin-top: ${calculateSpacing(6)};
  }
`;
const summaryCollectionHeadTypography = css `
  &.summary-item--layout-placement-text-below.summary-item--text-align-left,
  &.summary-item--layout-placement-text-below.summary-item--text-align-center,
  &.summary-item--layout-placement-text-below-desktop-only.summary-item--layout-proportions-33-66 {
    .summary-item__hed {
      ${minScreen(BREAKPOINTS.md)} {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
      }
    }
  }
`;
const SummaryCollectionGridAdRail = styled(Ad).withConfig({
    displayName: 'SummaryCollectionGridAdRail'
}) ``;
const SummaryCollectionGridTwoColumns = css `
  ${applyGridStylingForMobile}
  ${minScreen(BREAKPOINTS.md)} {
    // Use applyGridStylingForTablet to render
    // required number of columns for tablets
    ${findLastRow(2)} {
      border-bottom: 0;
    }
    grid-column: span 6;
  }

  .summary-item__hed {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')};
  }

  ${cssVariablesGrid()}
  &.summary-item--is-contributor {
    &.summary-item--has-border {
      ${minScreen(BREAKPOINTS.md)} {
        position: relative;
        /* All items on medium breakpoints receive a right border  */
        &:nth-of-type(odd)::after {
          display: block;
          position: absolute;
          top: 0;
          right: calc(-1 * var(--grid-gap) / 2);
          background-color: ${getColorToken('colors.discovery.body.white.border')};
          width: 1px;
          height: calc(100% + 1px);
          content: '';
        }
        /* Items below the first row receive larger padding  */
        &:nth-of-type(n + 3) {
          padding-top: ${calculateSpacing(3)};
        }
      }
    }
  }
`;
const SummaryCollectionGridTwoColumnsAndAdSection = css `
  & {
    &&.grid-layout--adrail {
      row-gap: 0;

      @media (min-width: ${BREAKPOINTS.lg}) and (max-width: 1393px) {
        grid-template-columns: repeat(12, 1fr);
      }

      && .grid-layout__content {
        ${minScreen(BREAKPOINTS.lg)} {
          grid-column: 1 / -1;
        }

        ${minScreen(BREAKPOINTS.xl)} {
          grid-column: 1 / -1;
        }
      }

      && .grid-layout__aside {
        display: block;
        grid-column: 1/-1;

        ${minScreen(BREAKPOINTS.md)} {
          grid-column: span 11;
        }

        ${minScreen(BREAKPOINTS.lg)} {
          grid-column: span 11;
        }

        ${minScreen(BREAKPOINTS.xl)} {
          grid-column: span 11;
        }
      }
    }
  }

  ${SummaryCollectionGridItems} {
    ${minScreen(BREAKPOINTS.md)} {
      margin: 0 auto;
    }
  }
`;
const SummaryCollectionGridThreeColumns = css `
  && {
    ${applyGridStylingForMobile}
    ${minScreen(BREAKPOINTS.md)} {
      // Use applyGridStylingForTablet to render
      // required number of columns for tablets
      ${findLastRow(3)} {
        border-bottom: 0;
      }
      grid-column: span 4;
    }
    ${summaryCollectionHeadTypography}
  }
`;
const summaryCollectionGridToAction = css `
  margin: ${calculateSpacing(4)} auto;
`;
const SummaryCollectionGridToActionWrapper = styled.div.withConfig({
    displayName: 'SummaryCollectionGridToActionWrapper'
}) `
  text-align: center;
  ${({ shouldUseFeaturedFooter }) => {
    if (shouldUseFeaturedFooter) {
        return css `
        text-align: end;

        .button__label {
          ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};
        }
      `;
    }
    return '';
}}

  ${({ showButtonForCallToActionLink }) => {
    if (showButtonForCallToActionLink) {
        return `
        display: flex;
        justify-content: center;
        padding-top: ${calculateSpacing(4)};
        text-align: center;
      `;
    }
    return ``;
}}
`;
const SummaryCollectionGridToFeaturedAction = css `
  margin: 0;
  padding: ${calculateSpacing(3)} 0 ${calculateSpacing(6)}
    ${calculateSpacing(4)};
  height: ${calculateSpacing(10.5)};
  ${({ theme }) => getLinkStyles(theme, 'colors.consumption.lead.standard.link')};

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};

  .button__icon-container {
    padding-left: ${calculateSpacing(0.3)};

    .icon-arrow {
      width: 18px;
    }
  }
`;
const SummaryCollectionGridButton = styled.button.withConfig({
    displayName: 'SummaryCollectionGridButton'
}) `
  svg {
    transform: scale(0.6);
  }
  ${({ shouldUseFeaturedFooter }) => {
    if (shouldUseFeaturedFooter) {
        return SummaryCollectionGridToFeaturedAction;
    }
    return summaryCollectionGridToAction;
}}

  ${({ showButtonForCallToActionLink }) => {
    if (showButtonForCallToActionLink) {
        return css `
        display: flex;
        justify-content: center;
        border: 2px solid
          ${getColorToken('colors.interactive.base.brand-primary')};
        border-color: ${getColorToken('colors.interactive.base.brand-primary')};
        padding: ${calculateSpacing(2)} 0 ${calculateSpacing(2)} 0;
        height: ${calculateSpacing(6)};
        text-align: center;
        color: ${getColorToken('colors.interactive.base.brand-primary')};

        &:hover {
          background-color: ${getColorToken('colors.interactive.base.brand-primary')};

          .button__label {
            color: ${getColorToken('colors.interactive.base.white')};
          }
        }

        .button__label {
          text-decoration: none;
          font-size: 14px;
          font-weight: 700;
          @media (max-width: ${BREAKPOINTS.md}) {
            padding: ${calculateSpacing(2)} ${calculateSpacing(2)}
              ${calculateSpacing(2)} ${calculateSpacing(2)};
          }

          &:hover {
            color: ${getColorToken('colors.interactive.base.white')};
          }
        }
      `;
    }
    return ``;
}}
`;
const SummaryCollectionGridFourColumns = css `
  &&& {
    ${({ hasTwoColumnOnMobile }) => {
    if (!hasTwoColumnOnMobile) {
        return applyGridStylingForMobile;
    }
    return ``;
}}

    ${minScreen(BREAKPOINTS.md)} {
      ${({ hasTwoColumnOnMobile }) => {
    if (!hasTwoColumnOnMobile) {
        return applyGridStylingForTablet;
    }
    return ``;
}}
    }
    ${minScreen(BREAKPOINTS.lg)} {
      ${findLastRow(4)} {
        ${({ shouldHaveBorderBottomOnLastItem }) => !shouldHaveBorderBottomOnLastItem && `border-bottom: 0;`}
      }
      grid-column: span 3;
    }

    ${({ shouldApplyEventStyle }) => shouldApplyEventStyle && `margin-bottom: ${calculateSpacing(3)};`}
  }

  &.summary-collection-grid--TextBelowDesktopOnlyThirds {
    ${SummaryCollectionGridItem} {
      ${minScreen(BREAKPOINTS_RANGE.md)} {
        .summary-item__content {
          padding-bottom: 0;
        }
        margin-bottom: ${calculateSpacing(2)};

        &:not(.summary-item--has-mobile-border) {
          margin-bottom: 0;
        }
      }
    }
  }

  &.summary-item--is-contributor {
    &.summary-item--has-border {
      ${minScreen(BREAKPOINTS.md)} {
        position: relative;
        /* All items on medium breakpoints receive a right border  */
        &:not(:last-child)::after {
          display: block;
          position: absolute;
          top: 0;
          right: calc(-1 * var(--grid-gap) / 2);
          background-color: ${getColorToken('colors.discovery.body.white.border')};
          width: 1px;
          height: calc(100% + 1px);
          content: '';
        }
      }
    }
  }

  & {
    ${summaryCollectionItemHeadDek}
  }
`;
const SummaryCollectionGridItemNoDesktopBorder = css `
  &&& {
    ${maxScreen(BREAKPOINTS.lg)} {
      margin-bottom: 0;
      border-bottom: var(--divider-width, 1px) solid
        ${getColorToken('colors.discovery.body.white.divider')};
      padding-top: ${calculateSpacing(2)};
      padding-bottom: ${calculateSpacing(2)};
    }
  }
`;
const SummaryCollectionGridItemMobileBorder = css `
  &&& {
    ${maxScreen(BREAKPOINTS.md)} {
      margin-bottom: 0;
      border-bottom: var(--divider-width, 1px) solid
        ${getColorToken('colors.discovery.body.white.divider')};
      padding-top: ${calculateSpacing(2)};
      padding-bottom: ${calculateSpacing(2)};
    }
  }
`;
const summaryCollectionGridCss = css `
  ${minScreen(BREAKPOINTS.md)} {
    margin-bottom: 0;
  }

  &:not(.summary-item--layout-placement-side-by-side-mobile-only) {
    .summary-item__hed {
      ${minScreen(BREAKPOINTS.md)} {
        ${({ theme, shouldOverrideTypeToken }) => shouldOverrideTypeToken
    ? getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')
    : getTypographyStyles(theme, 'typography.definitions.discovery.hed-feature')};
      }
    }
  }
`;
const summaryCollectionGridItemHedSecondary = css `
  &:not(.summary-item--layout-placement-side-by-side-mobile-only) {
    .summary-item__hed {
      ${minScreen(BREAKPOINTS.md)} {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
      }
    }
  }
`;
const SummaryCollectionGridBgSecondary = css `
  background-color: ${getColorToken('colors.discovery.lead.secondary.background')};
  padding-bottom: ${calculateSpacing(3)};

  ${maxScreen(BREAKPOINTS.md)} {
    padding-top: ${calculateSpacing(2)};
  }
`;
const SummaryItemDiscoverySubhedSectionSecondary = css `
  &:not(.summary-item--layout-placement-side-by-side-mobile-only) {
    .summary-item__hed {
      ${minScreen(BREAKPOINTS.md)} {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-secondary')};
      }
    }
  }
`;
const SummaryItemDiscoveryHedConsumptionDek = css `
  .summary-item--discovery-hed-consumption-dek {
    .summary-item__dek {
      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.body-core')};
    }
  }
`;
const SummaryCollectionGridTabletSingleColumn = css `
  ${({ lastItemIsAd, hasTwoColumnOnMobile }) => {
    if (!lastItemIsAd && hasTwoColumnOnMobile) {
        return `@media (max-width: ${maxThresholds.lg}px) {
          ${SummaryCollectionGridItems} {
            grid-template-columns: repeat(2, minmax(0, 1fr));
          }
        }`;
    }
    else if (!lastItemIsAd && !hasTwoColumnOnMobile) {
        return `@media (max-width: ${maxThresholds.lg}px) {
        ${SummaryCollectionGridItems} {
          grid-template-columns: none;
        }
      }`;
    }
    return '';
}}
`;
const SummaryCollectionGridWithIcon = css `
  ${SummaryCollectionGridSectionTitle} {
    margin-bottom: ${calculateSpacing(2)};
  }
  ${SummaryCollectionGridDek} {
    margin-top: ${calculateSpacing(3)};
    margin-bottom: ${calculateSpacing(3)};
    padding: 0;
    text-align: center;
    line-height: 24px;
    font-size: 18px;
  }
`;
const SummaryCollectionGridThreeColumnsAndAdSection = css `
  &&& {
    ${applyGridStylingForMobile};
    @media (min-width: ${BREAKPOINTS.md}) {
      /* Use applyGridStylingForTablet to render */
      /* required number of columns for tablets */
      ${({ shouldShowBottomBorderOnAllItems }) => !shouldShowBottomBorderOnAllItems &&
    `
        ${findLastRow(3)} {
        border-bottom: 0;
        }
     `}
      grid-column: span 3;
    }
    /* enabling hasBottomBorderOnLargeScreen is skipping border for last childs. shouldShowBottomBorderOnAllItems will ensure all items has border when set to true */
    ${({ hasBottomBorderOnLargeScreen, shouldShowBottomBorderOnAllItems }) => {
    if (hasBottomBorderOnLargeScreen && !shouldShowBottomBorderOnAllItems) {
        return `
          @media (min-width: ${BREAKPOINTS.lg}) {
            &:nth-last-child(2),
            &:nth-last-child(3),
            &:nth-last-child(4) {
              border-bottom: 0;
            }
          }
        `;
    }
    return '';
}}
    ${SummaryCollectionGridItem}:last-child {
      ${minScreen(BREAKPOINTS.md)} {
        grid-column: 10 / -1;
        ${({ gridRowForLastChild }) => `grid-row: 1 / ${gridRowForLastChild};`}
      }
    }
    ${SummaryCollectionGridItems} {
      @media (min-width: ${BREAKPOINTS.md}) and (max-width: 1043px) {
        grid-template-columns: repeat(9, 1fr) 40.2%;
      }

      @media (min-width: 1044px) and (max-width: 1392px) {
        grid-template-columns: repeat(9, 1fr) 31.9%;
      }
    }
    ${summaryCollectionItemHeadDek}
  }
`;
const summaryItemVideoHedDek = css `
  .summary-item__dek--video-dek {
    ${getTypographyStyles('typography.definitions.discovery.description-page')}
    color: ${getColorToken('colors.discovery.body.white.description')};
  }

  .summary-item__hed-link > .summary-item__hed {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-secondary')};
  }

  ${maxScreen(BREAKPOINTS.lg)} {
    margin-bottom: 0;
    padding-top: ${calculateSpacing(2)};
    padding-bottom: ${calculateSpacing(2)};
  }

  .summary-item__content {
    padding-bottom: ${calculateSpacing(0)};
  }
`;
const summaryItemImageFullWidth = css `
  ${minScreen(BREAKPOINTS.md)} {
    .summary-item__image-link {
      max-width: 100%;
    }
  }
  ${maxScreen(`calc(${BREAKPOINTS.md} - 1px)`)} {
    .summary-item__asset-container {
      grid-column-start: 4;
    }
  }

  ${minMaxScreen(BREAKPOINTS.md, `calc(${BREAKPOINTS.lg} - 1px)`)} {
    .summary-item__image-link {
      padding-top: ${calculateSpacing(2)};
    }
  }

  &&& {
    ${minScreen(BREAKPOINTS.md)} {
      border-bottom: 0;
    }
    ${minMaxScreen(BREAKPOINTS.sm, BREAKPOINTS.md)} {
      padding-top: ${calculateSpacing(2)};
    }
  }
`;
const SummaryCollectionGridItemDisplay = css `
  &&& {
    ${(props) => {
    if (props.showOnLargeScreens) {
        return `
    @media (max-width: ${maxThresholds.md}px) {
      display: none;
    }`;
    }
    else if (props.showOnSmallScreens) {
        return `
    @media (min-width: ${BREAKPOINTS.md}) {
      display: none;
    }
  `;
    }
    return '';
}}
  }
`;
const SummaryCollectionGridSummaryItem = styled.div.withConfig({
    displayName: 'SummaryCollectionGridSummaryItem'
}) `
  ${({ columnAmount, lastItemIsAd }) => {
    if (columnAmount === 2) {
        return SummaryCollectionGridTwoColumns;
    }
    else if (columnAmount === 3) {
        if (lastItemIsAd)
            return SummaryCollectionGridThreeColumnsAndAdSection;
        return SummaryCollectionGridThreeColumns;
    }
    return SummaryCollectionGridFourColumns;
}}
  ${({ hasBorderOnMobileAndTabletOnly }) => hasBorderOnMobileAndTabletOnly && SummaryCollectionGridItemNoDesktopBorder}
  ${({ hasBorderOnMobileOnly }) => hasBorderOnMobileOnly && SummaryCollectionGridItemMobileBorder}
  ${({ hasBottomBorderOnLargeScreen }) => hasBottomBorderOnLargeScreen
    ? SummaryCollectionGridItemLargeScreenBorder
    : SummaryCollectionGridItemLargeScreenNoBorder}
  ${SummaryItemDiscoverySubhedSectionSecondary}
  ${SummaryItemDiscoveryHedConsumptionDek}
  ${summaryCollectionGridCss}
  ${SummaryCollectionGridItemDisplay}
  ${({ shouldUseSecondaryItemHedStyle }) => shouldUseSecondaryItemHedStyle && summaryCollectionGridItemHedSecondary}

  ${({ shouldConsiderSummaryCollectionGrid }) => {
    if (shouldConsiderSummaryCollectionGrid) {
        return summaryItemVideoHedDek;
    }
    return '';
}}

  ${({ showImageFullWidth }) => {
    if (showImageFullWidth) {
        return summaryItemImageFullWidth;
    }
    return '';
}}

  ${({ summaryItemContentGridCol }) => {
    if (summaryItemContentGridCol >= 1) {
        return `${maxScreen(`calc(${BREAKPOINTS.md} - 1px)`)} {
        .summary-item__content {
          grid-column: span ${summaryItemContentGridCol};;
        }
      }`;
    }
    return '';
}}

  ${({ shouldTreatTabletLikeMobile }) => shouldTreatTabletLikeMobile &&
    `
        &&& {
          @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${maxThresholds.lg}px) {
            grid-column: span 8;
          }

          @media (max-width: ${maxThresholds.lg}px) {
            margin-bottom: 0;
            padding-top: ${calculateSpacing(2)};
            padding-bottom: ${calculateSpacing(2)};
          }
        }`}
    &.summary-item--name-center {
    display: flex;
  }

  .summary-item--contributor-name-center {
    margin-left: ${calculateSpacing(15)};
    ${maxScreen(BREAKPOINTS.md)} {
      margin-left: ${calculateSpacing(12)};
    }
  }

  ${({ hasAdBottomMargin }) => hasAdBottomMargin &&
    `
    ${maxScreen(`${maxThresholds.lg}px`)} {
      padding-bottom: ${calculateSpacing(4)};
    }
  `}
`;
const gridLayoutAdrailStyle = `
  .summary-item {
    ${summaryCollectionHeadTypography}
  }
`;
const SummaryCollectionGridComponent = styled.div.withConfig({
    displayName: 'SummaryCollectionGridComponent'
}) `
  && {
    > ${GridItem} {
      grid-column: 1 / -1;
    }
  }

  && {
    ${({ hasTopSpacing }) => {
    if (hasTopSpacing) {
        return `
          ${minScreen(BREAKPOINTS.md)} {
            margin-top: ${({ hasConsistentSpacing, theme }) => {
            return hasConsistentSpacing &&
                getSectionSpacingStyling(theme, 'gap-md') !== '0px'
                ? '0'
                : calculateSpacing(4);
        }};
          }
        `;
    }
    return '';
}}

    ${({ hasTopSpacingOnMobile }) => {
    if (hasTopSpacingOnMobile) {
        return `
          ${maxScreen(BREAKPOINTS.md)} {
            margin-top: ${calculateSpacing(4)}
          }
        `;
    }
    return '';
}}
  }

  ${({ shouldShowRailAd }) => shouldShowRailAd &&
    `
      > ${GridItem}:last-child{
        grid-column:auto;
      }
    `}
  ${({ lastItemIsAd }) => lastItemIsAd && SummaryCollectionGridThreeColumnsAndAdSection}

  ${({ shouldTreatTabletLikeMobile }) => shouldTreatTabletLikeMobile && SummaryCollectionGridTabletSingleColumn}
  ${({ hasMinimalMargin }) => hasMinimalMargin && SummaryCollectionGridMinimalMargin}

  ${({ hasAdditionalMargin }) => hasAdditionalMargin && SummaryCollectionGridAdditionalMargin}

  ${({ hasBackgroundSecondary }) => hasBackgroundSecondary && SummaryCollectionGridBgSecondary}

  ${({ shouldUseTitleFullWidth }) => shouldUseTitleFullWidth && SummaryCollectionGridTwoColumnsAndAdSection}

  ${({ shouldUseWithIcon }) => shouldUseWithIcon && SummaryCollectionGridWithIcon}

  &&.grid-layout--adrail {
    ${gridLayoutAdrailStyle}
  }

  .sticky-ad {
    top: ${calculateSpacing(10)};
    margin-bottom: ${calculateSpacing(5)};
  }
`;
module.exports = {
    SummaryCollectionGridAdRail,
    SummaryCollectionGridButton,
    SummaryCollectionGridComponent,
    SummaryCollectionGridContent,
    SummaryCollectionGridDek,
    SummaryCollectionGridHeader,
    SummaryCollectionGridItem,
    SummaryCollectionGridItems,
    SummaryCollectionGridMinimalMargin,
    SummaryCollectionGridMoreStories,
    SummaryCollectionGridSectionTitle,
    SummaryCollectionGridSummaryItem,
    SummaryCollectionGridToActionWrapper,
    SummaryCollectionGridItemsFooter
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 8466:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const SummaryCollectionGrid = __webpack_require__(6790);
SummaryCollectionGrid.TwoColumns = asVariation(SummaryCollectionGrid, 'TwoColumns', { columnAmount: 2 });
SummaryCollectionGrid.TwoColumnsWithAdSection = asVariation(SummaryCollectionGrid, 'TwoColumnsWithAdSection', { columnAmount: 2 }, { shouldShowRailAd: true, shouldUseTitleFullWidth: true });
SummaryCollectionGrid.ThreeColumns = asVariation(SummaryCollectionGrid, 'ThreeColumns', { columnAmount: 3 });
SummaryCollectionGrid.ThreeColumnsWithAdSection = asVariation(SummaryCollectionGrid, 'ThreeColumnsWithAdSection', { columnAmount: 3, lastItemIsAd: true });
SummaryCollectionGrid.FourColumns = asVariation(SummaryCollectionGrid, 'FourColumns', { columnAmount: 4 });
SummaryCollectionGrid.FourColumnsWithIcon = asVariation(SummaryCollectionGrid, 'FourColumnsWithIcon', {
    columnAmount: 4
}, {
    summaryItemVariation: 'WithIcon'
});
SummaryCollectionGrid.Contributors = asVariation(SummaryCollectionGrid, 'Contributors', { columnAmount: 2 }, {
    hasMinimalMargin: true,
    shouldDisableReadMoreAd: true,
    shouldShowDangerousDek: false,
    shouldUseDangerousDekAsLink: true,
    summaryItemVariation: 'Contributor',
    sectionTitleVariation: 'LineAboveLineBelowTextLeft'
});
SummaryCollectionGrid.ContributorsInFourColumns = asVariation(SummaryCollectionGrid, 'ContributorsInFourColumns', { columnAmount: 4 }, {
    hasMinimalMargin: true,
    shouldDisableReadMoreAd: true,
    shouldShowDangerousDek: false,
    shouldUseDangerousDekAsLink: true,
    summaryItemVariation: 'ContributorImageAtLeft',
    sectionTitleVariation: 'LineAboveLineBelowTextLeft'
});
SummaryCollectionGrid.ContributorsInThreeColumnsWithButton = asVariation(SummaryCollectionGrid, 'ContributorsInThreeColumnsWithButton', { columnAmount: 3 }, {
    hasRowGap: true,
    isLastChunk: true,
    sectionTitleVariation: 'LineAboveLineBelowTextLeft',
    shouldHideDangerousHedOfSummaryItem: true,
    shouldShowButton: true,
    shouldUseFeaturedFooter: true,
    showButtonForCallToActionLink: true,
    summaryItemVariation: 'ContributorAsCard'
});
module.exports = SummaryCollectionGrid;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 95831:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const Ad = __webpack_require__(19607);
const ArrowIcon = __webpack_require__(42361);
const Button = __webpack_require__(73730);
const Grid = __webpack_require__(86659);
const { PaymentGateway } = __webpack_require__(92807);
const SectionTitle = __webpack_require__(35864);
const StickyBox = __webpack_require__(28433);
const SummaryItem = __webpack_require__(74992);
const SummaryItemFeatured = __webpack_require__(29237);
const Breakpoints = __webpack_require__(99906);
const { getVariationNames } = __webpack_require__(81372);
const { getPropsForSummaryItemFeatured } = __webpack_require__(6518);
const { componentTracking } = __webpack_require__(90090);
const { useOnAdFilled } = __webpack_require__(1184);
const RecircMostPopular = __webpack_require__(69234);
const { TrackComponentChannel } = __webpack_require__(78788);
const { SummaryListWrapper, SummaryListTitle, SummaryListDangerousDek, SummaryListFooterWrapper, SummaryListCallToActionWrapper, SummaryItemWrapper, SummaryListButton, SummaryListAside } = __webpack_require__(63637);
const PaginationModal = __webpack_require__(49312);
const StackedRatingsCard = __webpack_require__(68712);
/**
 * SummaryList component
 *
 * @param {object} props - React props
 * @param {Function} [props.adCounter] - Optional ad counter handler
 * @param {string} [props.buttonType] - Button type for call to action
 * @param {number} [props.chunkIndex] - Optional
 * @param {number} [props.chunkSize] - Optional number of items per chunk
 * @param {number} [props.chunksTotal] - Optional total amount of chunks
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} [props.clickFunction] - Optional click handler for call to action
 * @param {Function} [props.clickItem] - Optional click item handler for call to action
 * @param {number} [props.currentPage] - Current page number
 * @param {string} [props.dangerousHed] - Optional string (possibly HTML) to use as the title
 * @param {string} [props.dangerousDek] - Optional string (possibly HTML) to use as the dek
 * @param {string} [props.filter] - Optional string to pass filters in query params
 * @param {object} [props.footerWithLink] - Optional data for footer
 * @param {string} [props.footerWithLink.link] - link for footer
 * @param {string} [props.footerWithLink.label] - label for footer
 * @param {boolean} [props.hasDividerAboveHed] - Optional flag for divider above HED Text
 * @param {boolean} [props.hasDividerBelowHed] - Optional flag for divider below HED Text
 * @param {boolean} [props.hasFeatured] - Optional flag that indicates the the summary list has a featured item
 * @param {boolean} [props.hasMoreItems] - Optional, whether the main list has more items
 * @param {boolean} [props.hasReducedMargin] - Optional. Set to `true` for margin spacing
 * @param {boolean} [props.hasRule] - Optional leading rule before first item, true by default
 * @param {boolean} [props.hasSectionTitlePrimary] - Optional flag to show title with primary typography
 * @param {boolean} [props.hasSideBySideMobileOnlyImageRight] - Optional. Enable side by side image to right for mobile view only
 * @param {boolean} [props.hasUnderlineHed] - Optional boolean to enable or disable underline in hed (default to true)
 * @param {boolean} [props.hideBottomBorderForLastItem] - flag to conditionally show/hide bottom border for last summary Item
 * @param {boolean} [props.hideBottomBorders] - Optional prop to hide bottom borders
 * @param {boolean} [props.hideBylinesUntil] - Option to show bylines until specific breakpoint
 * @param {boolean} [props.hideRubricItemSummary] - Show or hide rubrics in summary items
 * @param {string} [props.itemInViewGAEventName] - Optional GA event name that triggers when item is in view
 * @param {boolean} [props.shouldTrackItemImpressionForSnowplow] - Optional boolean to tell item impression event to be tracked for snowplow
 * @param {Function} [props.clickHandler] - Optional function to handle clicks for Snowplow tracking
 * @param {Array<SummaryItem.propTypes>} props.items - Array of items to render
 * @param {string} [props.label] - Label for call to action
 * @param {string} [props.link] - Optional link for call to action
 * @param {number} [props.maxDekLines] - Optional maximum number of visual lines for the dek to occupy
 * @param {number} [props.maxDekLinesInMobile] - Optional maximum number of visual lines for the dek to occupy in mobile screens
 * @param {number} [props.maxDekLinesInTablet] - Optional maximum number of visual lines for the dek to occupy in tablet screens
 * @param {number} [props.maxDekLinesInDesktop] - Optional maximum number of visual lines for the dek to occupy in desktop screens
 * @param {number} [props.maxDekLinesInLargeDesktop] - Optional maximum number of visual lines for the dek to occupy in large desktop screens
 * @param {number} [props.maxDekLinesInExtraLargeDesktop] - Optional maximum number of visual lines for the dek to occupy in extra large desktop screens
 * @param {string} [props.nextPage] - Optional url of next page
 * @param {string} [props.placement] - Optional top identify placement in snowplow tracking
 * @param {string} [props.previousPageUrl] - Optional url of previous page
 * @param {boolean} [props.recircRiver] - Recirc river title
 * @param {string} [props.sectionTitleVariation] - Optional variation of SectionTitle to use
 * @param {string} [props.sectionTitle] - Optional to show the SectionTitle in snowplow navigation tracking
 * @param {string} [props.imageAlignment] - Optional prop to display dek at the bottom of the container
 * @param {boolean} [props.isSpecial] - Optional prop to check whether it is special theme or not
 * @param {Array} [props.queryParamsForPagination] - Optional prop to pass query params required in pagination
 * @param {boolean} [props.shouldAppendReadMoreLinkForDek] - Optional flag to append 'Read More' link in item dek
 * @param {boolean} [props.shouldAlignDekInCenter] - Optional flag to append 'Read More' link in item dek
 * @param {boolean} [props.shouldDekHideOnMobileAndShowOnTablet] - Optional flag to hide dek on mobile but show on tablet
 * @param {boolean} [props.shouldDisplayLoadMore] - Optional flag to display load more call to action
 * @param {boolean} [props.shouldEnableCardLevelBookmark] - Optional flag to enable bookmarks on bundle page
 * @param {boolean} [props.shouldEnableCommentsCount] - Optional flag to enable comments count on bundle page
 * @param {boolean} [props.shouldEnableBundleComponentAnalytics] - Optional feature flag to append data-section-title attribute for analytics
 * @param {boolean} [props.shouldEnableSnowplowTracking ] - Optional feature flag to enable snowplow tracking navigation event
 * @param {boolean} [props.shouldHideBylines] - Optional flag to hide rubric
 * @param {boolean} [props.shouldHideDangerousDek] - Optional boolean to hide dangerousDek
 * @param {boolean} [props.shouldHideFinalBorder] - Optional to hide the last summary item bottom border
 * @param {boolean} [props.shouldHideMetadataSecondary] - Optional boolean to hide MetadataSecondary (default to false)
 * @param {boolean} [props.shouldHidePublishDate] - Optional boolean to hide Publish date
 * @param {boolean} [props.shouldHideSponsoredAd] - Optional boolean to hide Sponsored Ad
 * @param {boolean} [props.shouldHideVideoDek] - Optional boolean to hide video dek
 * @param {boolean} [props.shouldHoldImageSpace] - Optional flag to hold space for loading images
 * @param {Array} [props.shouldLimitSavingToContentTypes] - flag to determine if saving should be enabled only on certain content types
 * @param {boolean} [props.shouldTruncateDek] - Optional flag to truncate dek
 * @param {Function} [props.impressionHandler] - Optional prop which will have impression tracking function
 * @param {boolean} [props.shouldUseSmallImageMobileOnly] - Set to `true` will render a small sized image for XS,S and M breakpoints
 * @param {boolean} [props.shouldVerticallyAlignHed] - Optional flag to remove the margin-bottom from the summary item hed
 * @param {string} [props.sideBySideVerticalAlign] - Vertical alignment of content when placed side by side.
 * @param {string} [props.sort] - Optional string to pass sort values in query params
 * @param {object} [props.snowplowEvent] - Optional. Properties that can be passed to snowplow event navigation on click
 * @param {string} [props.summaryItemClassName] - Optional className for SummaryItem to use
 * @param {object} [props.summaryItemFeatured] - Optional object that contains options for the summary item that is featured within the list
 * @param {string} [props.summaryItemHedTag] - Optional item hed element to render
 * @param {string} [props.summaryItemRubricVariation] - Optional rubric variation name for SummaryItem to use
 * @param {string} [props.summaryItemVariation] - Optional variation of SummaryItem to use
 * @param {string} [props.summaryItemVariationList] - Optional alternating variations of SummaryItem to use
 * @param {boolean} [props.showRecircMostPopularInAsideWithRail] - Optional to show RecircMostPopularInAside
 * @param {Array} [props.recircMostPopularItems] - Optional prop that contains recirc most popular items
 * @param {number} [props.totalResults] - Optional prop to the total number of items
 * @param {string} [props.trackingNamespace] - Optional override the base namespace of data-section-title for component tracking
 * @param {string} [props.variations] - Variation properties used in rendering the component
 * @param {string} [props.variations.isCollection] - Adds a modifier class signaling it is part of a collection
 * @param {string} [props.variations.inputKind] - Changes the input type of the show more button
 * @param {string} [props.variations.withAside] - Changes the grid to include the rail
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.shouldRemoveSummaryItemBorder] - Component variation name used for Component Tracking
 * @param {string} [props.shouldUseLargeIconSize] - Optional to use large size icon
 * @param {boolean} [props.shouldShowStackedRatingsCard] - Optional flag to show StackedRatingsCard instead of SummaryItem
 * @param {boolean} [props.actionBarConfig] - Config for the action bar
 * @param {number} [props.totalItems] - Optional total items in component for snowplow
 * @param {boolean} [props.shouldUseBookmarkV3] - Feature flag to define whether to use bookmark v3
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - flag to enable bookmark drawer functionality
 * @param {boolean} [props.windowLocation] - Optional prop which contains window location
 *
 * @returns {ReactElement} <div>
 */
// eslint-disable-next-line complexity
const SummaryList = ({ adCounter = () => 0, buttonType = 'more', chunkIndex, chunkSize = 4, chunksTotal, className, clickFunction, clickItem, currentPage, dangerousHed, dangerousDek, filter, items, isSpecial = false, hasFeatured, hasMoreItems = false, hasReducedMargin = false, hasRule = true, recircMostPopularItems, hasSectionTitlePrimary, hasSideBySideMobileOnlyImageRight, hasUnderlineHed, impressionHandler, clickHandler, hideBottomBorderForLastItem, hideBottomBorders = false, hideBylinesUntil = 'sm', hideRubricItemSummary, hasDividerAboveHed = false, hasDividerBelowHed = false, itemInViewGAEventName, label, link, maxDekLines, maxDekLinesInMobile, maxDekLinesInTablet, maxDekLinesInDesktop, maxDekLinesInLargeDesktop, maxDekLinesInExtraLargeDesktop, nextPage, placement, previousPageUrl, sectionTitleVariation = 'TextCenter', imageAlignment = 'default', queryParamsForPagination, shouldAlignDekInCenter = false, shouldAppendReadMoreLinkForDek = false, shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark, shouldEnableCommentsCount, shouldDekHideOnMobileAndShowOnTablet = false, shouldDisplayLoadMore = false, shouldEnableBundleComponentAnalytics, shouldHideBylines = false, shouldHideFinalBorder = false, shouldHideSponsoredAd = false, shouldHideDangerousDek = false, shouldHideMetadataSecondary, shouldTrackItemImpressionForSnowplow, shouldHidePublishDate = true, shouldHideVideoDek = false, shouldHoldImageSpace, shouldLimitSavingToContentTypes, shouldRemoveSummaryItemBorder = false, shouldShowStackedRatingsCard = false, shouldTruncateDek, shouldUseBookmarkV3, shouldUseLargeIconSize = false, shouldVerticallyAlignHed, shouldUseSmallImageMobileOnly, sideBySideVerticalAlign, sort, snowplowEvent, summaryItemClassName, summaryItemFeatured, summaryItemHedTag, summaryItemRubricVariation, summaryItemVariation = 'TextBelowDesktopOnlyThirds', summaryItemVariationList, showRecircMostPopularInAsideWithRail = false, footerWithLink: { link: footerLink, label: footerLabel } = {}, totalItems, totalResults, trackingNamespace, recircRiver, variations: { inputKind, isCollection, withAside } = {}, variationName, actionBarConfig, windowLocation = '' }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SummaryList',
            variation: variationName
        });
    }, [variationName]);
    const hasButtonVariant = link && !shouldDisplayLoadMore;
    const ButtonVariant = hasButtonVariant ? Button.Utility : Button.Primary;
    const btnStyle = hasButtonVariant ? 'text' : 'filled';
    const GridVariant = withAside ? Grid.ContentWithAdRail : Grid.MarginsOnly;
    const SectionTitleComponent = SectionTitle[sectionTitleVariation];
    const computedInputKind = inputKind || link || nextPage ? 'link' : 'button';
    const [shouldShowRiverAd, shouldShowRiverAdClass, onRiverAdFilled] = useOnAdFilled('river-ad');
    const SummaryItemVariations = summaryItemVariationList && summaryItemVariationList.length
        ? summaryItemVariationList
        : [summaryItemVariation];
    const isLastChunk = hasMoreItems && chunksTotal === chunkIndex + 1;
    const determineButtonType = () => {
        switch (buttonType) {
            case 'more':
                return (React.createElement(SummaryListButton, { href: link || nextPage, inputKind: computedInputKind, label: label, btnStyle: btnStyle, onClickHandler: clickFunction, as: ButtonVariant }));
            case 'pagination':
                return (React.createElement(PaginationModal, { additionalParams: queryParamsForPagination, currentPage: currentPage, limit: chunkSize, shouldDisplayItemCount: false, totalResults: totalResults, filter: filter, nextPageURL: nextPage, previousPageUrl: previousPageUrl, sort: sort }));
            default:
                return null;
        }
    };
    const ctaButton = determineButtonType();
    let stackedRatingsCardProps = {};
    if (shouldShowStackedRatingsCard) {
        stackedRatingsCardProps = {
            shouldUseLargeIconSize,
            hasIcon: true,
            hideRubric: false,
            dangerousDek: '',
            ratingMethod: 'starRating',
            hedTag: 'h3',
            totalItems: items && items.length,
            placement,
            shouldEnableBookmarkDrawers,
            shouldEnableCardLevelBookmark,
            shouldEnableCommentsCount,
            shouldLimitSavingToContentTypes
        };
    }
    const getContentUrl = (url) => {
        try {
            // Use the passed windowLocation instead of directly accessing window
            return windowLocation ? new URL(url, windowLocation).href : url;
        }
        catch (e) {
            return url;
        }
    };
    return (React.createElement(SummaryListWrapper, { as: GridVariant, isCollection: isCollection, withAside: withAside, className: classnames('summary-list', className, {
            'summary-list--collection-list': isCollection
        }), "data-testid": "SummaryListWrapper" },
        React.createElement("div", null,
            dangerousHed && (React.createElement(SummaryListTitle, { as: SectionTitleComponent, dangerousHed: dangerousHed, link: dangerousDek && !shouldAlignDekInCenter
                    ? { html: dangerousDek }
                    : {}, hedTag: "h2", isCollection: isCollection, hasSectionTitlePrimary: hasSectionTitlePrimary, hasDividerAbove: hasDividerAboveHed, hasDividerBelow: hasDividerBelowHed })),
            dangerousDek && shouldAlignDekInCenter && (React.createElement(SummaryListDangerousDek, { dangerouslySetInnerHTML: { __html: dangerousDek } })),
            React.createElement("div", { className: "summary-list__items" }, 
            // eslint-disable-next-line complexity
            items.map((item, index) => {
                const SummaryItemComponent = SummaryItem[SummaryItemVariations[index % SummaryItemVariations.length]];
                const isLastItem = items.length === index + 1;
                const isRiverSponsoredSlot = index === 2;
                const shouldDisplayAd = !shouldHideSponsoredAd && !isCollection && isRiverSponsoredSlot;
                const shouldShowButton = (isLastChunk && isLastItem && !!clickFunction) ||
                    (!shouldDisplayLoadMore &&
                        (!!clickFunction || link || nextPage));
                const itemOrder = chunkSize * chunkIndex + index + adCounter() + 1;
                if (shouldShowRiverAd && shouldDisplayAd) {
                    adCounter(true);
                }
                // props shared between featured and non-featured summary items
                const sharedSummaryItemProps = {
                    clickHandler: (isSponsored) => {
                        if (isSponsored) {
                            clickItem(itemOrder, isSponsored);
                        }
                    },
                    clickItem,
                    hasUnderlineHed,
                    hideRubricItemSummary,
                    rubricVariation: summaryItemRubricVariation,
                    shouldHideMetadataSecondary,
                    shouldHidePublishDate,
                    shouldHideBylines,
                    recircRiver,
                    hasBorder: !hideBottomBorders
                };
                const { featuredProps, isBeforeHidden, isFeatured } = getPropsForSummaryItemFeatured({
                    item,
                    index,
                    sharedSummaryItemProps,
                    hasFeatured,
                    summaryItemFeatured,
                    shouldHoldImageSpace
                });
                const analyticsDataAttribute = componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, trackingNamespace || dangerousHed, index);
                const hideBottomBorder = hideBottomBorderForLastItem && items.length === index + 1
                    ? hideBottomBorderForLastItem
                    : false;
                return (React.createElement(React.Fragment, { key: index },
                    isFeatured ? (React.createElement(SummaryItemFeatured, { ...featuredProps, shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, hedTag: dangerousHed ? 'h3' : 'h2', impressionHandler: () => impressionHandler('impression', item, 5, 'right_rail', 6), clickHandler: () => clickHandler('click', item, 5, 'right_rail', 6) })) : (React.createElement(SummaryItemWrapper, { ...item, ...sharedSummaryItemProps, analyticsDataAttribute: analyticsDataAttribute, hasRule: hasRule, hedTag: summaryItemHedTag || (dangerousHed ? 'h3' : 'h2'), hideBottomBorder: hideBottomBorder, hideBylinesUntil: hideBylinesUntil, isTruncateDek: shouldTruncateDek, itemIndex: index, itemInViewGAEventName: itemInViewGAEventName, maxDekLines: maxDekLines, maxDekLinesInMobile: maxDekLinesInMobile, maxDekLinesInTablet: maxDekLinesInTablet, maxDekLinesInDesktop: maxDekLinesInDesktop, maxDekLinesInLargeDesktop: maxDekLinesInLargeDesktop, shouldTrackItemImpressionForSnowplow: shouldTrackItemImpressionForSnowplow, maxDekLinesInExtraLargeDesktop: maxDekLinesInExtraLargeDesktop, shouldAppendReadMoreLinkForDek: shouldAppendReadMoreLinkForDek, shouldDekHideOnMobileAndShowOnTablet: shouldDekHideOnMobileAndShowOnTablet, shouldHideDangerousDek: shouldHideDangerousDek, shouldHideFinalBorder: shouldHideFinalBorder, shouldHideVideoDek: shouldHideVideoDek, shouldHoldImageSpace: shouldHoldImageSpace, shouldVerticallyAlignHed: shouldVerticallyAlignHed, shouldUseSmallImageMobileOnly: shouldUseSmallImageMobileOnly, sideBySideVerticalAlign: sideBySideVerticalAlign, impressionHandler: () => impressionHandler('impression', item, index, placement, totalItems), placement: placement, snowplowEvent: snowplowEvent && {
                            ...snowplowEvent,
                            items: [
                                {
                                    content_title: item.dangerousHed,
                                    content_type: item.contentType,
                                    content_id: item.copilotID,
                                    content_url: getContentUrl(item.url)
                                }
                            ],
                            index,
                            total_index: snowplowEvent?.total_index
                                ? snowplowEvent?.total_index
                                : items.length,
                            placement,
                            subject_version: snowplowEvent?.subject_version
                        }, hasSideBySideMobileOnlyImageRight: hasSideBySideMobileOnlyImageRight, key: index, hasReducedMargin: hasReducedMargin, noClass: !summaryItemClassName, as: shouldShowStackedRatingsCard
                            ? StackedRatingsCard
                            : SummaryItemComponent, className: classnames(summaryItemClassName, {
                            'summary-list__item': !summaryItemClassName,
                            'summary-list__item--before-hidden': isBeforeHidden
                        }), imageAlignment: imageAlignment, isSpecial: isSpecial, shouldRemoveSummaryItemBorder: shouldRemoveSummaryItemBorder, ...stackedRatingsCardProps, actionBarConfig: actionBarConfig, shouldUseBookmarkV3: shouldUseBookmarkV3, shouldEnableCardLevelBookmark: shouldEnableCardLevelBookmark, shouldEnableCommentsCount: shouldEnableCommentsCount })),
                    shouldDisplayAd && (React.createElement("div", { className: shouldShowRiverAdClass },
                        React.createElement(PaymentGateway, { group: "ads" },
                            React.createElement(Ad, { position: "river", className: "summary-item summary-item--has-border summary-item--has-rule summary-item--article summary-item--text-align-left summary-list__item", trackClickHandler: () => clickItem(itemOrder + 1, true), onFilled: onRiverAdFilled })))),
                    shouldShowButton && (React.createElement(SummaryListCallToActionWrapper, { className: "summary-list__call-to-action-wrapper", "data-testid": "summary-list_call-to-action" }, ctaButton))));
            })),
            footerLink && footerLabel && (React.createElement(SummaryListFooterWrapper, null,
                React.createElement(SummaryListButton, { href: footerLink, inputKind: "link", label: footerLabel, btnStyle: "text", as: Button.Utility, hasEnableIcon: true, ButtonIcon: ArrowIcon })))),
        withAside && (React.createElement(SummaryListAside, { className: "summary-list__aside", showRecircMostPopularInAsideWithRail: showRecircMostPopularInAsideWithRail },
            React.createElement(StickyBox, null,
                React.createElement(PaymentGateway, { group: "ads" },
                    React.createElement(Ad, { position: "rail" })),
                showRecircMostPopularInAsideWithRail && (React.createElement(RecircMostPopular, { items: recircMostPopularItems })))))));
};
const SUMMARY_ITEM_VARIATIONS = getVariationNames(SummaryItem);
const SECTION_TITLE_VARIATIONS = getVariationNames(SectionTitle);
SummaryList.propTypes = {
    actionBarConfig: PropTypes.object,
    adCounter: PropTypes.func,
    buttonType: PropTypes.oneOf(['more', 'pagination']),
    chunkIndex: PropTypes.number,
    chunkSize: PropTypes.number,
    chunksTotal: PropTypes.number,
    className: PropTypes.string,
    clickFunction: PropTypes.func,
    clickHandler: PropTypes.func,
    clickItem: PropTypes.func,
    currentPage: PropTypes.number,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string,
    filter: PropTypes.string,
    footerWithLink: PropTypes.shape({
        label: PropTypes.string,
        link: PropTypes.string
    }),
    hasDividerAboveHed: PropTypes.bool,
    hasDividerBelowHed: PropTypes.bool,
    hasFeatured: PropTypes.bool,
    hasMoreItems: PropTypes.bool,
    hasReducedMargin: PropTypes.bool,
    hasRule: PropTypes.bool,
    hasSectionTitlePrimary: PropTypes.bool,
    hasSideBySideMobileOnlyImageRight: PropTypes.bool,
    hasUnderlineHed: PropTypes.bool,
    hideBottomBorderForLastItem: PropTypes.bool,
    hideBottomBorders: PropTypes.bool,
    hideBylinesUntil: PropTypes.oneOf(Breakpoints.sizes),
    hideRubricItemSummary: PropTypes.bool,
    imageAlignment: PropTypes.oneOf(['top', 'default', 'bottom']),
    impressionHandler: PropTypes.func,
    isSpecial: PropTypes.bool,
    itemInViewGAEventName: PropTypes.string,
    items: PropTypes.arrayOf(PropTypes.shape(SummaryItem.propTypes)).isRequired,
    label: PropTypes.string,
    link: PropTypes.string,
    maxDekLines: PropTypes.number,
    maxDekLinesInDesktop: PropTypes.number,
    maxDekLinesInExtraLargeDesktop: PropTypes.number,
    maxDekLinesInLargeDesktop: PropTypes.number,
    maxDekLinesInMobile: PropTypes.number,
    maxDekLinesInTablet: PropTypes.number,
    nextPage: PropTypes.string,
    placement: PropTypes.string,
    previousPageUrl: PropTypes.string,
    queryParamsForPagination: PropTypes.array,
    recircMostPopularItems: PropTypes.array,
    recircRiver: PropTypes.string,
    sectionTitle: PropTypes.string,
    sectionTitleVariation: PropTypes.oneOf(SECTION_TITLE_VARIATIONS),
    shouldAlignDekInCenter: PropTypes.bool,
    shouldAppendReadMoreLinkForDek: PropTypes.bool,
    shouldDekHideOnMobileAndShowOnTablet: PropTypes.bool,
    shouldDisplayLoadMore: PropTypes.bool,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldEnableCardLevelBookmark: PropTypes.bool,
    shouldEnableCommentsCount: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideDangerousDek: PropTypes.bool,
    shouldHideFinalBorder: PropTypes.bool,
    shouldHideMetadataSecondary: PropTypes.bool,
    shouldHidePublishDate: PropTypes.bool,
    shouldHideSponsoredAd: PropTypes.bool,
    shouldHideVideoDek: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldLimitSavingToContentTypes: PropTypes.array,
    shouldRemoveSummaryItemBorder: PropTypes.bool,
    shouldShowStackedRatingsCard: PropTypes.bool,
    shouldTrackItemImpressionForSnowplow: PropTypes.bool,
    shouldTruncateDek: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    shouldUseLargeIconSize: PropTypes.bool,
    shouldUseSmallImageMobileOnly: PropTypes.bool,
    shouldVerticallyAlignHed: PropTypes.bool,
    showRecircMostPopularInAsideWithRail: PropTypes.bool,
    sideBySideVerticalAlign: PropTypes.oneOf(['top', 'center']),
    snowplowEvent: PropTypes.object,
    sort: PropTypes.string,
    summaryItemClassName: PropTypes.string,
    summaryItemFeatured: PropTypes.shape({
        ctaTextLabel: PropTypes.string,
        ctaUrl: PropTypes.string,
        header: PropTypes.string,
        hideOnMobile: PropTypes.bool,
        itemIndex: PropTypes.number
    }),
    summaryItemHedTag: PropTypes.oneOf(['div', 'h2', 'h3']),
    summaryItemRubricVariation: PropTypes.string,
    summaryItemVariation: PropTypes.oneOf(SUMMARY_ITEM_VARIATIONS),
    summaryItemVariationList: PropTypes.arrayOf(PropTypes.oneOf(SUMMARY_ITEM_VARIATIONS)),
    totalItems: PropTypes.number,
    totalResults: PropTypes.number,
    trackingNamespace: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        inputKind: PropTypes.string,
        isCollection: PropTypes.bool,
        withAside: PropTypes.bool
    }),
    windowLocation: PropTypes.string
};
module.exports = SummaryList;
//# sourceMappingURL=SummaryList.js.map

/***/ }),

/***/ 63637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { SectionTitleHed } = __webpack_require__(33500);
const { calculateSpacing, getColorToken, getLinkStyles, getTypographyStyles, minScreen } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const SummaryListWrapperWithCollection = css `
  border-top: 1px solid ${getColorToken('colors.discovery.body.white.border')};
  padding-top: ${calculateSpacing(6)};

  @media (min-width: ${BREAKPOINTS.lg}) {
    border-top: unset;
    padding-top: unset;
  }

  .summary-item__hed {
    ${getTypographyStyles('typography.definitions.discovery.hed-core-primary')};
    @media (min-width: ${BREAKPOINTS.md}) {
      ${getTypographyStyles('typography.definitions.discovery.hed-core-secondary')};
    }
  }
`;
const SummaryListWrapperWithAside = css `
  .summary-item--layout-proportions-33-66,
  .summary-item--layout-placement-side-by-side-desktop-only,
  .summary-item--layout-placement-side-by-side {
    .summary-item__hed {
      @media (min-width: ${BREAKPOINTS.md}) {
        ${getTypographyStyles('typography.definitions.discovery.hed-core-primary')};
      }
    }
  }
`;
const SummaryListWrapper = styled.div.withConfig({
    displayName: 'SummaryListWrapper'
}) `
  .hide-river-ad .summary-list__item {
    display: none;
  }

  .show-river-ad {
    padding-bottom: ${calculateSpacing(4)};
  }

  .show-aside-ad .summary-list__item {
    display: block;
  }

  .summary-item--layout-placement-side-by-side-desktop-only,
  .summary-item--layout-placement-side-by-side {
    .summary-item__hed {
      @media (min-width: ${BREAKPOINTS.md}) {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-feature')};
      }
    }
  }

  .summary-item--layout-placement-side-by-side-desktop-only.summary-item--bundle {
    .summary-item__byline,
    .summary-item__hed,
    .summary-item__hed-link {
      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.display-small')};
      margin: auto;
    }
  }

  ${({ isCollection }) => isCollection && SummaryListWrapperWithCollection};

  ${({ withAside }) => withAside && SummaryListWrapperWithAside};
`;
const SummaryListTitle = styled.div.withConfig({
    displayName: 'SummaryListTitle'
}) `
  margin-bottom: ${calculateSpacing(5)};

  ${({ isCollection, theme, hasSectionTitlePrimary }) => {
    if (isCollection) {
        return css `
        ${SectionTitleHed} {
          ${getTypographyStyles(theme, hasSectionTitlePrimary
            ? 'typography.definitions.discovery.subhed-section-primary'
            : 'typography.definitions.discovery.subhed-section-tertiary')}
          padding: ${calculateSpacing(2)} ${calculateSpacing(1)};
        }
      `;
    }
    return '';
}}
`;
const SummaryListDangerousDek = styled(BaseText).withConfig({
    displayName: 'SummaryListDangerousDek'
}) `
  margin-bottom: ${calculateSpacing(4)};
  text-align: center;
`;
SummaryListDangerousDek.defaultProps = {
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.consumptionEditorial.description-core'
};
const SummaryListCallToActionWrapper = styled.div.withConfig({
    displayName: 'SummaryListCallToActionWrapper'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
`;
const SummaryListFooterWrapper = styled.div.withConfig({
    displayName: 'SummaryListFooterWrapper'
}) `
  display: flex;
  align-items: center;
  justify-content: flex-end;
  margin-top: ${calculateSpacing(4)};
  margin-bottom: ${calculateSpacing(4)};
  border-top: 1px solid ${getColorToken('colors.discovery.body.white.border')};

  a {
    padding: ${calculateSpacing(3)} 0 ${calculateSpacing(6)}
      ${calculateSpacing(4)};
    height: ${calculateSpacing(10.5)};
    ${({ theme }) => getLinkStyles(theme, 'colors.consumption.lead.standard.link')};

    .button__icon-container {
      padding-left: ${calculateSpacing(0.3)};

      .icon-arrow {
        width: 18px;
      }
    }
  }

  .button__label {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};
  }
`;
const SummaryItemWrapper = styled.div.withConfig({
    displayName: 'SummaryItemWrapper'
}) `
  && {
    ${({ noClass }) => noClass &&
    `
    padding-bottom: ${calculateSpacing(4)};

    &.summary-item--has-border {
      margin-bottom: ${calculateSpacing(4)};
    }

    &.summary-item--card {
      padding: 0 ${calculateSpacing(2)} 0 0;
      margin: 0 0 ${calculateSpacing(2)};

      ${minScreen(BREAKPOINTS.md)} {
        padding: 0 ${calculateSpacing(3)} 0 0;
        margin: 0 0 ${calculateSpacing(4)};
      }

      ${minScreen(BREAKPOINTS.lg)} {
        padding: 0 ${calculateSpacing(4)} 0 0;
      }
    }

    &:not(.summary-item--card) {
      .summary-item__content {
        padding-bottom: 0;
      }
    }
  
  `};

    ${({ hideBottomBorder }) => hideBottomBorder &&
    `
      border-bottom: none;
    `}

    ${({ hasReducedMargin }) => hasReducedMargin &&
    `
      padding-bottom: ${calculateSpacing(4)};
    `};
  }
`;
const SummaryListButton = styled.button.withConfig({
    displayName: 'SummaryListButton'
}) `
  svg {
    transform: scale(0.6);
  }
`;
const SummaryListAside = styled.aside.withConfig({
    displayName: 'SummaryListAside'
}) `
  ${({ showRecircMostPopularInAsideWithRail }) => showRecircMostPopularInAsideWithRail &&
    `
        width:300px;
      `};
  height: 100%;
`;
module.exports = {
    SummaryListTitle,
    SummaryListDangerousDek,
    SummaryListCallToActionWrapper,
    SummaryListFooterWrapper,
    SummaryListWrapper,
    SummaryItemWrapper,
    SummaryListButton,
    SummaryListAside
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 6518:
/***/ ((module) => {

/**
 * getPropsForSummaryItemFeatured - function to pass required props to get return result for <SummaryItemFeatured/> component
 *
 * @param {object} args - argument object
 * @param {object} args.item - summaryItem object
 * @param {number} args.index - unique numeric identifier for summaryItem
 * @param {object} args.sharedSummaryItemProps - shared props between featured and non-featured summary items
 * @param {boolean} args.hasFeatured - flag which indicates that the summary list has a featured item
 * @param {object} args.summaryItemFeatured - contains options for the summary item that is featured within the list
 * @param {boolean} args.shouldHoldImageSpace - flag to hold space for loading images
 *
 * @returns {object} contains options which is passed down to SummaryItemFeatured component
 */
const getPropsForSummaryItemFeatured = ({ item, index, sharedSummaryItemProps, hasFeatured, summaryItemFeatured, shouldHoldImageSpace }) => {
    const featuredProps = {};
    let isFeatured = false;
    let isBeforeHidden = false;
    if (hasFeatured && summaryItemFeatured) {
        const url = summaryItemFeatured.overrideFeaturedLinks
            ? summaryItemFeatured.ctaUrl || item.url
            : item.url;
        isFeatured = summaryItemFeatured.itemIndex === index;
        // identifiy which item appears before a hidden item
        isBeforeHidden =
            summaryItemFeatured.hideOnMobile &&
                summaryItemFeatured.itemIndex - 1 === index;
        if (isFeatured) {
            featuredProps.header = summaryItemFeatured.header;
            featuredProps.isHiddenOnMobile = !!summaryItemFeatured.hideOnMobile;
            featuredProps.linkLabel = summaryItemFeatured.ctaTextLabel;
            featuredProps.ctaUrl = summaryItemFeatured.ctaUrl;
            featuredProps.shouldHoldImageSpace = shouldHoldImageSpace;
            featuredProps.summaryItemProps = {
                ...item,
                ...sharedSummaryItemProps,
                url
            };
        }
    }
    return { featuredProps, isFeatured, isBeforeHidden };
};
module.exports = {
    getPropsForSummaryItemFeatured
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 62253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const SummaryList = __webpack_require__(95831);
SummaryList.Collection = asVariation(SummaryList, 'SummaryCollectionList', {
    isCollection: true,
    inputKind: 'link'
});
SummaryList.WithAside = asVariation(SummaryList, 'SummaryListWithAside', {
    withAside: true
});
SummaryList.WithAside.displayName = 'SummaryListWithAside';
SummaryList.WithAside.propTypes = {
    ...SummaryList.propTypes,
    summaryItemVariation: SummaryList.propTypes.summaryItemVariation ?? 'SideBySideDesktopOnly'
};
SummaryList.SubHedSecPrimary = asVariation(SummaryList, 'SubHedSecPrimary', {
    hasSubhedSecPrimary: true
});
module.exports = SummaryList;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 31850:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const { generateAdNodeId } = __webpack_require__(1184);
const AdInner = __webpack_require__(44168);
const { AdWrapper } = __webpack_require__(36185);
const { TrackComponentChannel } = __webpack_require__(78788);
const translations = (__webpack_require__(5523)/* ["default"] */ .A);
const connect = __webpack_require__(34967);
const { cytokine } = __webpack_require__(45831);
const getCnBus = () => ( true && window.cnBus) || { on: () => () => { } };
const { useState, useEffect, useRef } = React;
/**
 * Ad component
 *
 * @param {string|ReactElement} [children] - Optional content to display as a failsafe if adblock is detected
 * @param {string} [className] - Optional top-level class to add to component
 * @param {boolean} [isNoAds] - True if no ads should render, false otherwise
 * @param {Function} [onFilled] - Fire a callback when the ad filled event is emitted
 * @param {Function} [onEmpty] - Fire a callback when the ad is empty/suppressed/spacer
 * @param {string} position - Required name used to target ads
 * @param {boolean} [shouldDisplayLabel] - Display an `Advertisement` label
 * @param {boolean} [shouldHoldSpace] - Adds class should-hold-space if true
 * @param {string} [slotType] - Deprecated: name used to target ads, if `position` is not provided
 * @param {Function} [trackClickHandler] - Fire a callback when the ad is clicked
 * @param {string} [props.templateLayout] - optional prop for template layout of the commerce product container
 *
 * @returns {ReactElement} <div>
 */
function Ad({ children, className, stickyHeroAdConfig, handleAdSizeChange = () => { }, index, isNoAds, onFilled = () => { }, onEmpty = () => { }, position, shouldDisplayLabel, shouldHoldSpace, slotType, trackClickHandler = () => { }, templateLayout }) {
    const nodeId = useRef(generateAdNodeId());
    const { formatMessage } = useIntl();
    const slotPosition = position || slotType;
    const wrapperClassName = classnames(className, 'ad', `ad--${slotPosition}`, {
        'should-hold-space': shouldHoldSpace
    });
    /*
      nodeId is set so we can subscribe to ad events from the Ads lib. The Ads lib will broadcast events with the nodeId that it has read from the DOM node.
  
      Since we want to avoid re-rendering the ad container (AdInner) for any reason, nodeId is set as a data-attribute on the server and not used again. A ref is then forwarded to AdInner's element so we can read the nodeId that was set on the server and subscribe to the ad events that are relevant to this particular component instance.
    */
    const adContainer = useRef();
    const [isAdFilled, setIsAdFilled] = useState(false);
    const [isAdblockDetected, setIsAdblockDetected] = useState(false);
    const [slotState, setSlotState] = useState({});
    const [hasAdLabel, setHasAdLabel] = useState(false);
    useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Ad'
        });
    });
    /**
      Adops traffics blank 'spacers' to certain ad positions on specific content to ensure no ad serves. When a spacer gets served it's still technically a 'filled' ad, but it renders nothing so we don't want to display a label for it.
      The ads library will determine if a spacer served and include that information in the 'ad filled' event payload.
      We want to collapse padding and sometimes margin for filled spacer ads
    */
    const { isSpacer = false, isEmptyAd = false, isSuppressedAd = false } = slotState;
    // adblock detection
    // check once on mount if an adblock has been detected before this component mounted
    useEffect(() => {
        setIsAdblockDetected(cytokine.client.consumer.snapshot('adblock.v2.presence'));
        return () => null;
    }, []);
    // emptyAd detection
    // check once on mount if an ad  event is coming back as empty
    // spacer ads
    // the ads library will emit an event if it has determined that this component contains a spacer ad, after the ad has finished rendering.
    // ex. the ad creative itself contains code that informs the ads lib that it is a spacer ad, the ads lib will check each ad slot for the creative id and broadcast events to the Ad components that currently contain the spacer creative
    // suppressed ads
    // when commercial runs sponsorships in some occasions on our sites containing a script to remove a few ad slots from the page, in such cases, to minimize the ad div to avoid large white spaces, we use this event.
    useEffect(() => {
        const cnBus = getCnBus();
        const adSlotEmptyEvent = `ads.slotRenderEnded.${adContainer?.current?.dataset?.nodeId}.empty` ||
            '';
        const adSuppressionEvent = `ads.creative.${adContainer?.current?.dataset?.nodeId}.suppressed` || '';
        const adSlotSpacerEvent = `ads.creative.${adContainer?.current?.dataset?.nodeId}.spacer` || '';
        const adSpacer = cnBus.on(adSlotSpacerEvent, () => setSlotState((oldState) => {
            onEmpty();
            return { ...oldState, isSpacer: true };
        }));
        const adEmpty = cnBus.on(adSlotEmptyEvent, () => setSlotState((oldState) => {
            onEmpty();
            return { ...oldState, isEmptyAd: true };
        }));
        const adSuppression = cnBus.on(adSuppressionEvent, () => setSlotState((oldState) => {
            onEmpty();
            return { ...oldState, isSuppressedAd: true };
        }));
        return () => {
            adSpacer();
            adEmpty();
            adSuppression();
        };
    }, [slotState, setSlotState, onEmpty]);
    // adblock detection
    // listen for an adblock detection event so fallback child component(s) can be rendered in place of an ad
    useEffect(() => {
        const off = !isAdblockDetected
            ? cytokine.client.consumer.subscribe('adblock.v2.presence', (presence) => setIsAdblockDetected(presence))
            : () => { };
        return () => {
            off();
        };
    }, [isAdblockDetected]);
    // advertisment label
    // determine if we should wait to render a label until an ad is filled
    useEffect(() => {
        if (shouldDisplayLabel && isAdFilled && !isSpacer) {
            setHasAdLabel(true);
        }
        else if (shouldDisplayLabel && (isEmptyAd || isSpacer)) {
            setHasAdLabel(false);
        }
    }, [shouldDisplayLabel, isAdFilled, isSpacer, isEmptyAd]);
    // onFilled callback
    useEffect(() => {
        const cnBus = getCnBus();
        const eventName = `ads.slotRenderEnded.${adContainer?.current?.dataset?.nodeId}.filled` ||
            '';
        const off = !isAdFilled
            ? cnBus.on(eventName, (data = {}) => {
                setSlotState(data);
                handleAdSizeChange(data.size);
                setIsAdFilled(true);
                // this callback prop will only get called on the first ad fill, and will not get called on slot refresh
                // we can change it to run on every fill if there is a need for it
                onFilled(data);
            })
            : () => { };
        if (isAdFilled && cnBus.history(eventName).length) {
            setIsAdFilled(true);
        }
        return () => {
            off();
        };
    }, [isAdFilled, onFilled, handleAdSizeChange]);
    const handleKeys = (event) => {
        if (event.key === 'Enter') {
            trackClickHandler(event);
        }
    };
    const adLabel = formatMessage(translations.adLabel);
    const collapseAd = isSpacer || isEmptyAd || isSuppressedAd;
    if (isNoAds) {
        return null;
    }
    /* eslint-disable jsx-a11y/no-static-element-interactions */
    return (React.createElement(AdWrapper, { className: wrapperClassName, stickyHeroAdConfig: stickyHeroAdConfig, onKeyDown: handleKeys, onClick: (event) => trackClickHandler(event), collapse: collapseAd },
        hasAdLabel && React.createElement("span", { className: "ad-label" }, adLabel),
        React.createElement(AdInner, { index: index, ref: adContainer, position: slotPosition, nodeId: nodeId.current, templateLayout: templateLayout }),
        isAdblockDetected && children));
    /* eslint-enable jsx-a11y/no-static-element-interactions */
}
Ad.propTypes = {
    children: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
    className: PropTypes.string,
    handleAdSizeChange: PropTypes.func,
    index: PropTypes.number,
    isNoAds: PropTypes.bool,
    onEmpty: PropTypes.func,
    onFilled: PropTypes.func,
    position: PropTypes.string.isRequired,
    shouldDisplayLabel: PropTypes.bool,
    shouldHoldSpace: PropTypes.bool,
    slotType: PropTypes.string,
    stickyHeroAdConfig: PropTypes.shape({
        holdHeightDesktop: PropTypes.number,
        holdHeightMobile: PropTypes.number,
        shoulHoldStickyHeroAd: PropTypes.bool
    }),
    templateLayout: PropTypes.string,
    trackClickHandler: PropTypes.func
};
module.exports = connect(Ad, {
    keysToPluck: ['isNoAds', 'stickyHeroAdConfig']
});
//# sourceMappingURL=Ad.js.map

/***/ }),

/***/ 44168:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
// never re-render AdInner
const AdInner = React.memo(React.forwardRef(({ index, position, nodeId, templateLayout }, ref) => (React.createElement("div", { ref: ref, className: `ad__slot ad__slot--${position}`, dangerouslySetInnerHTML: { __html: '' }, suppressHydrationWarning: true, "data-node-id": nodeId, "data-ad-index": index, "data-sponsor-template-layout": templateLayout })), () => true));
AdInner.propTypes = {
    index: PropTypes.number,
    nodeId: PropTypes.string.isRequired,
    position: PropTypes.string,
    templateLayout: PropTypes.string
};
module.exports = AdInner;
//# sourceMappingURL=AdInner.js.map

/***/ }),

/***/ 51257:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const debounce = __webpack_require__(38221);
const Ad = __webpack_require__(31850);
const CloseIcon = __webpack_require__(76399);
const Button = __webpack_require__(73730);
const ConsumerMarketingUnit = __webpack_require__(71284);
const { PaymentGateway } = __webpack_require__(92807);
const { asThemedComponent } = __webpack_require__(20223);
const { StickyHeroAdWrapper, SpaceHolder } = __webpack_require__(36185);
const { asConfiguredComponent } = __webpack_require__(12892);
const { applyDefaultPagePadding } = __webpack_require__(1123);
const connect = __webpack_require__(34967);
/** @constant {number} */
// Calc verso padding into an int
const CALC_VERSO_PAGE_PADDING = applyDefaultPagePadding().slice(13, -3);
/** @constant {number} */
const DEFAULT_CREATIVE_HEIGHT = 250;
/** @constant {number} */
const MOBILE_HOLD_HEIGHT = 100;
const urlParams =  true
    ? new URLSearchParams(window.location.search)
    : 0;
/**
 *
 * @param {string} sizeEventName - The cnBus event string e.g. 'ads.stickyBanner.hero.slotRenderEnded.970x90'
 * @returns {number} The height value, e.g. 90
 */
function getHeightFromEventName(sizeEventName) {
    const creativeSize = sizeEventName.replace(/.*\.(.*)$/, '$1'); // Grab last block
    return parseInt(creativeSize.split('x')[1], 10);
}
/**
 * StickyHeroAd component
 *
 * This wraps an <Ad> component with the hero position and adds event hooks which can make it position:sticky
 *
 *
 * @returns {ReactElement} <div>
 */
class StickyHeroAd extends React.Component {
    constructor(props) {
        super(props);
        this.getHeaderHeight = () => {
            const headerElement = document.getElementsByClassName('persistent-bottom')[0]?.previousSibling;
            const headerId = headerElement?.getAttribute('data-testid');
            if (!headerId || headerId.indexOf('PersistentTop') < 0)
                return 0;
            return headerElement.children[0].offsetHeight;
        };
        this.clearListeners = () => {
            if (this.unbindSlotRendered) {
                this.unbindSlotRendered();
            }
            if (this.unbindImpressionViewed) {
                this.unbindImpressionViewed();
            }
            if (this.unbindEmptyHero) {
                this.unbindEmptyHero();
            }
            if (this.unbindSticykHero) {
                this.unbindSticykHero();
            }
            if (this.forceCloseTimeout) {
                clearTimeout(this.forceCloseTimeout);
            }
        };
        this.handleSlotRenderEnded = () => {
            const sizeEventName = window.cnBus.history('ads.stickyBanner.hero.slotRenderEnded.#')[0][0];
            const creativeHeight = getHeightFromEventName(sizeEventName);
            this.setState(() => ({ isSticky: true, creativeHeight }), () => {
                this.props.setIsHeroAdVisible?.(true);
                // Waiting for animation
                setTimeout(() => this.setState(() => ({ animating: true, isVisible: true }), this.bindImpressionViewable), 1000);
            });
        };
        this.bindImpressionViewable = () => {
            // Wait for 30 seconds for impression viewable even or force close
            if (!this.state.shouldHoldAd) {
                this.forceCloseTimeout = setTimeout(() => this.closeSticky(), 30000);
                this.unbindImpressionViewed = window.cnBus.on('ads.stickyBanner.hero.impressionViewable', () => {
                    setTimeout(() => {
                        if (!this.isInteracting) {
                            this.closeSticky();
                        }
                    }, 2000); // Keep it visible for at least 2 seconds before making it go away
                });
            }
            else {
                // if the persistent hero ad refreshes to an empty ad, close the sticky
                this.unbindEmptyHero = window.cnBus.on('#.hero_0.empty', () => {
                    this.closeSticky();
                });
                this.unbindSticykHero = window.cnBus.on('cnePlayer.stickyVideo.activated', () => {
                    this.closeSticky();
                });
            }
        };
        this.closeSticky = () => {
            this.clearListeners(); // We're done with everything, stop listening to events.
            if (!this.state.isVisible) {
                return;
            }
            // If we're near the top just jump to its spot of animating out and jumping into same place.
            if (window.pageYOffset < this.state.creativeHeight / 2) {
                this.setState({
                    animating: false,
                    isVisible: false,
                    isSticky: false
                });
                this.props.setIsHeroAdVisible?.(false);
                return;
            }
            this.setState(() => {
                this.props.setIsHeroAdVisible?.(false);
                return {
                    isVisible: false
                };
            }, () => {
                // Wait for the 1 second for close animation before changing its position
                setTimeout(() => {
                    this.setState(() => ({ animating: false, isSticky: false }));
                    this.props.setIsHeroAdVisible?.(false);
                }, 1000);
            });
        };
        this.triggerInteracting = () => {
            this.isInteracting = true;
        };
        this.handleResize = () => {
            const currentHeaderHeight = this.getHeaderHeight();
            if (currentHeaderHeight !== this.state.headerHeight) {
                this.setState({ headerHeight: currentHeaderHeight });
            }
        };
        const { stickyHeroAdConfig = { shoulHoldStickyHeroAd: false } } = props;
        this.state = {
            isSticky: false,
            isVisible: false,
            animating: false,
            creativeHeight: DEFAULT_CREATIVE_HEIGHT,
            headerHeight: 0,
            shouldHoldAd: urlParams?.get('test') === 'sticky-hero'
                ? true
                : stickyHeroAdConfig.shoulHoldStickyHeroAd
        };
        this.isInteracting = false;
        if ( true && window.cnBus && window.cnBus.history) {
            // We check to see if the hero already had a render even before react.
            const stickyRendered = window.cnBus.history('ads.stickyBanner.hero.slotRenderEnded.#');
            if (stickyRendered.length === 0) {
                // Usually it hasn't happened so add an event listener
                this.unbindSlotRendered = window.cnBus.on('ads.stickyBanner.hero.slotRenderEnded.#', this.handleSlotRenderEnded);
            }
            else {
                // If it had make it sticky right away.
                this.state.creativeHeight = getHeightFromEventName(stickyRendered[0][0]);
                this.state.isSticky = true;
                this.state.isVisible = true;
                this.bindImpressionViewable();
                this.props.setIsHeroAdVisible?.(true);
            }
        }
    }
    componentDidMount() {
        this.setState(() => ({
            headerHeight: this.getHeaderHeight()
        }));
        // increased debounce wait time (ideal debounce time is between 300-500ms)
        window?.addEventListener('scroll', debounce(this.handleResize, 300));
    }
    /**
     *
     * Unbind from cnBus events when this component unmounts.
     *
     * @returns {undefined} undefined
     */
    componentWillUnmount() {
        this.clearListeners();
        window?.removeEventListener('scroll', this.handleResize);
    }
    render() {
        const { isSticky, isVisible, animating, creativeHeight, headerHeight } = this.state;
        const { fullPageTheme = 'standard', navVariation = '', shouldHoldSpace = false, isNoAds, defaultCreativeHeightDesktop, defaultCreativeHeightMobile, stickyHeroAdConfig } = this.props;
        const withSearchbar = navVariation.toLowerCase().includes('withsearchbar');
        // Deducts Verso page padding from headerHeight
        const actualCalcHeaderHeight = headerHeight - CALC_VERSO_PAGE_PADDING - 35;
        // Keeping this to a minimum of 0 to not have negative values
        const calcHeaderHeight = Math.max(actualCalcHeaderHeight, 0);
        const wrapperClassName = isSticky && {
            'ad-stickyhero-issticky': true,
            'ad-stickyhero-sticky-animating': animating,
            [`ad-stickyhero-sticky-${creativeHeight}`]: !isVisible,
            'ad-stickyhero-sticky-visible': isVisible
        };
        const shouldHoldHeight = creativeHeight < MOBILE_HOLD_HEIGHT ||
            creativeHeight === DEFAULT_CREATIVE_HEIGHT;
        if (isNoAds) {
            return null;
        }
        return (React.createElement(React.Fragment, null,
            shouldHoldSpace && shouldHoldHeight && (React.createElement(SpaceHolder, { className: "ad-height-hold", key: "top", stickyHeroAdConfig: stickyHeroAdConfig })),
            React.createElement(StickyHeroAdWrapper, { className: classnames('ad-stickyhero', `ad-stickyhero--${fullPageTheme}`, this.props.isStickyDisabledMobile
                    ? 'ad-stickyhero-disable-mobile'
                    : 'ad-stickyhero-enable-mobile', {
                    'with-link-banner': navVariation
                        .toLowerCase()
                        .includes('linkbanner'),
                    'with-searchbar': withSearchbar
                }, wrapperClassName), "data-testid": "sticky-hero-ad", stickyHeroAdConfig: stickyHeroAdConfig, headerHeight: calcHeaderHeight, onMouseEnter: this.triggerInteracting, onTouchStart: this.triggerInteracting, shouldHoldHeight: shouldHoldHeight, defaultCreativeHeightDesktop: defaultCreativeHeightDesktop, defaultCreativeHeightMobile: defaultCreativeHeightMobile },
                isSticky && isVisible && (React.createElement(Button.Utility, { isIconButton: true, ButtonIcon: CloseIcon, className: "ad-stickyhero-button", label: "Close", onClickHandler: this.closeSticky, role: "button", "aria-expanded": CloseIcon })),
                React.createElement(PaymentGateway, { group: "ads" },
                    React.createElement(Ad, { position: "hero", onFilled: this.props.onFilled, shouldHoldSpace: true })),
                React.createElement(PaymentGateway, { group: "consumer-marketing" },
                    React.createElement(ConsumerMarketingUnit, { position: "display-hero" }))),
            shouldHoldSpace && shouldHoldHeight && (React.createElement(SpaceHolder, { className: "ad-height-hold", key: "bottom", stickyHeroAdConfig: stickyHeroAdConfig }))));
    }
}
StickyHeroAd.propTypes = {
    defaultCreativeHeightDesktop: PropTypes.number,
    defaultCreativeHeightMobile: PropTypes.number,
    fullPageTheme: PropTypes.oneOf(['inverted', 'standard']),
    isNoAds: PropTypes.bool,
    isStickyDisabledMobile: PropTypes.bool,
    navVariation: PropTypes.string,
    onFilled: PropTypes.func,
    /** If the StickyHeroAd is used within the OneNav component,
     * this function changes its visibility. */
    setIsHeroAdVisible: PropTypes.func,
    shouldHoldSpace: PropTypes.bool,
    stickyHeroAdConfig: PropTypes.shape({
        holdHeightDesktop: PropTypes.number,
        holdHeightMobile: PropTypes.number,
        shoulHoldStickyHeroAd: PropTypes.bool
    })
};
StickyHeroAd.displayName = 'StickyHeroAd';
module.exports = connect(asThemedComponent(asConfiguredComponent(StickyHeroAd, 'StickyHeroAd')), {
    keysToPluck: ['isNoAds', 'stickyHeroAdConfig']
});
//# sourceMappingURL=StickyHeroAd.js.map

/***/ }),

/***/ 19607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(31850);
module.exports.StickyHeroAd = __webpack_require__(51257);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 36185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BREAKPOINTS } = __webpack_require__(96472);
const { minScreen, calculateSpacing, maxScreen } = __webpack_require__(26865);
const MOBILE_HOLD_HEIGHT = 100;
// Default Ad heights
const MOBILE_HEIGHT_DEFAULT = 58;
const DESKTOP_HEIGHT_DEFAULT = 98;
const StickyHeroAdWrapper = styled.div.withConfig({
    displayName: 'StickyHeroAdWrapper'
}) `
  .icon-close {
    padding: 8px;
  }

  .cns-ads-slot-state-filled {
    &.cns-ads-slot-type-hero {
      padding: ${({ shouldHoldHeight }) => shouldHoldHeight ? calculateSpacing(1, 'px') : '0px'}
        0;
    }
  }
`;
const StickyMidContentAdWrapper = styled.div.withConfig({
    displayName: 'StickyMidContentAdWrapper'
}) `
  ${({ height }) => height && `height: ${height}px;`}
`;
const AdWrapper = styled.div.withConfig({ displayName: 'AdWrapper' }) `
  &&.ad {
    &.should-hold-space {
      display: flex;
      flex-direction: column;
      justify-content: center;

      min-height: ${({ stickyHeroAdConfig }) => stickyHeroAdConfig?.holdHeightMobile || MOBILE_HEIGHT_DEFAULT}px;

      ${minScreen(BREAKPOINTS.md)} {
        min-height: ${({ stickyHeroAdConfig }) => stickyHeroAdConfig?.holdHeightDesktop || DESKTOP_HEIGHT_DEFAULT}px;
      }
    }
    ${(props) => props.collapse &&
    `
        display: none;
        padding: 0;
        margin-top: 0;
        margin-bottom: 0;
        height: 0;
      `}
  }
`;
const AdsSpacer = styled.div.withConfig({
    displayName: 'AdsSpacer'
}) `
  padding-top: var(--header-height, ${calculateSpacing(7, 'px')});
`;
const SpaceHolder = styled.div.withConfig({ displayName: 'SpaceHolder' }) `
  ${maxScreen(BREAKPOINTS.md)} {
    min-height: calc(
      (
          ${MOBILE_HOLD_HEIGHT}px -
            ${({ stickyHeroAdConfig }) => stickyHeroAdConfig?.holdHeightMobile || MOBILE_HEIGHT_DEFAULT}px -
            ${calculateSpacing(2, 'px')}
        ) / 2
    );
  }
`;
module.exports = {
    AdWrapper,
    AdsSpacer,
    StickyHeroAdWrapper,
    StickyMidContentAdWrapper,
    SpaceHolder
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 5523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    adLabel: {
        id: 'Ad.adLabel',
        defaultMessage: 'Advertisement',
        description: 'Label for Ad'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 9580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const ResponsiveAsset = __webpack_require__(73275);
const { ResponsiveImageContainer } = __webpack_require__(7228);
const { BREAKPOINTS } = __webpack_require__(96472);
const { getColorToken, calculateSpacing, minScreen } = __webpack_require__(26865);
const AppDownloadLinksWrapper = styled.div.withConfig({
    displayName: 'AppDownloadLinksWrapper'
}) `
  ul {
    display: block;
    margin-bottom: ${calculateSpacing(4)};
    padding-left: 0;

    li {
      display: inline;

      a {
        white-space: normal;
      }
    }
  }

  picture {
    max-height: 2.5rem;

    img {
      margin-bottom: ${calculateSpacing(2)};
      width: inherit;
    }
  }

  color: ${getColorToken('colors.foundation.footer.links.secondary')};
`;
const AppDownloadLinksWrapperResponsiveAsset = styled(ResponsiveAsset).withConfig({
    displayName: 'AppDownloadLinksWrapperResponsiveAsset'
}) `
  display: flex;
  justify-content: center;
  margin: 0 auto;
  max-height: ${calculateSpacing(4)};

  ${minScreen(BREAKPOINTS.lg)} {
    justify-content: flex-start;
    margin: 0;
  }

  ${ResponsiveImageContainer} {
    width: auto;
    max-height: inherit;
  }
`;
const AppDownloadLinksWrapperItem = styled('li').withConfig({
    displayName: 'AppDownloadLinksWrapperItem'
}) `
  span,
  picture {
    display: inline;
  }

  padding-right: ${calculateSpacing(2)};
  color: ${getColorToken('colors.foundation.footer.links.secondary')};
`;
module.exports = {
    AppDownloadLinksWrapper,
    AppDownloadLinksWrapperResponsiveAsset,
    AppDownloadLinksWrapperItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 99071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { cantUseAspectRatioContainer } = __webpack_require__(11261);
const { TrackComponentChannel } = __webpack_require__(78788);
const { AspectRatioContainer } = __webpack_require__(7044);
const AspectRatio = (props) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'AspectRatio'
        });
    }, []);
    const { children, segmentedSources, shouldUseMediumBreakpoint, masterAspectRatio, shouldRestrictCropping } = props;
    const shouldNotUseAspectRatioContainer = cantUseAspectRatioContainer(segmentedSources, shouldUseMediumBreakpoint);
    if (shouldNotUseAspectRatioContainer) {
        return children;
    }
    return (React.createElement(AspectRatioContainer, { segmentedSources: segmentedSources, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping, "data-testid": "aspect-ratio-container" },
        React.createElement("div", { className: "aspect-ratio--overlay-container" }, children)));
};
AspectRatio.propTypes = {
    children: PropTypes.node,
    masterAspectRatio: PropTypes.string,
    segmentedSources: PropTypes.shape({
        sm: PropTypes.arrayOf(PropTypes.shape({
            height: PropTypes.number,
            width: PropTypes.number,
            url: PropTypes.string
        })),
        md: PropTypes.arrayOf(PropTypes.shape({
            height: PropTypes.number,
            width: PropTypes.number,
            url: PropTypes.string
        })),
        lg: PropTypes.arrayOf(PropTypes.shape({
            height: PropTypes.number,
            width: PropTypes.number,
            url: PropTypes.string
        }))
    }),
    shouldRestrictCropping: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool
};
module.exports = AspectRatio;
//# sourceMappingURL=AspectRatio.js.map

/***/ }),

/***/ 11261:
/***/ ((module) => {

const BREAKPOINT_DIRECTION = {
    UP: 'up',
    DOWN: 'down'
};
const up = (breakpoint) => `@media (min-width: ${breakpoint}px)`;
const down = (breakpoint) => `@media (max-width: ${breakpoint}px)`;
const generateCss = (breakpoint, upOrDown, image = {}) => {
    const { height, width, aspectRatio = ':' } = image;
    const mediaFunction = upOrDown === BREAKPOINT_DIRECTION.UP ? up : down;
    const [aspectWidthString, aspectHeightString] = aspectRatio.split(':');
    const shouldUseAspectRatioNumbers = !!aspectHeightString;
    const heightAndWidthForCalculations = shouldUseAspectRatioNumbers
        ? [Number(aspectHeightString), Number(aspectWidthString)]
        : [height, width];
    const [cssHeight, cssWidth] = heightAndWidthForCalculations;
    const generatedCSS = `
    ${mediaFunction(breakpoint)} {
      &::before {
        content: '';
        display: block;
        padding-top: min(${(cssHeight / cssWidth) * 100}%, var(--aspect-ratio-box-max-height, 200vh)); // clamping the default to 200vh to allow images taller than view port.
        width: 100%;
      }
    } ;
  `;
    return generatedCSS;
};
const generateCssStyles = (segmentedSources, shouldRestrictCropping, masterAspectRatio, breakpoint, breakpointDirection) => {
    const cssArray = [];
    const restrictCroppingAspectRatio = {
        aspectRatio: masterAspectRatio
    };
    if (segmentedSources) {
        const [segmentedSource] = segmentedSources;
        const augmentedAspectRatio = shouldRestrictCropping
            ? restrictCroppingAspectRatio
            : segmentedSource;
        const backgroundContainerPadding = generateCss(breakpoint, breakpointDirection, augmentedAspectRatio);
        cssArray.push(backgroundContainerPadding);
    }
    return cssArray;
};
const generateBreakPointsWithMedium = (masterAspectRatio, Breakpoints, segmentedSources = {}, shouldRestrictCropping = false) => {
    const smallScreenCss = generateCssStyles(segmentedSources.sm, shouldRestrictCropping, masterAspectRatio, Breakpoints.maxThresholds.md, BREAKPOINT_DIRECTION.DOWN);
    const mediumScreenCss = generateCssStyles(segmentedSources.md, shouldRestrictCropping, masterAspectRatio, Breakpoints.maxThresholds.lg, BREAKPOINT_DIRECTION.DOWN);
    const largeScreenCss = generateCssStyles(segmentedSources.lg, shouldRestrictCropping, masterAspectRatio, Breakpoints.minThresholds.xl, BREAKPOINT_DIRECTION.UP);
    return [...smallScreenCss, ...mediumScreenCss, ...largeScreenCss];
};
const generateBreakPointsWithoutMedium = (masterAspectRatio, Breakpoints, segmentedSources = {}, shouldRestrictCropping = false) => {
    const smallScreenCss = generateCssStyles(segmentedSources.sm, shouldRestrictCropping, masterAspectRatio, Breakpoints.maxThresholds.md, BREAKPOINT_DIRECTION.DOWN);
    const largeScreenCss = generateCssStyles(segmentedSources.lg, shouldRestrictCropping, masterAspectRatio, Breakpoints.minThresholds.lg, BREAKPOINT_DIRECTION.UP);
    return [...smallScreenCss, ...largeScreenCss];
};
const cantUseAspectRatioContainer = (segmentedSources, shouldUseMediumBreakpoint) => {
    const smallSegmentedSourceExists = !!segmentedSources?.sm?.[0];
    const largeSegmentedSourceExists = !!segmentedSources?.lg?.[0];
    const mediumBreakPointCheck = !shouldUseMediumBreakpoint ||
        (shouldUseMediumBreakpoint && !!segmentedSources?.md?.[0]);
    const shouldNotUseAspectRatioContainer = [
        smallSegmentedSourceExists,
        largeSegmentedSourceExists,
        mediumBreakPointCheck
    ].some((check) => check === false);
    return shouldNotUseAspectRatioContainer;
};
module.exports = {
    BREAKPOINT_DIRECTION,
    up,
    down,
    generateCss,
    generateCssStyles,
    generateBreakPointsWithMedium,
    generateBreakPointsWithoutMedium,
    cantUseAspectRatioContainer
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 60448:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(99071);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7044:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { generateBreakPointsWithMedium, generateBreakPointsWithoutMedium } = __webpack_require__(11261);
const Breakpoints = __webpack_require__(99906);
const AspectRatioContainer = styled.div.withConfig({
    displayName: 'AspectRatioContainer'
})((props) => {
    const { segmentedSources = {}, shouldUseMediumBreakpoint = false, shouldRestrictCropping, masterAspectRatio } = props;
    const mediaQueryFunctions = shouldUseMediumBreakpoint
        ? generateBreakPointsWithMedium
        : generateBreakPointsWithoutMedium;
    const paddingContainerCssMediaQueries = mediaQueryFunctions(masterAspectRatio, Breakpoints, segmentedSources, shouldRestrictCropping);
    const allTheMediaQueries = paddingContainerCssMediaQueries.join('\n');
    return `
      ${allTheMediaQueries}
            
      > .aspect-ratio--overlay-container {
        bottom: 0;
        left: 0;
        overflow: hidden;
        position: absolute;
        right: 0;
        top: 0;
      }
    `;
});
module.exports = {
    AspectRatioContainer
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 1902:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { BadgeWrapper, BadgeImage, BadgeDetailsList, BadgeDetailsListItem } = __webpack_require__(34447);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Badge component
 *
 * @param {object} props - React props
 * @param {object} props.award - Award object
 * @param {string} props.award.badgeUrl - Award badge image URL
 * @param {string} props.award.name - Name of award
 * @param {string} props.award.date - Date of award
 * @param {string} [props.className] - Optional top-level class to add
 * @param {boolean} props.hasYearLabel - Has Year of award visible
 * @param {boolean} props.hasNameLabel - Has Name of award visible
 * @param {boolean} [props.hasStaticPositionedAward] - Static positioning to resize .badge__image from it's default size
 * @returns {ReactElement} <div>
 */
const Badge = ({ award: { badgeUrl, date, name }, className, hasYearLabel, hasNameLabel, hasStaticPositionedAward = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Badge'
        });
    }, []);
    if (!badgeUrl)
        return null;
    return (React.createElement(BadgeWrapper, { hasStaticPositionedAward: hasStaticPositionedAward, className: classnames('badge', className), "data-testid": "badge-wrapper" },
        React.createElement(BadgeImage, { hasStaticPositionedAward: hasStaticPositionedAward, alt: name, src: badgeUrl }),
        (hasYearLabel || hasNameLabel) && (React.createElement(BadgeDetailsList, null,
            hasNameLabel && React.createElement(BadgeDetailsListItem, null, name),
            hasYearLabel && React.createElement(BadgeDetailsListItem, null, date)))));
};
Badge.propTypes = {
    award: PropTypes.shape({
        badgeUrl: PropTypes.string.isRequired,
        date: PropTypes.string.isRequired,
        name: PropTypes.string.isRequired
    }),
    className: PropTypes.string,
    hasNameLabel: PropTypes.bool,
    hasStaticPositionedAward: PropTypes.bool,
    hasYearLabel: PropTypes.bool
};
Badge.displayName = 'Badge';
module.exports = Badge;
//# sourceMappingURL=Badge.js.map

/***/ }),

/***/ 71501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const Badge = __webpack_require__(1902);
module.exports = asConfiguredComponent(Badge, 'Badge');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 34447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const BadgeWrapper = styled.div.withConfig({
    displayName: 'BadgeWrapper'
}) `
  ${({ hasStaticPositionedAward }) => hasStaticPositionedAward
    ? `
    width: 50%;

    @media (min-width: ${BREAKPOINTS.md}) {
      width: 145px;
    }

    @media (min-width: ${BREAKPOINTS.lg}) {
      width: 135px;
    }

    @media (min-width: 1039px) {
      width: 140px;
    }
  `
    : ``}
`;
const BadgeImage = styled.img.withConfig({ displayName: 'BadgeImage' }) `
  height: 85%;

  @media (min-width: ${BREAKPOINTS.md}) {
    height: 100%;
  }

  ${({ hasStaticPositionedAward }) => hasStaticPositionedAward
    ? `
    display: flex;
    margin: 0 auto;
    width: 75px;

    @media (min-width: ${BREAKPOINTS.md}) {
      width: 100px;
    }
  `
    : ``}
`;
const BadgeDetailsList = styled.ul.withConfig({
    displayName: 'BadgeDetailsList'
}) `
  margin: 0;
  padding: ${calculateSpacing(1)} 0 0 0;
  list-style: none;
  text-align: center;
`;
const BadgeDetailsListItem = styled(BaseText).withConfig({
    displayName: 'BadgeDetailsListItem'
}) `
  text-transform: uppercase;
`;
BadgeDetailsListItem.defaultProps = {
    as: 'li',
    textAlign: 'center',
    typeIdentity: 'typography.definitions.globalEditorial.numerical-small'
};
module.exports = {
    BadgeWrapper,
    BadgeImage,
    BadgeDetailsList,
    BadgeDetailsListItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 88456:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { componentTracking } = __webpack_require__(90090);
const { TrackComponentChannel } = __webpack_require__(78788);
const { snowplowClickHandler } = __webpack_require__(88963);
const Loader = __webpack_require__(79301);
const { ButtonWrapper, ButtonLabel, ButtonIconWrapper, ButtonIcon, ButtonCountWrapper, ButtonPriceLabel, ButtonPriceWrapper } = __webpack_require__(18974);
const layoutMapping = {
    'primary-filled': 'primary',
    'primary-outlined': 'primary-pair',
    'primary-text': 'utility-pair-secondary',
    'utility-filled': 'utility',
    'utility-outlined': 'utility-pair',
    'utility-text': 'secondary',
    'inverted-filled': 'utility-inverted',
    'inverted-outlined': 'utility-pair-inverted',
    'inverted-text': 'inverted-text'
};
const getUpdatedButtonProps = (isDisabled, shouldShowLoadingState, label) => {
    if (!isDisabled && shouldShowLoadingState) {
        return { showLoader: false, buttonLabel: label };
    }
    return { showLoader: true, buttonLabel: null };
};
const layoutStyle = (buttonStyle, typesStyle) => {
    if (typesStyle) {
        const typeStyleArr = typesStyle.split('-');
        const temp = typeStyleArr[typeStyleArr.length - 1] === 'inverted' &&
            typesStyle === 'utility-inverted'
            ? `${typeStyleArr[typeStyleArr.length - 1]}-${buttonStyle}`
            : `${typesStyle}-${buttonStyle}`;
        if (layoutMapping[temp])
            return layoutMapping[temp];
        return typesStyle;
    }
    return typesStyle;
};
// eslint-disable-next-line complexity
const Button = ({ ariaLabel, ariaLabelledby, ariaDescribedby, size = 'default', btnStyle = 'filled', ButtonIcon: Icon, className, componentId = undefined, cornerRadius = 'NoCornerRadius', countValue, dataAttrs, hasEnableIcon = false, form, isIconButton = false, hasLabelCount = false, href, hasMultipleLines, iconPosition = 'after', id, inputKind = 'button', isDisabled, shouldShowLoadingState, isInline, isLinkDisabled, isSpecial = false, hasPriceSection = false, label, onClickHandler, onKeyDownHandler, priceLabel, rel, role, shouldEnableBundleComponentAnalytics, shouldEnableClickTracking = true, shouldUseFullWidth = false, subject = 'button', tabIndex, target, title, loadingSpinnerColor, trackingNamespace, isInverted = false, variations = {
    typeStyle: 'primary'
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Button',
            variation: variationName
        });
    }, [variationName]);
    const { showLoader, buttonLabel } = getUpdatedButtonProps(isDisabled, shouldShowLoadingState, label);
    const shouldRenderLoaderOnButton = shouldShowLoadingState && showLoader;
    const tags = {
        button: 'button',
        link: 'a',
        reset: 'button',
        submit: 'button',
        text: 'div'
    };
    const TagName = tags[inputKind];
    const anchorProps = inputKind === 'link'
        ? {
            'aria-disabled': isLinkDisabled,
            href,
            rel,
            target
        }
        : {};
    const isLink = inputKind === 'link';
    const isStaticText = inputKind === 'text';
    const hasIcon = Boolean(ButtonIcon);
    const { typeStyle } = variations;
    let analyticsDataAttribute = {};
    if (shouldEnableBundleComponentAnalytics) {
        analyticsDataAttribute = componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, trackingNamespace || label);
    }
    const renderLabelHTML = () => {
        return shouldShowLoadingState ? buttonLabel : label;
    };
    const buttonIcon = (React.createElement(ButtonIconWrapper, { className: "button__icon-container", iconPosition: iconPosition, isIconButton: isIconButton, size: size },
        React.createElement(ButtonIcon, { className: "button-icon", as: Icon, size: size, isinline: isInline })));
    const price = (React.createElement(ButtonPriceWrapper, { as: "span", className: classnames('button', 'button-price') },
        React.createElement(ButtonPriceLabel, { className: "button__label", dangerouslySetInnerHTML: { __html: priceLabel } })));
    const Count = (React.createElement(ButtonCountWrapper, { as: "span", className: classnames('button', 'button-count'), dangerouslySetInnerHTML: { __html: countValue } }));
    if (ariaDescribedby) {
        anchorProps['aria-describedby'] = ariaDescribedby;
    }
    if (ariaLabelledby) {
        anchorProps['aria-labelledby'] = ariaLabelledby;
    }
    if (ariaLabel) {
        anchorProps['aria-label'] = ariaLabel;
    }
    const handleOnClick = (event, subject, componentId) => {
        if (isDisabled) {
            event.preventDefault();
            return;
        }
        onClickHandler && onClickHandler(event);
        if (shouldEnableClickTracking) {
            snowplowClickHandler(isLink, label, href, subject, 'click', componentId);
        }
    };
    return (React.createElement(ButtonWrapper, { ...analyticsDataAttribute, ...anchorProps, ...dataAttrs, as: TagName, btnStyle: btnStyle, hasEnableIcon: hasEnableIcon, loadingSpinnerColor: loadingSpinnerColor, className: classnames('button', {
            [`button--${layoutStyle(btnStyle, typeStyle)}`]: layoutStyle(btnStyle, typeStyle)
        }, className), cornerRadius: cornerRadius, isInline: isInline, isIconButton: isIconButton, hasIcon: hasIcon, isStaticText: isStaticText, isLink: isLink, typeStyle: layoutStyle(btnStyle, typeStyle), "data-event-click": JSON.stringify({
            element: 'Button',
            outgoingURL: href
        }), "data-testid": "Button", "aria-disabled": isDisabled, form: form, size: size, hasPriceSection: hasPriceSection, id: id, onClick: (event) => handleOnClick(event, subject, componentId), onKeyDown: onKeyDownHandler, role: role, shouldUseFullWidth: shouldUseFullWidth, tabIndex: tabIndex, title: title, type: inputKind !== 'link' && inputKind !== 'text' ? inputKind : '', isInverted: isInverted, isSpecial: isSpecial },
        shouldRenderLoaderOnButton && React.createElement(Loader, { className: "spinner" }),
        hasLabelCount && Count,
        (isIconButton || hasEnableIcon) &&
            Icon &&
            iconPosition === 'before' &&
            buttonIcon,
        React.createElement(ButtonLabel, { className: "button__label", dangerouslySetInnerHTML: { __html: renderLabelHTML() }, typeStyle: typeStyle, isIconButton: isIconButton, hasPriceSection: hasPriceSection, hasMultipleLines: hasMultipleLines }),
        hasPriceSection && price,
        (isIconButton || hasEnableIcon) &&
            Icon &&
            iconPosition === 'after' &&
            buttonIcon));
};
Button.propTypes = {
    ariaDescribedby: PropTypes.string,
    ariaLabel: PropTypes.string,
    ariaLabelledby: PropTypes.string,
    btnStyle: PropTypes.oneOf(['filled', 'outlined', 'text']),
    ButtonIcon: PropTypes.func,
    className: PropTypes.string,
    componentId: PropTypes.string,
    cornerRadius: PropTypes.oneOf([
        'NoCornerRadius',
        'RoundedCorner',
        'FullyRoundedCorner'
    ]),
    countValue: PropTypes.number,
    dataAttrs: PropTypes.object,
    form: PropTypes.string,
    hasEnableIcon: PropTypes.bool,
    hasLabelCount: PropTypes.bool,
    hasMultipleLines: PropTypes.bool,
    hasPriceSection: PropTypes.bool,
    href: PropTypes.string,
    iconPosition: PropTypes.oneOf(['before', 'after']),
    id: PropTypes.string,
    inputKind: PropTypes.oneOf(['button', 'link', 'reset', 'submit', 'text']),
    isDisabled: PropTypes.bool,
    isIconButton: PropTypes.bool,
    isInline: PropTypes.bool,
    isInverted: PropTypes.bool,
    isLinkDisabled: PropTypes.bool,
    isSpecial: PropTypes.bool,
    label: PropTypes.string.isRequired,
    loadingSpinnerColor: PropTypes.string,
    onClickHandler: PropTypes.func,
    onKeyDownHandler: PropTypes.func,
    priceLabel: PropTypes.string,
    rel: PropTypes.string,
    role: PropTypes.string,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldEnableClickTracking: PropTypes.bool,
    shouldShowLoadingState: PropTypes.bool,
    shouldUseFullWidth: PropTypes.bool,
    size: PropTypes.string,
    subject: PropTypes.string,
    tabIndex: PropTypes.number,
    target: PropTypes.string,
    title: PropTypes.string,
    trackingNamespace: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        typeStyle: PropTypes.oneOf(['primary', 'utility', 'utility-inverted'])
    })
};
module.exports = Button;
//# sourceMappingURL=Button.js.map

/***/ }),

/***/ 76960:
/***/ ((module) => {

const colorTokens = {
    primary: {
        normal: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        hover: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-secondary',
            border: 'colors.interactive.base.brand-secondary'
        },
        focus: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        active: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-secondary',
            border: 'colors.interactive.base.brand-secondary'
        },
        disabled: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.light',
            border: 'colors.interactive.base.light'
        }
    },
    'primary-pair': {
        normal: {
            text: 'colors.interactive.base.brand-primary',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.brand-primary'
        },
        hover: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        focus: {
            text: 'colors.interactive.base.brand-primary',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.brand-primary'
        },
        active: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        disabled: {
            text: 'colors.interactive.base.light',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.light'
        }
    },
    secondary: {
        normal: {
            text: 'colors.interactive.base.black'
        },
        hover: {
            text: 'colors.interactive.base.brand-primary'
        },
        focus: {
            text: 'colors.interactive.base.black'
        },
        active: {
            text: 'colors.interactive.base.brand-primary'
        },
        disabled: {
            text: 'colors.interactive.base.light'
        }
    },
    utility: {
        normal: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.black',
            border: 'colors.interactive.base.black'
        },
        hover: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        focus: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.black',
            border: 'colors.interactive.base.black'
        },
        active: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        disabled: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.light',
            border: 'colors.interactive.base.light'
        }
    },
    'utility-inverted': {
        normal: {
            text: 'colors.interactive.base.black',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        hover: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        focus: {
            text: 'colors.interactive.base.black',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        active: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.brand-primary',
            border: 'colors.interactive.base.brand-primary'
        },
        disabled: {
            text: 'colors.interactive.base.light',
            background: 'colors.interactive.base.dark',
            border: 'colors.interactive.base.dark'
        }
    },
    'utility-pair': {
        normal: {
            text: 'colors.interactive.base.black',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.black'
        },
        hover: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.black',
            border: 'colors.interactive.base.black'
        },
        focus: {
            text: 'colors.interactive.base.black',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.black'
        },
        active: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.black',
            border: 'colors.interactive.base.black'
        },
        disabled: {
            text: 'colors.interactive.base.light',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.light'
        }
    },
    'utility-pair-inverted': {
        normal: {
            text: 'colors.interactive.base.white',
            background: null,
            border: 'colors.interactive.base.white'
        },
        hover: {
            text: 'colors.interactive.base.black',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        focus: {
            text: 'colors.interactive.base.white',
            background: 'colors.interactive.base.black',
            border: 'colors.interactive.base.white'
        },
        active: {
            text: 'colors.interactive.base.black',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        disabled: {
            text: 'colors.interactive.base.dark',
            background: null,
            border: 'colors.interactive.base.dark'
        }
    },
    'inverted-text': {
        normal: {
            text: 'colors.interactive.base.white'
        },
        hover: {
            text: 'colors.interactive.base.brand-primary'
        },
        focus: {
            text: 'colors.interactive.base.white'
        },
        active: {
            text: 'colors.interactive.base.brand-primary'
        },
        disabled: {
            text: 'colors.interactive.base.dark'
        }
    },
    'utility-pair-secondary': {
        normal: {
            text: 'colors.interactive.base.brand-primary',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        hover: {
            text: 'colors.interactive.base.brand-secondary',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        focus: {
            text: 'colors.interactive.base.brand-primary',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        active: {
            text: 'colors.interactive.base.brand-secondary',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        },
        disabled: {
            text: 'colors.interactive.base.light',
            background: 'colors.interactive.base.white',
            border: 'colors.interactive.base.white'
        }
    }
};
module.exports = { colorTokens };
//# sourceMappingURL=colors.js.map

/***/ }),

/***/ 73730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(31226);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getTypographyStyles, calculateSpacing, getColorToken } = __webpack_require__(26865);
const { hideVisually } = __webpack_require__(52813);
const { INTERACTIVE, BREAKPOINTS } = __webpack_require__(96472);
const { BaseButton } = __webpack_require__(63825);
const { getButtonColors } = __webpack_require__(88963);
const { typographyTokens } = __webpack_require__(26057);
const typeStyleList = [
    'primary-pair',
    'utility',
    'utility-pair-inverted',
    'utility-inverted'
];
const ButtonWrapper = styled(BaseButton).withConfig({
    displayName: 'ButtonWrapper'
}) `
  .spinner {
    transform: scale(1.125);
    animation-name: spin;
    animation-duration: 1200ms;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
  }

  .spinner path {
    fill: ${({ loadingSpinnerColor }) => loadingSpinnerColor || 'black'};
  }

  @keyframes spin {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }

  ${({ hasPriceSection }) => hasPriceSection
    ? `
      justify-content: flex-start;
      flex-direction: row;`
    : `
      justify-content: center;
      `}

  ${({ shouldUseFullWidth }) => shouldUseFullWidth && 'width: 100%;'}

display: ${({ isLink, isStaticText, isInline }) => isLink || isStaticText || isInline ? 'inline-flex' : 'flex'};
  position: relative;
  align-items: center;
  z-index: 1;
  border-radius: ${({ cornerRadius, size }) => {
    if (cornerRadius === 'FullyRoundedCorner')
        return '50px';
    if (cornerRadius === 'RoundedCorner')
        return size === 'small' ? '2px' : '4px';
    return '0px';
}};

  padding: ${({ isInline, hasPriceSection, size, isIconButton }) => {
    if (!hasPriceSection) {
        if (size === 'small' && !!isInline === false)
            return isIconButton ? '0' : `0 12px`;
        return isInline || isIconButton === true
            ? `${calculateSpacing(2)}`
            : `0 ${calculateSpacing(2)}`;
    }
    return '';
}};
  min-width: ${({ isInline, size, isIconButton }) => {
    if (size === 'small' && !!isInline === false)
        return isIconButton ? '32px' : calculateSpacing(5);
    return isInline || isIconButton ? 'auto' : calculateSpacing(5);
}};
  height: ${({ isInline, size, isIconButton }) => {
    if (size === 'small' && !!isInline === false)
        return isIconButton ? '32px' : '32px';
    return isInline || isIconButton ? 'auto' : calculateSpacing(6);
}};

  min-height: ${({ isInline, isIconButton }) => isInline || isIconButton ? 'auto' : '0'};

  &.button--utility + &.button--utility {
    margin-top: ${calculateSpacing(2)};
  }

  &.button__icon--chevron-down .button-icon {
    transform: rotate(90deg);
  }

  &.button__icon--chevron-up .button-icon {
    transform: rotate(270deg);
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    min-width: ${({ isInline, size, isIconButton }) => {
    if (size === 'small' && !!isInline === false)
        return isIconButton ? calculateSpacing(4) : calculateSpacing(10);
    return isInline || isIconButton ? 'auto' : calculateSpacing(20);
}};
  }

  transition-property: color, background, border;
  transition-duration: ${INTERACTIVE.timingButtonDefault};
  transition-timing-function: ease-in;

  &:hover {
    outline: none;
    text-decoration: none;
  }

  &:focus {
    outline: none;
    text-decoration: none;
  }

  &:focus-visible {
    outline: 3px solid #0066cc;
    outline-offset: 3px;
    text-decoration: none;
  }

  &:active {
    outline: none;

    && {
      border-color: ${({ typeStyle }) => {
    if (typeStyle === 'primary' || typeStyle === 'utility-pair')
        return `rgba(255, 255, 255, 0.2);`;
    else if (typeStyleList.includes(typeStyle))
        return `rgba(0, 0, 0, 0.2);`;
    return null;
}};
    }
  }

  &:active::before {
    position: absolute;
    z-index: -1;
    background: ${({ typeStyle, isIconButton }) => {
    if (!isIconButton) {
        if (typeStyle === 'primary' || typeStyle === 'utility-pair')
            return `rgba(255, 255, 255, 0.2);`;
        else if (typeStyleList.includes(typeStyle))
            return `rgba(0, 0, 0, 0.2);`;
    }
    return null;
}};
    width: 100%;
    height: 100%;
    content: '';
  }

  &:active {
    outline: none;
    ${({ typeStyle }) => {
    if (typeStyle === 'secondary' || typeStyle === 'inverted-text')
        return `filter: brightness(80%);`;
    else if (typeStyle === 'utility-pair-secondary')
        return `opacity: .8`;
    return null;
}};
  }

  ${({ isSpecial }) => isSpecial &&
    `
    margin-top: ${calculateSpacing(2)};`}

  ${({ theme, typeStyle, isInverted, isSpecial }) => getButtonColors(theme, typeStyle, isInverted, isSpecial)}

  ${({ theme, typeStyle }) => getTypographyStyles(theme, typographyTokens[typeStyle])}
`;
const ButtonLabel = styled.span.withConfig({ displayName: 'ButtonLabel' }) `
  font-variant-ligatures: none;
  ${({ hasMultipleLines }) => hasMultipleLines &&
    ` text-overflow: ellipsis;
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        &{
        padding: 4px 8px 0px;
        }
    `}
  ${({ hasPriceSection }) => hasPriceSection
    ? `
        padding: ${calculateSpacing(2)} ${calculateSpacing(2.5)};
        flex-basis: 75%;
      `
    : `padding: ${calculateSpacing(1)} 0;`}
  ${({ isIconButton }) => {
    return isIconButton ? hideVisually() : '';
}}
`;
const ButtonIconWrapper = styled.div.withConfig({
    displayName: 'ButtonIconWrapper'
}) `
  padding-right: ${({ iconPosition, isIconButton }) => {
    return iconPosition === 'before' && !isIconButton
        ? calculateSpacing(1)
        : '0';
}};
  padding-left: ${({ iconPosition, isIconButton }) => {
    return iconPosition === 'after' && !isIconButton
        ? calculateSpacing(1)
        : '0';
}};
`;
const ButtonCountWrapper = styled.div.withConfig({
    displayName: 'ButtonCountWrapper'
}) `
  margin-right: ${calculateSpacing(1.5)};
  border: 1px solid;
  border-radius: 50%;
  background: ${getColorToken('colors.interactive.base.white')};
  padding: ${calculateSpacing(0.5)};
  width: 24px;
  height: 24px;
  line-height: 1.33em;
  color: ${getColorToken('colors.interactive.base.brand-primary')};
  font-size: 12px;
`;
const ButtonIcon = styled.span.withConfig({ displayName: 'ButtonIcon' }) `
  display: block;
  width: ${({ size, isinline }) => {
    if (size === 'small' && !!isinline === false)
        return '24px';
    return '32px';
}};
  height: ${({ size, isinline }) => {
    if (size === 'small' && !!isinline === false)
        return '24px';
    return '32px';
}};
`;
const ButtonPriceWrapper = styled.div.withConfig({
    displayName: 'ButtonPriceWrapper'
}) `
  display: flex;
  flex-direction: row;
  justify-content: center;
  padding: ${({ size }) => size === 'default'
    ? `${calculateSpacing(2)} ${calculateSpacing(2.5)}`
    : `${calculateSpacing(1)} ${calculateSpacing(2.5)}`};
  width: 50%;
  height: 100%;
  white-space: nowrap;

  &.button-price {
    background: ${getColorToken('colors.interactive.base.white')};
    color: ${getColorToken('colors.interactive.base.brand-primary')};
  }
`;
const ButtonPriceLabel = styled.span.withConfig({
    displayName: 'ButtonPriceLabel'
}) `
  font-variant-ligatures: none;
  padding: ${calculateSpacing(1)} 0;

  > :first-child {
    color: ${getColorToken('colors.interactive.base.dark')};
  }
`;
module.exports = {
    ButtonWrapper,
    ButtonLabel,
    ButtonIconWrapper,
    ButtonIcon,
    ButtonPriceWrapper,
    ButtonCountWrapper,
    ButtonPriceLabel
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 26057:
/***/ ((module) => {

const typographyTokens = {
    primary: 'typography.definitions.utility.button-core',
    'primary-pair': 'typography.definitions.utility.button-core',
    secondary: 'typography.definitions.utility.button-bulletin',
    utility: 'typography.definitions.utility.button-utility',
    'utility-inverted': 'typography.definitions.utility.button-utility',
    'utility-pair': 'typography.definitions.utility.button-utility',
    'utility-pair-inverted': 'typography.definitions.utility.button-utility',
    'inverted-text': 'typography.definitions.utility.button-utility',
    'utility-pair-secondary': 'typography.definitions.utility.button-utility'
};
module.exports = { typographyTokens };
//# sourceMappingURL=typography.js.map

/***/ }),

/***/ 88963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getColorToken } = __webpack_require__(26865);
const { colorTokens } = __webpack_require__(76960);
const { nonURLClickEvent } = __webpack_require__(14307);
const { trackNavigationClick } = __webpack_require__(99623);
const getStylesForState = (theme, typeStyle, buttonState, isInverted, isSpecial) => {
    const typeStyleColors = colorTokens[typeStyle];
    const stateColors = typeStyleColors && typeStyleColors[buttonState];
    let textColor = getColorToken(theme, stateColors?.text);
    let backgroundColor = getColorToken(theme, stateColors?.background);
    let borderColor = getColorToken(theme, stateColors?.border);
    if (isInverted) {
        textColor = getColorToken(theme, 'colors.background.black');
        backgroundColor = getColorToken(theme, 'colors.background.white');
        borderColor = getColorToken(theme, 'colors.background.white');
    }
    if (isSpecial) {
        textColor = getColorToken(theme, 'colors.background.white');
        backgroundColor = getColorToken(theme, 'colors.consumption.lead.special.background');
        borderColor = getColorToken(theme, 'colors.background.white');
    }
    return `
      ${textColor ? `color: ${textColor};` : ''}
      ${borderColor
        ? `
        border-color: ${borderColor};
        border-width: 2px;
        border-style: solid;
      `
        : ''}
      ${isSpecial ? `border-width: 4px;` : ''}
      background-color: ${backgroundColor || 'transparent'};
    `;
};
const getButtonColors = (theme, typeStyle, isInverted, isSpecial) => {
    return `
  ${getStylesForState(theme, typeStyle, 'normal', isInverted, isSpecial)}

    &:hover {
      ${getStylesForState(theme, typeStyle, 'hover')}
    }

    &:focus {
      ${getStylesForState(theme, typeStyle, 'focus')}
    }

    &:active {
      ${getStylesForState(theme, typeStyle, 'active', isInverted, isSpecial)}
    }

    &:disabled,
    &[aria-disabled='true'],
    &&[aria-disabled='true']:focus,
    &&[aria-disabled='true']:active { 
      cursor: default;
      pointer-events: none;
      ${getStylesForState(theme, typeStyle, 'disabled')}
    }
  `;
};
const snowplowClickHandler = (isLink, label, href, subject = 'button', type = 'click', componentId = null) => {
    if (!isLink && label) {
        nonURLClickEvent(label, href);
    }
    if (isLink) {
        // snowplow tracking
        trackNavigationClick(href, label, subject, type, componentId);
    }
};
module.exports = {
    getButtonColors,
    getStylesForState,
    snowplowClickHandler
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 31226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const Button = __webpack_require__(88456);
Button.Primary = asVariation(Button, 'Primary', {
    typeStyle: 'primary'
});
Button.Secondary = asVariation(Button, 'Secondary', {
    typeStyle: 'secondary'
});
Button.Utility = asVariation(Button, 'Utility', {
    typeStyle: 'utility'
});
Button.UtilityInverted = asVariation(Button, 'Utility', {
    typeStyle: 'utility-inverted'
});
Button.UtilityPairInverted = asVariation(Button, 'UtilityPairInverted', {
    typeStyle: 'utility-pair-inverted'
});
Button.InvertedText = asVariation(Button, 'InvertedText', {
    typeStyle: 'inverted-text'
});
Button.UtilityPairSecondary = asVariation(Button, 'UtilityPairSecondary', {
    typeStyle: 'utility-pair-secondary'
});
module.exports = Button;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 70366:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = __webpack_require__(12353);
const { TrackComponentChannel } = __webpack_require__(78788);
const { BylineWrapper, BylineName, BylineNamesWrapper, BylineLink, BylinePreamble, BylineContributorTitle } = __webpack_require__(74423);
const { Design } = __webpack_require__(75163);
/*
 * Intersperses an array with a single element.
 * intersperse([1, 2, 3], '+') => new Array([1, '+', 2, '+', 3])
 *
 * @param {Array} array_ - any Array
 * @param {*} element - an item to insert between each element
 */
function intersperse(array_, element) {
    return array_.reduce((a, b) => [].concat(a, element, b));
}
/**
 * @param {Array} linkedItems - linkedItems - Arary of contributors name component
 * @param {boolean} [useSpaceInsteadOfComma] - optional use space instead of comma
 * @param {object} intl - React-Intl object
 *
 * if contributor name count is less than or equal to 2, concat both name with " and"
 *
 * otherwise show all three names by concat last with " and"
 *
 * @returns {Array} contributor list
 */
function namesConcat(linkedItems, useSpaceInsteadOfComma, intl) {
    // useSpaceInsteadOfComma is used exclusively for English languages
    if (useSpaceInsteadOfComma && linkedItems.length > 2) {
        return [
            ...intersperse(linkedItems.slice(0, -1), ' '),
            ' and ',
            ...linkedItems.slice(-1)
        ];
    }
    return intl.formatList(linkedItems, { style: 'long', type: 'conjunction' });
}
const getSocialMediaLink = (socialMedias, hasBackground, isInverted) => {
    let socialLink = null;
    for (let i = 0; i < socialMedias.length; i++) {
        const { handle, network, url } = socialMedias[i];
        // No url or handle, skip the media
        if (!(url && handle))
            continue;
        const classes = classnames('byline__social-link', Design.Component.BylineLink, network && network.toLowerCase());
        socialLink = (React.createElement(BylineLink, { className: classes, hasBackground: hasBackground, href: url, isInverted: isInverted, key: network }, handle));
        break;
    }
    return socialLink;
};
const getBylineItems = (items, showCommaAsideContributorName, shouldLink, hasBackground, isInverted, clickHandler, socialMediaLink, showContributorTitle, bylinePreamble, brandName) => {
    return items.map(({ name, dangerousTitle, url }, index, arr) => {
        let author = name;
        const contributortitle = dangerousTitle;
        // showCommaAsideContributorName is only used for English speaking
        // languages
        if (showCommaAsideContributorName && arr.length > 2) {
            if (index < arr.length - 1) {
                author += ',';
            }
        }
        // .link__last-letter-spacing is defined within
        // components/compositions/content-header/_styles.scss, this is only applied
        // when it's a child of .content-header__row
        if (shouldLink && url) {
            author = (React.createElement(BylineLink, { className: `byline__name-link button ${Design.Component.BylineLink}`, hasBackground: hasBackground, href: url, isInverted: isInverted, onClick: clickHandler, key: `${index}_${name}` }, author));
        }
        const contributorTitle = showContributorTitle && contributortitle && (React.createElement(BylineContributorTitle, { className: "byline__name-link button", hasBackground: hasBackground, isInverted: isInverted, key: `${index}__${name}` }, [', ', contributortitle]));
        const brandNameComponent = brandName && (React.createElement("span", { className: "byline__name-brandname" },
            ", ",
            brandName));
        return (React.createElement(BylineName, { hasBackground: hasBackground, isInverted: isInverted, "data-testid": "BylineName", className: "byline__name", key: name },
            !index && bylinePreamble,
            author,
            socialMediaLink && [' ', socialMediaLink],
            contributorTitle,
            brandNameComponent));
    });
};
/**
 * Byline component
 *
 * @param {object}     props - React props
 * @param {string}    [props.brandName] - Brand Name
 * @param {string}    [props.className] - Optional top-level class to add.
 * @param {Function}  [props.clickHandler] - called when user clicks on link
 * @param {string}    [props.contentAlign] - Optional alignment of content
 * @param {string}    [props.conjunction] - Optional
 * @param {string}    [props.type] - the type of the contributor
 * @param {boolean}   [props.isCompact] - Remove spacing between multiple contributors
 * @param {Array}     [props.items] - list of contributors with name and optional url.
 * @param {number}    [props.maxContributorsNames] - Optional maximum number of contributors names of a type to be displayed
 * @param {string}    [props.preamble] - Text preceding the byline. Defaults to "By". Note: surrounding whitespace will be trimmed.
 * @param {boolean}   [props.shouldLink] - Tells whether to link contributor names and handles. Defaults to true.
 * @param {boolean}   [props.showCommaAsideContributorName] - optional flag to override exisitng comma(,) with custom logic to fix visual bug with long author name. see #8939 for details - defaults to false
 * @param {object}    [props.variations] - Optional
 * @param {boolean}   [props.variations.hasBackground] - Optional
 * @param {boolean}   [props.variations.isInverted] - Optional, colors are reversed
 * @param {boolean}   [props.variations.showPreamble] - Optional
 * @param {boolean}   [props.variations.showContributorTypeAsPreamble] - Optional, to pass contributor type as preamble eg- (Author: xyz), where type is author
 * @param {string}    [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
const Byline = ({ className, clickHandler, contentAlign = 'center', isCompact = true, items = [], maxContributorsNames = Math.Infinity, preamble, shouldLink = true, showCommaAsideContributorName = false, type, variations = {
    hasBackground: false,
    showContributorTypeAsPreamble: false,
    showPreamble: true
}, variationName, brandName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Byline',
            variation: variationName
        });
    }, [variationName]);
    const intl = useIntl();
    if (items.length === 0) {
        return null;
    }
    const { hasBackground, showPreamble, showContributorTitle, isInverted, showContributorTypeAsPreamble } = variations;
    // Display social media handle, if there is only one contributor
    // If multiple social media handles for that contributor, display first one
    // only
    const shouldDisplaySocialLink = shouldLink && items.length === 1 && items[0].socialMedia;
    let socialMediaLink = null;
    if (shouldDisplaySocialLink) {
        socialMediaLink = getSocialMediaLink(items[0].socialMedia, hasBackground, isInverted);
    }
    const bylinePreambleContent = (showContributorTypeAsPreamble
        ? `${type.charAt(0).toUpperCase() + type.slice(1)}:`
        : preamble || intl.formatMessage(translations.preamble)).trim();
    const bylinePreamble = showPreamble && (React.createElement(BylinePreamble, { className: "byline__preamble", isInverted: isInverted }, `${bylinePreambleContent} `));
    let bylines = items.slice(0, maxContributorsNames);
    bylines = getBylineItems(bylines, showCommaAsideContributorName, shouldLink, hasBackground, isInverted, clickHandler, socialMediaLink, showContributorTitle, bylinePreamble, brandName);
    if (items.length > maxContributorsNames) {
        bylines.push(intl.formatMessage(translations.more));
    }
    const names = hasBackground
        ? intersperse(bylines, ' ')
        : namesConcat(bylines, showCommaAsideContributorName, intl);
    return (React.createElement(BylineWrapper, { className: classnames('byline', className), contentAlign: contentAlign, "data-testid": "BylineWrapper", hasBackground: hasBackground, isCompact: isCompact, isInverted: isInverted, itemProp: "author", itemScope: "", itemType: "http://schema.org/Person" },
        React.createElement(BylineNamesWrapper, { itemProp: "name" }, names)));
};
Byline.propTypes = {
    brandName: PropTypes.string,
    className: PropTypes.string,
    clickHandler: PropTypes.func,
    contentAlign: PropTypes.oneOf(['left', 'center']),
    isCompact: PropTypes.bool,
    items: PropTypes.arrayOf(PropTypes.shape({
        name: PropTypes.string.isRequired,
        url: PropTypes.string,
        socialMedia: PropTypes.arrayOf(PropTypes.shape({
            url: PropTypes.string,
            network: PropTypes.string,
            handle: PropTypes.string
        }))
    })),
    maxContributorsNames: PropTypes.number,
    preamble: PropTypes.string,
    shouldLink: PropTypes.bool,
    showCommaAsideContributorName: PropTypes.bool,
    type: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        hasBackground: PropTypes.bool,
        isInverted: PropTypes.bool,
        showContributorTitle: PropTypes.bool,
        showContributorTypeAsPreamble: PropTypes.bool,
        showPreamble: PropTypes.bool
    })
};
module.exports = Byline;
//# sourceMappingURL=Byline.js.map

/***/ }),

/***/ 77813:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(54323);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 74423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseLink, BaseText } = __webpack_require__(76955);
const { calculateSpacing, removeTextDecoration, getLinkStyles, getTypographyStyles, getColorStyles, getColorToken } = __webpack_require__(26865);
const { Design } = __webpack_require__(75163);
const BylineWrapper = styled.span.withConfig({
    displayName: 'BylineWrapper'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-core')}

  display: block;
  @media (max-width: ${BREAKPOINTS.md}) {
    display: inline;

    ::after {
      content: ', ';
    }

    :last-child {
      ::after {
        content: '';
      }
    }
  }
  margin: ${calculateSpacing(1)} 0 0;
  text-align: ${({ contentAlign }) => contentAlign};

  color: var(
    ${Design.Color.TextByline},
    ${({ theme, isInverted }) => {
    if (isInverted) {
        return getColorToken(theme, 'colors.consumption.lead.inverted.accreditation');
    }
    return getColorToken(theme, 'colors.consumption.lead.standard.accreditation');
}}
  );

  ${removeTextDecoration()}

  ${({ isCompact }) => isCompact && `&& + & { margin-top: 0}`}
`;
const BylineName = styled.span.withConfig({
    displayName: 'BylineName'
}) `
  display: inline-block;
  @media (max-width: ${BREAKPOINTS.md}) {
    display: inline;
  }

  ${({ hasBackground, theme }) => hasBackground &&
    `
    @media (max-width: ${BREAKPOINTS.md}) {
      line-height: 3em;
    }
    margin-right: ${calculateSpacing(0.25)};
    ${getColorStyles(theme, 'background-color', 'colors.consumption.lead.standard.context-signature')};
    padding: ${calculateSpacing(1)} ${calculateSpacing(1)};
    padding-top: ${calculateSpacing(1)};
    ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-texture')};
  `}

  ${({ isInverted, theme }) => isInverted &&
    css `
      ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-texture')};
    `}
`;
const BylineLink = styled(BaseLink).withConfig({
    displayName: 'BylineLink'
}) `
  ${({ theme, hasBackground, isInverted }) => (hasBackground || isInverted) &&
    `
    ${getLinkStyles(theme, 'colors.consumption.lead.inverted.link')}
    cursor: pointer;
    text-decoration: none;

    &:active,
    &:link,
    &:visited {
      text-decoration: none;
    }

    &:hover,
    &:focus {
      text-decoration: underline;
    }`}
`;
BylineLink.defaultProps = {
    colorSecondaryLinkToken: 'colors.consumption.lead.standard.link-hover',
    colorStaticLinkToken: 'colors.consumption.lead.standard.link',
    hasUnderline: false,
    typeToken: 'typography.definitions.globalEditorial.accreditation-core'
};
const BylineContributorTitle = styled(BaseText).withConfig({
    displayName: 'BylineContributorTitle'
}) `
  color: var(
    ${Design.Color.TextByline},
    ${({ isInverted, theme }) => getColorToken(theme, isInverted
    ? 'colors.consumption.lead.inverted.accreditation'
    : 'colors.consumption.lead.standard.accreditation')}
  );
`;
BylineContributorTitle.defaultProps = {
    as: 'span',
    typeIdentity: 'typography.definitions.globalEditorial.accreditation-core'
};
const BylinePreamble = styled(BaseText).withConfig({
    displayName: 'BylinePreamble'
}) `
  color: var(
    ${Design.Color.TextByline},
    ${({ isInverted, theme }) => getColorToken(theme, isInverted
    ? 'colors.consumption.lead.inverted.accreditation'
    : 'colors.consumption.lead.standard.accreditation')}
  );
`;
BylinePreamble.defaultProps = {
    as: 'span',
    typeIdentity: 'typography.definitions.globalEditorial.accreditation-core'
};
const BylineNamesWrapper = styled.span.withConfig({
    displayName: 'BylineNamesWrapper'
}) ``;
module.exports = {
    BylineWrapper,
    BylineName,
    BylineNamesWrapper,
    BylineLink,
    BylinePreamble,
    BylineContributorTitle
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 12353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { defineMessages } = __webpack_require__(46984);
module.exports = defineMessages({
    more: {
        id: 'Byline.More',
        defaultMessage: 'more',
        description: 'Suffix for when there are more items than wanted'
    },
    preamble: {
        id: 'Byline.Preamble',
        defaultMessage: 'By',
        description: 'Preamble for the contributors'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 54323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const Byline = __webpack_require__(70366);
Byline.Item = asVariation(Byline, 'Item', {
    hasBackground: false,
    showPreamble: true
});
Byline.Inverted = asVariation(Byline, 'Inverted', {
    isInverted: true,
    showPreamble: true
});
Byline.ItemWithoutPreamble = asVariation(Byline, 'ItemWithoutPreamble', {
    hasBackground: false,
    showPreamble: false
});
Byline.Card = asVariation(Byline, 'Card', {
    hasBackground: true,
    showPreamble: false
});
Byline.ItemWithContributorTitle = asVariation(Byline, 'Item', {
    hasBackground: false,
    showPreamble: true,
    showContributorTitle: true
});
Byline.ItemWithContributorTypePreamble = asVariation(Byline, 'Item', {
    hasBackground: false,
    showPreamble: true,
    showContributorTypeAsPreamble: true
});
module.exports = Byline;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 12046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { CaptionCredit, CaptionText, CaptionWrapper } = __webpack_require__(38860);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Caption component
 *
 * @param {string} [className] - Optional top-level class to add.
 * @param {boolean} [creditTextStyle] - Optional to enable the credit span to use the same typography token as the caption span.
 * @param {string} [dangerousCaptionText] - Optional caption field.
 * @param {string} [dangerousCredit] - Optional credit field.
 * @param {boolean} [hasLinebreak] - Optional whether to break a line between caption and credit.
 * @param {string} [shade] - Optional shade of color tokens.
 * @param {string} [theme] - Optional theme.
 * @param {Function} [onClickHandler] - OnClick function fot the caption
 *
 * @returns {ReactElement} <figcaption>
 */
const Caption = ({ dangerousCaptionText, dangerousCredit, className, creditTextStyle = 'default', hasLinebreak = false, shade, topSpacing = 1, theme = 'standard', isCartoonCaption = false, onClickHandler }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Caption'
        });
    }, []);
    const isInverted = theme === 'inverted';
    return (React.createElement(CaptionWrapper, { className: classnames('caption', className), "data-testid": "caption-wrapper", hasShade: shade === 'light', hasLinebreak: hasLinebreak, topSpacing: topSpacing, isInverted: isInverted, onClick: onClickHandler },
        dangerousCaptionText && (React.createElement(CaptionText, { className: "caption__text", hasShade: shade === 'light', hasLinebreak: hasLinebreak, dangerouslySetInnerHTML: { __html: dangerousCaptionText }, isInverted: isInverted, isCartoonCaption: isCartoonCaption })),
        dangerousCredit && (React.createElement(CaptionCredit, { className: "caption__credit", hasShade: shade === 'light', hasLinebreak: hasLinebreak, creditTextStyle: creditTextStyle, dangerouslySetInnerHTML: { __html: dangerousCredit }, isCartoonCaption: isCartoonCaption, isInverted: isInverted }))));
};
Caption.propTypes = {
    className: PropTypes.string,
    creditTextStyle: PropTypes.oneOf(['caption', 'default']),
    dangerousCaptionText: PropTypes.string,
    dangerousCredit: PropTypes.string,
    hasLinebreak: PropTypes.bool,
    isCartoonCaption: PropTypes.bool,
    onClickHandler: PropTypes.func,
    shade: PropTypes.oneOf(['light']),
    theme: PropTypes.oneOf(['standard', 'inverted', 'special']),
    topSpacing: PropTypes.number
};
Caption.displayName = 'Caption';
module.exports = Caption;
//# sourceMappingURL=Caption.js.map

/***/ }),

/***/ 14760:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const Caption = __webpack_require__(12046);
module.exports = asConfiguredComponent(Caption, 'Caption');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 38860:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorStyles, getLinkStyles, styledProperty, getTypographyStyles, getColorToken } = __webpack_require__(26865);
const { Design } = __webpack_require__(75163);
const CAPTION_MAX_WIDTH = '600px';
const CaptionWrapper = styled.div.withConfig({
    displayName: 'CaptionWrapper'
}) `
  margin-top: ${({ topSpacing }) => calculateSpacing(topSpacing)};
  background: ${({ isInverted, theme }) => {
    if (isInverted) {
        return getColorToken(theme, 'colors.background.dark');
    }
    return 'inherit';
}};

  ${({ theme }) => `${getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-secondary')};
  `}

  p {
    margin: 0;
  }

  a {
    ${({ isInverted, theme }) => isInverted
    ? getLinkStyles(theme, 'colors.consumption.lead.inverted.link')
    : getLinkStyles(theme, 'colors.consumption.body.standard.body')}

    &:hover,
    &:focus,
    &:active,
    &:link {
      text-decoration: underline;
    }
  }

  ${({ hasLinebreak }) => hasLinebreak ? `margin-right: 0;` : `p { display: contents; }`}
`;
const CaptionText = styled(BaseText).withConfig({ displayName: 'CaptionText' }) `
  ${styledProperty('hasLinebreak', true, `margin-right: 0;`)}

  ${styledProperty('hasLinebreak', false, `margin-right: ${calculateSpacing(1)};`)}
  
  color: var(
    ${Design.Color.TextImageCaption},
    ${({ isInverted, theme }) => {
    if (isInverted) {
        return getColorToken(theme, 'colors.consumption.lead.inverted.description');
    }
    return getColorToken(theme, 'colors.consumption.lead.standard.description');
}}
  );

  &&& .small {
    font-variant: small-caps;
    text-transform: lowercase;
    font-style: inherit;
  }

  .underline {
    text-decoration: underline;
  }

  .italic {
    font-style: italic;
  }

  ${styledProperty('isCartoonCaption', true, css `
      max-width: ${CAPTION_MAX_WIDTH};
      text-align: center;
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.lead.standard.description')};
    `)}
`;
CaptionText.defaultProps = {
    as: 'span',
    typeIdentity: 'typography.definitions.globalEditorial.context-secondary'
};
const CaptionCredit = styled(BaseText).withConfig({
    displayName: 'CaptionCredit'
}) `
  margin-top: 8px;

  ${({ creditTextStyle, isCartoonCaption, theme }) => creditTextStyle === 'caption' &&
    !isCartoonCaption &&
    getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-secondary')}

  ${({ hasLinebreak }) => hasLinebreak
    ? `
    display: block;
    text-align: left;
  `
    : ``}

  &::before {
    content: '';
  }

  color: var(
    ${Design.Color.TextImageCredit},
    ${({ theme, hasShade, isInverted }) => {
    if (hasShade) {
        return getColorToken(theme, 'colors.consumption.lead.standard.syndication');
    }
    else if (isInverted) {
        return getColorToken(theme, 'colors.consumption.lead.inverted.description');
    }
    return getColorToken(theme, 'colors.consumption.body.standard.body-deemphasized');
}}
  );

  a:hover,
  a:focus,
  a:active,
  a:link {
    text-decoration: underline;
  }
`;
CaptionCredit.defaultProps = {
    as: 'span',
    typeIdentity: 'typography.definitions.globalEditorial.context-tertiary'
};
module.exports = {
    CaptionCredit,
    CaptionText,
    CaptionWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 2758:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const get = __webpack_require__(58156);
const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
const { ConsumerMarketingUnitThemedWrapper } = __webpack_require__(43152);
/**
 * ConsumerMarketingUnit component
 *
 * @param {string} position - Required name used to target ads
 * @param {boolean} [shouldDisplayLabel] - Optional flag to determine if `Advertisement` label should be displayed
 * @param {string} [secondPosition] - Optional name used to target a second ad
 * @param {func} [onCMUnitClick] - CM Unit optional click event handler
 * @param {object} [aria] - Optional ARIA element properties
 * @param {number} tabIndex - Optional prop used to add attribute for keyboard accessibility
 * @returns {ReactElement} <div>
 */
class ConsumerMarketingUnit extends React.Component {
    /**
     * Send an event message over the Ad Library bus
     *
     * @param {string} [event] - name of the event
     * @param {string} position - Required name used to target ads
     * @returns {undefined} undefined
     */
    static notifyAdLibrary(event, position) {
        if ( false ||
            typeof get(window, 'cnBus.emit') !== 'function') {
            return;
        }
        window.cnBus.emit(`consumer-marketing-unit.${event}`, {
            classname: `consumer-marketing-unit--${position}`
        });
    }
    componentDidMount() {
        ConsumerMarketingUnit.notifyAdLibrary('componentDidMount', this.props.position);
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ConsumerMarketingUnit'
        });
    }
    componentDidUpdate() {
        ConsumerMarketingUnit.notifyAdLibrary('componentDidUpdate', this.props.position);
    }
    /**
     * Render the ConsumerMarketingUnit component
     *
     * @returns {ReactElement} <ConsumerMarketingUnit>
     */
    render() {
        const { aria = {}, className, fullPageTheme, position, shouldDisplayLabel, secondPosition, onCMUnitClick, mutation = {}, tabIndex } = this.props;
        const wrapperClassName = classnames(className, 'consumer-marketing-unit', `consumer-marketing-unit--${position}`);
        // Excluding "nav-rollover", the "aria-hidden" attribute is handler
        // by <NavCta /> component.
        if (position !== 'nav-rollover') {
            aria['aria-hidden'] = !mutation[position];
        }
        return (React.createElement(ConsumerMarketingUnitThemedWrapper, { fullPageTheme: fullPageTheme, tabIndex: typeof tabIndex === 'number' && !aria.visibility
                ? tabIndex
                : undefined, className: wrapperClassName, onClick: onCMUnitClick, role: "presentation", ...aria },
            shouldDisplayLabel && (React.createElement("span", { className: "consumer-marketing-unit-label" }, " Advertisement ")),
            React.createElement("div", { 
                // These classnames are used to control ad / failsafe injection.
                // Please message #paywalls-eng on Slack if a change is desired.
                className: classnames('consumer-marketing-unit__slot', `consumer-marketing-unit__slot--${position}`, secondPosition
                    ? `consumer-marketing-unit__slot--${secondPosition}`
                    : ''), 
                // setting html prevents react from digging too deep
                dangerouslySetInnerHTML: { __html: '' } }),
            React.createElement("div", { className: "journey-unit" })));
    }
}
ConsumerMarketingUnit.propTypes = {
    aria: PropTypes.object,
    className: PropTypes.string,
    fullPageTheme: PropTypes.oneOf(['inverted', 'standard']),
    mutation: PropTypes.object,
    onCMUnitClick: PropTypes.func,
    position: PropTypes.string.isRequired,
    secondPosition: PropTypes.string,
    shouldDisplayLabel: PropTypes.bool,
    tabIndex: PropTypes.number
};
ConsumerMarketingUnit.defaultProps = {
    fullPageTheme: 'standard',
    shouldDisplayLabel: false
};
ConsumerMarketingUnit.displayName = 'ConsumerMarketingUnit';
module.exports = ConsumerMarketingUnit;
//# sourceMappingURL=ConsumerMarketingUnit.js.map

/***/ }),

/***/ 71284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const flow = __webpack_require__(49870);
const ConsumerMarketingUnit = __webpack_require__(2758);
const { withVisibilityState, withMutationState } = __webpack_require__(15356);
const withLinkClickTracking = __webpack_require__(84385);
const { asThemedComponent } = __webpack_require__(20223);
/*
  The withElement HOC creates the CMU element that the withVisibilityState factory
  will watch for in the DOM.
*/
const withElement = __webpack_require__(36884);
const withImpressionTracking = __webpack_require__(2046);
const enhance = flow([
    withLinkClickTracking,
    withImpressionTracking,
    withVisibilityState(),
    withMutationState(),
    withElement
]);
module.exports = asThemedComponent(enhance(ConsumerMarketingUnit));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 43152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorStyles } = __webpack_require__(26865);
const ConsumerMarketingUnitThemedWrapper = styled.div.withConfig({
    displayName: 'ConsumerMarketingUnitThemedWrapper'
}) `
  ${({ fullPageTheme, theme }) => fullPageTheme === 'inverted'
    ? `
          ${getColorStyles(theme, 'background', 'colors.consumption.lead.inverted.background')}
        `
    : ``};
`;
module.exports = {
    ConsumerMarketingUnitThemedWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 36884:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
/**
 * withElement
 *
 * This HOC creates a CMU 'element' object from a position property.
 * For example, if props.position is 'paywall-modal', the 'element'
 * object will be:
 * {
 *  name: 'paywall-modal',
 *  className: 'consumer-marketing-unit--paywall-modal'
 * }
 *
 * Finally, the created 'element' is passed to the wrapped component
 * via props.
 *
 * @param {ReactComponent} Component - The to-be-wrapped component
 * @returns {ReactComponent} the wrapped component
 */
const withElement = (Component) => {
    const componentName = Component.displayName || Component.name || 'Component';
    const Element = (props) => (React.createElement(Component, { ...props, element: {
            name: props.position,
            className: `consumer-marketing-unit--${props.position}`
        } }));
    Element.displayName = `withElement(${componentName})`;
    Element.propTypes = {
        position: PropTypes.string.isRequired
    };
    return Element;
};
module.exports = withElement;
//# sourceMappingURL=withElement.js.map

/***/ }),

/***/ 2046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useState, useEffect } = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const get = __webpack_require__(58156);
const { googleAnalytics } = __webpack_require__(90090);
const emitImpressionTrackingEvent = (element, onImpressionTracked) => {
    const node = window.document.querySelector(`.${element.className} [data-impression-name]`);
    const payloadNode = window.document.querySelector(`.${element.className} [data-impression-payload]`);
    if (!node || !node.dataset) {
        return;
    }
    const eventName = `${node.dataset.impressionName}-impression`;
    const payloadData = get(payloadNode, 'dataset.impressionPayload');
    let eventPayload;
    if (payloadData) {
        eventPayload = JSON.parse(payloadData);
    }
    googleAnalytics.emitUniqueGoogleTrackingEvent(eventName, eventPayload);
    onImpressionTracked();
};
/**
 * withImpressionTracking
 *
 * A ConsumerMarketingUnit enhancer component that uses visibility
 * state of an element to fire GA impression events only when that element
 * is visible in the viewport, and impression tracking is enabled for the
 * specified element.
 *
 * @param {ReactComponent} Component - The to-be-wrapped component
 * @returns {Function} withImpressionTracking HOC Component
 */
const withImpressionTracking = (Component) => {
    const componentName = Component.displayName || Component.name || 'Component';
    const ImpressionTracking = (props) => {
        const [impressionTracked, setImpressionTracked] = useState(false);
        useEffect(() => {
            const { element, position, visibility } = props;
            if (impressionTracked || !visibility[position]) {
                return;
            }
            emitImpressionTrackingEvent(element, () => setImpressionTracked(true));
        });
        return React.createElement(Component, { ...props });
    };
    ImpressionTracking.displayName = `withImpressionTracking(${componentName})`;
    ImpressionTracking.propTypes = {
        element: PropTypes.object,
        position: PropTypes.string,
        visibility: PropTypes.object
    };
    return ImpressionTracking;
};
module.exports = withImpressionTracking;
//# sourceMappingURL=withImpressionTracking.js.map

/***/ }),

/***/ 84385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { googleAnalytics } = __webpack_require__(90090);
const CTAElementsSelector = 'a, button';
const emitClickTrackingEvent = ({ target }) => {
    const link = target.matches(CTAElementsSelector)
        ? target
        : target.closest(CTAElementsSelector);
    if (!link) {
        return;
    }
    const clickName = link.getAttribute('data-click-name');
    const payload = link.getAttribute('data-click-payload');
    if (!clickName) {
        return;
    }
    const eventName = `${clickName}-click`;
    const eventPayload = JSON.parse(payload);
    googleAnalytics.emitUniqueGoogleTrackingEvent(eventName, eventPayload);
};
/**
 * withLinkClickTracking
 *
 * This function will add the behavior of emitting GA events on click events
 * to the wrapped component based on the 'clickName' attribute of the link
 * that is clicked.
 *
 * @param {ReactComponent} Component - The to-be-wrapped component
 *
 * @returns {ReactComponent} Wrapped component
 */
const withLinkClickTracking = (Component) => {
    const componentName = Component.displayName || Component.name || 'Component';
    const LinkClickTracking = (props) => (React.createElement(Component, { ...props, onCMUnitClick: emitClickTrackingEvent }));
    LinkClickTracking.displayName = `withLinkClickTracking(${componentName})`;
    return LinkClickTracking;
};
module.exports = withLinkClickTracking;
//# sourceMappingURL=withLinkClickTracking.js.map

/***/ }),

/***/ 94851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const ResponsiveAsset = __webpack_require__(73275);
const SocialIcons = __webpack_require__(35676);
const { TrackComponentChannel } = __webpack_require__(78788);
const { READ_MORE_PLACEHOLDER } = __webpack_require__(43541);
const { ContributorBioWrapper, ContributorBioAvatar, ContributorBioContent, ContributorBioBio, ContributorBioFooter, ContributorBioHeader, ContributorBioTitle, ContributorBioName } = __webpack_require__(94500);
const translations = (__webpack_require__(29422)/* ["default"] */ .A);
/**
 * ContributorBio styled-component
 *
 * @param {object} props - React props
 * @param {string} [props.avatarImageShape] - Optional shape of avatar image, either round or rectangle
 * @param {string} [props.className] - Optional top-level class to add
 * @param {boolean} [props.contentAlign] - Optional prop to align content
 * @param {string} [props.dangerousBio] - Parsed markdown (dangerously set) bio section
 * @param {string} [props.name] - Parsed name (dangerously set) bio section
 * @param {string} [props.dangerousTitle] - Optional parsed markdown (dangerously set) Contributor/Employee title
 * @param {ResponsiveAsset.propTypes} [props.photo] - Photo containing image sources for a ResponsiveAsset
 * @param {boolean} [props.shouldHideImage] - Optional prop to turn off Image
 * @param {boolean} [props.shouldHideSocialIcons] - Optional prop to turn off SocialIcons
 * @param {boolean} [props.shouldHideTitle] - Optional prop to turn off Title
 * @param {boolean} [props.shouldUseTitleForContributorBio] - Optional prop to use the title as the contributor bio
 * @param {boolean} [props.shouldUseNameAsTitle] - Optional prop to use the name as Title
 * @param {SocialMedia.propTypes} [props.socialMedia] - Optional SocialIcons props
 * @param {string} [props.dividerColor] - Optional prop to get divider color for article page from copilot
 * @param {string} [props.url] - Optional
 *
 * @returns {ReactElement} <div>
 */
const ContributorBio = ({ avatarImageShape = 'rectangle', contentAlign = 'left', dangerousBio, dangerousTitle, name, photo, shouldHideImage = false, shouldHideSocialIcons = false, shouldHideTitle = false, shouldUseNameAsTitle = false, shouldUseTitleForContributorBio = false, dividerColor, socialMedia, url }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ContributorBio'
        });
    }, []);
    const { formatMessage } = useIntl();
    const dangerousBioContent = shouldUseTitleForContributorBio
        ? dangerousTitle
        : dangerousBio;
    if (!dangerousBioContent) {
        return null;
    }
    const socialIconsProps = {
        links: socialMedia
    };
    return (React.createElement(ContributorBioWrapper, { contentAlign: contentAlign, dividerColor: dividerColor, "data-testid": "contributor-bio-wrapper" },
        photo && !shouldHideImage && (React.createElement(ContributorBioAvatar, { avatarShape: avatarImageShape },
            React.createElement("a", { href: url },
                React.createElement(ResponsiveAsset, { ...photo })))),
        React.createElement(ContributorBioContent, null,
            React.createElement(ContributorBioHeader, null, shouldUseNameAsTitle && (React.createElement(ContributorBioName, { dangerouslySetInnerHTML: { __html: name } }))),
            React.createElement(ContributorBioBio, { dangerouslySetInnerHTML: {
                    __html: dangerousBioContent.replace(READ_MORE_PLACEHOLDER, formatMessage(translations.readMore))
                } }),
            React.createElement(ContributorBioFooter, null,
                dangerousTitle && !shouldHideTitle && (React.createElement(ContributorBioTitle, { dangerouslySetInnerHTML: { __html: dangerousTitle } })),
                socialMedia && !shouldHideSocialIcons && (React.createElement(SocialIcons.Standard, { ...socialIconsProps }))))));
};
ContributorBio.propTypes = {
    avatarImageShape: PropTypes.oneOf(['rectangle', 'round']),
    contentAlign: PropTypes.string,
    dangerousBio: PropTypes.string,
    dangerousTitle: PropTypes.string,
    dividerColor: PropTypes.string,
    name: PropTypes.string,
    photo: PropTypes.object,
    shouldHideImage: PropTypes.bool,
    shouldHideSocialIcons: PropTypes.bool,
    shouldHideTitle: PropTypes.bool,
    shouldUseNameAsTitle: PropTypes.bool,
    shouldUseTitleForContributorBio: PropTypes.bool,
    socialMedia: PropTypes.arrayOf(PropTypes.shape({
        label: PropTypes.string,
        network: PropTypes.string
    })),
    url: PropTypes.string
};
ContributorBio.displayName = 'ContributorBio';
module.exports = ContributorBio;
//# sourceMappingURL=ContributorBio.js.map

/***/ }),

/***/ 43541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.READ_MORE_PLACEHOLDER = void 0;
/** Placeholder for "read more" value to replace it with the translated value. */
exports.READ_MORE_PLACEHOLDER = 'READ_MORE_PLACEHOLDER';
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 65920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const ContributorBio = __webpack_require__(94851);
module.exports = asConfiguredComponent(ContributorBio, 'ContributorBio');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94500:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { roundImageBase } = __webpack_require__(52027);
const { calculateSpacing, getColorStyles, getLinkStyles, getTypographyStyles } = __webpack_require__(26865);
const { BREAKPOINTS, INTERACTIVE } = __webpack_require__(96472);
const { SocialIconsListItem, SocialIconExternalLink, SocialIconsList } = __webpack_require__(51000);
const { ResponsiveImageContainer } = __webpack_require__(7228);
const { applyCustomDividerColor } = __webpack_require__(1123);
const ContributorBioAvatar = styled.div.withConfig({
    displayName: 'ContributorBioAvatar'
}) `
  display: flex;
  flex: 0 0 auto;
  justify-self: center;
  margin-bottom: ${calculateSpacing(2)};

  @media (min-width: ${BREAKPOINTS.md}) {
    align-self: start;
    margin-right: ${calculateSpacing(3)};
    margin-bottom: 0;
  }

  .responsive-image {
    display: block;
    max-width: 90px;
    max-height: 90px;
    ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.background.light')};
  }

  ${({ avatarShape }) => avatarShape === 'round' &&
    css `
      .responsive-image,
      ${ResponsiveImageContainer} {
        ${roundImageBase('100%', '80px', '80px')}
      }

      @media (min-width: ${BREAKPOINTS.md}) {
        .responsive-image,
        ${ResponsiveImageContainer} {
          ${roundImageBase('100%', '90px', '90px')};
        }
      }
    `}
`;
const ContributorBioBio = styled.div.withConfig({
    displayName: 'ContributorBioBio'
}) `
  margin-top: 0;
  text-align: left;

  a {
    transition: color ${INTERACTIVE.timingLinkDefault} ease;
    ${({ theme }) => getLinkStyles(theme, 'colors.consumption.body.standard.link', 'colors.consumption.body.standard.link-hover')}
  }
`;
const ContributorBioHeader = styled.div.withConfig({
    displayName: 'ContributorBioHeader'
}) `
  display: flex;
  align-items: center;
  margin-top: ${calculateSpacing(0)};
  margin-bottom: ${calculateSpacing(0.5)};

  &:empty {
    display: none;
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    justify-content: flex-start;
  }
`;
const ContributorBioFooter = styled.div.withConfig({
    displayName: 'ContributorBioFooter'
}) `
  display: flex;
  align-items: center;
  margin-top: ${calculateSpacing(2)};
  margin-bottom: ${calculateSpacing(-0.5)};

  &:empty {
    display: none;
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    justify-content: flex-start;
  }

  ${SocialIconsList} {
    margin-left: 0;
  }

  ${SocialIconExternalLink} {
    width: ${calculateSpacing(4)};
    height: ${calculateSpacing(4)};
  }

  ${SocialIconsListItem} {
    padding: 0;
  }
`;
const handleWrapperAlignment = (contentAlign) => {
    switch (contentAlign) {
        case 'left':
            return css `
        ${ContributorBioAvatar} {
          justify-content: left;
        }

        ${ContributorBioHeader} {
          justify-content: left;
        }

        ${ContributorBioBio} {
          text-align: left;
        }

        ${ContributorBioFooter} {
          justify-content: left;
        }
      `;
        case 'center':
            return css `
        ${ContributorBioAvatar} {
          justify-content: center;
        }

        ${ContributorBioHeader} {
          justify-content: center;

          @media (min-width: ${BREAKPOINTS.md}) {
            text-align: left;
          }
        }

        ${ContributorBioBio} {
          text-align: center;

          @media (min-width: ${BREAKPOINTS.md}) {
            text-align: left;
          }
        }

        ${ContributorBioFooter} {
          justify-content: center;

          @media (min-width: ${BREAKPOINTS.md}) {
            text-align: left;
          }
        }
      `;
        default:
            return '';
    }
};
const ContributorBioWrapper = styled.div.withConfig({
    displayName: 'ContributorBioWrapper'
}) `
  padding-top: ${calculateSpacing(4)};
  padding-bottom: ${calculateSpacing(4)};
  text-align: center;

  @media (min-width: ${BREAKPOINTS.sm}) {
    text-align: left;
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    display: flex;
    text-align: inherit;
    justify-items: auto;
  }

  &:not(:last-child) {
    border-width: 0 0 1px;
    border-style: solid;
    ${({ dividerColor, theme }) => `${dividerColor
    ? `${applyCustomDividerColor(dividerColor)};`
    : `${getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.divider')};`}`}
  }

  ${({ contentAlign }) => handleWrapperAlignment(contentAlign)}
`;
const ContributorBioContent = styled.div.withConfig({
    displayName: 'ContributorBioContent'
}) `
  flex: auto;
`;
const ContributorBioTitle = styled.span.withConfig({
    displayName: 'ContributorBioTitle'
}) `
  margin-right: ${calculateSpacing(2)};
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.body-deemphasized')};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-tertiary')}

  a {
    text-decoration: none;
    color: inherit;
  }
`;
const ContributorBioName = styled.span.withConfig({
    displayName: 'ContributorBioName'
}) `
  margin-right: ${calculateSpacing(2)};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-tertiary')}

  a {
    text-decoration: none;
    color: inherit;
  }
`;
module.exports = {
    ContributorBioWrapper,
    ContributorBioAvatar,
    ContributorBioContent,
    ContributorBioBio,
    ContributorBioFooter,
    ContributorBioHeader,
    ContributorBioName,
    ContributorBioTitle
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 29422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    readMore: {
        id: 'ContributorBio.ReadMore',
        defaultMessage: 'Read More',
        description: 'Label for read more link'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 69741:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles, getColorStyles } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText } = __webpack_require__(18730);
const { INTERACTIVE: { timingButtonDefault } } = __webpack_require__(96472);
const discoveryCheckboxIconBorderWidth = '2px';
const discoverySelectionControlSize = calculateSpacing(3);
const selectionControlStyledInput = ({ selectionControlBackgroundColor, selectionControlBorderColor, selectionControlSize }) => {
    return css `
    transition-property: background, border;
    transition-duration: ${timingButtonDefault};
    transition-timing-function: ease-in;
    position: relative;
    border-width: 1px;
    border-style: solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', selectionControlBorderColor)};
    ${({ theme }) => getColorStyles(theme, 'background-color', selectionControlBackgroundColor)};
    width: ${selectionControlSize};
    height: ${selectionControlSize};
    pointer-events: none;

    &::before {
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      transition-property: background, border;
      transition-duration: ${timingButtonDefault};
      transition-timing-function: ease-in;
      opacity: 0;
      content: '';
    }
  `;
};
const selectionControlCheckbox = ({ checkboxIconBorderWidth, checkboxIconColor }) => {
    return css `
    transform: translate(-50%, -60%) rotate(45deg);
    border-width: 0 ${checkboxIconBorderWidth} ${checkboxIconBorderWidth} 0;
    border-style: solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', checkboxIconColor)};
    width: 25%;
    height: 75%;
  `;
};
const selectionControlRadio = ({ radioIconColor, theme }) => {
    return `
    border-radius: 100%;
    transform: translate(-50%, -50%);
    border-radius: 100%;
    ${getColorStyles(theme, 'border-color', radioIconColor)};
    width: 50%;
    height: 50%;
  `;
};
const DiscoverySelectionControlStyledCheckbox = styled.div.withConfig({
    displayName: 'DiscoverySelectionControlStyledCheckbox'
}) `
  ${selectionControlStyledInput({
    selectionControlBackgroundColor: 'colors.interactive.base.white',
    selectionControlBorderColor: 'colors.interactive.base.black',
    selectionControlSize: discoverySelectionControlSize
})}

  &::before {
    ${selectionControlCheckbox({
    checkboxIconBorderWidth: discoveryCheckboxIconBorderWidth,
    checkboxIconColor: 'colors.interactive.base.white'
})}
  }
`;
const DiscoverySelectionControlStyledRadio = styled.div.withConfig({
    displayName: 'DiscoverySelectionControlStyledRadio'
}) `
  ${selectionControlStyledInput({
    selectionControlBackgroundColor: 'colors.interactive.base.white',
    selectionControlBorderColor: 'colors.interactive.base.black',
    selectionControlSize: discoverySelectionControlSize
})}

  border-radius: 100%;

  &::before {
    ${({ theme }) => selectionControlRadio({
    radioIconColor: 'colors.interactive.base.black',
    theme
})}
  }
`;
const selectionControlNativeInput = ({ selectionControlBackgroundColor, theme }) => {
    return `
    &:checked,
    &:active {
      + ${DiscoverySelectionControlStyledRadio}::before {
        opacity: 1;
      }
      + ${DiscoverySelectionControlStyledCheckbox} {
        &::before {
          opacity: 1;
        }
        ${getColorStyles(theme, 'border-color', 'colors.interactive.base.brand-primary')};
        ${getColorStyles(theme, 'background-color', selectionControlBackgroundColor)};
      }
    }

    &:disabled {
      + ${DiscoverySelectionControlStyledRadio},
        + ${DiscoverySelectionControlStyledCheckbox} {
        ${getColorStyles(theme, 'border-color', 'colors.interactive.base.light')};
      }
    }

    &:disabled:checked {
      + ${DiscoverySelectionControlStyledCheckbox} {
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.light')};

      + ${DiscoverySelectionControlStyledRadio}::before {
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.light')};
      }
    }
  `;
};
const getNativeInputCommonStyles = ({ theme }) => {
    return css `
    ${selectionControlNativeInput({
        selectionControlBackgroundColor: 'colors.interactive.base.brand-primary',
        theme
    })}
  `;
};
const disabledStyles = ({ theme }) => {
    return css `
    cursor: default;
    pointer-events: none;
    ${getColorStyles(theme, 'color', 'colors.interactive.base.light')};
  `;
};
const DiscoverySelectionControlNativeRadio = styled.input.withConfig({
    displayName: 'DiscoverySelectionControlNativeRadio'
}) `
  ${({ theme }) => getNativeInputCommonStyles({ theme })}
`;
const DiscoverySelectionControlNativeCheckbox = styled.input.withConfig({
    displayName: 'DiscoverySelectionControlNativeCheckbox'
}) `
  ${({ theme }) => getNativeInputCommonStyles({ theme })}
`;
const DiscoverySelectionControlLabelWrapper = styled.label.withConfig({
    displayName: 'DiscoverySelectionControlLabelWrapper'
}) `
  display: grid;
  position: relative;
  grid-column-gap: ${calculateSpacing(2)};
  grid-template-columns: ${discoverySelectionControlSize} auto;
  grid-row-gap: ${calculateSpacing(0.5)};

  @media (min-width: ${BREAKPOINTS.md}) {
    grid-column-gap: ${calculateSpacing(2)};
    grid-row-gap: ${calculateSpacing(1)};
  }

  &:hover {
    ${DiscoverySelectionControlStyledCheckbox} {
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.brand-primary')};
    }

    ${DiscoverySelectionControlStyledRadio} {
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.brand-primary')};
    }

    ${DiscoverySelectionControlNativeCheckbox}:checked + ${DiscoverySelectionControlStyledCheckbox} {
      ${({ theme }) => getColorStyles(theme, 'background', 'colors.interactive.base.black')};
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.black')};
    }

    ${DiscoverySelectionControlNativeRadio}:checked + ${DiscoverySelectionControlStyledRadio} {
      ${({ theme }) => getColorStyles(theme, 'background', 'colors.interactive.base.white')};
    }
  }

  ${({ isDisabled, theme }) => isDisabled && disabledStyles({ theme })};
`;
const DiscoverySelectionControlContext = styled(BaseText).withConfig({
    displayName: 'DiscoverySelectionControlContext'
}) `
  ${({ theme, typeIdentity }) => getTypographyStyles(theme, typeIdentity)}
  grid-column-start: 2;
  margin-bottom: ${calculateSpacing(0.5)};
  ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)};
  ${({ isDisabled, theme }) => isDisabled && disabledStyles({ theme })};
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-bottom: 0;
  }
`;
DiscoverySelectionControlContext.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
const DiscoverySelectionControlHed = styled(BaseText).withConfig({
    displayName: 'DiscoverySelectionControlHed'
}) `
  ${({ theme, typeIdentity }) => getTypographyStyles(theme, typeIdentity)}
  ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)};
  ${({ isDisabled, theme }) => isDisabled && disabledStyles({ theme })};
`;
DiscoverySelectionControlHed.defaultProps = {
    as: 'span',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.hed-core-secondary'
};
const DiscoverySelectionControlDek = styled(BaseText).withConfig({
    displayName: 'DiscoverySelectionControlDek'
}) `
  ${({ theme, typeIdentity }) => getTypographyStyles(theme, typeIdentity)}
  ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)};
  grid-column-start: 2;
  ${({ isDisabled, theme }) => isDisabled && disabledStyles({ theme })};
`;
DiscoverySelectionControlDek.defaultProps = {
    as: 'span',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
module.exports = {
    DiscoverySelectionControlLabelWrapper,
    DiscoverySelectionControlStyledCheckbox,
    DiscoverySelectionControlNativeCheckbox,
    DiscoverySelectionControlStyledRadio,
    DiscoverySelectionControlNativeRadio,
    DiscoverySelectionControlContext,
    DiscoverySelectionControlHed,
    DiscoverySelectionControlDek
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 9573:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { connect } = __webpack_require__(67851);
const { TrackComponentChannel } = __webpack_require__(78788);
const { handleLinkClick } = __webpack_require__(43428);
const { handleAffiliateLinkClick } = __webpack_require__(14307);
const { extractTrackingParameters, encodeAffiliateLink } = __webpack_require__(25203);
const { getAmazonAffiliateAttributes } = __webpack_require__(82063);
const { decodeAffiliateLink } = __webpack_require__(25203);
const { getComponentType } = __webpack_require__(5143);
/**
 * Given an array of strings (such as "nofollow"), join with presets
 * and return a string for us as rel attribute of link tag.
 *
 * @param {Array<string>} additional - array of strings to join with presets
 * @param {boolean} isExternal - isExternal flag to determine any internal link
 * @returns {string} joined rel attribute value
 */
function getRelValues(additional = [], isExternal = true) {
    const presets = isExternal ? ['nofollow', 'noopener'] : ['noopener'];
    return [...additional, ...presets].join(' ');
}
/**
 * ExternalLink component
 * Safely render a link to a new window.
 *
 * @param {object} props - React props
 * @param {Array<string>} [props.additionalRelVals] - Optional additional values for rel attribute
 * @param {object} [props.attributes] - Optional attributes to add top level i.e. aria-*, role, etc.
 * @param {Array<ReactElement>|string} [props.children] - Wraps children with an anchor tag
 * @param {string} [props.className] - An optional additional className
 * @param {object} [props.dangerouslySetInnerHTML] - Enables use of unsafe html instead of passing children
 * @param {string} props.href - The target URL
 * @param {string} [props.id] - Optional id attribute which is appended when External link is used
 * @param {string} [props.isExternal] - Optional flag to determine any internal link
 * @param {string} [props.linkRef] - Optional React ref to the link component
 * @param {Function} [props.onClick] - Optional on click callback
 * @param {string} [props.rel] - Optional
 * @param {string} [props.target] - Optional
 * @param {string} [props.component] -optional
 * @param {object} [props.actionIdFlags] - Optional action id flags
 * @param {string} [props.amazonAffiliateTag] - Optional Amazon affiliate tag from tenant config
 * @returns {ReactElement} <a>
 */
const ExternalLink = ({ additionalRelVals, attributes, children, className, dangerouslySetInnerHTML, href, id, isExternal, linkRef, onClick, component, actionIdFlags, amazonAffiliateTag, rel = getRelValues(additionalRelVals, isExternal), target = '_blank' }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ExternalLink'
        });
    }, []);
    const isActionIdEnabledForComponent = actionIdFlags?.enableActionIdForExternalLink;
    const isCnastLink = href?.includes('cna.st');
    const enableActionIdMapping = isCnastLink && isActionIdEnabledForComponent;
    const handleClick = (event) => {
        const href = event?.currentTarget?.getAttribute('href');
        // Generic component detection: prioritize explicit prop, fallback to context detection
        const componentUsed = getComponentType(event, component);
        const queryParams = extractTrackingParameters();
        if (enableActionIdMapping && href) {
            event.preventDefault();
            handleLinkClick({
                event,
                linkProps: href,
                setLinkProps: (newhref) => {
                    window.open(newhref, '_blank', 'noopener, noreferrer');
                },
                onClickHandler: onClick || handleAffiliateLinkClick,
                type: 'AffiliateLink',
                label: componentUsed,
                component: componentUsed,
                queryParams
            });
        }
        else if (isCnastLink) {
            // Encode affiliate link with query params in the else part
            if (queryParams) {
                const encodedHref = encodeAffiliateLink(href, {
                    component: componentUsed,
                    extractedParams: queryParams
                });
                event.currentTarget.setAttribute('href', encodedHref);
            }
            onClick && onClick(event);
            handleAffiliateLinkClick(event, {
                type: 'product_affiliate_link',
                component: componentUsed
            });
        }
        else {
            onClick && onClick(event);
        }
    };
    // Get Amazon affiliate attributes for the external link
    // Use data-offer-url if available (contains the actual product URL), otherwise use href
    const offerUrl = attributes?.['data-offer-url'] || decodeAffiliateLink(href);
    const amazonAffiliateAttributes = getAmazonAffiliateAttributes(offerUrl, amazonAffiliateTag);
    const allAttributes = {
        ...attributes,
        className: classnames('external-link', className),
        'data-event-click': JSON.stringify({
            element: 'ExternalLink',
            outgoingURL: href
        }),
        href,
        id,
        onClick: handleClick,
        rel,
        ref: linkRef,
        target,
        ...amazonAffiliateAttributes
    };
    if (dangerouslySetInnerHTML && children) {
        console.warn('ExternalLink cannot be rendered with both children and dangerouslySetInnerHTML.');
        return null;
    }
    return dangerouslySetInnerHTML != null ? (React.createElement("a", { ...allAttributes, dangerouslySetInnerHTML: dangerouslySetInnerHTML })) : (React.createElement("a", { ...allAttributes }, children));
};
ExternalLink.propTypes = {
    actionIdFlags: PropTypes.object,
    additionalRelVals: PropTypes.arrayOf(PropTypes.string),
    amazonAffiliateTag: PropTypes.string,
    attributes: PropTypes.object,
    children: PropTypes.node,
    className: PropTypes.string,
    component: PropTypes.string,
    dangerouslySetInnerHTML: PropTypes.shape({ __html: PropTypes.string }),
    href: PropTypes.string.isRequired,
    id: PropTypes.string,
    isExternal: PropTypes.bool,
    linkRef: PropTypes.object,
    onClick: PropTypes.func,
    rel: PropTypes.string,
    target: PropTypes.string
};
const mapStateToProps = (state) => ({
    amazonAffiliateTag: state.commercePlatform?.amazonAffiliateTag || ''
});
module.exports = connect(mapStateToProps)(ExternalLink);
//# sourceMappingURL=ExternalLink.js.map

/***/ }),

/***/ 39832:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ExternalLink = __webpack_require__(9573);
const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(ExternalLink, 'ExternalLink');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 38299:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Account = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-account'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.account)),
        React.createElement("circle", { cx: "16", cy: "10", r: "7.25", stroke: "black", strokeWidth: "1.5" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 18.5H18C22.6944 18.5 26.5 22.3056 26.5 27V30H28V27C28 21.4772 23.5228 17 18 17H14C8.47715 17 4 21.4771 4 27V29.6V30H5.5V29.6V27C5.5 22.3056 9.30558 18.5 14 18.5Z", fill: "black" })));
};
Account.propTypes = {
    className: PropTypes.string
};
module.exports = Account;
//# sourceMappingURL=Account.js.map

/***/ }),

/***/ 42368:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const prop_types_1 = __importDefault(__webpack_require__(5556));
const react_1 = __importDefault(__webpack_require__(96540));
const classnames_1 = __importDefault(__webpack_require__(32485));
const react_intl_1 = __webpack_require__(46984);
const translations_1 = __importDefault(__webpack_require__(68766));
const AgeGate = ({ className, fill }) => {
    const { formatMessage } = (0, react_intl_1.useIntl)();
    return (react_1.default.createElement("svg", { className: (0, classnames_1.default)(className, 'icon icon-age-gate'), focusable: "false", fill: fill, width: "32", height: "32", viewBox: "0 0 32 32", xmlns: "http://www.w3.org/2000/svg" },
        react_1.default.createElement("title", null, formatMessage(translations_1.default.ageGate)),
        react_1.default.createElement("g", { clipPath: "url(#a)", fillRule: "evenodd", clipRule: "evenodd" },
            react_1.default.createElement("path", { d: "M15.789 29.578c3.698 0 7.167-1.464 9.734-4.023a13.812 13.812 0 0 0 2.445-3.294h-3.314c-.336.46-.71.895-1.117 1.301a10.934 10.934 0 0 1-7.748 3.202c-6.061 0-10.975-4.914-10.975-10.975S9.728 4.814 15.79 4.814a10.958 10.958 0 0 1 9.25 5.065h3.212a13.775 13.775 0 0 0-1.172-2.008A13.772 13.772 0 0 0 15.79 2C8.174 2 2 8.174 2 15.789c0 7.615 6.174 13.789 13.789 13.789Z" }),
            react_1.default.createElement("path", { d: "M14.73 18.033c0 1.716 1.418 2.742 3.606 2.742 2.175 0 3.607-1.026 3.607-2.742 0-1.094-.568-1.904-1.54-2.215.797-.297 1.364-1.121 1.364-2.107 0-1.553-1.391-2.526-3.43-2.526-2.054 0-3.432.973-3.432 2.526 0 .986.54 1.81 1.338 2.107-.973.31-1.513 1.121-1.513 2.215Zm-4.025-3.269v5.809h2.174v-9.185h-1.89c0 1.134-.406 1.661-2.23 1.661v1.716h1.946Zm7.631.284c.824 0 1.351-.46 1.351-1.148 0-.716-.54-1.162-1.35-1.162-.825 0-1.351.446-1.351 1.162 0 .689.553 1.148 1.35 1.148Zm1.473 2.837c0 .77-.595 1.27-1.473 1.27-.878 0-1.472-.5-1.472-1.27 0-.757.621-1.256 1.472-1.256.878 0 1.473.5 1.473 1.256Zm8.08-4.91h-1.97v2.11h-2.11v1.97h2.11v2.11h1.97v-2.11H30v-1.97h-2.11v-2.11Z" })),
        react_1.default.createElement("defs", null,
            react_1.default.createElement("clipPath", { id: "a" },
                react_1.default.createElement("path", { d: "M0 0h32v32H0z" })))));
};
AgeGate.propTypes = {
    className: prop_types_1.default.string,
    fill: prop_types_1.default.string
};
AgeGate.displayName = 'AgeGateIcon';
exports["default"] = AgeGate;
//# sourceMappingURL=AgeGate.js.map

/***/ }),

/***/ 42361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Arrow = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-arrow'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.arrow)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M29.06 16 15.53 2.47l-1.06 1.06 11.72 11.72H2v1.5h24.19L14.47 28.47l1.06 1.06L29.06 16Z" })));
};
Arrow.propTypes = {
    className: PropTypes.string
};
module.exports = Arrow;
//# sourceMappingURL=Arrow.js.map

/***/ }),

/***/ 4498:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Article = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-article'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.article)),
        React.createElement("path", { d: "M2 5.25h25v1.5H2v-1.5Zm0 10h28v1.5H2v-1.5Zm19 10H2v1.5h19v-1.5Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Article.propTypes = {
    className: PropTypes.string
};
module.exports = Article;
//# sourceMappingURL=Article.js.map

/***/ }),

/***/ 59257:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const BlueSky = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bluesky'), focusable: "false", height: "32", viewBox: "0 0 32 32", width: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.bluesky)),
        React.createElement("path", { d: "M8.07 4.683c3.21 2.444 6.662 7.399 7.93 10.058 1.268-2.66 4.72-7.614 7.93-10.058C26.248 2.919 30 1.555 30 5.897c0 .867-.49 7.284-.778 8.325-1 3.622-4.641 4.546-7.881 3.987 5.663.977 7.103 4.214 3.992 7.452-5.908 6.148-8.492-1.543-9.154-3.514-.121-.36-.178-.53-.179-.386 0-.144-.058.025-.179.387-.662 1.97-3.246 9.66-9.154 3.513-3.111-3.238-1.67-6.475 3.992-7.452-3.24.559-6.882-.365-7.881-3.987C2.49 13.181 2 6.764 2 5.897c0-4.342 3.753-2.978 6.07-1.214Z", fill: "#000" })));
};
BlueSky.propTypes = {
    className: PropTypes.string
};
module.exports = BlueSky;
//# sourceMappingURL=BlueSky.js.map

/***/ }),

/***/ 43706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 */
const Bookmark = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || title || formatMessage(translations.bookmark)),
        React.createElement("path", { className: "icon-bookmark-stroke", fill: "black", fillRule: "evenodd", d: "M24.25 11V3H25.75V11H24.25Z", clipRule: "evenodd" }),
        React.createElement("path", { fill: "black", fillRule: "evenodd", d: "M29 7.75L21 7.75L21 6.25L29 6.25L29 7.75Z", clipRule: "evenodd" }),
        React.createElement("path", { fill: "black", fillRule: "evenodd", d: "M6.25 4.25H18.25V5.75H7.75V25.7158L16 21.062L24.25 25.7158V14.25H25.75V28.2842L16 22.7842L6.25 28.2842V4.25Z", clipRule: "evenodd" })));
};
Bookmark.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = Bookmark;
//# sourceMappingURL=Bookmark.js.map

/***/ }),

/***/ 20215:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 */
const BookmarkActivated = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark icon-bookmark--activated'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle ||
            title ||
            formatMessage(translations.bookmarkActivated)),
        React.createElement("path", { className: "icon-bookmark-fill icon-bookmark--activated-outline", d: "M6.25 4.25H16V5.75H7.75V25.7158L16 21.062L24.25 25.7158V16H25.75V28.2842L16 22.7842L6.25 28.2842V4.25Z", fill: "black", fillRule: "evenodd", clipRule: "evenodd" }),
        React.createElement("path", { className: "icon-bookmark-fill icon-bookmark--activated-checkmark", fill: "black", fillRule: "evenodd", d: "M16.0001 14.9393L26.4697 4.46967L27.5304 5.53033L16.0001 17.0607L10.4697 11.5303L11.5304 10.4697L16.0001 14.9393Z", clipRule: "evenodd" })));
};
BookmarkActivated.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = BookmarkActivated;
//# sourceMappingURL=BookmarkActivated.js.map

/***/ }),

/***/ 66718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 */
const BookmarkNew = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || title || formatMessage(translations.bookmark)),
        React.createElement("path", { d: "M15.6315 22.1309L7 27V5H25V27L16.3685 22.1309L16 21.9231L15.6315 22.1309Z", stroke: "black", strokeWidth: "1.5", strokeLinecap: "square" })));
};
BookmarkNew.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = BookmarkNew;
//# sourceMappingURL=BookmarkNew.js.map

/***/ }),

/***/ 3540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CartFilled = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-cart'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.cart)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.614 8.848H2v-2h6.044l.23.676 1.093 3.193h20.8l-.308 1.241-1.281 5.159-.145.582-.582.147-15.83 3.977-.892.224-.298-.87-4.217-12.33Zm19.83 16.734c.007.315-.05.628-.17.92-.12.294-.298.56-.526.786-.228.225-.5.404-.8.527a2.517 2.517 0 0 1-1.896 0 2.45 2.45 0 0 1-.8-.526 2.358 2.358 0 0 1-.525-.785 2.296 2.296 0 0 1-.17-.92 2.329 2.329 0 0 1 .734-1.639 2.488 2.488 0 0 1 1.708-.674c.64 0 1.253.241 1.71.673.456.432.72 1.02.735 1.638Zm-9.948.921c.12-.293.178-.606.17-.921a2.329 2.329 0 0 0-.735-1.638 2.488 2.488 0 0 0-1.71-.673c-.638 0-1.252.242-1.708.674a2.328 2.328 0 0 0-.734 1.638c-.008.315.05.628.17.921.12.293.298.56.526.785.228.225.5.404.8.526a2.515 2.515 0 0 0 1.896 0c.3-.123.572-.302.8-.527.227-.225.406-.492.525-.785Z", fill: "#000" })));
};
CartFilled.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = CartFilled;
//# sourceMappingURL=CartFilled.js.map

/***/ }),

/***/ 64510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CartOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    const pathStyle = {
        fill: 'none'
    };
    return (React.createElement("svg", { className: classnames(className, 'icon icon-cart'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.cart)),
        React.createElement("g", { clipPath: "url(#clip0_3732_178638)" },
            React.createElement("path", { d: "M2 3h4l4 17h15l4-13H14", stroke: "#000", strokeWidth: "1.5", strokeLinejoin: "round", style: pathStyle }),
            React.createElement("circle", { cx: "2", cy: "2", r: "2", transform: "matrix(1 0 0 -1 11 29)", stroke: "#000", strokeWidth: "1.5" }),
            React.createElement("circle", { cx: "2", cy: "2", r: "2", transform: "matrix(1 0 0 -1 20 29)", stroke: "#000", strokeWidth: "1.5" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "clip0_3732_178638" },
                React.createElement("rect", { width: "32", height: "32", fill: "white" })),
            React.createElement("clipPath", { id: "clip1_3732_178638" },
                React.createElement("rect", { width: "32", height: "32", fill: "white" })))));
};
CartOutlined.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = CartOutlined;
//# sourceMappingURL=CartOutlined.js.map

/***/ }),

/***/ 76196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Check = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-check'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.check)),
        React.createElement("path", { d: "M13.5 20.44 24.97 8.97l1.06 1.06L13.5 22.56l-7.03-7.03 1.06-1.06 5.97 5.97Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Check.propTypes = {
    className: PropTypes.string
};
module.exports = Check;
//# sourceMappingURL=Check.js.map

/***/ }),

/***/ 16619:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronDown = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-down'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronDown)),
        React.createElement("path", { d: "M16 21.94 3.53 9.47l-1.06 1.06L16 24.06l13.53-13.53-1.06-1.06L16 21.94Z", fillRule: "nonzero", fill: "black" })));
};
ChevronDown.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronDown;
//# sourceMappingURL=ChevronDown.js.map

/***/ }),

/***/ 32586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronFill = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevronFill'), width: "36", height: "36", viewBox: "0 0 36 36", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronFill)),
        React.createElement("rect", { width: "36", height: "36", rx: "18", fill: "black" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.1212 17.707C21.5118 18.0975 21.5118 18.7307 21.1212 19.1212L17.1212 23.1212C16.7307 23.5117 16.0976 23.5117 15.707 23.1212C15.3165 22.7307 15.3165 22.0975 15.707 21.707L18.9999 18.4141L15.707 15.1212C15.3165 14.7306 15.3165 14.0975 15.707 13.7069C16.0976 13.3164 16.7307 13.3164 17.1213 13.7069L21.1212 17.707Z", fill: "white" })));
};
ChevronFill.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronFill;
//# sourceMappingURL=ChevronFill.js.map

/***/ }),

/***/ 87986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronLeft = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-left'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronLeft)),
        React.createElement("path", { d: "M11.06 16 23.53 3.53l-1.06-1.06L8.94 16l13.53 13.53 1.06-1.06L11.06 16Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
ChevronLeft.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronLeft;
//# sourceMappingURL=ChevronLeft.js.map

/***/ }),

/***/ 39733:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronRight = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevron)),
        React.createElement("path", { d: "M21.94 16 9.47 3.53l1.06-1.06L24.06 16 10.53 29.53l-1.06-1.06L21.94 16Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
ChevronRight.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronRight;
//# sourceMappingURL=ChevronRight.js.map

/***/ }),

/***/ 56430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronUp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-up'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronUp)),
        React.createElement("path", { d: "m16 10.06 12.47 12.47 1.06-1.06L16 7.94 2.47 21.47l1.06 1.06L16 10.06Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
ChevronUp.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronUp;
//# sourceMappingURL=ChevronUp.js.map

/***/ }),

/***/ 30616:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Close = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-close'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", role: "none", ...attrs },
        React.createElement("title", null, formatMessage(translations.close)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.94 16 2.453 28.486l1.094 1.028L16 17.06l12.453 12.453 1.094-1.028L17.061 16 29.547 3.514l-1.094-1.028L16 14.94 3.547 2.486 2.453 3.514 14.94 16Z" })));
};
Close.propTypes = {
    className: PropTypes.string
};
module.exports = Close;
//# sourceMappingURL=Close.js.map

/***/ }),

/***/ 87241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Collapse = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-collapse'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.collapse)),
        React.createElement("path", { d: "M2 15.25h28v1.5H2v-1.5Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Collapse.propTypes = {
    className: PropTypes.string
};
module.exports = Collapse;
//# sourceMappingURL=Collapse.js.map

/***/ }),

/***/ 34577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Comment = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-comment'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.comment)),
        React.createElement("path", { d: "M17 22h13V4H2v18h6v6l9-6Zm-7.5 3.197 7.046-4.697H28.5v-15h-25v15h6v4.697Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Comment.propTypes = {
    className: PropTypes.string
};
module.exports = Comment;
//# sourceMappingURL=Comment.js.map

/***/ }),

/***/ 70195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CopyLink = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-copylink'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.copyLink)),
        React.createElement("g", { clipPath: "url(#clip0_3732_178637)" },
            React.createElement("path", { d: "M22.654 13.67a.752.752 0 0 0 .284 1.039.787.787 0 0 0 1.063-.279l1.944-3.295c1.718-2.913.699-6.637-2.277-8.318-2.976-1.682-6.782-.684-8.5 2.229l-3.111 5.273c-1.718 2.912-.699 6.636 2.277 8.318.293.165.594.304.9.418a.694.694 0 0 0 .833-.311c.256-.434-.006-.99-.476-1.19a4.745 4.745 0 0 1-.479-.236c-2.232-1.26-2.997-4.054-1.708-6.238l3.111-5.273c1.289-2.185 4.143-2.933 6.375-1.672s2.997 4.054 1.708 6.239l-1.944 3.295ZM9.126 18.33a.752.752 0 0 0-.284-1.04.787.787 0 0 0-1.063.28l-1.944 3.296c-1.719 2.912-.699 6.636 2.277 8.317 2.976 1.682 6.782.684 8.5-2.229l3.111-5.273c1.718-2.912.699-6.636-2.277-8.318a6.327 6.327 0 0 0-.9-.419.694.694 0 0 0-.833.312c-.256.434.007.99.476 1.19.162.069.322.147.479.236 2.232 1.26 2.997 4.054 1.708 6.238l-3.111 5.273c-1.289 2.184-4.143 2.933-6.375 1.672s-2.997-4.054-1.708-6.238l1.944-3.296Z", fill: "#000" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "clip0_3732_178637" },
                React.createElement("rect", { width: "32", height: "32", fill: "white" })),
            React.createElement("clipPath", { id: "clip1_3732_178637" },
                React.createElement("rect", { width: "32", height: "32", fill: "white" })))));
};
CopyLink.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = CopyLink;
//# sourceMappingURL=CopyLink.js.map

/***/ }),

/***/ 71039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Dot = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-dots'), viewBox: "0 0 32 32", width: "32", height: "32", fill: "#DADADA", xmlns: "http://www.w3.org/2000/svg", role: "img", ...attrs },
        React.createElement("title", null, formatMessage(translations.dots)),
        React.createElement("path", { d: "M20 16a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" })));
};
Dot.propTypes = {
    className: PropTypes.string
};
module.exports = Dot;
//# sourceMappingURL=Dot.js.map

/***/ }),

/***/ 29165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const DownloadCloud = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-downloadCloud'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.downloadCloud)),
        React.createElement("path", { d: "M16.53 27.49V17.189h-1.322v10.303l-2.773-2.906-1.057 1.056L15.868 30l4.492-4.359-1.057-1.056-2.774 2.905Zm6.603-20.207C22.869 4.245 20.227 2 17.189 2c-2.51 0-4.887 1.717-5.68 4.094-.263-.132-.66-.132-.924-.132a5.919 5.919 0 0 0-5.943 5.944c0 .396 0 .66.132 1.057C3.057 13.755 2 15.34 2 17.189c0 2.51 2.113 4.623 4.623 4.623h5.283v-1.32H6.623a3.27 3.27 0 0 1-3.302-3.303c0-1.453.924-2.774 2.377-3.17l.66-.132-.131-.66c-.133-.529-.265-.925-.265-1.321 0-2.51 2.114-4.623 4.623-4.623.396 0 .793 0 1.321.132l.66.264.132-.66c.397-2.113 2.378-3.698 4.491-3.698 2.51 0 4.623 2.113 4.623 4.623v.66h.66a5.919 5.919 0 0 1 5.944 5.944 5.919 5.919 0 0 1-5.944 5.943h-2.641v1.32h2.641c3.963 0 7.265-3.301 7.265-7.263 0-3.83-2.906-6.869-6.604-7.265Z", fill: "#000" })));
};
DownloadCloud.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = DownloadCloud;
//# sourceMappingURL=DownloadCloud.js.map

/***/ }),

/***/ 5198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const DownloadWeb = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-downloadWeb'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.downloadWeb)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m23.47 14.47-6.72 6.72V2h-1.5v19.19l-6.72-6.72-1.06 1.06L16 24.06l8.53-8.53-1.06-1.06ZM2 29.75h28v-1.5H2v1.5Z", fill: "#000" })));
};
DownloadWeb.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = DownloadWeb;
//# sourceMappingURL=DownloadWeb.js.map

/***/ }),

/***/ 49140:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Email = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-email'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.email)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M27.44 7.5H4.56L16 18.94 27.44 7.5ZM3.5 8.56V24.5h25V8.56L16 21.06 3.5 8.56ZM2 26V6h28v20H2Z", fill: "#000" })));
};
Email.propTypes = {
    className: PropTypes.string
};
module.exports = Email;
//# sourceMappingURL=Email.js.map

/***/ }),

/***/ 88852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const EmailFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-email-filled'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.email)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.002 18.061 3.219 6h25.558L16.002 18.061ZM2 26V7.258L16.004 20.47 30 7.26V26H2Z", fill: "#000" })));
};
EmailFilled.propTypes = {
    className: PropTypes.string
};
module.exports = EmailFilled;
//# sourceMappingURL=EmailFilled.js.map

/***/ }),

/***/ 3686:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Enlarge = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-enlarge'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.expand)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M27.19 3.75H16v-1.5h13.75V16h-1.5V4.81l-8.72 8.72-1.06-1.06 8.72-8.72ZM3.75 16h-1.5v13.75H16v-1.5H4.81l8.72-8.72-1.06-1.06-8.72 8.72V16Z", fill: "#000", fillOpacity: "0.64" })));
};
Enlarge.propTypes = {
    className: PropTypes.string
};
module.exports = Enlarge;
//# sourceMappingURL=Enlarge.js.map

/***/ }),

/***/ 84050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Expand = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-expand'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.expand)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.75 15.25V2h-1.5v13.25H2v1.5h13.25V30h1.5V16.75H30v-1.5H16.75Z", fill: "#fff" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: "#fff", d: "M0 0h32v32H0z" })))));
};
Expand.propTypes = {
    className: PropTypes.string
};
module.exports = Expand;
//# sourceMappingURL=Expand.js.map

/***/ }),

/***/ 67818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Facebook = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-facebook'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.facebook)),
        React.createElement("path", { d: "M11.837 7.423v3.855H9v4.713h2.837V30h5.827V15.991h3.912s.365-2.259.542-4.73h-4.431V8.038c0-.482.635-1.131 1.264-1.131h3.174V2h-4.317c-6.115 0-5.971 4.718-5.971 5.423Z", fill: "#000" })));
};
Facebook.propTypes = {
    className: PropTypes.string
};
module.exports = Facebook;
//# sourceMappingURL=Facebook.js.map

/***/ }),

/***/ 39792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Filmstrip = ({ color = 'black', ...otherProps }) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = otherProps;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-filmstrip-collapsed'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.filmstrip)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.25 2.25h15.5v27.5H2.25V2.25Zm1.5 1.5v24.5h12.5V3.75H3.75Zm20-1.5v27.5h-1.5V2.25h1.5Zm6 27.5V2.25h-1.5v27.5h1.5Z", fill: color })));
};
Filmstrip.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = Filmstrip;
//# sourceMappingURL=Filmstrip.js.map

/***/ }),

/***/ 73137:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Flipboard = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-flipboard'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.flipboard)),
        React.createElement("path", { d: "M2 2v28h28V2H2Zm22.4 11.2h-5.6v5.6h-5.6v5.6H7.6V7.6h16.8v5.6Z", fill: "#000" })));
};
Flipboard.propTypes = {
    className: PropTypes.string
};
module.exports = Flipboard;
//# sourceMappingURL=Flipboard.js.map

/***/ }),

/***/ 96774:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Gallery = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-gallery'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.gallery)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.5 8.5h-18v11H8V11h15.5V8.5ZM25 11V7H4v14h4v4h20V11h-3ZM9.5 12.5h17v11h-17v-11Z", fill: "#000" })));
};
Gallery.propTypes = {
    className: PropTypes.string
};
module.exports = Gallery;
//# sourceMappingURL=Gallery.js.map

/***/ }),

/***/ 15514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const GoogleNews = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-googlenews'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.googlenews)),
        React.createElement("path", { d: "M26.811 26.313a.675.675 0 0 1-.21.485.732.732 0 0 1-.505.202H5.902a.731.731 0 0 1-.505-.202.675.675 0 0 1-.21-.485V11.645c0-.182.076-.356.21-.485a.732.732 0 0 1 .505-.202h20.194c.19 0 .371.073.505.202s.21.303.21.485v14.668Zm-3.537-3.833v-1.34a.088.088 0 0 0-.027-.064.094.094 0 0 0-.066-.027h-6.268v1.527h6.268a.096.096 0 0 0 .087-.058.089.089 0 0 0 .006-.035v-.003Zm.954-2.9v-1.347a.087.087 0 0 0-.027-.064.094.094 0 0 0-.065-.028h-7.223v1.527h7.22a.095.095 0 0 0 .067-.025.087.087 0 0 0 .028-.062v-.005.003Zm-.954-2.901v-1.353a.088.088 0 0 0-.027-.064.094.094 0 0 0-.066-.026h-6.268v1.527h6.268c.024 0 .048-.01.065-.027a.09.09 0 0 0 .028-.062v.005Zm-11.767 1.613v1.374h2.066c-.17.84-.94 1.449-2.066 1.449-1.272-.045-2.265-1.073-2.218-2.296.045-1.159 1.012-2.088 2.218-2.131a2.111 2.111 0 0 1 1.462.55l1.09-1.046a3.747 3.747 0 0 0-2.552-.956c-2.106 0-3.813 1.64-3.813 3.664 0 2.023 1.707 3.664 3.813 3.664 2.204 0 3.655-1.489 3.655-3.585a4.252 4.252 0 0 0-.06-.693l-3.595.006Zm-6.859-7.164c.001-.182.077-.356.21-.485a.733.733 0 0 1 .505-.202h14.18l-1.48-3.913a.675.675 0 0 0-.342-.385.72.72 0 0 0-.526-.044L2.43 11.264a.68.68 0 0 0-.376.36.642.642 0 0 0 0 .508l2.595 6.852v-7.856Zm0 0c.001-.182.077-.356.21-.485a.733.733 0 0 1 .505-.202h14.18l-1.48-3.913a.675.675 0 0 0-.342-.385.72.72 0 0 0-.526-.044L2.43 11.264a.68.68 0 0 0-.376.36.642.642 0 0 0 0 .508l2.595 6.852v-7.856Zm24.864-.348-10.27-2.655.877 2.316h6.514c.19 0 .371.073.505.201.134.13.21.304.21.486v9.859l2.622-9.378a.64.64 0 0 0-.05-.506.686.686 0 0 0-.408-.323Zm-5.245-1.876V5.68a.67.67 0 0 0-.21-.482.727.727 0 0 0-.503-.199H8.444a.737.737 0 0 0-.505.196.684.684 0 0 0-.213.482v3.18l9.789-3.421a.718.718 0 0 1 .527.046.673.673 0 0 1 .339.39l.635 1.68 5.251 1.35Z", fill: "#000" })));
};
GoogleNews.propTypes = {
    className: PropTypes.string
};
module.exports = GoogleNews;
//# sourceMappingURL=GoogleNews.js.map

/***/ }),

/***/ 34890:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Grid = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-grid'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.grid)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 3.5h9v9h-9v-9ZM2 14V2h12v12H2Zm1.5 5.5h9v9h-9v-9ZM2 30V18h12v12H2ZM28.5 3.5h-9v9h9v-9ZM18 2v12h12V2H18Zm1.5 17.5h9v9h-9v-9ZM18 30V18h12v12H18Z", fill: "#000" })));
};
Grid.propTypes = {
    className: PropTypes.string
};
module.exports = Grid;
//# sourceMappingURL=Grid.js.map

/***/ }),

/***/ 77818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.headphoneIconTitle] - Optional prop to show custom title
 */
const Headphone = (props) => {
    const { formatMessage } = useIntl();
    const { headphoneIconTitle, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-headphone'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, headphoneIconTitle || formatMessage(translations.headphone)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 2C8.267 2 2 8.267 2 16v6.387C2 26.544 5.456 30 9.613 30h1.225v-2.198c1.172-.463 1.917-1.607 1.917-2.86v-5.11c0-1.252-.745-2.396-1.917-2.859v-2.199H9.613c-2.03 0-3.816.746-5.162 1.98V16C4.451 9.681 9.681 4.451 16 4.451c6.319 0 11.549 5.23 11.549 11.549v.754c-1.346-1.234-3.133-1.98-5.162-1.98h-1.225v2.199c-1.172.463-1.916 1.607-1.916 2.86v5.109c0 1.253.744 2.397 1.916 2.86V30h1.225C26.544 30 30 26.544 30 22.387V16c0-7.733-6.267-14-14-14Z" })));
};
Headphone.propTypes = {
    className: PropTypes.string,
    headphoneIconTitle: PropTypes.string
};
module.exports = Headphone;
//# sourceMappingURL=Headphone.js.map

/***/ }),

/***/ 83558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Information = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-information'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.information)),
        React.createElement("path", { d: "M14.25 10.313c0-.722.59-1.313 1.313-1.313h.874c.722 0 1.313.59 1.313 1.313v.874c0 .722-.59 1.313-1.313 1.313h-.875c-.721 0-1.312-.59-1.312-1.313v-.874ZM19.5 23h-7v-1.75h1.75V16H12.5v-1.75h5.25v7h1.75V23Z", fill: "#000" }),
        React.createElement("path", { d: "M16 2C8.268 2 2 8.268 2 16s6.268 14 14 14 14-6.268 14-14S23.732 2 16 2Zm0 25.375C9.717 27.375 4.625 22.282 4.625 16 4.625 9.717 9.717 4.625 16 4.625c6.282 0 11.375 5.092 11.375 11.375 0 6.282-5.093 11.375-11.375 11.375Z", fill: "#000" })));
};
Information.propTypes = {
    className: PropTypes.string
};
module.exports = Information;
//# sourceMappingURL=Information.js.map

/***/ }),

/***/ 33528:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Instagram = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-instagram'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.instagram)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 2c3.803 0 4.279.018 5.771.084 1.491.068 2.508.304 3.399.651.92.357 1.703.837 2.48 1.615a6.823 6.823 0 0 1 1.615 2.48c.346.89.583 1.908.651 3.399C29.984 11.72 30 12.197 30 16s-.017 4.279-.084 5.771c-.068 1.491-.305 2.508-.651 3.399a6.862 6.862 0 0 1-1.615 2.48 6.823 6.823 0 0 1-2.48 1.615c-.89.346-1.908.583-3.399.651C20.28 29.984 19.803 30 16 30s-4.279-.017-5.771-.084c-1.491-.068-2.508-.305-3.399-.651a6.863 6.863 0 0 1-2.48-1.615 6.861 6.861 0 0 1-1.615-2.48c-.346-.89-.583-1.908-.651-3.399C2.017 20.28 2 19.803 2 16s.018-4.279.084-5.771c.068-1.491.304-2.508.651-3.399A6.838 6.838 0 0 1 4.35 4.35a6.824 6.824 0 0 1 2.48-1.615c.89-.346 1.908-.583 3.399-.651C11.72 2.017 12.197 2 16 2Zm0 3.5c-3.42 0-3.825.012-5.175.075-1.25.056-1.926.264-2.38.441a3.967 3.967 0 0 0-1.47.957c-.45.449-.728.875-.959 1.474-.175.452-.385 1.129-.44 2.378C5.511 12.175 5.5 12.581 5.5 16c0 3.42.012 3.826.075 5.175.056 1.25.264 1.927.441 2.38.231.596.51 1.023.957 1.47.449.45.875.728 1.474.959.452.175 1.129.385 2.378.44 1.35.064 1.756.076 5.175.076 3.42 0 3.826-.012 5.175-.075 1.25-.056 1.927-.265 2.38-.441a3.933 3.933 0 0 0 1.47-.958 3.93 3.93 0 0 0 .959-1.473c.175-.451.385-1.129.44-2.378.064-1.35.076-1.756.076-5.175 0-3.42-.012-3.825-.075-5.175-.056-1.25-.265-1.926-.441-2.38a3.966 3.966 0 0 0-.958-1.47 3.968 3.968 0 0 0-1.473-.959c-.451-.175-1.129-.385-2.378-.44C19.825 5.511 19.419 5.5 16 5.5Zm0 3.094a7.406 7.406 0 1 1 0 14.813 7.406 7.406 0 0 1 0-14.813Zm0 11.55a4.144 4.144 0 1 0 0-8.289 4.144 4.144 0 0 0 0 8.289Zm9.275-11.406a2.013 2.013 0 1 1-4.025 0 2.013 2.013 0 0 1 4.025 0Z", fill: "black" })));
};
Instagram.propTypes = {
    className: PropTypes.string
};
module.exports = Instagram;
//# sourceMappingURL=Instagram.js.map

/***/ }),

/***/ 708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LargeChevron = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-large-chevron'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.largechevron)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m1.47 10.53 1.06-1.06L16 22.94 29.47 9.47l1.06 1.06L16 25.06 1.47 10.53Z", fill: "#000" })));
};
LargeChevron.propTypes = {
    className: PropTypes.string
};
module.exports = LargeChevron;
//# sourceMappingURL=LargeChevron.js.map

/***/ }),

/***/ 47424:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const LeftChevron = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-left_chevron'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevron)),
        React.createElement("path", { d: "M11 15L4 8L11 1", stroke: "black", strokeWidth: "1.5" })));
};
LeftChevron.propTypes = {
    className: PropTypes.string
};
module.exports = LeftChevron;
//# sourceMappingURL=LeftChevron.js.map

/***/ }),

/***/ 36737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Like = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-like'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.like)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m14.94 8.423 1.072-1.048L17.1 8.408l-1.073 1.13-1.088-1.115Zm2.097-2.146c-.657.711-1.025 1.098-1.025 1.098s-.376-.385-1.03-1.093c-.352-.38-.784-.852-1.282-1.408C12.542 3.806 11.161 3 9.712 3 5.452 3 2 6.604 2 11.043A8.249 8.249 0 0 0 3.356 15.6c.882 1.337 4.74 5.448 11.597 12.337L16.013 29l1.057-1.064c6.834-6.887 10.69-10.998 11.574-12.335A8.25 8.25 0 0 0 30 11.043C30 6.602 26.547 3 22.288 3c-1.45 0-2.906.708-3.966 1.874-.503.553-.935 1.024-1.285 1.403Zm10.355 8.498c-.378.572-1.56 1.938-3.693 4.2-1.889 2.004-4.45 4.636-7.688 7.899-3.249-3.264-5.816-5.896-7.709-7.9-2.134-2.26-3.316-3.626-3.693-4.197A6.749 6.749 0 0 1 3.5 11.048v-.005C3.5 7.372 6.34 4.5 9.712 4.5c.886 0 1.897.5 2.92 1.43a106.778 106.778 0 0 0 2.136 2.316l.125.13.034.034.012.013 1.073-1.048L17.1 8.408l.042-.045.12-.127.46-.492c.401-.43.982-1.06 1.71-1.862.818-.899 1.888-1.382 2.856-1.382 3.372 0 6.212 2.87 6.212 6.543a6.752 6.752 0 0 1-1.108 3.732Z", fill: "#000" })));
};
Like.propTypes = {
    className: PropTypes.string
};
module.exports = Like;
//# sourceMappingURL=Like.js.map

/***/ }),

/***/ 68165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LikeFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-like-filled'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.likeFilled)),
        React.createElement("path", { d: "M29.25 11.12a7.637 7.637 0 0 1-1.234 4.192c-.421.644-1.655 2.074-3.773 4.343-1.998 2.14-4.74 4.981-8.232 8.527-3.502-3.546-6.25-6.388-8.252-8.527-2.12-2.268-3.354-3.699-3.774-4.342a7.636 7.636 0 0 1-1.235-4.19v-.003c0-4.105 3.153-7.37 6.962-7.37 1.163 0 2.358.656 3.451 1.666.665.756 1.21 1.547 1.592 2.156a17.166 17.166 0 0 1 .581 1.003l.006.012.001.002.679 1.338.663-1.345V8.58l.007-.012a15.656 15.656 0 0 1 .57-.998c.381-.615.933-1.415 1.618-2.177.939-1.043 2.202-1.643 3.408-1.643 3.809 0 6.962 3.264 6.962 7.37Z", fill: "#000", stroke: "#000", strokeWidth: "1.5" })));
};
LikeFilled.propTypes = {
    className: PropTypes.string
};
module.exports = LikeFilled;
//# sourceMappingURL=LikeFilled.js.map

/***/ }),

/***/ 80636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Line = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-line'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.line)),
        React.createElement("path", { d: "M30 14.36C30 8.098 23.72 3 16 3 8.281 3 2 8.097 2 14.36c0 5.617 4.98 10.321 11.708 11.21.456.099 1.076.301 1.233.69.141.355.093.909.046 1.266l-.2 1.199c-.06.354-.28 1.384 1.213.755 1.495-.63 8.062-4.748 11-8.129 2.029-2.224 3-4.482 3-6.99Zm-18.94 3.346c0 .15-.122.272-.272.272H6.865a.27.27 0 0 1-.272-.271v-6.1c0-.151.122-.273.272-.273h.982c.15 0 .272.122.272.272v4.845h2.669c.15 0 .272.122.272.273v.982Zm2.368 0c0 .151-.122.273-.273.273h-.981a.273.273 0 0 1-.273-.272v-6.1c0-.151.122-.273.273-.273h.982c.15 0 .272.122.272.272v6.1Zm6.759 0c0 .151-.122.273-.273.273h-.982a.28.28 0 0 1-.224-.114l-2.799-3.78v3.623c0 .15-.122.272-.273.272h-.982a.272.272 0 0 1-.272-.272v-6.102c0-.15.122-.272.272-.272h.982a.26.26 0 0 1 .225.122l2.795 3.775v-3.625c0-.15.122-.272.273-.272h.982c.15 0 .272.122.272.272l.004 6.1Zm5.423-5.117c0 .15-.122.272-.273.272H22.67v1.032h2.668c.15 0 .273.122.273.273v.982c0 .15-.122.272-.273.272H22.67v1.031h2.668c.15 0 .273.122.273.273v.982c0 .15-.122.272-.273.272h-3.922a.277.277 0 0 1-.273-.272v-6.099c0-.148.125-.272.273-.272h3.922c.15 0 .273.122.273.273v.981Z", fill: "#000" })));
};
Line.propTypes = {
    className: PropTypes.string
};
module.exports = Line;
//# sourceMappingURL=Line.js.map

/***/ }),

/***/ 41876:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LinkedIn = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-linkedin'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.linkedIn)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M30 29.921h-5.783v-9.053c0-2.16-.04-4.936-3.005-4.936-3.011 0-3.472 2.353-3.472 4.78v9.21h-5.783V11.305h5.552v2.542h.075c.774-1.463 2.66-3.007 5.476-3.007 5.86 0 6.94 3.857 6.94 8.868v10.212ZM5.438 8.711a3.356 3.356 0 1 1-.164-6.71 3.356 3.356 0 0 1 .164 6.71ZM2.54 29.921h5.788V11.306H2.54V29.92Z", fill: "#000" })));
};
LinkedIn.propTypes = {
    className: PropTypes.string
};
module.exports = LinkedIn;
//# sourceMappingURL=LinkedIn.js.map

/***/ }),

/***/ 49498:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const List = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-list'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.list)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M30 5.25H6v1.5h24v-1.5Zm0 10H6v1.5h24v-1.5Zm-28 0h2v1.5H2v-1.5Zm2-10H2v1.5h2v-1.5Zm2 20h24v1.5H6v-1.5Zm-2 0H2v1.5h2v-1.5Z", fill: "#000" })));
};
List.propTypes = {
    className: PropTypes.string
};
module.exports = List;
//# sourceMappingURL=List.js.map

/***/ }),

/***/ 79301:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Loader = (props) => {
    const { formatMessage } = useIntl();
    const { className } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-loader'), width: "32", height: "32", viewBox: "0 0 36 36", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("title", null, formatMessage(translations.loader)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.2984 12.6411C20.4141 9.82282 15.7913 9.87628 12.9731 12.7605L12.0648 11.873C15.3732 8.48721 20.8 8.42444 24.1858 11.7329C27.5717 15.0413 27.6344 20.468 24.326 23.8539L23.4178 22.9664C26.2361 20.0822 26.1826 15.4594 23.2984 12.6411Z", fill: "url(#paint0_linear_503_154)" }),
        React.createElement("defs", null,
            React.createElement("linearGradient", { id: "paint0_linear_503_154", x1: "24.5143", y1: "22.6285", x2: "23.8286", y2: "23.4857", gradientUnits: "userSpaceOnUse" },
                React.createElement("stop", null),
                React.createElement("stop", { offset: "1", stopOpacity: "0" }))),
        React.createElement("animateTransform", { attributeName: "transform", attributeType: "XML", type: "rotate", dur: "1s", from: "0 0 0", to: "360 0 0", repeatCount: "indefinite" })));
};
Loader.propTypes = {
    className: PropTypes.string
};
module.exports = Loader;
//# sourceMappingURL=Loader.js.map

/***/ }),

/***/ 60836:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Maximize = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-maximize'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.maximize)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2.25H2.25V12h1.5V3.75H12v-1.5Zm8 26h8.25V20h1.5v9.75H20v-1.5Zm8.25-24.5V12h1.5V2.25H20v1.5h8.25ZM3.75 20v8.25H12v1.5H2.25V20h1.5Z", fill: "#000" })));
};
Maximize.propTypes = {
    className: PropTypes.string
};
module.exports = Maximize;
//# sourceMappingURL=Maximize.js.map

/***/ }),

/***/ 88845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Menu = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-menu'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.menu)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 5.25h28v1.5H2v-1.5Zm0 10h28v1.5H2v-1.5Zm28 10H2v1.5h28v-1.5Z", fill: "#000" })));
};
Menu.propTypes = {
    className: PropTypes.string
};
module.exports = Menu;
//# sourceMappingURL=Menu.js.map

/***/ }),

/***/ 90906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * Native share icon.
 *
 * @param {string}  [className] - classes for svg
 * @param {func}    [onIconClick] - onClick hadler
 * @returns {ReactElement} child components
 */
const NativeShare = ({ className = '', onIconClick = () => { }, onKeyDown = () => { }, tabIndex = '-1' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: `icon ${className}`, viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", focusable: "false", onClick: onIconClick, onKeyDown: onKeyDown, tabIndex: tabIndex },
        React.createElement("title", null, formatMessage(translations.nativeShare)),
        React.createElement("path", { d: "M24.834 10.4c.857 0 1.694-.267 2.395-.764a4.196 4.196 0 0 0 1.525-2.013c.29-.814.325-1.698.098-2.531a4.204 4.204 0 0 0-1.363-2.128 4.14 4.14 0 0 0-4.777-.379 4.188 4.188 0 0 0-1.676 1.886 4.23 4.23 0 0 0-.296 2.516l-9.88 5.807a4.137 4.137 0 0 0-4.445-.606 4.176 4.176 0 0 0-1.76 1.55 4.224 4.224 0 0 0 0 4.521 4.177 4.177 0 0 0 1.76 1.55 4.137 4.137 0 0 0 4.445-.606l9.88 5.81a4.229 4.229 0 0 0 .46 2.844 4.176 4.176 0 0 0 2.172 1.876c.92.348 1.933.356 2.859.024a4.174 4.174 0 0 0 2.2-1.84 4.228 4.228 0 0 0-.92-5.334 4.147 4.147 0 0 0-2.687-.983 4.147 4.147 0 0 0-2.684.995l-9.879-5.81a4.257 4.257 0 0 0 0-1.573l9.878-5.806a4.144 4.144 0 0 0 2.695.994Z", fill: "#000" })));
};
NativeShare.propTypes = {
    className: PropTypes.string,
    onIconClick: PropTypes.func,
    onKeyDown: PropTypes.func,
    tabIndex: PropTypes.string
};
module.exports = NativeShare;
//# sourceMappingURL=NativeShare.js.map

/***/ }),

/***/ 86173:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Newsletter = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-newsletter'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.newsletter)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M28.75 3.25H3.25v10h-1v16.5h27.5v-16.5h-1v-10ZM27.94 16h.31v12.25H3.75V16h.311L16 27.02 27.94 16Zm-.69-1.405V4.75H4.75v9.845L16 24.979l11.25-10.384ZM22 10.75H10v-1.5h12v1.5Zm-12 6h12v-1.5H10v1.5Z", fill: "#000" })));
};
Newsletter.propTypes = {
    className: PropTypes.string
};
module.exports = Newsletter;
//# sourceMappingURL=Newsletter.js.map

/***/ }),

/***/ 21516:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const NewsletterArrow = (props) => {
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-newsletter icon-newsletter-arrow'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("g", null,
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m25.954 21.11-2 1.972H10.656v-3.946h8.658L5.5 4.71 8.408 2l13.546 14.147v-8.21h4v13.172ZM2 29h28v-1H2v1Z", fill: "#000" }))));
};
NewsletterArrow.propTypes = {
    className: PropTypes.string
};
module.exports = NewsletterArrow;
//# sourceMappingURL=NewsletterArrow.js.map

/***/ }),

/***/ 56148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const OK = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-ok'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ok)),
        React.createElement("path", { d: "M23.336 9.227c0 3.984-3.241 7.224-7.227 7.224-3.985 0-7.226-3.24-7.226-7.224C8.883 5.242 12.124 2 16.109 2c3.986 0 7.226 3.241 7.227 7.227Zm-4.235 0a2.995 2.995 0 0 0-2.992-2.992 2.995 2.995 0 0 0-2.99 2.992 2.995 2.995 0 0 0 2.99 2.991 2.995 2.995 0 0 0 2.992-2.99Zm-.068 13.118 4.038 4.041a2.114 2.114 0 0 1 0 2.994l-.001.002a2.114 2.114 0 0 1-2.99-.002l-3.972-3.97-3.968 3.97a2.118 2.118 0 0 1-2.995-2.994l4.04-4.04a13.538 13.538 0 0 1-4.196-1.738 2.117 2.117 0 0 1-.663-2.92l.001-.003a2.115 2.115 0 0 1 2.918-.662 9.177 9.177 0 0 0 9.73-.001 2.116 2.116 0 0 1 2.253 3.586 13.527 13.527 0 0 1-4.195 1.737Z", fill: "black", fillRule: "evenodd", clipRule: "evenodd" })));
};
OK.propTypes = {
    className: PropTypes.string
};
module.exports = OK;
//# sourceMappingURL=OK.js.map

/***/ }),

/***/ 87468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Share = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-paperclip'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.share)),
        React.createElement("g", { clipPath: "url(#clip0_80_170)" },
            React.createElement("path", { d: "M6.28 16C6.28 13.948 7.948 12.28 10 12.28H14.8V10H10C6.688 10 4 12.688 4 16C4 19.312 6.688 22 10 22H14.8V19.72H10C7.948 19.72 6.28 18.052 6.28 16ZM11.2 17.2H20.8V14.8H11.2V17.2ZM22 10H17.2V12.28H22C24.052 12.28 25.72 13.948 25.72 16C25.72 18.052 24.052 19.72 22 19.72H17.2V22H22C25.312 22 28 19.312 28 16C28 12.688 25.312 10 22 10Z", fill: "black" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "clip0_80_170" },
                React.createElement("rect", { width: "24", height: "12", fill: "white", transform: "translate(4 10)" })))));
};
Share.propTypes = {
    className: PropTypes.string
};
module.exports = Share;
//# sourceMappingURL=Paperclip.js.map

/***/ }),

/***/ 87444:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Passkey = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-passkey'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.passkey)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.219 17.252s.009 2.201.922 3.195c.977 1.062 1.977 1.318 1.977 1.318v5.27H2v-3.294c0-4.38 8.779-6.588 13.177-6.588.527 0 1.4.033 2.042.099Zm4.546-8.664a6.586 6.586 0 0 1-6.588 6.589 6.586 6.586 0 0 1-6.589-6.589A6.586 6.586 0 0 1 15.177 2a6.586 6.586 0 0 1 6.588 6.588Zm3.678 3.953c-2.564.03-4.636 2.048-4.666 4.538a4.318 4.318 0 0 0 2.83 4.134l-.08 6.679c-.003.2.059.37.212.513l1.208 1.148a.47.47 0 0 0 .636-.014l2.25-2.192c.2-.202.197-.477.008-.667l-1.27-1.223 1.822-1.782a.445.445 0 0 0-.006-.653l-1.73-1.7c2.129-.897 3.32-2.485 3.343-4.35.03-2.482-2.001-4.46-4.557-4.43Zm1.922 4.612a1.976 1.976 0 1 1-3.953 0 1.976 1.976 0 0 1 3.953 0Z", fill: "#000" })));
};
Passkey.propTypes = {
    className: PropTypes.string
};
module.exports = Passkey;
//# sourceMappingURL=Passkey.js.map

/***/ }),

/***/ 87574:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Pause = (props) => {
    const { formatMessage } = useIntl();
    const { className, title, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-pause'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.pause)),
        React.createElement("g", { fillRule: "nonzero" },
            React.createElement("path", { fill: "#000", d: "M11 10h3v12h-3zM18 10h3v12h-3z" }))));
};
Pause.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = Pause;
//# sourceMappingURL=Pause.js.map

/***/ }),

/***/ 42710:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const PhotoStack = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-photoStack'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.photoStack)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.25 2.25h19.5v19.5H2.25V2.25Zm1.5 1.5v16.5h16.5V3.75H3.75Z", fill: "#0879BF" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M25.75 3v22.75H3v-1.5h21.25V3h1.5Z", fill: "#0879BF" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M29.75 8v21.75H8v-1.5h20.25V8h1.5Z", fill: "#0879BF" })));
};
PhotoStack.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = PhotoStack;
//# sourceMappingURL=PhotoStack.js.map

/***/ }),

/***/ 80890:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Pinterest = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-pinterest'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.pinterest)),
        React.createElement("path", { d: "M14.045 20.284c-.658 2.879-1.302 5.652-2.706 7.84-.43.67-.862 1.514-1.597 1.876-1.085-5.588 1.184-10.29 2.08-14.987-1.142-2.333-.432-6.283 2.017-6.73 3.545-.648 2.61 3.629 2.01 5.617-.332 1.092-.925 2.137-.836 3.334.198 2.521 3.37 2.686 4.996 1.386 2.331-1.857 3.007-5.446 2.777-8.395-.344-4.489-5.428-6.72-9.919-4.926-2.315.924-4.415 3.05-4.72 6.174-.157 1.645.188 2.959.835 3.886.097.142.433.39.483.767.102.76-.35 1.578-.763 2.145-2.3-.661-3.486-2.724-3.675-5.337C4.59 6.984 9.476 2.462 15.221 2.038c6.137-.45 10.999 3.093 11.45 8.257.336 3.838-1.027 7.7-3.19 9.78-1.627 1.562-5.084 3.093-7.91 1.599-.625-.333-.905-.739-1.526-1.39Z", fill: "black" })));
};
Pinterest.propTypes = {
    className: PropTypes.string
};
module.exports = Pinterest;
//# sourceMappingURL=Pinterest.js.map

/***/ }),

/***/ 11936:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Play = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-play'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.play)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m6 2 24 14L6 30V2Z" })));
};
Play.propTypes = {
    className: PropTypes.string
};
module.exports = Play;
//# sourceMappingURL=Play.js.map

/***/ }),

/***/ 23150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const { PlayCNEWrapper } = __webpack_require__(60132);
const PlayCNE = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement(PlayCNEWrapper, { className: classnames(className, 'icon icon-playcne'), focusable: "false", viewBox: "0 0 54 54", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playCNE)),
        React.createElement("circle", { cx: "27", cy: "27", r: "25" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M38 27.0185L22 36.0866V18.0393L38 27.0185Z" })));
};
PlayCNE.propTypes = {
    className: PropTypes.string
};
module.exports = PlayCNE;
//# sourceMappingURL=PlayCNE.js.map

/***/ }),

/***/ 3330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const PlayOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-play-outlined'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playOutlined)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 2v28l24-14L6 2Zm1.5 2.612v22.776L27.023 16 7.5 4.612Z" })));
};
PlayOutlined.propTypes = {
    className: PropTypes.string
};
module.exports = PlayOutlined;
//# sourceMappingURL=PlayOutlined.js.map

/***/ }),

/***/ 54280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const PlaylistIcon = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-playlist'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playlist)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M24 4.25H2v1.5h22v-1.5Zm0 8H2v1.5h22v-1.5Zm-22 8h15v1.5H2v-1.5ZM30 23l-10-6v12l10-6Z", fill: "#000" })));
};
PlaylistIcon.propTypes = {
    className: PropTypes.string
};
module.exports = PlaylistIcon;
//# sourceMappingURL=Playlist.js.map

/***/ }),

/***/ 7967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Print = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-print'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.print)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.25 2.25h15.5v7h6v14.5h-6v6H8.25v-6h-6V9.25h6v-7Zm0 20v-3h15.5v3h4.5v-11.5H3.75v11.5h4.5Zm14-18.5v5.5H9.75v-5.5h12.5Zm-12.5 24.5v-7.5h12.5v7.5H9.75Z", fill: "#000" })));
};
Print.propTypes = {
    className: PropTypes.string
};
module.exports = Print;
//# sourceMappingURL=Print.js.map

/***/ }),

/***/ 97195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const { PrivacyOTIconWrapper } = __webpack_require__(60132);
const PrivacyOT = (props) => {
    const { className, ...attrs } = props;
    return (React.createElement(PrivacyOTIconWrapper, { className: classnames(className, 'icon icon-privacyOT'), focusable: "false", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 14", width: "32", height: "9.5", ...attrs },
        React.createElement("g", null,
            React.createElement("g", { id: "final---dec.11-2020_1_" },
                React.createElement("g", { id: "_x30_208-our-toggle_2_", transform: "translate(-1275.000000, -200.000000)" },
                    React.createElement("g", { id: "Final-Copy-2_2_", transform: "translate(1275.000000, 200.000000)" },
                        React.createElement("path", { className: "st0", d: "M7.4,12.8h6.8l3.1-11.6H7.4C4.2,1.2,1.6,3.8,1.6,7S4.2,12.8,7.4,12.8z" })))),
            React.createElement("g", { id: "final---dec.11-2020" },
                React.createElement("g", { id: "_x30_208-our-toggle", transform: "translate(-1275.000000, -200.000000)" },
                    React.createElement("g", { id: "Final-Copy-2", transform: "translate(1275.000000, 200.000000)" },
                        React.createElement("path", { className: "st1", d: "M22.6,0H7.4c-3.9,0-7,3.1-7,7s3.1,7,7,7h15.2c3.9,0,7-3.1,7-7S26.4,0,22.6,0z M1.6,7c0-3.2,2.6-5.8,5.8-5.8\n                h9.9l-3.1,11.6H7.4C4.2,12.8,1.6,10.2,1.6,7z" }),
                        React.createElement("path", { id: "x", className: "st2", d: "M24.6,4c0.2,0.2,0.2,0.6,0,0.8l0,0L22.5,7l2.2,2.2c0.2,0.2,0.2,0.6,0,0.8c-0.2,0.2-0.6,0.2-0.8,0\n                l0,0l-2.2-2.2L19.5,10c-0.2,0.2-0.6,0.2-0.8,0c-0.2-0.2-0.2-0.6,0-0.8l0,0L20.8,7l-2.2-2.2c-0.2-0.2-0.2-0.6,0-0.8\n                c0.2-0.2,0.6-0.2,0.8,0l0,0l2.2,2.2L23.8,4C24,3.8,24.4,3.8,24.6,4z" }),
                        React.createElement("path", { id: "y", className: "st3", d: "M12.7,4.1c0.2,0.2,0.3,0.6,0.1,0.8l0,0L8.6,9.8C8.5,9.9,8.4,10,8.3,10c-0.2,0.1-0.5,0.1-0.7-0.1l0,0\n                L5.4,7.7c-0.2-0.2-0.2-0.6,0-0.8c0.2-0.2,0.6-0.2,0.8,0l0,0L8,8.6l3.8-4.5C12,3.9,12.4,3.9,12.7,4.1z" })))))));
};
PrivacyOT.propTypes = {
    className: PropTypes.string
};
module.exports = PrivacyOT;
//# sourceMappingURL=PrivacyOT.js.map

/***/ }),

/***/ 45191:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-rating-filled', className), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ratingFilled)),
        React.createElement("path", { d: "M16 25.145 7.347 30l1.718-10.154L2 12.694l9.714-1.417L16 2l4.285 9.275L30 12.695l-7.065 7.151L24.653 30 16 25.145Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
RatingFilled.propTypes = {
    className: PropTypes.string
};
module.exports = RatingFilled;
//# sourceMappingURL=RatingFilled.js.map

/***/ }),

/***/ 45530:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingHalf = (props) => {
    const { formatMessage } = useIntl();
    const { className, showTitle = true, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-rating-half', className), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        showTitle ? (React.createElement("title", null, formatMessage(translations.ratingHalf))) : null,
        React.createElement("path", { fill: primaryFill, d: "M9.578 18.783a1.103 1.103 0 0 1 .368 1.207l-2.818 9.17a.647.647 0 0 0 .385.805.578.578 0 0 0 .56-.087l7.315-5.618c.176-.134.391-.207.613-.21V2a.63.63 0 0 0-.543.438l-2.817 8.855a1.033 1.033 0 0 1-.963.735H2.613a.613.613 0 0 0-.612.63.595.595 0 0 0 .245.507l7.332 5.618Z" }),
        React.createElement("path", { fill: secondaryFill, d: "m16.613 24.26 7.315 5.618a.596.596 0 0 0 .857-.14.718.718 0 0 0 .088-.578l-2.818-9.17a1.103 1.103 0 0 1 .368-1.207l7.333-5.618a.648.648 0 0 0-.083-1.074.56.56 0 0 0-.267-.063h-9.03a1.033 1.033 0 0 1-.98-.735l-2.818-8.855A.578.578 0 0 0 16 2v22.05c.222.003.437.076.613.21Z" })));
};
RatingHalf.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string,
    showTitle: PropTypes.bool
};
module.exports = RatingHalf;
//# sourceMappingURL=RatingHalf.js.map

/***/ }),

/***/ 64577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-rating-outlined', className), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ratingOutlined)),
        React.createElement("path", { d: "m16 23.425 6.65 3.732-1.322-7.818 5.52-5.59-7.583-1.107L16 5.576l-3.265 7.068-7.583 1.106 5.52 5.589-1.322 7.818L16 23.425ZM7.347 30l1.718-10.154L2 12.694l9.714-1.417L16 2l4.285 9.275L30 12.695l-7.065 7.151L24.653 30 16 25.145 7.347 30Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
RatingOutlined.propTypes = {
    className: PropTypes.string
};
module.exports = RatingOutlined;
//# sourceMappingURL=RatingOutlined.js.map

/***/ }),

/***/ 3653:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Replay = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-replay'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.replay)),
        React.createElement("path", { d: "M8.163 15.938C8.438 10.222 12.867 5.75 18.2 5.75c5.507 0 10.05 4.768 10.05 10.75S23.707 27.25 18.2 27.25c-2.723 0-5.2-1.158-7.017-3.055L10.1 25.233c2.078 2.169 4.937 3.517 8.1 3.517 6.422 0 11.55-5.53 11.55-12.25S24.622 4.25 18.2 4.25c-5.998 0-10.866 4.822-11.484 10.934l-3.059-4.83-1.253.792 4.7 7.42 6.97-5.005-.884-1.234-5.027 3.61Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Replay.propTypes = {
    className: PropTypes.string
};
module.exports = Replay;
//# sourceMappingURL=Replay.js.map

/***/ }),

/***/ 43018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const Review = () => {
    return (React.createElement("svg", { width: "49", height: "49", viewBox: "0 0 49 49", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("path", { d: "M0 0L49 49V0H0Z", fill: "white" }),
        React.createElement("path", { d: "M34.9218 1.08956L38.7694 4.85116L27.4952 16.136L33.0428 21.6888L44.317 10.404L48.075 14.2552V1L34.9218 1.08956Z", fill: "#FF3530" }),
        React.createElement("path", { d: "M34.9221 23.6589L47.9858 36.8245V23.6589H34.9221Z", fill: "#FF3530" }),
        React.createElement("path", { d: "M12.2842 1L25.4374 14.1656L25.3479 1H12.2842Z", fill: "#FF3530" })));
};
module.exports = Review;
//# sourceMappingURL=Review.js.map

/***/ }),

/***/ 94416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Rss = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-rss'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.rss)),
        React.createElement("path", { d: "M5.85 22.3c2.1 0 3.5 1.75 3.85 3.85 0 2.1-1.75 3.85-3.85 3.85S2 28.25 2 26.15s1.75-3.85 3.85-3.85Zm-3.5-10.85c10.15 0 18.2 8.05 18.2 18.2V30H15.3v-.35c0-7-5.6-12.95-12.95-12.95H2l.35-5.25Zm0-9.45C17.4 2 30 14.25 30 29.65V30h-5.25v-.35c0-12.25-10.15-22.4-22.4-22.4H2L2.35 2Z" })));
};
Rss.propTypes = {
    className: PropTypes.string
};
module.exports = Rss;
//# sourceMappingURL=Rss.js.map

/***/ }),

/***/ 90506:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Search = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-search'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", "data-testid": "iconSearch", ...attrs },
        React.createElement("title", null, formatMessage(translations.search)),
        React.createElement("path", { d: "M24.5 14c0 5.799-4.701 10.5-10.5 10.5S3.5 19.799 3.5 14 8.201 3.5 14 3.5 24.5 8.201 24.5 14Zm1.5 0c0 6.627-5.373 12-12 12S2 20.627 2 14 7.373 2 14 2s12 5.373 12 12Zm-3.997 9.064 6.467 6.466 1.06-1.06-6.466-6.467-1.06 1.06Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Search.propTypes = {
    className: PropTypes.string
};
module.exports = Search;
//# sourceMappingURL=Search.js.map

/***/ }),

/***/ 16119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Share = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-share'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.share)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.53 8.47 16 1.94 9.47 8.47l1.06 1.06 4.72-4.72V22h1.5V4.81l4.72 4.72 1.06-1.06ZM5.25 12.25h7.114v1.5H6.75v14.5h18.5v-14.5h-5.614v-1.5h7.114v17.5H5.25v-17.5Z", fill: "#000" })));
};
Share.propTypes = {
    className: PropTypes.string
};
module.exports = Share;
//# sourceMappingURL=Share.js.map

/***/ }),

/***/ 10934:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Shopping = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-shopping'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.shopping)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.75 9a4.25 4.25 0 0 1 8.5 0h-8.5Zm-1.5 0a5.75 5.75 0 0 1 11.5 0H30v20H2V9h8.25ZM3.5 27.5v-17h25v17h-25Z", fill: "#000" })));
};
Shopping.propTypes = {
    className: PropTypes.string
};
module.exports = Shopping;
//# sourceMappingURL=Shopping.js.map

/***/ }),

/***/ 28153:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const SlimHeadphone = (props) => {
    const { formatMessage } = useIntl();
    const { className, title, ...attrs } = props;
    return (React.createElement("svg", { className: `icon ${className}`, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", focusable: "false", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.headphone)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M29.314 21.708v-6.445C29.314 7.938 23.376 2 16.05 2S2.787 7.938 2.787 15.263V23.5h.002a6.633 6.633 0 0 0 5.867 6.456l.026.003a6.714 6.714 0 0 0 1.474 0v-1.684a4.423 4.423 0 0 0 2.947-4.17v-1.474a4.423 4.423 0 0 0-2.947-4.169v-1.685a6.689 6.689 0 0 0-1.474 0l-.026.003A6.622 6.622 0 0 0 4.26 19.2v-3.937c0-6.511 5.278-11.79 11.79-11.79 6.51 0 11.79 5.279 11.79 11.79V19.2a6.622 6.622 0 0 0-4.396-2.42l-.026-.003a6.714 6.714 0 0 0-1.474 0v1.685a4.423 4.423 0 0 0-2.947 4.17v1.473a4.423 4.423 0 0 0 2.947 4.17v1.684a6.688 6.688 0 0 0 1.474 0l.026-.002a6.633 6.633 0 0 0 5.869-6.557V21.708ZM8.656 28.444a5.133 5.133 0 0 1 0-10.15v10.15Zm19.158-5.076a5.133 5.133 0 0 0-4.369-5.075v10.15a5.133 5.133 0 0 0 4.369-5.075Z", fill: "#000" })));
};
SlimHeadphone.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = SlimHeadphone;
//# sourceMappingURL=SlimHeadphone.js.map

/***/ }),

/***/ 10312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Snapchat = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-snapchat'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.snapchat)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.27 3h-.07l-.484.005c-1.155 0-5.07.321-6.916 4.462-.622 1.393-.474 3.76-.353 5.66l.042.682a1.116 1.116 0 0 1-.544.12c-.368 0-.802-.116-1.29-.346a1.039 1.039 0 0 0-.443-.09c-.57 0-1.255.376-1.36.936-.077.403.103.991 1.4 1.503.118.048.258.092.407.139.535.17 1.346.426 1.565.944.114.268.069.614-.135 1.026l-.012.028c-.072.167-1.786 4.073-5.592 4.7a.58.58 0 0 0-.484.606.72.72 0 0 0 .061.26c.286.666 1.492 1.157 3.685 1.498.072.098.149.449.194.661.048.21.093.428.162.658.067.225.237.495.679.495.179 0 .39-.042.631-.09.367-.07.867-.17 1.494-.17.347 0 .707.032 1.07.092.707.117 1.309.544 2.005 1.035.998.705 2.127 1.503 3.843 1.503.049 0 .096 0 .143-.005.055.004.127.005.204.005 1.72 0 2.847-.798 3.842-1.503.7-.491 1.3-.918 2.01-1.035a6.59 6.59 0 0 1 1.07-.092c.596 0 1.07.078 1.49.158.264.053.478.08.632.08h.034a.632.632 0 0 0 .647-.485 10.6 10.6 0 0 0 .16-.65c.045-.213.123-.56.194-.66 2.195-.341 3.4-.829 3.685-1.494a.774.774 0 0 0 .063-.263.579.579 0 0 0-.486-.605c-3.807-.627-5.52-4.534-5.59-4.699a.432.432 0 0 0-.014-.028c-.203-.412-.247-.758-.133-1.026.22-.518 1.028-.774 1.565-.944.149-.047.29-.093.405-.139.95-.373 1.427-.835 1.416-1.368-.009-.418-.333-.79-.853-.976h-.001a1.558 1.558 0 0 0-.585-.114 1.291 1.291 0 0 0-.535.11c-.452.211-.858.327-1.207.341a1.071 1.071 0 0 1-.47-.116l.035-.6.005-.08c.121-1.902.27-4.27-.35-5.664C21.35 3.323 17.425 3 16.267 3h.002Z", fill: "black" })));
};
Snapchat.propTypes = {
    className: PropTypes.string
};
module.exports = Snapchat;
//# sourceMappingURL=Snapchat.js.map

/***/ }),

/***/ 7507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const SocialHandle = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-socialHandle'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.socialHandle)),
        React.createElement("path", { d: "M20.788 8.92h3.285L21.85 16.7c-.174.632-.302 1.105-.383 1.415-.07.299-.104.562-.104.789 0 .358.116.7.348 1.022.231.31.602.466 1.112.466.996 0 1.993-.67 2.99-2.008 1.007-1.35 1.511-3.137 1.511-5.36 0-3.286-1.367-5.646-4.102-7.08-1.714-.909-3.643-1.363-5.787-1.363-3.94 0-7.103 1.243-9.49 3.729-2.155 2.247-3.233 4.941-3.233 8.085 0 3.489 1.263 6.256 3.79 8.299 2.236 1.804 4.964 2.707 8.185 2.707 2.202 0 4.259-.418 6.17-1.255 1.043-.442 2.121-1.07 3.233-1.882l.418-.305 1.268 2.008a18.673 18.673 0 0 1-5.353 3.011A17.629 17.629 0 0 1 16.461 30c-4.809 0-8.534-1.542-11.176-4.625C3.095 22.818 2 19.788 2 16.287c0-3.92 1.367-7.242 4.102-9.967C8.975 3.44 12.654 2 17.138 2c3.65 0 6.674.986 9.073 2.958C28.737 7.038 30 9.798 30 13.239c0 2.713-.8 5.043-2.399 6.991-1.598 1.936-3.423 2.904-5.474 2.904-1.066 0-1.889-.31-2.468-.932-.568-.621-.852-1.26-.852-1.918v-.269l.035-.34c-.44.86-.933 1.547-1.478 2.061-.985.92-2.166 1.38-3.545 1.38-1.402 0-2.573-.52-3.511-1.56-.927-1.039-1.39-2.49-1.39-4.355 0-2.163.712-4.189 2.137-6.077s3.175-2.832 5.25-2.832c1.216 0 2.16.346 2.832 1.04.51.537.852 1.153 1.026 1.846l.625-2.259Zm-7.49 10.755c.382.538.926.806 1.633.806 1.24 0 2.254-.968 3.042-2.904.8-1.948 1.199-3.477 1.199-4.589 0-.633-.186-1.165-.556-1.595-.371-.43-.87-.645-1.495-.645-1.205 0-2.242.777-3.111 2.33-.87 1.542-1.304 3.036-1.304 4.482 0 .872.197 1.577.591 2.115Z", fill: "#000" })));
};
SocialHandle.propTypes = {
    className: PropTypes.string
};
module.exports = SocialHandle;
//# sourceMappingURL=SocialHandle.js.map

/***/ }),

/***/ 84502:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Spotify = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-spotify'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.spotify)),
        React.createElement("path", { d: "M24.281 14.411c-4.511-2.68-11.956-2.926-16.264-1.619a1.309 1.309 0 1 1-.76-2.506c4.946-1.501 13.165-1.21 18.361 1.873a1.309 1.309 0 1 1-1.337 2.252Zm-.147 3.969a1.092 1.092 0 0 1-1.502.36c-3.762-2.313-9.499-2.983-13.95-1.63a1.094 1.094 0 0 1-.634-2.09c5.084-1.543 11.405-.796 15.727 1.86.513.315.674.989.359 1.5Zm-1.715 3.813a.87.87 0 0 1-1.199.29c-3.286-2.008-7.425-2.463-12.299-1.35a.872.872 0 0 1-.388-1.701c5.334-1.218 9.908-.693 13.597 1.56a.871.871 0 0 1 .29 1.201h-.001ZM16 2a14 14 0 1 0 0 28 14 14 0 0 0 0-28Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Spotify.propTypes = {
    className: PropTypes.string
};
module.exports = Spotify;
//# sourceMappingURL=Spotify.js.map

/***/ }),

/***/ 68642:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Star = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-star'), focusable: "false", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.star)),
        React.createElement("path", { d: "M6 9.09287L2.29173 11L3.02782 7.01113L0 4.20131L4.16334 3.64444L6 0L7.83666 3.64375L12 4.20131L8.97218 7.01113L9.70827 11L6 9.09287Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
Star.propTypes = {
    className: PropTypes.string
};
module.exports = Star;
//# sourceMappingURL=Star.js.map

/***/ }),

/***/ 97475:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Subscribe = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-subscribe'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.subscribe)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M28.991 17.822a2.156 2.156 0 0 1 0-3.644c1.897-1.25.924-4.1-1.362-4.03-1.617.048-2.772-1.482-2.237-2.954.766-2.079-1.75-3.842-3.574-2.487-1.277.946-3.15.362-3.611-1.122-.645-2.113-3.77-2.113-4.414 0-.462 1.495-2.334 2.08-3.61 1.122-1.824-1.343-4.341.42-3.575 2.487.547 1.46-.62 2.99-2.237 2.955-2.298-.058-3.259 2.791-1.362 4.03a2.156 2.156 0 0 1 0 3.643c-1.897 1.25-.924 4.1 1.362 4.03 1.617-.048 2.772 1.482 2.237 2.954-.766 2.079 1.75 3.83 3.574 2.487 1.277-.946 3.15-.362 3.611 1.122.645 2.114 3.77 2.114 4.414 0 .462-1.495 2.334-2.08 3.61-1.122 1.825 1.344 4.341-.42 3.575-2.487-.547-1.46.62-2.99 2.237-2.955 2.298.059 3.259-2.791 1.362-4.03Zm-6.055-3.504-3.623 2.523c-.146.105-.207.28-.146.444l1.386 4.087c.122.374-.316.678-.644.444l-3.623-2.523a.414.414 0 0 0-.487 0l-3.623 2.523c-.328.234-.766-.082-.644-.444l1.386-4.087c.06-.164 0-.35-.146-.444l-3.623-2.523c-.328-.233-.158-.724.243-.724h4.474a.43.43 0 0 0 .401-.28l1.386-4.088c.122-.373.67-.373.79 0l1.387 4.088a.43.43 0 0 0 .401.28h4.474c.402 0 .572.49.244.724h-.013Z", fill: "#0879BF" })));
};
Subscribe.propTypes = {
    className: PropTypes.string
};
module.exports = Subscribe;
//# sourceMappingURL=Subscribe.js.map

/***/ }),

/***/ 74561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Telegram = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-telegram'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.telegram)),
        React.createElement("path", { d: "M8.99416 14.7272L18.5258 10.7948C19.4588 10.3937 22.6588 9.12795 22.6588 9.12795C22.6588 9.12795 24.1251 8.52776 23.9914 9.92721C23.9245 10.5274 23.5918 12.527 23.3243 14.6604L22.3245 21.0589C22.3245 21.0589 22.2577 21.9918 21.5253 22.1924C20.7914 22.3929 19.6593 21.5922 19.4588 21.4585C19.3251 21.3248 16.3925 19.5257 15.3258 18.5928C15.0599 18.3268 14.7256 17.8589 15.3927 17.2602C16.859 15.9276 18.5927 14.2607 19.6579 13.1941C20.1243 12.7276 20.6577 11.5272 18.5912 12.9281L12.7929 16.7937C12.7929 16.7937 12.1258 17.1933 10.9269 16.8605C9.72656 16.5278 8.26027 15.9944 8.26027 15.9944C8.26027 15.9944 7.3273 15.3942 8.99416 14.7272Z", fill: "black" })));
};
Telegram.propTypes = {
    className: PropTypes.string
};
module.exports = Telegram;
//# sourceMappingURL=Telegram.js.map

/***/ }),

/***/ 10033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Threads = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-threads'), focusable: "false", height: "32", viewBox: "0 0 32 32", width: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.threads)),
        React.createElement("path", { d: "M22.745 14.977a9.78 9.78 0 0 0-.367-.166c-.216-3.982-2.392-6.262-6.046-6.286h-.05c-2.185 0-4.003.933-5.121 2.63l2.01 1.379c.835-1.268 2.146-1.538 3.112-1.538h.034c1.203.008 2.11.357 2.698 1.04.428.496.714 1.182.855 2.048a15.373 15.373 0 0 0-3.453-.166c-3.474.2-5.707 2.226-5.557 5.041.076 1.428.788 2.657 2.003 3.46 1.028.678 2.351 1.01 3.727.934 1.817-.1 3.242-.792 4.236-2.06.755-.962 1.233-2.21 1.444-3.781.866.522 1.508 1.21 1.862 2.036.602 1.405.638 3.715-1.246 5.597-1.651 1.649-3.635 2.362-6.634 2.384-3.326-.024-5.842-1.091-7.478-3.17-1.531-1.947-2.323-4.76-2.352-8.359.03-3.6.82-6.412 2.352-8.359 1.636-2.079 4.152-3.146 7.478-3.17 3.35.024 5.91 1.096 7.608 3.186.833 1.024 1.46 2.313 1.875 3.815l2.354-.628c-.501-1.85-1.29-3.443-2.365-4.764C23.547 3.4 20.363 2.028 16.26 2h-.016C12.149 2.028 9 3.406 6.886 6.095 5.004 8.488 4.033 11.817 4 15.99v.02c.033 4.173 1.004 7.502 2.886 9.895C9 28.594 12.149 29.972 16.244 30h.016c3.64-.025 6.206-.978 8.32-3.09 2.765-2.763 2.682-6.226 1.77-8.352-.654-1.524-1.9-2.763-3.605-3.58Zm-6.285 5.91c-1.522.085-3.104-.598-3.182-2.062-.058-1.085.772-2.296 3.275-2.44.287-.017.569-.025.845-.025.91 0 1.76.088 2.533.257-.288 3.603-1.98 4.188-3.47 4.27Z", fill: "#000" })));
};
Threads.propTypes = {
    className: PropTypes.string
};
module.exports = Threads;
//# sourceMappingURL=Threads.js.map

/***/ }),

/***/ 28304:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Tiktok = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-tiktok'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.tiktok)),
        React.createElement("path", { d: "M27.957 13.328a7.535 7.535 0 0 1-.689.035 7.474 7.474 0 0 1-6.254-3.38v11.51a8.507 8.507 0 1 1-8.507-8.507c.178 0 .351.016.526.027v4.192c-.175-.02-.346-.053-.526-.053a4.342 4.342 0 1 0 0 8.684c2.399 0 4.516-1.89 4.516-4.288L17.065 2h4.01a7.47 7.47 0 0 0 6.886 6.67v4.658", fill: "#000" })));
};
Tiktok.propTypes = {
    className: PropTypes.string
};
module.exports = Tiktok;
//# sourceMappingURL=Tiktok.js.map

/***/ }),

/***/ 82728:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Timestamp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-timestamp'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.timestamp)),
        React.createElement("path", { d: "M28.5 16c0 6.904-5.596 12.5-12.5 12.5S3.5 22.904 3.5 16 9.096 3.5 16 3.5 28.5 9.096 28.5 16Zm1.5 0c0 7.732-6.268 14-14 14S2 23.732 2 16 8.268 2 16 2s14 6.268 14 14Zm-13.25-.31V6h-1.5v10.31l5.22 5.22 1.06-1.06-4.78-4.78Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Timestamp.propTypes = {
    className: PropTypes.string
};
module.exports = Timestamp;
//# sourceMappingURL=Timestamp.js.map

/***/ }),

/***/ 43438:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Triangle = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-triangle', className), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangle)),
        React.createElement("path", { fill: "#000", d: "M30 9H2l14 14L30 9Z" })));
};
Triangle.propTypes = {
    className: PropTypes.string
};
module.exports = Triangle;
//# sourceMappingURL=Triangle.js.map

/***/ }),

/***/ 47774:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const TriangleDown = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-triangle-down'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangledown)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16 21.94 28.47 9.47l1.06 1.06L16 24.06 2.47 10.53l1.06-1.06L16 21.94Z", fill: "#000" })));
};
TriangleDown.propTypes = {
    className: PropTypes.string
};
module.exports = TriangleDown;
//# sourceMappingURL=TriangleDown.js.map

/***/ }),

/***/ 48767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const TriangleUp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-triangle-up', className), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangleup)),
        React.createElement("path", { fill: "#000", fillRule: "evenodd", clipRule: "evenodd", d: "M16 10.06 3.53 22.53l-1.06-1.06L16 7.94l13.53 13.53-1.06 1.06L16 10.06Z" })));
};
TriangleUp.propTypes = {
    className: PropTypes.string
};
module.exports = TriangleUp;
//# sourceMappingURL=TriangleUp.js.map

/***/ }),

/***/ 30920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Tumblr = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-tumblr'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.tumblr)),
        React.createElement("path", { d: "M22.746 24.365c-.52.248-1.516.464-2.26.484-2.24.06-2.675-1.575-2.695-2.761V13.37h5.623V9.133h-5.602V2H13.71c-.067 0-.185.059-.2.21-.24 2.182-1.263 6.014-5.51 7.544v3.617h2.834v9.15c0 3.131 2.31 7.581 8.41 7.477 2.057-.035 4.343-.898 4.85-1.64l-1.348-3.993Z", fill: "black" })));
};
Tumblr.propTypes = {
    className: PropTypes.string
};
module.exports = Tumblr;
//# sourceMappingURL=Tumblr.js.map

/***/ }),

/***/ 63579:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Twitter = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-twitter'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.twitter)),
        React.createElement("path", { d: "M18.3055 13.8561L28.505 2H26.088L17.2318 12.2945L10.1584 2H2L12.6964 17.5671L2 30H4.41709L13.7695 19.1287L21.2396 30H29.3979L18.3049 13.8561H18.3055ZM14.995 17.7042L13.9112 16.1541L5.288 3.81955H9.00051L15.9595 13.7739L17.0433 15.324L26.0892 28.2632H22.3767L14.995 17.7048V17.7042Z", fill: "black" })));
};
Twitter.propTypes = {
    className: PropTypes.string
};
module.exports = Twitter;
//# sourceMappingURL=Twitter.js.map

/***/ }),

/***/ 74921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VK = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-vk'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.vk)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M29.374 8.126c.194-.647 0-1.126-.924-1.126h-3.067c-.781 0-1.134.412-1.336.865 0 0-1.554 3.798-3.764 6.268-.714.715-1.042.942-1.428.942-.193 0-.487-.227-.487-.874V8.134c0-.781-.219-1.126-.866-1.126h-4.814c-.488 0-.782.362-.782.706 0 .74 1.1.908 1.218 2.983v4.512c0 .992-.176 1.168-.57 1.168-1.043 0-3.563-3.814-5.067-8.184C7.192 7.344 6.899 7 6.117 7H3.05C2.176 7 2 7.412 2 7.865c0 .815 1.042 4.84 4.84 10.159 2.529 3.638 6.1 5.604 9.343 5.604 1.95 0 2.185-.437 2.185-1.193v-2.748c0-.873.184-1.05.798-1.05.453 0 1.235.227 3.05 1.983 2.075 2.075 2.42 3.008 3.588 3.008h3.067c.873 0 1.31-.437 1.058-1.302-.277-.857-1.268-2.11-2.588-3.588-.714-.84-1.781-1.756-2.109-2.21-.453-.588-.328-.84 0-1.361 0 0 3.73-5.26 4.126-7.041h.017Z", fill: "black" })));
};
VK.propTypes = {
    className: PropTypes.string
};
module.exports = VK;
//# sourceMappingURL=VK.js.map

/***/ }),

/***/ 21318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VerificationBadge = ({ className, color = '#EB0000', ...attrs }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: classnames(className, 'icon icon-verification-badge'), width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.verificationBadge)),
        React.createElement("path", { d: "M29.481 17.866a4.668 4.668 0 0 1 0-3.545l.156-.374c.995-2.363-.156-5.1-2.52-6.096l-.341-.155a4.554 4.554 0 0 1-2.52-2.52l-.124-.31a4.74 4.74 0 0 0-6.126-2.52l-.311.124a4.744 4.744 0 0 1-3.577 0l-.28-.124c-2.332-.964-5.069.186-6.064 2.55l-.124.25a4.554 4.554 0 0 1-2.52 2.518l-.279.125c-2.332.995-3.483 3.732-2.488 6.096l.124.28a4.667 4.667 0 0 1 0 3.546l-.124.342c-.995 2.364.124 5.101 2.519 6.065l.311.125a4.554 4.554 0 0 1 2.52 2.519l.155.342c.964 2.395 3.7 3.515 6.064 2.55l.342-.155a4.745 4.745 0 0 1 3.576 0l.28.125c2.364.995 5.1-.156 6.096-2.52l.124-.249a4.554 4.554 0 0 1 2.52-2.52l.248-.092a4.642 4.642 0 0 0 2.519-6.097l-.156-.28Zm-14.803 4.2-6.064-5.102 1.866-2.208 3.856 3.266 6.81-8.087 2.209 1.866-8.677 10.264Z", fill: color })));
};
VerificationBadge.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = VerificationBadge;
//# sourceMappingURL=VerificationBadge.js.map

/***/ }),

/***/ 35788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Vero = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-vero'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.vero)),
        React.createElement("path", { d: "M26.87 4 16 22.833l-1.89-3.131L23.123 4H2l14 23.962L30 4h-3.13Z", fill: "black" })));
};
Vero.propTypes = {
    className: PropTypes.string
};
module.exports = Vero;
//# sourceMappingURL=Vero.js.map

/***/ }),

/***/ 81058:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Viber = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-viber'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.viber)),
        React.createElement("path", { d: "M25.387 4.424c-.655-.596-3.483-2.374-9.385-2.4 0 0-6.988-.459-10.38 2.615-1.888 1.865-2.524 4.639-2.594 8.023-.07 3.384-.431 9.85 5.757 11.57l-.027 5.222c0 .295.046.497.215.539.121.03.303-.033.457-.187.99-.994 4.157-4.818 4.157-4.818 4.25.278 7.632-.562 7.995-.68.858-.276 5.496-.675 6.28-7.018.812-6.538-.297-11.001-2.474-12.866ZM22.81 19.85l-.002.012a6.074 6.074 0 0 1-1.212 1.492c-.005.003-.005.006-.01.009-.418.349-.828.547-1.231.595a.813.813 0 0 1-.18.011 1.634 1.634 0 0 1-.523-.08l-.013-.02c-.62-.175-1.657-.613-3.383-1.565a20.171 20.171 0 0 1-2.842-1.879 14.914 14.914 0 0 1-1.278-1.133l-.043-.044-.043-.043-.044-.043-.043-.043c-.402-.405-.78-.832-1.133-1.279a20.18 20.18 0 0 1-1.877-2.843C8 11.272 7.562 10.236 7.386 9.614L7.367 9.6a1.638 1.638 0 0 1-.08-.523c-.003-.06 0-.12.01-.18.051-.402.25-.813.597-1.232l.008-.01c.43-.481.934-.89 1.492-1.213l.012-.002c.562-.293 1.095-.194 1.457.234.003.002.754.905 1.076 1.345.332.468.64.951.924 1.45.37.663.138 1.342-.225 1.622l-.732.583c-.37.299-.321.854-.321.854s1.085 4.108 5.138 5.143c0 0 .555.047.854-.321l.582-.733c.28-.363.959-.595 1.622-.225.498.284.98.593 1.447.924.44.325 1.342 1.078 1.345 1.078.43.362.528.895.236 1.457ZM19.455 9.714c-.82-.896-1.945-1.385-3.438-1.494a.395.395 0 1 1 .058-.788c1.68.123 3.013.712 3.962 1.75.953 1.04 1.418 2.349 1.385 3.89a.395.395 0 0 1-.395.386h-.008a.395.395 0 0 1-.386-.404c.029-1.349-.356-2.441-1.178-3.34Zm-.058 2.65a.395.395 0 0 1-.374.414h-.02a.395.395 0 0 1-.394-.374c-.066-1.342-.697-1.998-1.985-2.065a.395.395 0 0 1 .042-.788c1.7.089 2.644 1.062 2.731 2.813Zm3.706 1.905H23.1a.394.394 0 0 1-.395-.392c-.018-2.381-.732-4.277-2.123-5.633-1.394-1.36-3.154-2.055-5.234-2.07a.394.394 0 0 1 .003-.79h.003c2.29.016 4.234.788 5.779 2.294 1.547 1.51 2.341 3.593 2.361 6.193a.394.394 0 0 1-.391.398Z", fill: "black" })));
};
Viber.propTypes = {
    className: PropTypes.string
};
module.exports = Viber;
//# sourceMappingURL=Viber.js.map

/***/ }),

/***/ 37819:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Video = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-video'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.video)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 2v28l24-14L4 2Zm1.5 2.612v22.776L25.023 16 5.5 4.612Z", fill: "#000" })));
};
Video.propTypes = {
    className: PropTypes.string
};
module.exports = Video;
//# sourceMappingURL=Video.js.map

/***/ }),

/***/ 48848:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VolumeHigh = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-volume-high'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.volumeHigh)),
        React.createElement("path", { d: "M24.76 24.178c1.707-2.32 2.707-5.133 2.707-8.166 0-3.043-1.008-5.866-2.726-8.19M21.333 11.911c.868 1.205 1.363 2.601 1.363 4.089 0 1.488-.495 2.884-1.363 4.089M15 4 6 9v3H2v8h4v3l9 5V4ZM6 12v8", stroke: "#000", strokeWidth: "1.5" })));
};
VolumeHigh.propTypes = {
    className: PropTypes.string
};
module.exports = VolumeHigh;
//# sourceMappingURL=VolumeHigh.js.map

/***/ }),

/***/ 75937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VolumeMute = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-volume-mute'), focusable: "false", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.volumeMute)),
        React.createElement("path", { d: "M15 4 6 9v3H2v8h4v3l9 5V4ZM6 12v8M22 12l8 8M30 12l-4 4-4 4", stroke: "#000", strokeWidth: "1.5" })));
};
VolumeMute.propTypes = {
    className: PropTypes.string
};
module.exports = VolumeMute;
//# sourceMappingURL=VolumeMute.js.map

/***/ }),

/***/ 36108:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const WeChat = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-wechat'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.weChat)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M27.086 25.101C28.864 23.813 30 21.908 30 19.79c0-3.879-3.777-7.028-8.432-7.028s-8.433 3.146-8.433 7.028c0 3.883 3.778 7.028 8.433 7.028.961 0 1.89-.138 2.754-.384l.246-.037c.164 0 .309.051.447.131l1.846 1.067.164.05a.28.28 0 0 0 .28-.279l-.048-.207-.381-1.418-.029-.182a.576.576 0 0 1 .24-.457ZM12.12 5C6.532 5 2 8.777 2 13.432c0 2.54 1.364 4.83 3.498 6.375.17.12.283.323.283.548l-.037.214-.457 1.702-.054.247a.34.34 0 0 0 .337.337l.196-.062 2.217-1.28c.167-.095.341-.156.537-.156l.298.043c1.034.298 2.148.465 3.305.465l.555-.015a6.55 6.55 0 0 1-.34-2.065c0-4.248 4.132-7.692 9.23-7.692l.548.015C21.354 8.08 17.17 5 12.12 5Zm6.636 13.664a1.126 1.126 0 0 1 0-2.25 1.126 1.126 0 0 1 0 2.25Zm5.624 0a1.126 1.126 0 0 1 0-2.25 1.126 1.126 0 0 1 0 2.25ZM8.749 12.082a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7Zm6.745 0a1.35 1.35 0 1 1 0-2.7 1.35 1.35 0 0 1 0 2.7Z", fill: "black" })));
};
WeChat.propTypes = {
    className: PropTypes.string
};
module.exports = WeChat;
//# sourceMappingURL=WeChat.js.map

/***/ }),

/***/ 75088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Weibo = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-weibo'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.weibo)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.676 5.075c4.546-.603 7.975 2.522 8.295 6.65.126 1.563-.141 3.437-1.175 3.527-1.266.112-1.082-.91-.904-1.898.059-.325.117-.646.122-.922.06-3.236-2.7-5.483-5.4-5.483-.138 0-.307.017-.492.035-.845.083-2.004.197-1.778-1.128.113-.636.603-.694 1.134-.757l.198-.024Zm.863 7.045c.692.81.431 2.254 0 3.37.3.164.611.315.92.466 1.69.826 3.32 1.622 2.993 4.302-.097.76-.558 1.778-1.02 2.426C22.13 27.31 12.17 29.26 5.943 25.74c-2.09-1.175-4.248-2.901-3.906-6.338.283-2.961 2.276-5.252 4.226-7.201 1.86-1.868 3.823-3.326 6.494-3.995 2.902-.73 3.757 1.688 2.976 4.069.473-.032 1.096-.204 1.783-.393 1.744-.482 3.898-1.077 5.024.237Zm-11.04 13.86c3.608.237 7.216-1.035 8.927-2.977.625-.714 1.25-1.792 1.25-3.05-.007-3.89-4.902-5.334-8.764-5.014-2.112.171-3.533.618-5.014 1.488-1.212.707-2.626 1.867-2.976 3.6-.788 3.906 3.46 5.744 6.577 5.952Zm13.778-11.978c.684-.045 1.026-1.079.863-2.27-.231-1.68-1.697-3.05-3.683-2.893a4.667 4.667 0 0 1-.181.01c-.457.019-1.069.044-1.069.853 0 .786.552.786 1.183.785.366 0 .759 0 1.086.152.454.216.975.938 1.02 1.563.016.253.003.497-.01.718-.038.669-.064 1.138.79 1.082Zm-16.91 8.615c-1.064-2.902 1.495-5.208 4.151-5.483 2.27-.238 3.958.915 4.464 2.433 1.666 5.036-7.023 7.38-8.615 3.05Zm5.178-1.786a.597.597 0 0 0 .595-.595.597.597 0 0 0-.595-.595.597.597 0 0 0-.595.595c0 .327.267.595.595.595Zm-2.299 2.433c.81 0 1.473-.662 1.473-1.473s-.662-1.473-1.473-1.473c-.81 0-1.473.662-1.473 1.473 0 .81.662 1.473 1.473 1.473Z", fill: "black" })));
};
Weibo.propTypes = {
    className: PropTypes.string
};
module.exports = Weibo;
//# sourceMappingURL=Weibo.js.map

/***/ }),

/***/ 87924:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Whatsapp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-whatsapp'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.whatsapp)),
        React.createElement("path", { d: "M25.9167 6.07188C23.2878 3.44761 19.7878 2 16.0622 2C8.37778 2 2.11667 8.22394 2.11667 15.8723C2.11667 18.3185 2.75444 20.7028 3.97556 22.8084L2 30L9.38889 28.0724C11.4267 29.1794 13.7211 29.76 16.0544 29.76H16.0622C23.7467 29.76 30 23.5361 30 15.8878C30 12.1797 28.5533 8.69616 25.9167 6.07188ZM16.0622 27.4222C13.9778 27.4222 11.94 26.8648 10.1589 25.812L9.73889 25.5643L5.34444 26.7022L6.51111 22.4446L6.23889 22.0111C5.08 20.1764 4.46556 18.0553 4.46556 15.8723C4.46556 9.51673 9.66889 4.33785 16.0622 4.33785C19.1578 4.33785 22.0667 5.53774 24.2522 7.72076C26.4378 9.90379 27.6433 12.799 27.6433 15.88C27.6433 22.2433 22.4478 27.4144 16.0622 27.4222ZM22.4167 18.783C22.0667 18.6127 20.3556 17.7689 20.0367 17.6528C19.7178 17.5366 19.4844 17.4824 19.2511 17.8231C19.0178 18.1714 18.3489 18.9533 18.1467 19.1855C17.9444 19.4177 17.7422 19.4487 17.3922 19.2707C17.0422 19.1004 15.9222 18.7288 14.5922 17.5521C13.5578 16.6309 12.8578 15.5007 12.6556 15.1523C12.4533 14.804 12.6322 14.6182 12.8111 14.4479C12.9667 14.2931 13.1611 14.0453 13.3322 13.8441C13.5033 13.6428 13.5656 13.4957 13.6822 13.2635C13.7989 13.0312 13.7367 12.83 13.6511 12.6597C13.5656 12.4894 12.8656 10.7785 12.5778 10.0818C12.2978 9.40835 12.01 9.50124 11.7922 9.48576C11.59 9.47802 11.3567 9.47028 11.1233 9.47028C10.89 9.47028 10.5167 9.55543 10.1978 9.90379C9.87889 10.2521 8.97667 11.0882 8.97667 12.799C8.97667 14.5098 10.2211 16.151 10.4 16.3832C10.5711 16.6154 12.8578 20.1145 16.35 21.6163C17.1822 21.9724 17.8278 22.1891 18.3333 22.3439C19.1656 22.6071 19.9278 22.5684 20.5267 22.4833C21.1956 22.3826 22.5878 21.6472 22.8756 20.8344C23.1633 20.0216 23.1633 19.3326 23.0778 19.1855C22.9922 19.0384 22.7589 18.9533 22.4167 18.783Z", fill: "#111B21" })));
};
Whatsapp.propTypes = {
    className: PropTypes.string
};
module.exports = Whatsapp;
//# sourceMappingURL=Whatsapp.js.map

/***/ }),

/***/ 40426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Xing = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-xing'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.xing)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M26.54 2c.141 0 .23.15.16.27l-7.983 13.64a.177.177 0 0 0 0 .18L26.7 29.73a.18.18 0 0 1-.16.27h-5.1a.185.185 0 0 1-.16-.09l-8.087-13.82a.176.176 0 0 1 0-.18l8.088-13.82a.185.185 0 0 1 .16-.09h5.099Zm-12.588 9.498a.01.01 0 0 0 .008-.015l-2.95-5.048a.277.277 0 0 0-.24-.136H6.184a.27.27 0 0 0-.24.404l2.793 4.78a.01.01 0 0 1-.009.015.01.01 0 0 0-.008.005L5.04 17.435a.27.27 0 0 0 .237.41h4.578c.096 0 .186-.049.236-.13l3.852-6.212a.01.01 0 0 1 .009-.005Z", fill: "#000" })));
};
Xing.propTypes = {
    className: PropTypes.string
};
module.exports = Xing;
//# sourceMappingURL=Xing.js.map

/***/ }),

/***/ 94342:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const YandexZen = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-yandexzen'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.yandexzen)),
        React.createElement("path", { d: "M2 15.65c5.775-.175 8.925-.35 11.025-2.625C15.3 10.925 15.65 7.775 15.65 2 8.125 2.175 2.175 8.125 2 15.65ZM30 15.65C29.825 8.3 23.875 2.175 16.525 2c.175 5.775.35 8.925 2.625 11.025 2.1 2.1 5.25 2.625 10.85 2.625ZM2 16.525c.35 7.35 6.3 13.3 13.65 13.475-.175-5.6-.525-8.75-2.625-10.85-2.1-2.1-5.25-2.625-11.025-2.625ZM16.525 30c7.35-.35 13.125-6.125 13.475-13.475-5.6.175-8.75.525-10.85 2.625-2.1 2.1-2.625 5.25-2.625 10.85Z", fill: "#000" })));
};
YandexZen.propTypes = {
    className: PropTypes.string
};
module.exports = YandexZen;
//# sourceMappingURL=YandexZen.js.map

/***/ }),

/***/ 57961:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const YouTube = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-youtube'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.youTube)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M29.4155 9.08C29.2571 8.48435 28.945 7.94078 28.5104 7.50373C28.0758 7.06668 27.534 6.7515 26.9392 6.58975C24.7552 6 16 6 16 6C16 6 7.24475 6 5.06075 6.58975C4.46601 6.7515 3.9242 7.06668 3.48961 7.50373C3.05502 7.94078 2.74289 8.48435 2.5845 9.08C2 11.278 2 15.863 2 15.863C2 15.863 2 20.448 2.5845 22.646C2.74263 23.242 3.05463 23.7859 3.48924 24.2233C3.92385 24.6606 4.4658 24.9761 5.06075 25.138C7.24475 25.7277 16 25.7277 16 25.7277C16 25.7277 24.7552 25.7277 26.9392 25.138C27.5342 24.9761 28.0761 24.6606 28.5108 24.2233C28.9454 23.7859 29.2574 23.242 29.4155 22.646C30 20.4497 30 15.863 30 15.863C30 15.863 30 11.278 29.4155 9.08ZM13.137 20.0262V11.6997L20.4538 15.8647L13.137 20.0262Z", fill: "black" })));
};
YouTube.propTypes = {
    className: PropTypes.string
};
module.exports = YouTube;
//# sourceMappingURL=YouTube.js.map

/***/ }),

/***/ 97504:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Account = __webpack_require__(38299);
const AgeGate = (__webpack_require__(42368)["default"]);
const Arrow = __webpack_require__(42361);
const Article = __webpack_require__(4498);
const Bookmark = __webpack_require__(43706);
const BookmarkActivated = __webpack_require__(20215);
const BookmarkNew = __webpack_require__(66718);
const BlueSky = __webpack_require__(59257);
const CartFilled = __webpack_require__(3540);
const CartOutlined = __webpack_require__(64510);
const Check = __webpack_require__(76196);
const ChevronRight = __webpack_require__(39733);
const ChevronLeft = __webpack_require__(87986);
const ChevronUp = __webpack_require__(56430);
const ChevronDown = __webpack_require__(16619);
const ChevronFill = __webpack_require__(32586);
const Close = __webpack_require__(30616);
const Collapse = __webpack_require__(87241);
const Comment = __webpack_require__(34577);
const CopyLink = __webpack_require__(70195);
const DownloadCloud = __webpack_require__(29165);
const DownloadWeb = __webpack_require__(5198);
const Dot = __webpack_require__(71039);
const Email = __webpack_require__(49140);
const EmailFilled = __webpack_require__(88852);
const Enlarge = __webpack_require__(3686);
const Expand = __webpack_require__(84050);
const Facebook = __webpack_require__(67818);
const Filmstrip = __webpack_require__(39792);
const Flipboard = __webpack_require__(73137);
const GoogleNews = __webpack_require__(15514);
const Gallery = __webpack_require__(96774);
const Grid = __webpack_require__(34890);
const Headphone = __webpack_require__(77818);
const SlimHeadphone = __webpack_require__(28153);
const Information = __webpack_require__(83558);
const Instagram = __webpack_require__(33528);
const LargeChevron = __webpack_require__(708);
const LeftChevron = __webpack_require__(47424);
const Like = __webpack_require__(36737);
const LikeFilled = __webpack_require__(68165);
const Line = __webpack_require__(80636);
const LinkedIn = __webpack_require__(41876);
const OK = __webpack_require__(56148);
const Paperclip = __webpack_require__(87468);
const Loader = __webpack_require__(79301);
const List = __webpack_require__(49498);
const Maximize = __webpack_require__(60836);
const Menu = __webpack_require__(88845);
const NativeShare = __webpack_require__(90906);
const Newsletter = __webpack_require__(86173);
const NewsletterArrow = __webpack_require__(21516);
const Pause = __webpack_require__(87574);
const PhotoStack = __webpack_require__(42710);
const Pinterest = __webpack_require__(80890);
const Play = __webpack_require__(11936);
const Passkey = __webpack_require__(87444);
const PlayCNE = __webpack_require__(23150);
const PlaylistIcon = __webpack_require__(54280);
const PlayOutlined = __webpack_require__(3330);
const Print = __webpack_require__(7967);
const PrivacyOT = __webpack_require__(97195);
const RatingFilled = __webpack_require__(45191);
const RatingHalf = __webpack_require__(45530);
const RatingOutlined = __webpack_require__(64577);
const Replay = __webpack_require__(3653);
const Rss = __webpack_require__(94416);
const Search = __webpack_require__(90506);
const Share = __webpack_require__(16119);
const Shopping = __webpack_require__(10934);
const Snapchat = __webpack_require__(10312);
const Spotify = __webpack_require__(84502);
const SocialHandle = __webpack_require__(7507);
const Subscribe = __webpack_require__(97475);
const Telegram = __webpack_require__(74561);
const Timestamp = __webpack_require__(82728);
const Threads = __webpack_require__(10033);
const Tiktok = __webpack_require__(28304);
const Triangle = __webpack_require__(43438);
const TriangleDown = __webpack_require__(47774);
const TriangleUp = __webpack_require__(48767);
const Tumblr = __webpack_require__(30920);
const Twitter = __webpack_require__(63579);
const VerificationBadge = __webpack_require__(21318);
const Vero = __webpack_require__(35788);
const Viber = __webpack_require__(81058);
const Video = __webpack_require__(37819);
const VolumeHigh = __webpack_require__(48848);
const VolumeMute = __webpack_require__(75937);
const VK = __webpack_require__(74921);
const WeChat = __webpack_require__(36108);
const Weibo = __webpack_require__(75088);
const Whatsapp = __webpack_require__(87924);
const YandexZen = __webpack_require__(94342);
const YouTube = __webpack_require__(57961);
module.exports = {
    Account,
    AgeGate,
    Arrow,
    Article,
    Bookmark,
    BookmarkActivated,
    BookmarkNew,
    BlueSky,
    CartFilled,
    CartOutlined,
    Check,
    ChevronRight,
    ChevronFill,
    ChevronLeft,
    ChevronUp,
    ChevronDown,
    Close,
    Collapse,
    Comment,
    CopyLink,
    DownloadCloud,
    DownloadWeb,
    Dot,
    Email,
    EmailFilled,
    Enlarge,
    Expand,
    Facebook,
    Filmstrip,
    Flipboard,
    GoogleNews,
    Gallery,
    Grid,
    Headphone,
    SlimHeadphone,
    Information,
    Instagram,
    LargeChevron,
    LeftChevron,
    Like,
    LikeFilled,
    Line,
    LinkedIn,
    OK,
    Paperclip,
    List,
    Maximize,
    Menu,
    NativeShare,
    Newsletter,
    NewsletterArrow,
    Pause,
    PhotoStack,
    Pinterest,
    Play,
    Passkey,
    PlayCNE,
    PlaylistIcon,
    PlayOutlined,
    Print,
    PrivacyOT,
    RatingFilled,
    RatingHalf,
    RatingOutlined,
    Replay,
    Loader,
    Rss,
    Search,
    Share,
    Shopping,
    Snapchat,
    Spotify,
    SocialHandle,
    Subscribe,
    Telegram,
    Timestamp,
    Tiktok,
    Threads,
    Triangle,
    TriangleDown,
    TriangleUp,
    Tumblr,
    Twitter,
    VerificationBadge,
    Vero,
    Viber,
    Video,
    VolumeHigh,
    VolumeMute,
    VK,
    WeChat,
    Weibo,
    Whatsapp,
    YandexZen,
    YouTube
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 60132:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { getColorToken } = __webpack_require__(26865);
const PlayCNEWrapper = styled.svg.withConfig({ displayName: 'PlayCNEWrapper' }) `
  width: 32px;
  height: 32px;
  fill: none;

  circle {
    fill: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.black')};
    fill-opacity: 0.4;
    stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
    stroke-opacity: 0.6;
    stroke-width: 3;
    transition: fill-opacity 300ms, stroke-opacity 300ms;
  }

  path {
    fill: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
  }

  &:active,
  &:focus,
  &:hover {
    circle {
      fill-opacity: 0.8;
      stroke-opacity: 1;
    }
  }
`;
// otherwise this is styled.svg, which causes tests to fail. the icons aren't using any other displayName pattern so this is fine
PlayCNEWrapper.displayName = 'svg';
const PrivacyOTIconWrapper = styled.svg.withConfig({
    displayName: 'PrivacyOTIconWrapper'
}) `
  .st0 {
    fill-rule: evenodd;
    clip-rule: evenodd;
    fill: #ffffff;
  }

  .st1 {
    fill-rule: evenodd;
    clip-rule: evenodd;
    fill: #0066ff;
  }

  .st2 {
    fill: #ffffff;
  }

  .st3 {
    fill: #0066ff;
  }
`;
// otherwise this is styled.svg, which causes tests to fail. the icons aren't using any other displayName pattern so this is fine
PrivacyOTIconWrapper.displayName = 'svg';
module.exports = {
    PlayCNEWrapper,
    PrivacyOTIconWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 92237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Account = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-account'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.account)),
        React.createElement("circle", { cx: "12", cy: "8", r: "5.25", stroke: "black", strokeWidth: "1.5" }),
        React.createElement("mask", { id: "path-2-inside-1_14_4055", fill: "white" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 14.5H14C17.0376 14.5 19.5 16.9624 19.5 20V22H21V20C21 16.134 17.866 13 14 13H10C6.13401 13 3 16.134 3 20V21.75V22H4.5V21.75V20C4.5 16.9624 6.96243 14.5 10 14.5Z" })),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 14.5H14C17.0376 14.5 19.5 16.9624 19.5 20V22H21V20C21 16.134 17.866 13 14 13H10C6.13401 13 3 16.134 3 20V21.75V22H4.5V21.75V20C4.5 16.9624 6.96243 14.5 10 14.5Z", fill: "black" }),
        React.createElement("path", { d: "M19.5 22H18V23.5H19.5V22ZM21 22V23.5H22.5V22H21ZM3 22H1.5V23.5H3V22ZM4.5 22V23.5H6V22H4.5ZM14 13H10V16H14V13ZM21 20C21 16.134 17.866 13 14 13V16C16.2091 16 18 17.7909 18 20H21ZM21 22V20H18V22H21ZM19.5 23.5H21V20.5H19.5V23.5ZM19.5 20V22H22.5V20H19.5ZM14 14.5C17.0376 14.5 19.5 16.9624 19.5 20H22.5C22.5 15.3056 18.6944 11.5 14 11.5V14.5ZM10 14.5H14V11.5H10V14.5ZM4.5 20C4.5 16.9624 6.96243 14.5 10 14.5V11.5C5.30558 11.5 1.5 15.3056 1.5 20H4.5ZM4.5 21.75V20H1.5V21.75H4.5ZM4.5 22V21.75H1.5V22H4.5ZM3 23.5H4.5V20.5H3V23.5ZM3 21.75V22H6V21.75H3ZM3 20V21.75H6V20H3ZM10 13C6.13401 13 3 16.134 3 20H6C6 17.7909 7.79086 16 10 16V13Z", fill: "black", mask: "url(#path-2-inside-1_14_4055)" })));
};
Account.propTypes = {
    className: PropTypes.string
};
module.exports = Account;
//# sourceMappingURL=Account.js.map

/***/ }),

/***/ 86138:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const prop_types_1 = __importDefault(__webpack_require__(5556));
const react_1 = __importDefault(__webpack_require__(96540));
const classnames_1 = __importDefault(__webpack_require__(32485));
const react_intl_1 = __webpack_require__(46984);
const translations_1 = __importDefault(__webpack_require__(68766));
const AgeGate = ({ className, fill }) => {
    const { formatMessage } = (0, react_intl_1.useIntl)();
    return (react_1.default.createElement("svg", { className: (0, classnames_1.default)(className, 'icon icon-age-gate'), focusable: "false", fill: fill, width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" },
        react_1.default.createElement("title", null, formatMessage(translations_1.default.ageGate)),
        react_1.default.createElement("g", { clipPath: "url(#a)", fillRule: "evenodd", clipRule: "evenodd" },
            react_1.default.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.802 18.795a9.82 9.82 0 0 1-6.953 2.873C6.41 21.668 2 17.258 2 11.82c0-5.44 4.41-9.85 9.85-9.85a9.837 9.837 0 0 1 8.064 4.194c.32.456.6.936.836 1.435h-2.294A7.827 7.827 0 0 0 11.85 3.98a7.84 7.84 0 1 0 6.332 12.462h2.367a9.869 9.869 0 0 1-1.746 2.353ZM13.67 15.38c-1.563 0-2.576-.733-2.576-1.959 0-.781.386-1.36 1.08-1.582-.569-.212-.955-.8-.955-1.505 0-1.11.984-1.804 2.45-1.804 1.458 0 2.451.694 2.451 1.804 0 .704-.405 1.293-.974 1.505.694.222 1.1.8 1.1 1.582 0 1.226-1.023 1.959-2.576 1.959Zm-5.452-.145v-4.149H6.828V9.862c1.303 0 1.592-.376 1.592-1.187h1.35v6.561H8.218Zm6.416-4.766c0 .492-.376.82-.964.82-.57 0-.965-.328-.965-.82 0-.511.376-.83.965-.83.579 0 .964.319.964.83Zm-.964 3.753c.627 0 1.051-.357 1.051-.907 0-.54-.424-.897-1.051-.897-.608 0-1.052.357-1.052.897 0 .55.424.907 1.052.907Zm6.823-4.414h-1.407v1.508h-1.507v1.407h1.507v1.507h1.407v-1.507H22v-1.407h-1.508V9.809Z", fill: "#2B2B2B" })),
        react_1.default.createElement("defs", null,
            react_1.default.createElement("clipPath", { id: "a" },
                react_1.default.createElement("path", { fill: "#fff", d: "M0 0h32v32H0z" })))));
};
AgeGate.propTypes = {
    className: prop_types_1.default.string,
    fill: prop_types_1.default.string
};
AgeGate.displayName = 'AgeGateIcon';
exports["default"] = AgeGate;
//# sourceMappingURL=AgeGate.js.map

/***/ }),

/***/ 69571:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Arrow = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-arrow', className), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.arrow)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m22.06 12-9.53-9.53-1.06 1.06 7.718 7.719H2v1.5h17.19l-7.72 7.72 1.06 1.061L22.06 12Z" })));
};
Arrow.propTypes = {
    className: PropTypes.string
};
module.exports = Arrow;
//# sourceMappingURL=Arrow.js.map

/***/ }),

/***/ 90628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Article = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-article'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.article)),
        React.createElement("path", { d: "M2 3.25h17v1.5H2v-1.5Zm0 8h20v1.5H2v-1.5Zm13 8H2v1.5h13v-1.5Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Article.propTypes = {
    className: PropTypes.string
};
module.exports = Article;
//# sourceMappingURL=Article.js.map

/***/ }),

/***/ 81463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const BlueSky = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bluesky'), focusable: "false", height: "24", viewBox: "0 0 24 24", width: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.bluesky)),
        React.createElement("path", { d: "M6.902 5.125C8.965 6.76 11.185 10.072 12 11.85c.815-1.778 3.035-5.091 5.098-6.725C18.588 3.946 21 3.034 21 5.937c0 .58-.315 4.87-.5 5.566-.642 2.421-2.984 3.039-5.066 2.665 3.64.654 4.566 2.818 2.566 4.982-3.798 4.11-5.46-1.031-5.885-2.349-.078-.241-.114-.354-.115-.258 0-.096-.037.017-.115.258-.426 1.318-2.087 6.46-5.885 2.35-2-2.165-1.074-4.33 2.566-4.983-2.082.374-4.423-.244-5.066-2.665-.185-.697-.5-4.987-.5-5.566 0-2.903 2.413-1.99 3.902-.812Z", fill: "#000" })));
};
BlueSky.propTypes = {
    className: PropTypes.string
};
module.exports = BlueSky;
//# sourceMappingURL=BlueSky.js.map

/***/ }),

/***/ 315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 */
const Bookmark = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark'), width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || formatMessage(translations.bookmark)),
        React.createElement("path", { fill: "#000", fillRule: "evenodd", d: "M4.25 3.25h8.5v1.5h-7v14.958L12 16.136l6.25 3.572V12.25h1.5v10.042L12 17.864l-7.75 4.428V3.25ZM18.25 10V2h1.5v8h-1.5Z", clipRule: "evenodd" }),
        React.createElement("path", { fill: "#000", fillRule: "evenodd", d: "M23 6.75h-8v-1.5h8v1.5Z", clipRule: "evenodd" })));
};
Bookmark.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string
};
module.exports = Bookmark;
//# sourceMappingURL=Bookmark.js.map

/***/ }),

/***/ 52585:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 */
const BookmarkActivated = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark icon-bookmark--activated'), width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || formatMessage(translations.bookmarkActivated)),
        React.createElement("path", { className: "icon-bookmark-fill icon-bookmark--activated-checkmark", fill: "#000", fillRule: "evenodd", d: "M4.25 3.25h8.5v1.5h-7v14.958L12 16.136l6.25 3.572V11.25h1.5v11.042L12 17.864l-7.75 4.428V3.25Z", clipRule: "evenodd" }),
        React.createElement("path", { className: "icon-bookmark--activated-checkmark-stroke", fill: "#000", fillRule: "evenodd", d: "m12 10.94 7.47-7.47 1.06 1.06L12 13.06 8.47 9.53l1.06-1.06L12 10.94Z", clipRule: "evenodd" })));
};
BookmarkActivated.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string
};
module.exports = BookmarkActivated;
//# sourceMappingURL=BookmarkActivated.js.map

/***/ }),

/***/ 44584:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 */
const BookmarkNew = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, className, fill, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark'), width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || formatMessage(translations.bookmark)),
        React.createElement("path", { d: "M11.6279 17.2126L5 21V4H19V21L12.3721 17.2126L12 17L11.6279 17.2126Z", stroke: "black", strokeWidth: "1.5", strokeLinecap: "square", fill: fill || 'none' })));
};
BookmarkNew.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string,
    fill: PropTypes.string
};
module.exports = BookmarkNew;
//# sourceMappingURL=BookmarkNew.js.map

/***/ }),

/***/ 58366:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CartFilled = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-cart'), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.cart)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.935 7.209H2v-2h4.364l.231.676.675 1.972h14.423l-.309 1.241-.877 3.53-.145.583-.582.146-10.84 2.722-.892.224-.298-.87-2.815-8.224ZM18.74 18.345a1.57 1.57 0 0 1-.117.63c-.081.201-.204.384-.36.538a1.68 1.68 0 0 1-.547.36 1.726 1.726 0 0 1-1.299 0 1.68 1.68 0 0 1-.547-.36 1.615 1.615 0 0 1-.36-.537 1.571 1.571 0 0 1-.117-.63c.01-.423.19-.825.502-1.12a1.704 1.704 0 0 1 1.17-.462c.438 0 .858.165 1.171.46.313.296.494.698.504 1.121Zm-6.812.63c.081-.2.12-.414.116-.63a1.593 1.593 0 0 0-.504-1.12 1.704 1.704 0 0 0-1.17-.461c-.438 0-.858.165-1.17.461a1.593 1.593 0 0 0-.503 1.121c-.005.215.034.43.116.63s.205.383.36.538c.157.154.343.276.548.36a1.726 1.726 0 0 0 1.299 0 1.68 1.68 0 0 0 .547-.361c.156-.154.279-.337.36-.538Z", fill: "#000" })));
};
CartFilled.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = CartFilled;
//# sourceMappingURL=CartFilled.js.map

/***/ }),

/***/ 72172:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CartOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-cart'), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.cart)),
        React.createElement("g", { clipPath: "url(#clip0_3732_178638)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.414 3.75H2v-1.5h3a.75.75 0 0 1 .728.568L8.586 14.25h9.812l1.667-7.5H11v-1.5h10a.75.75 0 0 1 .732.913l-2 9a.75.75 0 0 1-.732.587H8a.75.75 0 0 1-.728-.568L4.414 3.75Z", fill: "#000" }),
            React.createElement("path", { d: "M12 19.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0ZM19 19.5a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0Z", fill: "#000" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "clip0_3732_178638" },
                React.createElement("rect", { width: "24", height: "24", fill: "white" })),
            React.createElement("clipPath", { id: "clip1_3732_178638" },
                React.createElement("rect", { width: "24", height: "24", fill: "white" })))));
};
CartOutlined.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = CartOutlined;
//# sourceMappingURL=CartOutlined.js.map

/***/ }),

/***/ 9218:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Check = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-check'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.check)),
        React.createElement("path", { d: "m10 14.94 8.47-8.47 1.06 1.06L10 17.06l-5.53-5.53 1.06-1.06L10 14.94Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Check.propTypes = {
    className: PropTypes.string
};
module.exports = Check;
//# sourceMappingURL=Check.js.map

/***/ }),

/***/ 40589:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronDown = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-down'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronDown)),
        React.createElement("path", { d: "M12 15.94 3.53 7.47 2.47 8.53 12 18.06l9.53-9.53-1.06-1.06L12 15.94Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
ChevronDown.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronDown;
//# sourceMappingURL=ChevronDown.js.map

/***/ }),

/***/ 58180:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronFill = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevronFill'), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronFill)),
        React.createElement("rect", { width: "24", height: "24", rx: "18", fill: "black" }),
        React.createElement("path", { d: "M22 12c0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10 10-4.477 10-10Z", fill: "#000" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m13.94 12-3.47-3.47 1.06-1.06L16.06 12l-4.53 4.53-1.06-1.06L13.94 12Z", fill: "#fff" })));
};
ChevronFill.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronFill;
//# sourceMappingURL=ChevronFill.js.map

/***/ }),

/***/ 18972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronLeft = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-left'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronLeft)),
        React.createElement("path", { d: "m8.06 12 8.47-8.47-1.06-1.06L5.94 12l9.53 9.53 1.06-1.06L8.06 12Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
ChevronLeft.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronLeft;
//# sourceMappingURL=ChevronLeft.js.map

/***/ }),

/***/ 25751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronRight = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevron)),
        React.createElement("path", { d: "M15.94 12 7.47 3.53l1.06-1.06L18.06 12l-9.53 9.53-1.06-1.06L15.94 12Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
ChevronRight.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronRight;
//# sourceMappingURL=ChevronRight.js.map

/***/ }),

/***/ 68804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronUp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevronUp'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronUp)),
        React.createElement("path", { d: "m12 8.06 8.47 8.47 1.06-1.06L12 5.94l-9.53 9.53 1.06 1.06L12 8.06Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
ChevronUp.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronUp;
//# sourceMappingURL=ChevronUp.js.map

/***/ }),

/***/ 80046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Close = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-close'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", role: "none", ...attrs },
        React.createElement("title", null, formatMessage(translations.close)),
        React.createElement("path", { d: "m12 13.06 9.453 9.454 1.094-1.028L13.061 12l9.486-9.486-1.094-1.028L12 10.94 2.547 1.486 1.453 2.514 10.939 12l-9.486 9.486 1.094 1.028L12 13.06Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Close.propTypes = {
    className: PropTypes.string
};
module.exports = Close;
//# sourceMappingURL=Close.js.map

/***/ }),

/***/ 56099:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Collapse = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-collapse'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.collapse)),
        React.createElement("path", { d: "M2 11.25h20v1.5H2v-1.5Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Collapse.propTypes = {
    className: PropTypes.string
};
module.exports = Collapse;
//# sourceMappingURL=Collapse.js.map

/***/ }),

/***/ 56807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Comment = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-comment'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.comment)),
        React.createElement("path", { d: "M13 17h9V3H2v14h4v4l7-4Zm-5.5 1.415 5.102-2.915H20.5v-11h-17v11h4v2.915Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Comment.propTypes = {
    className: PropTypes.string
};
module.exports = Comment;
//# sourceMappingURL=Comment.js.map

/***/ }),

/***/ 25601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const CopyLink = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-copylink'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.copyLink)),
        React.createElement("path", { d: "M17.158 10.335a.548.548 0 0 0 .196.743c.256.15.584.06.732-.2l1.34-2.353c1.183-2.08.48-4.74-1.57-5.942-2.049-1.2-4.67-.488-5.853 1.592L9.86 7.942c-1.183 2.08-.481 4.74 1.569 5.941.201.118.408.218.619.3a.47.47 0 0 0 .574-.223c.177-.31-.005-.707-.328-.85a3.23 3.23 0 0 1-.33-.168c-1.537-.901-2.064-2.896-1.176-4.456l2.143-3.767a3.188 3.188 0 0 1 4.39-1.194c1.537.9 2.064 2.896 1.176 4.456l-1.339 2.354Zm-9.316 3.33a.548.548 0 0 0-.196-.743.531.531 0 0 0-.732.2l-1.34 2.353c-1.183 2.08-.48 4.74 1.57 5.942 2.049 1.2 4.67.488 5.853-1.592l2.143-3.767c1.183-2.08.481-4.74-1.569-5.941a4.283 4.283 0 0 0-.619-.3.47.47 0 0 0-.574.223c-.177.31.005.707.328.85.112.049.222.105.33.168 1.537.901 2.064 2.896 1.176 4.456l-2.143 3.767a3.188 3.188 0 0 1-4.39 1.194c-1.537-.9-2.064-2.896-1.176-4.456l1.339-2.354Z", fill: "#000" })));
};
CopyLink.propTypes = {
    className: PropTypes.string
};
module.exports = CopyLink;
//# sourceMappingURL=CopyLink.js.map

/***/ }),

/***/ 60261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Dot = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-dots'), viewBox: "0 0 24 24", width: "24", height: "24", fill: "#DADADA", xmlns: "http://www.w3.org/2000/svg", role: "img", ...attrs },
        React.createElement("title", null, formatMessage(translations.dots)),
        React.createElement("path", { d: "M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" })));
};
Dot.propTypes = {
    className: PropTypes.string
};
module.exports = Dot;
//# sourceMappingURL=Dot.js.map

/***/ }),

/***/ 66087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const DownloadCloud = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-downloadCloud'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.downloadCloud)),
        React.createElement("path", { d: "M12.476 20.207V12.85h-.952v7.358l-2-2.075-.762.755L12 22l3.238-3.113-.761-.755-2 2.075Zm4.762-14.433C17.048 3.604 15.143 2 12.952 2c-1.81 0-3.523 1.226-4.095 2.925-.19-.095-.476-.095-.667-.095-2.38 0-4.285 1.887-4.285 4.246 0 .283 0 .471.095.754-1.238.566-2 1.699-2 3.02 0 1.792 1.524 3.301 3.333 3.301h3.81v-.943h-3.81c-1.333 0-2.38-1.038-2.38-2.359 0-1.037.666-1.98 1.714-2.264l.476-.094-.095-.472c-.096-.377-.19-.66-.19-.943 0-1.793 1.523-3.302 3.332-3.302.286 0 .572 0 .953.094l.476.189.095-.472c.286-1.51 1.714-2.642 3.238-2.642 1.81 0 3.334 1.51 3.334 3.302v.472h.476c2.38 0 4.285 1.887 4.285 4.246 0 2.358-1.904 4.245-4.285 4.245h-1.905v.943h1.905c2.857 0 5.238-2.358 5.238-5.188 0-2.736-2.095-4.906-4.762-5.19Z", fill: "#000" })));
};
DownloadCloud.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = DownloadCloud;
//# sourceMappingURL=DownloadCloud.js.map

/***/ }),

/***/ 39392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const DownloadWeb = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-downloadWeb'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.downloadWeb)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m16.47 10.47-3.72 3.72V2h-1.5v12.19l-3.72-3.72-1.06 1.06L12 17.06l5.53-5.53-1.06-1.06ZM3 20.75h18v-1.5H3v1.5Z", fill: "#000" })));
};
DownloadWeb.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = DownloadWeb;
//# sourceMappingURL=DownloadWeb.js.map

/***/ }),

/***/ 57942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Email = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-email'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.email)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.44 6.5H4.56L12 13.94l7.44-7.44ZM3.5 7.56v9.94h17V7.56l-8.5 8.5-8.5-8.5ZM2 19V5h20v14H2Z", fill: "#000" })));
};
Email.propTypes = {
    className: PropTypes.string
};
module.exports = Email;
//# sourceMappingURL=Email.js.map

/***/ }),

/***/ 62410:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const EmailFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-emailfilled'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.email)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 14 3 5h18l-9 9ZM2 19V5.955l10.003 10.037L22 5.957V19H2Z", fill: "#000" })));
};
EmailFilled.propTypes = {
    className: PropTypes.string
};
module.exports = EmailFilled;
//# sourceMappingURL=EmailFilled.js.map

/***/ }),

/***/ 83476:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Enlarge = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-enlarge'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.expand)),
        React.createElement("path", { d: "M19.19 3.75H12v-1.5h9.75V12h-1.5V4.81l-5.72 5.72-1.06-1.06 5.72-5.72ZM3.75 12h-1.5v9.75H12v-1.5H4.81l5.72-5.72-1.06-1.06-5.72 5.72V12Z", clipRule: "evenodd", fillRule: "evenodd", fill: "#000" })));
};
Enlarge.propTypes = {
    className: PropTypes.string
};
module.exports = Enlarge;
//# sourceMappingURL=Enlarge.js.map

/***/ }),

/***/ 58332:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Expand = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-expand'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.expand)),
        React.createElement("path", { d: "M12.75 11.25V2h-1.5v9.25H2v1.5h9.25V22h1.5v-9.25H22v-1.5h-9.25Z", clipRule: "evenodd", fillRule: "evenodd", fill: "#fff" })));
};
Expand.propTypes = {
    className: PropTypes.string
};
module.exports = Expand;
//# sourceMappingURL=Expand.js.map

/***/ }),

/***/ 69192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Facebook = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-facebook'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.facebook)),
        React.createElement("path", { d: "M8.945 5.874v2.753H7v3.367h1.945V22h3.996V11.994h2.682s.251-1.614.372-3.379h-3.038V6.312c0-.343.435-.807.866-.807H16V2h-2.96C8.847 2 8.945 5.37 8.945 5.874Z", fill: "#000" })));
};
Facebook.propTypes = {
    className: PropTypes.string
};
module.exports = Facebook;
//# sourceMappingURL=Facebook.js.map

/***/ }),

/***/ 50694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Filmstrip = ({ color = 'black', ...otherProps }) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = otherProps;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-filmstrip-collapsed'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.filmstrip)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.25 2.25h11.5v19.5H2.25V2.25Zm1.5 1.5v16.5h8.5V3.75h-8.5Zm14-1.5v19.5h-1.5V2.25h1.5Zm4 19.5V2.25h-1.5v19.5h1.5Z", fill: color })));
};
Filmstrip.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = Filmstrip;
//# sourceMappingURL=Filmstrip.js.map

/***/ }),

/***/ 50907:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Flipboard = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-flipboard'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.flipboard)),
        React.createElement("path", { d: "M2 2v20h20V2H2Zm16 8h-4v4h-4v4H6V6h12v4Z", fill: "#000" })));
};
Flipboard.propTypes = {
    className: PropTypes.string
};
module.exports = Flipboard;
//# sourceMappingURL=Flipboard.js.map

/***/ }),

/***/ 39336:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Gallery = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-gallery'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.gallery)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M17.5 6.5h-13v9H6V8h11.5V6.5ZM19 8V5H3v12h3v2h15V8h-2ZM7.5 9.5h12v8h-12v-8Z", fill: "#000" })));
};
Gallery.propTypes = {
    className: PropTypes.string
};
module.exports = Gallery;
//# sourceMappingURL=Gallery.js.map

/***/ }),

/***/ 24596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const GoogleNews = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-googlenews'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.googlenews)),
        React.createElement("path", { d: "M19.722 19.5c0 .133-.054.26-.15.353a.518.518 0 0 1-.36.147H4.787a.518.518 0 0 1-.36-.147.495.495 0 0 1-.15-.353V8.833c0-.132.054-.26.15-.353a.518.518 0 0 1 .36-.147h14.425c.135 0 .265.053.36.147.096.094.15.22.15.353V19.5Zm-2.526-2.788v-.974a.063.063 0 0 0-.02-.047.067.067 0 0 0-.047-.019h-4.477v1.11h4.477a.07.07 0 0 0 .048-.02.066.066 0 0 0 .02-.047l-.001-.003Zm.68-2.109v-.98a.064.064 0 0 0-.018-.046.066.066 0 0 0-.047-.02h-5.16v1.11h5.159a.068.068 0 0 0 .047-.018.065.065 0 0 0 .02-.045v-.003.002Zm-.68-2.11v-.983a.064.064 0 0 0-.02-.046.067.067 0 0 0-.047-.02h-4.477v1.11h4.477a.068.068 0 0 0 .047-.018.065.065 0 0 0 .02-.046v.004Zm-8.405 1.174v1h1.475c-.121.61-.67 1.053-1.475 1.053-.909-.033-1.618-.78-1.584-1.67.032-.843.723-1.518 1.584-1.55.388-.006.763.137 1.044.4l.779-.76a2.65 2.65 0 0 0-1.823-.696c-1.504 0-2.724 1.193-2.724 2.665s1.22 2.665 2.724 2.665c1.574 0 2.61-1.083 2.61-2.607 0-.17-.015-.338-.043-.504l-2.567.004Zm-4.9-5.21c.001-.133.055-.26.15-.353a.519.519 0 0 1 .361-.147h10.13l-1.058-2.846a.489.489 0 0 0-.245-.28.506.506 0 0 0-.375-.032L2.306 8.555a.49.49 0 0 0-.268.262.474.474 0 0 0 0 .37l1.854 4.983V8.457Zm0 0c.001-.133.055-.26.15-.353a.519.519 0 0 1 .361-.147h10.13l-1.058-2.846a.489.489 0 0 0-.245-.28.506.506 0 0 0-.375-.032L2.306 8.555a.49.49 0 0 0-.268.262.474.474 0 0 0 0 .37l1.854 4.983V8.457Zm17.76-.254-7.335-1.93.626 1.684h4.653c.136 0 .265.053.36.147.097.093.15.22.15.353v7.17l1.873-6.82a.473.473 0 0 0-.036-.368.49.49 0 0 0-.29-.236ZM17.906 6.84V4.495a.492.492 0 0 0-.15-.35.515.515 0 0 0-.36-.145H6.604a.518.518 0 0 0-.36.143.497.497 0 0 0-.153.35v2.313l6.992-2.488a.505.505 0 0 1 .376.033c.116.06.203.162.243.284l.454 1.221 3.75.983Z", fill: "#000" })));
};
GoogleNews.propTypes = {
    className: PropTypes.string
};
module.exports = GoogleNews;
//# sourceMappingURL=GoogleNews.js.map

/***/ }),

/***/ 49776:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Grid = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-grid'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.grid)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.5 3.5h6v6h-6v-6ZM2 11V2h9v9H2Zm1.5 3.5h6v6h-6v-6ZM2 22v-9h9v9H2ZM20.5 3.5h-6v6h6v-6ZM13 2v9h9V2h-9Zm1.5 12.5h6v6h-6v-6ZM13 22v-9h9v9h-9Z", fill: "#000" })));
};
Grid.propTypes = {
    className: PropTypes.string
};
module.exports = Grid;
//# sourceMappingURL=Grid.js.map

/***/ }),

/***/ 53636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.headphoneIconTitle] - Optional prop to show custom title
 */
const Headphone = (props) => {
    const { formatMessage } = useIntl();
    const { headphoneIconTitle, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-headphone'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, headphoneIconTitle || formatMessage(translations.headphone)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2C6.476 2 2 6.476 2 12v4.562C2 19.532 4.469 22 7.438 22h.875v-1.57a2.186 2.186 0 0 0 1.369-2.043v-3.65c0-.894-.532-1.712-1.369-2.042v-1.57h-.875c-1.45 0-2.726.532-3.687 1.414V12c0-4.513 3.736-8.25 8.249-8.25s8.25 3.737 8.25 8.25v.539a5.393 5.393 0 0 0-3.688-1.414h-.875v1.57a2.186 2.186 0 0 0-1.369 2.042v3.65c0 .895.532 1.712 1.369 2.043V22h.875C19.532 22 22 19.531 22 16.562V12c0-5.524-4.476-10-10-10Z", fill: "#000" })));
};
Headphone.propTypes = {
    className: PropTypes.string,
    headphoneIconTitle: PropTypes.string
};
module.exports = Headphone;
//# sourceMappingURL=Headphone.js.map

/***/ }),

/***/ 7994:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Instagram = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-instagram'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.instagram)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 2c2.716 0 3.056.013 4.122.06 1.066.049 1.792.217 2.428.465a4.884 4.884 0 0 1 1.771 1.154 4.873 4.873 0 0 1 1.154 1.771c.247.636.416 1.362.465 2.428.049 1.066.06 1.406.06 4.122s-.012 3.056-.06 4.122c-.049 1.066-.218 1.792-.465 2.428a4.9 4.9 0 0 1-1.154 1.771 4.874 4.874 0 0 1-1.771 1.154c-.636.247-1.363.416-2.428.465-1.066.049-1.406.06-4.122.06s-3.056-.012-4.122-.06c-1.066-.049-1.792-.218-2.428-.465a4.901 4.901 0 0 1-1.771-1.154 4.9 4.9 0 0 1-1.154-1.771c-.248-.636-.416-1.363-.465-2.428C2.013 15.056 2 14.716 2 12s.013-3.056.06-4.122c.049-1.066.217-1.792.465-2.428a4.884 4.884 0 0 1 1.154-1.771A4.874 4.874 0 0 1 5.45 2.525c.636-.248 1.362-.416 2.428-.465C8.944 2.013 9.284 2 12 2Zm0 2.5c-2.443 0-2.732.009-3.696.054-.893.04-1.377.188-1.7.315-.397.146-.756.38-1.05.684-.322.32-.52.625-.685 1.052-.125.322-.275.806-.315 1.699C4.509 9.267 4.5 9.557 4.5 12c0 2.443.009 2.732.054 3.696.04.893.188 1.377.315 1.7.165.427.364.732.684 1.05.32.321.625.52 1.052.685.322.125.806.275 1.699.315.963.045 1.253.054 3.696.054 2.443 0 2.732-.009 3.696-.054.893-.04 1.377-.189 1.7-.315a2.811 2.811 0 0 0 1.05-.683c.321-.32.52-.625.685-1.053.125-.322.275-.806.315-1.699.045-.963.054-1.253.054-3.696 0-2.443-.009-2.732-.054-3.696-.04-.893-.189-1.377-.315-1.7a2.835 2.835 0 0 0-.683-1.05 2.834 2.834 0 0 0-1.053-.685c-.322-.125-.806-.275-1.699-.315C14.733 4.509 14.443 4.5 12 4.5Zm0 2.21a5.29 5.29 0 1 1 0 10.58 5.29 5.29 0 0 1 0-10.58Zm0 8.25a2.96 2.96 0 1 0 0-5.92 2.96 2.96 0 0 0 0 5.92Zm6.625-8.148a1.438 1.438 0 1 1-2.876 0 1.438 1.438 0 0 1 2.876 0Z", fill: "black" })));
};
Instagram.propTypes = {
    className: PropTypes.string
};
module.exports = Instagram;
//# sourceMappingURL=Instagram.js.map

/***/ }),

/***/ 79350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LargeChevron = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-large-chevron'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.largechevron)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m2.47 8.53 1.06-1.06L12 15.94l8.47-8.47 1.06 1.06L12 18.06 2.47 8.53Z", fill: "#000" })));
};
LargeChevron.propTypes = {
    className: PropTypes.string
};
module.exports = LargeChevron;
//# sourceMappingURL=LargeChevron.js.map

/***/ }),

/***/ 65234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LeftChevron = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-left_chevron'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevron)),
        React.createElement("path", { d: "M16 21L7 12L16 3", stroke: "black", strokeWidth: "1.5" })));
};
LeftChevron.propTypes = {
    className: PropTypes.string
};
module.exports = LeftChevron;
//# sourceMappingURL=LeftChevron.js.map

/***/ }),

/***/ 35483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Like = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-like'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.like)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m10.924 7.233 1.085-1.036 1.1 1.02-1.085 1.168-1.1-1.152Zm2.097-2.15c-.644.718-1.012 1.114-1.012 1.114s-.377-.395-1.017-1.11c-.19-.212-.402-.452-.635-.718C9.53 3.59 8.544 3 7.51 3 4.466 3 2 5.633 2 8.877a6.129 6.129 0 0 0 .969 3.332c.617.957 3.276 3.862 7.993 8.716.338.348.687.707 1.047 1.075l1.045-1.077c4.701-4.853 7.36-7.757 7.977-8.714A6.13 6.13 0 0 0 22 8.877C22 5.632 19.534 3 16.491 3c-1.035 0-2.075.517-2.832 1.37l-.638.714Zm6.75 6.313c-.247.382-1.065 1.353-2.595 3.013a315.438 315.438 0 0 1-5.169 5.44 306.64 306.64 0 0 1-5.182-5.44c-1.531-1.66-2.348-2.63-2.595-3.012a4.629 4.629 0 0 1-.73-2.514v-.006C3.5 6.368 5.385 4.5 7.509 4.5c.463 0 1.076.274 1.77.914a77.68 77.68 0 0 0 1.61 1.783l.025.026.01.01 1.085-1.036 1.1 1.02.03-.033.087-.094.33-.361c.287-.316.703-.777 1.224-1.364.519-.584 1.17-.865 1.711-.865 2.124 0 4.009 1.867 4.009 4.377a4.63 4.63 0 0 1-.73 2.518Z", fill: "#000" })));
};
Like.propTypes = {
    className: PropTypes.string
};
module.exports = Like;
//# sourceMappingURL=Like.js.map

/***/ }),

/***/ 74771:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LikeFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-like-filled'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.likeFilled)),
        React.createElement("path", { d: "M21.25 8.877a5.38 5.38 0 0 1-.849 2.925c-.29.448-1.157 1.47-2.673 3.116-1.396 1.514-3.301 3.515-5.72 6.007-2.427-2.492-4.337-4.494-5.734-6.008-1.519-1.646-2.386-2.667-2.674-3.114a5.378 5.378 0 0 1-.85-2.923v-.003c0-2.876 2.176-5.127 4.759-5.127.746 0 1.545.428 2.308 1.14.462.534.842 1.093 1.11 1.525a12.287 12.287 0 0 1 .388.676l.019.036.004.008v.001l.68 1.359.665-1.366v-.001l.004-.008.018-.035.076-.145a11.115 11.115 0 0 1 1.438-2.073c.638-.718 1.484-1.117 2.272-1.117 2.584 0 4.759 2.25 4.759 5.127Z", fill: "#000", stroke: "#000", strokeWidth: "1.5" })));
};
LikeFilled.propTypes = {
    className: PropTypes.string
};
module.exports = LikeFilled;
//# sourceMappingURL=LikeFilled.js.map

/***/ }),

/***/ 8990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Line = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-line'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.line)),
        React.createElement("path", { d: "M22 10.09C22 5.63 17.514 2 12 2S2 5.63 2 10.09c0 4 3.557 7.35 8.363 7.984.325.07.769.214.88.492.102.252.067.646.033.901l-.142.854c-.043.252-.2.985.866.537 1.068-.448 5.759-3.381 7.857-5.789C21.307 13.485 22 11.877 22 10.091ZM8.472 12.474a.194.194 0 0 1-.195.194H5.475a.193.193 0 0 1-.195-.193V8.129c0-.107.088-.194.195-.194h.701c.108 0 .195.087.195.194v3.45h1.906c.107 0 .195.087.195.195v.699Zm1.69 0a.194.194 0 0 1-.194.195h-.701a.194.194 0 0 1-.195-.194V8.129c0-.107.087-.194.195-.194h.701c.108 0 .195.087.195.194v4.345Zm4.829 0a.194.194 0 0 1-.195.195h-.701a.2.2 0 0 1-.16-.082l-2-2.692v2.58a.194.194 0 0 1-.195.194h-.701a.194.194 0 0 1-.195-.194V8.13c0-.107.087-.194.195-.194h.7c.066 0 .128.03.162.087l1.996 2.689V8.129c0-.107.088-.194.195-.194h.701c.108 0 .195.087.195.194l.003 4.345Zm3.873-3.644a.194.194 0 0 1-.194.194h-1.907v.734h1.907c.107 0 .194.087.194.195v.7a.194.194 0 0 1-.194.193h-1.907v.735h1.907c.107 0 .194.086.194.194v.699a.194.194 0 0 1-.194.194h-2.802a.198.198 0 0 1-.195-.194V8.13c0-.106.09-.194.195-.194h2.802c.107 0 .194.087.194.194v.699Z", fill: "#000" })));
};
Line.propTypes = {
    className: PropTypes.string
};
module.exports = Line;
//# sourceMappingURL=Line.js.map

/***/ }),

/***/ 25534:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LinkedIn = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-linkedin'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.linkedIn)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22 22h-4.13v-6.485c0-1.547-.03-3.535-2.147-3.535-2.151 0-2.48 1.685-2.48 3.424V22H9.112V8.666h3.966v1.82h.054c.552-1.048 1.9-2.153 3.911-2.153 4.185 0 4.957 2.762 4.957 6.352V22ZM4.456 6.807a2.391 2.391 0 0 1-2.268-1.47 2.41 2.41 0 0 1 1.333-3.17 2.391 2.391 0 0 1 2.592.558 2.408 2.408 0 0 1 0 3.358 2.394 2.394 0 0 1-1.657.724ZM2.386 22H6.52V8.666H2.386V22Z", fill: "#000" })));
};
LinkedIn.propTypes = {
    className: PropTypes.string
};
module.exports = LinkedIn;
//# sourceMappingURL=LinkedIn.js.map

/***/ }),

/***/ 61852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const List = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-list'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.list)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22 3.25H5v1.5h17v-1.5Zm0 8H5v1.5h17v-1.5Zm-20 0h1.438v1.5H2v-1.5Zm1.438-8H2v1.5h1.438v-1.5ZM5 19.25h17v1.5H5v-1.5Zm-1.563 0H2v1.5h1.438v-1.5Z", fill: "#000" })));
};
List.propTypes = {
    className: PropTypes.string
};
module.exports = List;
//# sourceMappingURL=List.js.map

/***/ }),

/***/ 30110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Maximize = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-maximize'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.maximize)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 2.25H2.25V10h1.5V3.75H10v-1.5Zm4 18h6.25V14h1.5v7.75H14v-1.5Zm6.25-16.5V10h1.5V2.25H14v1.5h6.25ZM3.75 14v6.25H10v1.5H2.25V14h1.5Z", fill: "#000" })));
};
Maximize.propTypes = {
    className: PropTypes.string
};
module.exports = Maximize;
//# sourceMappingURL=Maximize.js.map

/***/ }),

/***/ 15447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Menu = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-menu'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.menu)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 3.25h20v1.5H2v-1.5Zm0 8h20v1.5H2v-1.5Zm20 8H2v1.5h20v-1.5Z", fill: "#000" })));
};
Menu.propTypes = {
    className: PropTypes.string
};
module.exports = Menu;
//# sourceMappingURL=Menu.js.map

/***/ }),

/***/ 28828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * Native share icon.
 *
 * @param {string}  [className] - classes for svg
 * @param {func}    [onIconClick] - onClick hadler
 * @returns {ReactElement} child components
 */
const NativeShare = ({ className = '', onIconClick = () => { }, onKeyDown = () => { }, tabIndex = '-1' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: `icon ${className}`, viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", focusable: "false", onClick: onIconClick, onKeyDown: onKeyDown, tabIndex: tabIndex },
        React.createElement("title", null, formatMessage(translations.nativeShare)),
        React.createElement("path", { d: "M18 8a3 3 0 1 0-2.947-2.438L7.939 9.71a3 3 0 1 0 0 4.578l7.114 4.15a3 3 0 1 0 1.008-1.727l-7.113-4.15c.07-.371.07-.753 0-1.124L16.06 7.29c.524.442 1.2.71 1.94.71Z", fill: "#000" })));
};
NativeShare.propTypes = {
    className: PropTypes.string,
    onIconClick: PropTypes.func,
    onKeyDown: PropTypes.func,
    tabIndex: PropTypes.string
};
module.exports = NativeShare;
//# sourceMappingURL=NativeShare.js.map

/***/ }),

/***/ 60779:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Newsletter = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-newsletter'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.newsletter)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.75 3.25H3.25v7h-1v11.5h19.5v-11.5h-1v-7Zm-1.5 8.16V4.75H4.75v6.66L12 17.05l7.25-5.64ZM16 8.799H8v-1.5h8v1.5ZM3.75 20.25v-7.717L12 18.95l8.25-6.416v7.716H3.75ZM8 12.75h8v-1.5H8v1.5Z", fill: "#000" })));
};
Newsletter.propTypes = {
    className: PropTypes.string
};
module.exports = Newsletter;
//# sourceMappingURL=Newsletter.js.map

/***/ }),

/***/ 65102:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const NewsletterArrow = (props) => {
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-newsletter icon-newsletter-arrow'), viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("g", null,
            React.createElement("mask", { id: "path-1-inside-1_285_2455", fill: "white" },
                React.createElement("path", { d: "M17.1133 15.7394V17.0546L18.399 15.7394H17.1133ZM5.25 4.80603L16.1786 16.6424L18.048 14.8364L7.11946 3L5.25 4.80603ZM18.399 15.7394V6.95756H15.8276V15.7394H18.399ZM17.1133 14.4242H8.56434V17.0546H17.1133V14.4242Z" })),
            React.createElement("path", { d: "M17.1133 15.7394V17.0546L18.399 15.7394H17.1133ZM5.25 4.80603L16.1786 16.6424L18.048 14.8364L7.11946 3L5.25 4.80603ZM18.399 15.7394V6.95756H15.8276V15.7394H18.399ZM17.1133 14.4242H8.56434V17.0546H17.1133V14.4242Z", fill: "black" }),
            React.createElement("path", { d: "M17.1133 15.7394V14.7394H16.1133V15.7394H17.1133ZM17.1133 17.0546V18.0546H17.5342L17.8284 17.7536L17.1133 17.0546ZM18.399 15.7394L19.1141 16.4385L19.399 16.147V15.7394H18.399ZM5.25 4.80603L4.5552 4.08683L3.85207 4.7661L4.51528 5.4844L5.25 4.80603ZM16.1786 16.6424L15.4439 17.3208L16.1377 18.0723L16.8734 17.3616L16.1786 16.6424ZM18.048 14.8364L18.7428 15.5556L19.4459 14.8764L18.7827 14.158L18.048 14.8364ZM7.11946 3L7.85419 2.32163L7.16031 1.57011L6.42466 2.2808L7.11946 3ZM18.399 6.95756H19.399V5.95756H18.399V6.95756ZM15.8276 6.95756V5.95756H14.8276V6.95756H15.8276ZM15.8276 15.7394H14.8276V16.7394H15.8276V15.7394ZM17.1133 14.4242H18.1133V13.4242H17.1133V14.4242ZM8.56434 14.4242V13.4242H7.56434V14.4242H8.56434ZM8.56434 17.0546H7.56434V18.0546H8.56434V17.0546ZM16.1133 15.7394V17.0546H18.1133V15.7394H16.1133ZM17.8284 17.7536L19.1141 16.4385L17.684 15.0403L16.3982 16.3555L17.8284 17.7536ZM18.399 14.7394H17.1133V16.7394H18.399V14.7394ZM4.51528 5.4844L15.4439 17.3208L16.9133 15.964L5.98472 4.12766L4.51528 5.4844ZM16.8734 17.3616L18.7428 15.5556L17.3532 14.1172L15.4838 15.9232L16.8734 17.3616ZM18.7827 14.158L7.85419 2.32163L6.38474 3.67837L17.3133 15.5148L18.7827 14.158ZM6.42466 2.2808L4.5552 4.08683L5.9448 5.52524L7.81426 3.7192L6.42466 2.2808ZM19.399 15.7394V6.95756H17.399V15.7394H19.399ZM18.399 5.95756H15.8276V7.95756H18.399V5.95756ZM14.8276 6.95756V15.7394H16.8276V6.95756H14.8276ZM15.8276 16.7394H18.399V14.7394H15.8276V16.7394ZM17.1133 13.4242H8.56434V15.4242H17.1133V13.4242ZM7.56434 14.4242V17.0546H9.56434V14.4242H7.56434ZM8.56434 18.0546H17.1133V16.0546H8.56434V18.0546ZM18.1133 17.0546V14.4242H16.1133V17.0546H18.1133Z", fill: "black", mask: "url(#path-1-inside-1_285_2455)" }),
            React.createElement("path", { d: "M3 21H21H3Z", fill: "black" }),
            React.createElement("path", { d: "M3 21H21", stroke: "black" })),
        React.createElement("g", null,
            React.createElement("path", { d: "M0 28H28", stroke: "black", strokeWidth: "2" }))));
};
NewsletterArrow.propTypes = {
    className: PropTypes.string
};
module.exports = NewsletterArrow;
//# sourceMappingURL=NewsletterArrow.js.map

/***/ }),

/***/ 22650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const OK = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-ok'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ok)),
        React.createElement("path", { d: "M16.954 7.162a5.166 5.166 0 0 1-5.162 5.16 5.166 5.166 0 0 1-5.162-5.16A5.168 5.168 0 0 1 11.793 2a5.167 5.167 0 0 1 5.162 5.162Zm-3.024 0a2.14 2.14 0 0 0-2.138-2.137 2.14 2.14 0 0 0-2.136 2.137A2.14 2.14 0 0 0 11.792 9.3a2.14 2.14 0 0 0 2.138-2.137Zm-.05 9.37 2.885 2.887a1.51 1.51 0 0 1 0 2.138v.001a1.51 1.51 0 0 1-2.136-.001l-2.837-2.836-2.835 2.836a1.512 1.512 0 0 1-2.14-2.139l2.886-2.886a9.671 9.671 0 0 1-2.996-1.24 1.512 1.512 0 0 1-.474-2.086v-.002a1.511 1.511 0 0 1 2.085-.473 6.555 6.555 0 0 0 6.949 0l.001-.001a1.512 1.512 0 0 1 1.61 2.561c-.922.58-1.936 1-2.998 1.241Z", fill: "black", fillRule: "evenodd", clipRule: "evenodd" })));
};
OK.propTypes = {
    className: PropTypes.string
};
module.exports = OK;
//# sourceMappingURL=OK.js.map

/***/ }),

/***/ 13150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Share = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-paperclip'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.share)),
        React.createElement("g", { clipPath: "url(#clip0_81_1090)" },
            React.createElement("path", { d: "M4.71 12C4.71 10.461 5.961 9.21 7.5 9.21H11.1V7.5H7.5C5.016 7.5 3 9.516 3 12C3 14.484 5.016 16.5 7.5 16.5H11.1V14.79H7.5C5.961 14.79 4.71 13.539 4.71 12ZM8.4 12.9H15.6V11.1H8.4V12.9ZM16.5 7.5H12.9V9.21H16.5C18.039 9.21 19.29 10.461 19.29 12C19.29 13.539 18.039 14.79 16.5 14.79H12.9V16.5H16.5C18.984 16.5 21 14.484 21 12C21 9.516 18.984 7.5 16.5 7.5Z", fill: "black" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "clip0_81_1090" },
                React.createElement("rect", { width: "18", height: "9", fill: "white", transform: "translate(3 7.5)" })))));
};
Share.propTypes = {
    className: PropTypes.string
};
module.exports = Share;
//# sourceMappingURL=Paperclip.js.map

/***/ }),

/***/ 57946:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Passkey = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-passkey'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.passkey)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.87 12.894s.007 1.573.66 2.283c.697.758 1.411.94 1.411.94v3.765H2V17.53c0-3.129 6.27-4.705 9.412-4.705.376 0 1 .023 1.459.07Zm3.248-6.188c0 2.6-2.106 4.706-4.706 4.706a4.705 4.705 0 0 1-4.706-4.706C6.706 4.106 8.812 2 11.412 2c2.6 0 4.706 2.106 4.706 4.706Zm2.627 2.824c-1.831.02-3.312 1.462-3.333 3.24a3.084 3.084 0 0 0 2.022 2.954l-.058 4.77a.465.465 0 0 0 .152.367l.863.82a.336.336 0 0 0 .454-.01l1.607-1.566c.143-.144.14-.34.006-.476l-.907-.874 1.301-1.273a.318.318 0 0 0-.004-.466l-1.236-1.214c1.52-.641 2.372-1.776 2.388-3.107.021-1.774-1.43-3.186-3.255-3.165Zm1.373 3.294a1.412 1.412 0 1 1-2.824 0 1.412 1.412 0 0 1 2.824 0Z", fill: "#000" })));
};
Passkey.propTypes = {
    className: PropTypes.string
};
module.exports = Passkey;
//# sourceMappingURL=Passkey.js.map

/***/ }),

/***/ 13148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Pause = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-pause'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.pause)),
        React.createElement("g", { fillRule: "nonzero" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10 6H7v12h3V6Zm4 0h3v12h-3V6Z", fill: "#000" }))));
};
Pause.propTypes = {
    className: PropTypes.string
};
module.exports = Pause;
//# sourceMappingURL=Pause.js.map

/***/ }),

/***/ 5232:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const PhotoStack = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-photoStack'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.photoStack)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.25 2.25h13.5v13.5H2.25V2.25Zm1.5 1.5v10.5h10.5V3.75H3.75Z", fill: "#0879BF" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18.75 3v15.75H3v-1.5h14.25V3h1.5Z", fill: "#0879BF" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.75 6v15.75H6v-1.5h14.25V6h1.5Z", fill: "#0879BF" })));
};
PhotoStack.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = PhotoStack;
//# sourceMappingURL=PhotoStack.js.map

/***/ }),

/***/ 24888:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Pinterest = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-pinterest'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.pinterest)),
        React.createElement("path", { d: "M10.46 15.06c-.47 2.056-.93 4.037-1.932 5.6-.307.479-.616 1.081-1.141 1.34-.775-3.991.846-7.35 1.486-10.705-.816-1.666-.308-4.488 1.44-4.808 2.533-.462 1.865 2.593 1.436 4.013-.237.78-.66 1.526-.597 2.381.141 1.801 2.408 1.919 3.569.99 1.665-1.326 2.147-3.89 1.983-5.996-.246-3.206-3.877-4.8-7.085-3.519-1.653.66-3.153 2.179-3.37 4.41-.113 1.175.133 2.114.596 2.777.068.1.308.278.345.547.072.543-.25 1.127-.546 1.533-1.642-.473-2.49-1.947-2.625-3.813-.312-4.25 3.178-7.48 7.282-7.783 4.383-.32 7.856 2.21 8.179 5.898.24 2.741-.734 5.5-2.28 6.986-1.162 1.115-3.63 2.209-5.65 1.141-.446-.237-.646-.527-1.09-.992Z", fill: "black" })));
};
Pinterest.propTypes = {
    className: PropTypes.string
};
module.exports = Pinterest;
//# sourceMappingURL=Pinterest.js.map

/***/ }),

/***/ 11118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Play = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-play'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.play)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m4 2 17 10L4 22V2Z" })));
};
Play.propTypes = {
    className: PropTypes.string
};
module.exports = Play;
//# sourceMappingURL=Play.js.map

/***/ }),

/***/ 25856:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const PlayOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-play-outlined'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playOutlined)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 2v20l17-10L4 2Zm1.5 2.623v14.754L18.041 12 5.5 4.623Z" })));
};
PlayOutlined.propTypes = {
    className: PropTypes.string
};
module.exports = PlayOutlined;
//# sourceMappingURL=PlayOutlined.js.map

/***/ }),

/***/ 85026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const PlaylistIcon = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-playlist'), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playlist)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M18 3.25H2v1.5h16v-1.5Zm0 6H2v1.5h16v-1.5Zm-16 6h10.667v1.5H2v-1.5ZM22 17l-7-4v8l7-4Z", fill: "#000" })));
};
PlaylistIcon.propTypes = {
    className: PropTypes.string
};
module.exports = PlaylistIcon;
//# sourceMappingURL=Playlist.js.map

/***/ }),

/***/ 40641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Print = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-print'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.print)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.25 2.25h11.5v5h4v10.5h-4v4H6.25v-4h-4V7.25h4v-5Zm0 14v-3h11.5v3h2.5v-7.5H3.75v7.5h2.5Zm10-12.5v3.5h-8.5v-3.5h8.5Zm-8.5 16.5v-5.5h8.5v5.5h-8.5Z", fill: "#000" })));
};
Print.propTypes = {
    className: PropTypes.string
};
module.exports = Print;
//# sourceMappingURL=Print.js.map

/***/ }),

/***/ 35149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-rating-filled'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ratingFilled)),
        React.createElement("path", { d: "M12 18.532 5.82 22l1.226-7.252L2 9.637l6.939-1.012L12 2l3.061 6.625L22 9.639l-5.046 5.109L18.18 22 12 18.532Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
RatingFilled.propTypes = {
    className: PropTypes.string
};
module.exports = RatingFilled;
//# sourceMappingURL=RatingFilled.js.map

/***/ }),

/***/ 36928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingHalf = ({ className, primaryFill = '#000', secondaryFill = '#fff' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: classnames('icon icon-rating-half', className), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg" },
        React.createElement("title", null, formatMessage(translations.ratingHalf)),
        React.createElement("path", { fill: primaryFill, d: "M7.413 13.988a.787.787 0 0 1 .262.862L5.663 21.4a.463.463 0 0 0 .275.575.411.411 0 0 0 .4-.062l5.225-4.013a.738.738 0 0 1 .437-.15V2a.45.45 0 0 0-.387.313L9.6 8.638a.737.737 0 0 1-.687.525H2.438a.437.437 0 0 0-.438.45.425.425 0 0 0 .175.362l5.238 4.013Z" }),
        React.createElement("path", { fill: secondaryFill, d: "m12.438 17.9 5.225 4.013a.424.424 0 0 0 .612-.1.514.514 0 0 0 .063-.413l-2.013-6.55a.787.787 0 0 1 .263-.862l5.237-4.013a.463.463 0 0 0-.059-.767.4.4 0 0 0-.19-.045h-6.45a.737.737 0 0 1-.7-.525l-2.013-6.325A.412.412 0 0 0 12 2v15.75a.738.738 0 0 1 .438.15Z" })));
};
RatingHalf.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = RatingHalf;
//# sourceMappingURL=RatingHalf.js.map

/***/ }),

/***/ 85323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const RatingOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-rating-outlined'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ratingOutlined)),
        React.createElement("path", { d: "M12.367 17.8784L12 17.6725L11.633 17.8784L6.82068 20.5783L7.78586 14.8726L7.84994 14.4938L7.57994 14.2204L3.57577 10.1668L9.04719 9.36839L9.44932 9.30971L9.61976 8.94078L12.0001 3.78822L14.3803 8.93958L14.5507 9.30839L14.9527 9.36712L20.4245 10.1665L16.4201 14.2204L16.1501 14.4938L16.2141 14.8726L17.1793 20.5783L12.367 17.8784Z", fillRule: "evenodd", stroke: "#000", strokeWidth: "1.5" })));
};
RatingOutlined.propTypes = {
    className: PropTypes.string
};
module.exports = RatingOutlined;
//# sourceMappingURL=RatingOutlined.js.map

/***/ }),

/***/ 81055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Replay = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-replay'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.replay)),
        React.createElement("path", { d: "M7.216 11.076C7.649 8.048 10.18 5.75 13.2 5.75c3.321 0 6.05 2.778 6.05 6.25s-2.729 6.25-6.05 6.25a5.93 5.93 0 0 1-4.226-1.778l-1.066 1.056A7.43 7.43 0 0 0 13.2 19.75c4.19 0 7.55-3.49 7.55-7.75s-3.36-7.75-7.55-7.75c-3.662 0-6.69 2.665-7.395 6.18L4.273 8.091l-1.248.818 3.113 4.751 4.616-3.205-.86-1.239-2.678 1.86Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Replay.propTypes = {
    className: PropTypes.string
};
module.exports = Replay;
//# sourceMappingURL=Replay.js.map

/***/ }),

/***/ 29454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Rss = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-rss'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.rss)),
        React.createElement("path", { d: "M4.75 16.5c1.5 0 2.5 1.25 2.75 2.75 0 1.5-1.25 2.75-2.75 2.75S2 20.75 2 19.25s1.25-2.75 2.75-2.75Zm-2.5-7.75c7.25 0 13 5.75 13 13V22H11.5v-.25c0-5-4-9.25-9.25-9.25H2l.25-3.75Zm0-6.75C13 2 22 10.75 22 21.75V22h-3.75v-.25c0-8.75-7.25-16-16-16H2L2.25 2Z" })));
};
Rss.propTypes = {
    className: PropTypes.string
};
module.exports = Rss;
//# sourceMappingURL=Rss.js.map

/***/ }),

/***/ 36652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Search = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-search'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.search)),
        React.createElement("path", { d: "M17.5 10.5a7 7 0 1 1-14 0 7 7 0 0 1 14 0Zm-1.543 6.517a8.5 8.5 0 1 1 1.06-1.06l5.013 5.013-1.06 1.06-5.013-5.013Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Search.propTypes = {
    className: PropTypes.string
};
module.exports = Search;
//# sourceMappingURL=Search.js.map

/***/ }),

/***/ 69657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * Share icon.
 *
 * @param {string}  [color] - color to fill
 * @param {string}  [className] - classes for svg
 * @param {func}    [onIconClick] - onClick hadler
 * @returns {ReactElement} child components
 */
const Share = ({ color = '#000000', className = '', onIconClick = () => { }, onKeyDown = () => { }, tabIndex = '-1' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: `icon ${className}`, viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", focusable: "false", onClick: onIconClick, onKeyDown: onKeyDown, tabIndex: tabIndex },
        React.createElement("title", null, formatMessage(translations.share)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.53 6.47 12 1.94 7.47 6.47l1.06 1.06 2.72-2.72V16h1.5V4.81l2.72 2.72 1.06-1.06ZM5.25 10.25H9v1.5H6.75v8.5h10.5v-8.5H15v-1.5h3.75v11.5H5.25v-11.5Z", fill: color })));
};
Share.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string,
    onIconClick: PropTypes.func,
    onKeyDown: PropTypes.func,
    tabIndex: PropTypes.string
};
module.exports = Share;
//# sourceMappingURL=Share.js.map

/***/ }),

/***/ 64964:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Shopping = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-shopping'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.shopping)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.75 7a3.25 3.25 0 0 1 6.5 0h-6.5Zm-1.5 0a4.75 4.75 0 0 1 9.5 0H22v14H2V7h5.25ZM3.5 19.5v-11h17v11h-17Z", fill: "#000" })));
};
Shopping.propTypes = {
    className: PropTypes.string
};
module.exports = Shopping;
//# sourceMappingURL=Shopping.js.map

/***/ }),

/***/ 20855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const SlimHeadphone = (props) => {
    const { formatMessage } = useIntl();
    const { title, ...attrs } = props;
    const className = '';
    return (React.createElement("svg", { className: `icon ${className}`, width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", focusable: "false", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.headphone)),
        React.createElement("mask", { id: "a", fill: "#fff" },
            React.createElement("path", { d: "M20.457 11.474a8.421 8.421 0 1 0-16.842 0V17H2.562v-5.526a9.474 9.474 0 1 1 18.948 0V17h-1.053v-5.526Z" })),
        React.createElement("path", { d: "M2.563 17h-1.5v1.5h1.5V17Zm1.052 0v1.5h1.5V17h-1.5Zm16.842 0h-1.5v1.5h1.5V17Zm1.053 0v1.5h1.5V17h-1.5ZM12.036 4.553a6.921 6.921 0 0 1 6.921 6.92h3c0-5.479-4.442-9.92-9.92-9.92v3Zm-6.92 6.92a6.921 6.921 0 0 1 6.92-6.92v-3c-5.48 0-9.92 4.441-9.92 9.92h3Zm6.92-7.973a7.974 7.974 0 0 1 7.974 7.974h3C23.01 5.414 18.097.5 12.036.5v3Zm-7.973 7.974A7.974 7.974 0 0 1 12.035 3.5v-3C5.976.5 1.063 5.413 1.063 11.474h3Zm-3 0V17h3v-5.526h-3Zm1.052 0V17h3v-5.526h-3Zm.447 7.026h1.053v-3H2.562v3Zm16.395-7.026V17h3v-5.526h-3Zm1.5 7.026h1.053v-3h-1.053v3ZM23.01 17v-5.526h-3V17h3Z", fill: "#000", mask: "url(#a)" }),
        React.createElement("mask", { id: "b", fill: "#fff" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.826 12.555v9.416a4.737 4.737 0 1 1 0-9.416Z" })),
        React.createElement("path", { d: "m7.826 21.971.164 1.49 1.336-.147v-1.343h-1.5Zm0-9.416h1.5v-1.343l-1.336-.148-.164 1.491Zm1.5 9.416v-9.416h-3v9.416h3ZM7.66 20.48a3.28 3.28 0 0 1-.362.02v3c.233 0 .464-.013.691-.038l-.33-2.982Zm-.362.02a3.237 3.237 0 0 1-3.237-3.237h-3A6.237 6.237 0 0 0 7.3 23.5v-3Zm-3.237-3.237A3.237 3.237 0 0 1 7.3 14.026v-3a6.237 6.237 0 0 0-6.237 6.237h3ZM7.3 14.026c.123 0 .244.007.362.02l.33-2.982a6.273 6.273 0 0 0-.692-.038v3Z", fill: "#000", mask: "url(#b)" }),
        React.createElement("mask", { id: "c", fill: "#fff" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.247 21.971v-9.416a4.737 4.737 0 1 1 0 9.416Z" })),
        React.createElement("path", { d: "m16.247 12.555-.165-1.49-1.335.147v1.343h1.5Zm0 9.416h-1.5v1.343l1.335.148.165-1.49Zm-1.5-9.416v9.416h3v-9.416h-3Zm1.665 1.491c.118-.013.238-.02.361-.02v-3c-.233 0-.464.013-.691.038l.33 2.982Zm.361-.02a3.237 3.237 0 0 1 3.237 3.237h3a6.237 6.237 0 0 0-6.237-6.237v3Zm3.237 3.237a3.237 3.237 0 0 1-3.237 3.237v3a6.237 6.237 0 0 0 6.237-6.237h-3ZM16.773 20.5c-.123 0-.243-.007-.361-.02l-.33 2.982c.227.025.458.038.691.038v-3Z", fill: "#000", mask: "url(#c)" }),
        React.createElement("path", { d: "M6.773 13.579a3.158 3.158 0 0 1 3.158 3.158v1.052a3.158 3.158 0 0 1-3.158 3.158V13.58ZM17.3 20.947a3.158 3.158 0 0 1-3.159-3.158v-1.052a3.158 3.158 0 0 1 3.158-3.158v7.368Z", fill: "#000" })));
};
SlimHeadphone.propTypes = {
    title: PropTypes.string
};
module.exports = SlimHeadphone;
//# sourceMappingURL=SlimHeadphone.js.map

/***/ }),

/***/ 74170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Snapchat = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-snapchat'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.snapchat)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.193 2h-.05l-.346.004c-.825 0-3.622.233-4.94 3.236-.444 1.01-.339 2.728-.252 4.106l.03.495a.787.787 0 0 1-.388.087c-.264 0-.573-.084-.922-.25a.732.732 0 0 0-.317-.066c-.407 0-.896.273-.97.678-.056.293.073.72 1 1.091.083.035.183.066.29.1.382.124.961.31 1.118.685.081.195.049.446-.097.745l-.009.02c-.05.121-1.275 2.955-3.993 3.41a.413.413 0 0 0-.256.152.426.426 0 0 0-.09.287.528.528 0 0 0 .044.188c.204.484 1.065.84 2.631 1.087.052.072.107.326.14.48.033.153.066.31.115.477.047.163.169.36.485.36.127 0 .278-.031.45-.066.263-.05.62-.123 1.067-.123.248 0 .505.023.765.066.505.085.935.395 1.432.751.713.512 1.519 1.09 2.745 1.09.035 0 .069 0 .102-.003.04.003.09.004.146.004 1.228 0 2.034-.58 2.744-1.09.5-.357.929-.667 1.435-.752.258-.043.515-.066.765-.066.426 0 .764.056 1.065.115.188.038.34.057.451.057h.024a.447.447 0 0 0 .294-.09.459.459 0 0 0 .168-.261c.047-.163.08-.317.114-.471.033-.155.088-.408.14-.48 1.567-.247 2.428-.6 2.631-1.083a.568.568 0 0 0 .045-.191.424.424 0 0 0-.09-.288.413.413 0 0 0-.257-.151c-2.72-.454-3.942-3.289-3.992-3.409a.297.297 0 0 0-.01-.02c-.146-.299-.177-.55-.096-.745.157-.375.735-.56 1.118-.684.107-.034.207-.068.29-.1.678-.272 1.018-.607 1.01-.993-.005-.303-.237-.573-.608-.708h-.001a1.098 1.098 0 0 0-.418-.083.91.91 0 0 0-.382.08c-.323.153-.613.237-.862.247a.755.755 0 0 1-.336-.084l.025-.435.004-.059c.086-1.38.193-3.097-.25-4.108C15.821 2.234 13.018 2 12.191 2h.001Z", fill: "black" })));
};
Snapchat.propTypes = {
    className: PropTypes.string
};
module.exports = Snapchat;
//# sourceMappingURL=Snapchat.js.map

/***/ }),

/***/ 89281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const SocialHandle = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-socialHandle'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.socialHandle)),
        React.createElement("path", { d: "M18.7362 11.9539H20.6133L19.342 16.3995C19.2427 16.7614 19.1699 17.0312 19.1235 17.2087C19.0838 17.3794 19.0639 17.5297 19.0639 17.6594C19.0639 17.8643 19.1301 18.0589 19.2626 18.2433C19.395 18.4208 19.6069 18.5096 19.8982 18.5096C20.4676 18.5096 21.037 18.1272 21.6065 17.3624C22.1825 16.5907 22.4705 15.5698 22.4705 14.2996C22.4705 12.4217 21.6892 11.073 20.1266 10.2535C19.1467 9.73453 18.0443 9.47503 16.8194 9.47503C14.5682 9.47503 12.7606 10.1852 11.3966 11.6056C10.1651 12.8895 9.54935 14.4294 9.54935 16.2254C9.54935 18.2194 10.2711 19.8003 11.7145 20.968C12.9923 21.9991 14.5516 22.5147 16.3923 22.5147C17.6503 22.5147 18.8256 22.2757 19.9181 21.7977C20.514 21.545 21.1297 21.1865 21.7654 20.7222L22.0037 20.548L22.7287 21.6953C21.7885 22.4464 20.7689 23.0201 19.6698 23.4161C18.5773 23.8054 17.4418 24 16.2632 24C13.5154 24 11.3867 23.1191 9.87709 21.3572C8.6257 19.8959 8 18.1647 8 16.1639C8 13.924 8.7813 12.0256 10.3439 10.4686C11.9859 8.82288 14.0881 8 16.6505 8C18.7362 8 20.4643 8.56338 21.8349 9.69014C23.2783 10.8784 24 12.4558 24 14.4225C24 15.9727 23.5431 17.3043 22.6294 18.4174C21.7157 19.5237 20.6729 20.0768 19.5009 20.0768C18.8918 20.0768 18.4217 19.8993 18.0906 19.5442C17.7662 19.1891 17.604 18.8237 17.604 18.4481C17.604 18.4003 17.604 18.3491 17.604 18.2945C17.6106 18.233 17.6172 18.1682 17.6238 18.0999C17.3722 18.5915 17.0908 18.9842 16.7796 19.2778C16.2168 19.8037 15.5415 20.0666 14.7536 20.0666C13.9524 20.0666 13.2837 19.7695 12.7474 19.1754C12.2177 18.5813 11.9528 17.7516 11.9528 16.6863C11.9528 15.4503 12.36 14.2928 13.1744 13.2138C13.9888 12.1349 14.9886 11.5954 16.1738 11.5954C16.869 11.5954 17.4086 11.7934 17.7927 12.1895C18.084 12.4968 18.2793 12.8485 18.3786 13.2446L18.7362 11.9539ZM14.4556 18.0999C14.6741 18.4072 14.9853 18.5608 15.3892 18.5608C16.0977 18.5608 16.677 18.0077 17.1272 16.9014C17.5841 15.7883 17.8125 14.9142 17.8125 14.2791C17.8125 13.9172 17.7066 13.6133 17.4947 13.3675C17.2828 13.1216 16.9981 12.9987 16.6406 12.9987C15.952 12.9987 15.3594 13.4426 14.8628 14.3303C14.3662 15.2113 14.1179 16.0649 14.1179 16.8912C14.1179 17.3897 14.2305 17.7926 14.4556 18.0999Z", fill: "#2B2B2B" })));
};
SocialHandle.propTypes = {
    className: PropTypes.string
};
module.exports = SocialHandle;
//# sourceMappingURL=SocialHandle.js.map

/***/ }),

/***/ 59596:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Spotify = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-spotify'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.spotify)),
        React.createElement("path", { d: "M17.915 10.865c-3.222-1.914-8.54-2.09-11.617-1.156a.935.935 0 0 1-.543-1.79c3.532-1.073 9.404-.865 13.115 1.337a.936.936 0 0 1-.955 1.609ZM17.81 13.7a.78.78 0 0 1-1.072.258c-2.688-1.653-6.785-2.132-9.965-1.165A.781.781 0 0 1 6.32 11.3c3.631-1.103 8.146-.569 11.234 1.329a.78.78 0 0 1 .256 1.071Zm-1.225 2.724a.623.623 0 0 1-.856.207c-2.348-1.435-5.304-1.76-8.785-.965a.623.623 0 0 1-.278-1.215c3.81-.87 7.078-.495 9.713 1.115.295.18.387.563.207.858h-.001ZM12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Spotify.propTypes = {
    className: PropTypes.string
};
module.exports = Spotify;
//# sourceMappingURL=Spotify.js.map

/***/ }),

/***/ 86522:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Subscribe = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-subscribe'), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.subscribe)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.28 13.301a1.54 1.54 0 0 1 0-2.602c1.354-.893.66-2.928-.973-2.878-1.155.033-1.98-1.06-1.598-2.11.547-1.486-1.25-2.745-2.553-1.778-.912.676-2.25.259-2.58-.8-.46-1.51-2.692-1.51-3.152 0-.33 1.067-1.668 1.484-2.58.8-1.302-.96-3.1.3-2.553 1.777.391 1.043-.443 2.136-1.598 2.11-1.641-.041-2.327 1.994-.972 2.879a1.54 1.54 0 0 1 0 2.602c-1.355.893-.66 2.928.972 2.878 1.155-.033 1.98 1.06 1.598 2.11-.547 1.486 1.25 2.737 2.553 1.778.912-.676 2.25-.259 2.58.8.46 1.51 2.692 1.51 3.152 0 .33-1.067 1.668-1.484 2.58-.8 1.302.96 3.1-.3 2.553-1.777-.391-1.043.443-2.136 1.598-2.11 1.641.041 2.327-1.994.972-2.879ZM16.953 10.8 14.366 12.6c-.104.075-.147.2-.104.317l.99 2.92c.087.266-.226.483-.46.316l-2.588-1.802a.296.296 0 0 0-.347 0l-2.588 1.802c-.235.167-.547-.058-.46-.317l.99-2.92a.267.267 0 0 0-.105-.316l-2.588-1.802c-.234-.167-.113-.518.174-.518h3.196c.13 0 .243-.083.286-.2l.99-2.92c.087-.266.478-.266.565 0l.99 2.92c.043.117.156.2.287.2h3.196c.286 0 .408.35.173.518h-.009Z", fill: "#0879BF" })));
};
Subscribe.propTypes = {
    className: PropTypes.string
};
module.exports = Subscribe;
//# sourceMappingURL=Subscribe.js.map

/***/ }),

/***/ 46119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Telegram = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-telegram'), focusable: "false", viewBox: "0 0 32 32", width: "32", height: "32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.telegram)),
        React.createElement("path", { d: "M8.99416 14.7272L18.5258 10.7948C19.4588 10.3937 22.6588 9.12795 22.6588 9.12795C22.6588 9.12795 24.1251 8.52776 23.9914 9.92721C23.9245 10.5274 23.5918 12.527 23.3243 14.6604L22.3245 21.0589C22.3245 21.0589 22.2577 21.9918 21.5253 22.1924C20.7914 22.3929 19.6593 21.5922 19.4588 21.4585C19.3251 21.3248 16.3925 19.5257 15.3258 18.5928C15.0599 18.3268 14.7256 17.8589 15.3927 17.2602C16.859 15.9276 18.5927 14.2607 19.6579 13.1941C20.1243 12.7276 20.6577 11.5272 18.5912 12.9281L12.7929 16.7937C12.7929 16.7937 12.1258 17.1933 10.9269 16.8605C9.72656 16.5278 8.26027 15.9944 8.26027 15.9944C8.26027 15.9944 7.3273 15.3942 8.99416 14.7272Z", fill: "black" })));
};
Telegram.propTypes = {
    className: PropTypes.string
};
module.exports = Telegram;
//# sourceMappingURL=Telegram.js.map

/***/ }),

/***/ 29011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Threads = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-threads'), focusable: "false", height: "24", viewBox: "0 0 24 24", width: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.threads)),
        React.createElement("path", { d: "M16.392 11.27a7.013 7.013 0 0 0-.262-.12c-.155-2.844-1.71-4.472-4.32-4.49h-.035c-1.562 0-2.86.667-3.66 1.88l1.436.984c.597-.905 1.534-1.098 2.224-1.098h.024c.86.005 1.508.255 1.928.742.306.355.51.845.611 1.464a10.99 10.99 0 0 0-2.467-.12c-2.482.144-4.077 1.59-3.97 3.602.054 1.02.563 1.897 1.431 2.47.734.485 1.68.722 2.663.668 1.298-.07 2.316-.566 3.026-1.471.54-.688.88-1.579 1.031-2.701.62.373 1.078.864 1.33 1.455.431 1.003.456 2.652-.89 3.997-1.179 1.178-2.597 1.688-4.739 1.703-2.376-.017-4.174-.78-5.342-2.264C5.317 16.58 4.75 14.57 4.73 12c.021-2.571.587-4.58 1.68-5.97 1.17-1.486 2.967-2.248 5.343-2.265 2.394.017 4.222.783 5.436 2.275.595.732 1.043 1.653 1.339 2.726l1.682-.45c-.358-1.32-.922-2.458-1.69-3.402C16.965 3.001 14.69 2.02 11.76 2h-.012c-2.925.02-5.174 1.004-6.685 2.925C3.717 6.634 3.023 9.012 3 11.993v.014c.023 2.98.717 5.359 2.062 7.068 1.51 1.92 3.76 2.905 6.685 2.925h.012c2.6-.018 4.434-.699 5.944-2.207 1.975-1.974 1.916-4.447 1.265-5.966-.468-1.089-1.358-1.973-2.576-2.557Zm-4.49 4.22c-1.088.062-2.218-.427-2.274-1.472-.041-.775.552-1.64 2.34-1.743.205-.012.406-.018.604-.018.65 0 1.257.063 1.81.184-.207 2.573-1.415 2.99-2.48 3.05Z", fill: "#000" })));
};
Threads.propTypes = {
    className: PropTypes.string
};
module.exports = Threads;
//# sourceMappingURL=Threads.js.map

/***/ }),

/***/ 50610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Tiktok = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-tiktok'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.tiktok)),
        React.createElement("path", { d: "M20.112 10.092a5.339 5.339 0 0 1-4.959-2.39v8.222a6.076 6.076 0 1 1-6.077-6.077c.127 0 .251.011.376.02v2.994c-.125-.015-.247-.038-.376-.038a3.101 3.101 0 0 0 0 6.203c1.714 0 3.226-1.35 3.226-3.063L12.332 2h2.865a5.336 5.336 0 0 0 4.918 4.764v3.328", fill: "#000" })));
};
Tiktok.propTypes = {
    className: PropTypes.string
};
module.exports = Tiktok;
//# sourceMappingURL=Tiktok.js.map

/***/ }),

/***/ 92566:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Timestamp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-timestamp'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.timestamp)),
        React.createElement("path", { d: "M20.5 12a8.5 8.5 0 1 1-17 0 8.5 8.5 0 0 1 17 0Zm1.5 0c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Zm-9.25-.31V6h-1.5v6.31l3.22 3.22 1.06-1.06-2.78-2.78Z", fillRule: "evenodd", clipRule: "evenodd", fill: "#000" })));
};
Timestamp.propTypes = {
    className: PropTypes.string
};
module.exports = Timestamp;
//# sourceMappingURL=Timestamp.js.map

/***/ }),

/***/ 90040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Triangle = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-triangle', className), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangle)),
        React.createElement("path", { fill: "#000", d: "M22 8H2l10 10L22 8Z" })));
};
Triangle.propTypes = {
    className: PropTypes.string
};
module.exports = Triangle;
//# sourceMappingURL=Triangle.js.map

/***/ }),

/***/ 82652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const TriangleDown = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-triangle-down'), focusable: "false", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangledown)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m12 15.94 8.47-8.47 1.06 1.06L12 18.06 2.47 8.53l1.06-1.06L12 15.94Z", fill: "#000" })));
};
TriangleDown.propTypes = {
    className: PropTypes.string
};
module.exports = TriangleDown;
//# sourceMappingURL=TriangleDown.js.map

/***/ }),

/***/ 15497:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const TriangleUp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-triangle-up', className), focusable: "false", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangleup)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m12 8.06-8.47 8.47-1.06-1.06L12 5.94l9.53 9.53-1.06 1.06L12 8.06Z", fill: "#000" })));
};
TriangleUp.propTypes = {
    className: PropTypes.string
};
module.exports = TriangleUp;
//# sourceMappingURL=TriangleUp.js.map

/***/ }),

/***/ 32262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Tumblr = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-tumblr'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.tumblr)),
        React.createElement("path", { d: "M16.533 17.975c-.372.177-1.083.331-1.614.345-1.6.043-1.912-1.124-1.926-1.972v-6.226h4.017V7.095h-4.001V2h-2.93c-.049 0-.133.042-.144.15C9.764 3.708 9.033 6.444 6 7.538v2.583h2.024v6.536c0 2.236 1.65 5.415 6.008 5.34 1.469-.024 3.101-.64 3.463-1.17l-.962-2.853Z", fill: "black" })));
};
Tumblr.propTypes = {
    className: PropTypes.string
};
module.exports = Tumblr;
//# sourceMappingURL=Tumblr.js.map

/***/ }),

/***/ 33189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Twitter = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-twitter'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.twitter)),
        React.createElement("path", { d: "M13.6468 10.4686L20.9321 2H19.2057L12.8799 9.3532L7.82741 2H2L9.6403 13.1193L2 22H3.72649L10.4068 14.2348L15.7425 22H21.5699L13.6464 10.4686H13.6468ZM11.2821 13.2173L10.508 12.1101L4.34857 3.29968H7.00037L11.9711 10.4099L12.7452 11.5172L19.2066 20.7594H16.5548L11.2821 13.2177V13.2173Z", fill: "black" })));
};
Twitter.propTypes = {
    className: PropTypes.string
};
module.exports = Twitter;
//# sourceMappingURL=Twitter.js.map

/***/ }),

/***/ 52783:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VK = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-vk'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.vk)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.553 6.804c.138-.462 0-.804-.66-.804h-2.19c-.559 0-.81.294-.955.618 0 0-1.11 2.713-2.689 4.477-.51.51-.744.672-1.02.672-.138 0-.348-.162-.348-.624V6.81c0-.558-.156-.804-.618-.804h-3.44c-.347 0-.557.258-.557.504 0 .528.786.648.87 2.13v3.224c0 .708-.126.834-.408.834-.744 0-2.545-2.725-3.619-5.846-.21-.606-.42-.852-.978-.852H2.75C2.125 6 2 6.294 2 6.618c0 .582.744 3.457 3.457 7.256 1.806 2.599 4.357 4.003 6.674 4.003 1.392 0 1.56-.312 1.56-.852v-1.962c0-.625.132-.75.57-.75.324 0 .883.161 2.179 1.415 1.482 1.483 1.728 2.15 2.563 2.15h2.19c.624 0 .936-.313.756-.931-.198-.612-.906-1.506-1.848-2.563-.51-.6-1.273-1.254-1.507-1.578-.324-.42-.234-.6 0-.973 0 0 2.665-3.757 2.947-5.029h.012Z", fill: "black" })));
};
VK.propTypes = {
    className: PropTypes.string
};
module.exports = VK;
//# sourceMappingURL=VK.js.map

/***/ }),

/***/ 192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VerificationBadge = ({ className, color = '#EB0000', ...attrs }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: classnames(className, 'icon icon-verification-badge'), width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.verificationBadge)),
        React.createElement("path", { d: "M21.63 13.333a3.334 3.334 0 0 1 0-2.533l.11-.266c.712-1.689-.11-3.644-1.799-4.355l-.244-.11a3.253 3.253 0 0 1-1.8-1.8l-.088-.222a3.385 3.385 0 0 0-4.376-1.8l-.222.089a3.389 3.389 0 0 1-2.555 0l-.2-.089c-1.666-.689-3.62.133-4.332 1.822l-.088.178a3.253 3.253 0 0 1-1.8 1.8l-.2.088C2.37 6.845 1.548 8.8 2.26 10.489l.09.2a3.333 3.333 0 0 1 0 2.533l-.09.245a3.291 3.291 0 0 0 1.8 4.332l.222.089a3.253 3.253 0 0 1 1.8 1.8l.11.244c.689 1.71 2.644 2.51 4.332 1.821l.244-.11a3.39 3.39 0 0 1 2.555 0l.2.088c1.688.711 3.643-.111 4.353-1.8l.09-.177a3.253 3.253 0 0 1 1.799-1.8l.177-.066a3.316 3.316 0 0 0 1.8-4.355l-.111-.2Zm-10.574 3-4.332-3.644 1.333-1.578 2.755 2.333 4.864-5.776L17.254 9l-6.198 7.331Z", fill: color })));
};
VerificationBadge.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = VerificationBadge;
//# sourceMappingURL=VerificationBadge.js.map

/***/ }),

/***/ 34214:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Vero = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-vero'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.vero)),
        React.createElement("path", { d: "M19.764 3 12 16.452l-1.35-2.237L17.088 3H2l10 17.115L22 3h-2.236Z", fill: "black" })));
};
Vero.propTypes = {
    className: PropTypes.string
};
module.exports = Vero;
//# sourceMappingURL=Vero.js.map

/***/ }),

/***/ 16576:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Viber = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-viber'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.viber)),
        React.createElement("path", { d: "M18.991 3.731c-.468-.425-2.488-1.695-6.704-1.714 0 0-4.991-.328-7.414 1.868C3.524 5.217 3.07 7.198 3.02 9.615c-.05 2.418-.308 7.037 4.112 8.265 0 0-.017 3.429-.02 3.73 0 .21.034.355.154.385.087.021.217-.024.327-.134.707-.71 2.97-3.44 2.97-3.44 3.035.197 5.45-.402 5.71-.487.613-.197 3.925-.482 4.486-5.012.58-4.67-.213-7.859-1.768-9.19Zm-1.842 11.02-.001.008c-.23.4-.523.76-.866 1.066l-.008.006c-.298.25-.59.392-.878.425a1.169 1.169 0 0 1-.502-.05l-.01-.013c-.443-.125-1.184-.438-2.416-1.118a14.412 14.412 0 0 1-2.03-1.342c-.32-.252-.624-.523-.913-.81l-.03-.03-.032-.032-.03-.03-.031-.031a10.636 10.636 0 0 1-.81-.914 14.417 14.417 0 0 1-1.34-2.03c-.68-1.233-.994-1.973-1.119-2.418l-.014-.01a1.17 1.17 0 0 1-.05-.501c.037-.288.179-.581.427-.88l.006-.008a4.331 4.331 0 0 1 1.065-.866l.009-.002c.4-.209.781-.138 1.04.167.002.002.539.647.77.962.236.333.457.679.66 1.034.263.475.098.96-.162 1.16l-.523.416c-.264.213-.229.61-.229.61s.775 2.934 3.67 3.674c0 0 .396.033.61-.23l.416-.523c.2-.26.684-.425 1.159-.16.355.202.7.422 1.033.66.315.23.959.769.96.769.307.259.378.64.17 1.04Zm-2.395-7.24c-.586-.64-1.39-.99-2.456-1.068a.282.282 0 1 1 .042-.563c1.199.088 2.151.508 2.83 1.25.68.743 1.012 1.678.989 2.778a.282.282 0 0 1-.282.276h-.007a.282.282 0 0 1-.275-.288c.02-.964-.255-1.744-.841-2.386Zm-.042 1.892a.282.282 0 0 1-.267.296h-.014a.282.282 0 0 1-.282-.268c-.047-.958-.497-1.427-1.417-1.475a.282.282 0 0 1 .03-.563c1.213.064 1.888.759 1.95 2.01Zm2.647 1.36h-.002a.282.282 0 0 1-.282-.28c-.013-1.7-.523-3.054-1.516-4.023-.996-.97-2.253-1.468-3.739-1.479a.282.282 0 0 1 .002-.564h.002c1.636.012 3.025.563 4.128 1.639 1.105 1.078 1.673 2.566 1.687 4.423a.282.282 0 0 1-.28.285Z", fill: "black" })));
};
Viber.propTypes = {
    className: PropTypes.string
};
module.exports = Viber;
//# sourceMappingURL=Viber.js.map

/***/ }),

/***/ 12037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Video = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-video'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.video)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 2v20l17-10L4 2Zm1.5 2.623v14.754L18.041 12 5.5 4.623Z", fill: "#000" })));
};
Video.propTypes = {
    className: PropTypes.string
};
module.exports = Video;
//# sourceMappingURL=Video.js.map

/***/ }),

/***/ 29186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VolumeHigh = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-volume-high'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.volumeMute)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.75 1.708V22.292l-1.122-.64-7-4-.378-.217V15.75h-3v-7.5h3V6.565l.378-.216 7-4 1.122-.641Zm-7 5.727V16.565l5.5 3.143V4.292l-5.5 3.143Zm-3 2.315h1.5v4.5h-1.5v-4.5Zm16.922-4.34c1.381 1.868 2.195 4.144 2.195 6.6 0 2.446-.808 4.714-2.18 6.578l-1.235-.91a9.518 9.518 0 0 0 1.881-5.669c0-2.11-.697-4.068-1.894-5.686l1.233-.912ZM16.756 12c0-.94-.312-1.832-.878-2.619l1.244-.895c.735 1.02 1.167 2.222 1.167 3.514 0 1.292-.432 2.493-1.167 3.514l-1.244-.895c.566-.787.878-1.68.878-2.619Z", fill: "#000" })));
};
VolumeHigh.propTypes = {
    className: PropTypes.string
};
module.exports = VolumeHigh;
//# sourceMappingURL=VolumeHigh.js.map

/***/ }),

/***/ 3711:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VolumeMute = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-volume-mute'), focusable: "false", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.volumeHigh)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.75 1.708V22.292l-1.122-.64-7-4-.378-.217V15.75h-3v-7.5h3V6.565l.378-.216 7-4 1.122-.641Zm-7 5.727V16.565l5.5 3.143V4.292l-5.5 3.143Zm-3 2.315h1.5v4.5h-1.5v-4.5Zm18.72 5.78L19 13.06l-2.47 2.47-1.06-1.06L17.94 12l-2.47-2.47 1.06-1.06L19 10.94l2.47-2.47 1.06 1.06L20.06 12l2.47 2.47-1.06 1.06Z", fill: "#000" })));
};
VolumeMute.propTypes = {
    className: PropTypes.string
};
module.exports = VolumeMute;
//# sourceMappingURL=VolumeMute.js.map

/***/ }),

/***/ 85858:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const WeChat = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-wechat'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.weChat)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.919 18.358c1.27-.92 2.081-2.28 2.081-3.794 0-2.77-2.698-5.02-6.023-5.02-3.325 0-6.023 2.247-6.023 5.02 0 2.773 2.698 5.02 6.023 5.02.687 0 1.35-.099 1.967-.275l.176-.026c.117 0 .22.036.319.093l1.32.762.116.037a.2.2 0 0 0 .2-.2l-.034-.148-.272-1.013-.021-.13a.412.412 0 0 1 .17-.326ZM9.229 4C5.236 4 2 6.698 2 10.023c0 1.814.974 3.45 2.498 4.554a.48.48 0 0 1 .203.391l-.026.153-.327 1.215-.039.177c0 .132.109.24.241.24l.14-.043 1.584-.915a.768.768 0 0 1 .383-.112l.213.031a8.548 8.548 0 0 0 2.36.332l.397-.01a4.679 4.679 0 0 1-.243-1.475c0-3.035 2.952-5.494 6.593-5.494l.391.01C15.824 6.2 12.836 4 9.228 4Zm4.74 9.76a.804.804 0 1 1 0-1.608.804.804 0 0 1 0 1.608Zm4.016 0a.804.804 0 1 1 .002-1.608.804.804 0 0 1-.002 1.608ZM6.821 9.06a.964.964 0 1 1 0-1.929.964.964 0 0 1 0 1.929Zm4.818 0a.964.964 0 1 1 0-1.929.964.964 0 0 1 0 1.929Z", fill: "black" })));
};
WeChat.propTypes = {
    className: PropTypes.string
};
module.exports = WeChat;
//# sourceMappingURL=WeChat.js.map

/***/ }),

/***/ 93470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Weibo = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-weibo'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.weibo)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M16.054 4.053c3.247-.43 5.697 1.802 5.925 4.75.09 1.117-.1 2.456-.84 2.52-.903.08-.772-.65-.644-1.356.041-.232.083-.461.087-.658.042-2.312-1.93-3.917-3.858-3.917-.098 0-.22.012-.35.025-.605.06-1.432.141-1.27-.806.08-.454.43-.495.81-.54l.14-.018Zm.617 5.032c.494.58.308 1.61 0 2.408.215.117.436.225.656.333 1.207.59 2.372 1.158 2.139 3.073-.07.542-.399 1.27-.728 1.732-2.36 3.305-9.475 4.698-13.923 2.184-1.493-.84-3.034-2.072-2.79-4.527.203-2.115 1.627-3.752 3.019-5.144C6.372 7.81 7.775 6.769 9.683 6.29c2.072-.52 2.684 1.207 2.126 2.907.337-.022.783-.145 1.273-.28 1.246-.345 2.784-.77 3.589.168Zm-7.886 9.9c2.577.17 5.154-.738 6.377-2.125.446-.51.892-1.281.892-2.179-.005-2.78-3.501-3.81-6.26-3.582-1.509.123-2.524.441-3.581 1.063-.866.505-1.876 1.334-2.125 2.572-.564 2.79 2.47 4.102 4.697 4.251Zm9.841-8.555c.49-.032.733-.77.617-1.62-.165-1.202-1.212-2.18-2.63-2.068a3.33 3.33 0 0 1-.13.007c-.327.014-.764.032-.764.61 0 .561.394.56.845.56.262 0 .542 0 .776.109.324.154.696.67.728 1.116.012.181.002.355-.007.513-.027.478-.046.813.565.773ZM6.548 16.583c-.76-2.072 1.068-3.72 2.965-3.916 1.62-.17 2.827.654 3.188 1.738 1.19 3.597-5.016 5.271-6.153 2.178Zm3.698-1.275a.426.426 0 0 0 .425-.425.426.426 0 0 0-.425-.425.426.426 0 0 0-.425.425c0 .234.191.425.425.425Zm-1.642 1.738c.58 0 1.052-.473 1.052-1.053 0-.579-.473-1.052-1.052-1.052-.579 0-1.052.473-1.052 1.052 0 .58.473 1.053 1.052 1.053Z", fill: "black" })));
};
Weibo.propTypes = {
    className: PropTypes.string
};
module.exports = Weibo;
//# sourceMappingURL=Weibo.js.map

/***/ }),

/***/ 90370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Whatsapp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-whatsapp'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.whatsapp)),
        React.createElement("path", { d: "M19.0833 4.90849C17.2056 3.03401 14.7056 2 12.0444 2C6.55556 2 2.08333 6.44567 2.08333 11.9088C2.08333 13.6561 2.53889 15.3591 3.41111 16.8631L2 22L7.27778 20.6232C8.73333 21.4139 10.3722 21.8286 12.0389 21.8286H12.0444C17.5333 21.8286 22 17.3829 22 11.9198C22 9.27122 20.9667 6.78297 19.0833 4.90849ZM12.0444 20.1587C10.5556 20.1587 9.1 19.7606 7.82778 19.0086L7.52778 18.8316L4.38889 19.6445L5.22222 16.6033L5.02778 16.2936C4.2 14.9831 3.76111 13.4681 3.76111 11.9088C3.76111 7.36909 7.47778 3.66989 12.0444 3.66989C14.2556 3.66989 16.3333 4.52696 17.8944 6.08626C19.4556 7.64556 20.3167 9.71357 20.3167 11.9143C20.3167 16.4595 16.6056 20.1532 12.0444 20.1587ZM16.5833 13.9878C16.3333 13.8662 15.1111 13.2635 14.8833 13.1805C14.6556 13.0976 14.4889 13.0589 14.3222 13.3022C14.1556 13.551 13.6778 14.1095 13.5333 14.2754C13.3889 14.4412 13.2444 14.4634 12.9944 14.3362C12.7444 14.2145 11.9444 13.9491 10.9944 13.1087C10.2556 12.4506 9.75556 11.6433 9.61111 11.3945C9.46667 11.1457 9.59444 11.013 9.72222 10.8913C9.83333 10.7808 9.97222 10.6038 10.0944 10.46C10.2167 10.3163 10.2611 10.2112 10.3444 10.0453C10.4278 9.87946 10.3833 9.73569 10.3222 9.61404C10.2611 9.4924 9.76111 8.27039 9.55556 7.77274C9.35556 7.29168 9.15 7.35803 8.99444 7.34697C8.85 7.34144 8.68333 7.33591 8.51667 7.33591C8.35 7.33591 8.08333 7.39674 7.85556 7.64556C7.62778 7.89439 6.98333 8.49157 6.98333 9.71357C6.98333 10.9356 7.87222 12.1078 8 12.2737C8.12222 12.4396 9.75556 14.9389 12.25 16.0116C12.8444 16.266 13.3056 16.4208 13.6667 16.5314C14.2611 16.7194 14.8056 16.6917 15.2333 16.6309C15.7111 16.559 16.7056 16.0337 16.9111 15.4531C17.1167 14.8725 17.1167 14.3804 17.0556 14.2754C16.9944 14.1703 16.8278 14.1095 16.5833 13.9878Z", fill: "black" })));
};
Whatsapp.propTypes = {
    className: PropTypes.string
};
module.exports = Whatsapp;
//# sourceMappingURL=Whatsapp.js.map

/***/ }),

/***/ 36216:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Xing = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-xing'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.xing)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.386 2c.1 0 .164.107.114.193l-5.703 9.743a.127.127 0 0 0 0 .128l5.703 9.744a.129.129 0 0 1-.114.192h-3.643a.132.132 0 0 1-.114-.065l-5.777-9.871a.126.126 0 0 1 0-.128l5.777-9.871A.132.132 0 0 1 15.743 2h3.643Zm-8.992 6.784c.005 0 .009-.005.006-.01L8.293 5.168a.198.198 0 0 0-.171-.097H4.845a.193.193 0 0 0-.172.288L6.67 8.774c.002.005-.001.01-.007.01a.007.007 0 0 0-.006.004L4.03 13.025a.193.193 0 0 0 .169.293h3.27a.198.198 0 0 0 .168-.093l2.752-4.437a.007.007 0 0 1 .006-.004Z", fill: "#000" })));
};
Xing.propTypes = {
    className: PropTypes.string
};
module.exports = Xing;
//# sourceMappingURL=Xing.js.map

/***/ }),

/***/ 51716:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const YandexZen = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-yandexzen'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.yandexzen)),
        React.createElement("path", { d: "M2 11.75c4.125-.125 6.375-.25 7.875-1.875C11.5 8.375 11.75 6.125 11.75 2A9.928 9.928 0 0 0 2 11.75ZM22 11.75C21.875 6.5 17.625 2.125 12.375 2c.125 4.125.25 6.375 1.875 7.875 1.5 1.5 3.75 1.875 7.75 1.875ZM2 12.375c.25 5.25 4.5 9.5 9.75 9.625-.125-4-.375-6.25-1.875-7.75S6.125 12.375 2 12.375ZM12.375 22A10.06 10.06 0 0 0 22 12.375c-4 .125-6.25.375-7.75 1.875S12.375 18 12.375 22Z", fill: "#000" })));
};
YandexZen.propTypes = {
    className: PropTypes.string
};
module.exports = YandexZen;
//# sourceMappingURL=YandexZen.js.map

/***/ }),

/***/ 92459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const YouTube = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-youtube'), focusable: "false", viewBox: "0 0 24 24", width: "24", height: "24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.youTube)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.5825 7.2C21.4694 6.77454 21.2464 6.38627 20.936 6.0741C20.6256 5.76192 20.2386 5.53679 19.8137 5.42125C18.2537 5 12 5 12 5C12 5 5.74625 5 4.18625 5.42125C3.76143 5.53679 3.37443 5.76192 3.06401 6.0741C2.75359 6.38627 2.53064 6.77454 2.4175 7.2C2 8.77 2 12.045 2 12.045C2 12.045 2 15.32 2.4175 16.89C2.53045 17.3157 2.75331 17.7042 3.06375 18.0166C3.37418 18.329 3.76128 18.5544 4.18625 18.67C5.74625 19.0913 12 19.0913 12 19.0913C12 19.0913 18.2537 19.0913 19.8137 18.67C20.2387 18.5544 20.6258 18.329 20.9363 18.0166C21.2467 17.7042 21.4696 17.3157 21.5825 16.89C22 15.3212 22 12.045 22 12.045C22 12.045 22 8.77 21.5825 7.2ZM9.955 15.0187V9.07125L15.1813 12.0463L9.955 15.0187Z", fill: "black" })));
};
YouTube.propTypes = {
    className: PropTypes.string
};
module.exports = YouTube;
//# sourceMappingURL=YouTube.js.map

/***/ }),

/***/ 91470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Account = __webpack_require__(92237);
const AgeGate = (__webpack_require__(86138)["default"]);
const Arrow = __webpack_require__(69571);
const Article = __webpack_require__(90628);
const Bookmark = __webpack_require__(315);
const BookmarkActivated = __webpack_require__(52585);
const BookmarkNew = __webpack_require__(44584);
const BlueSky = __webpack_require__(81463);
const CartFilled = __webpack_require__(58366);
const CartOutlined = __webpack_require__(72172);
const Check = __webpack_require__(9218);
const ChevronRight = __webpack_require__(25751);
const ChevronFill = __webpack_require__(58180);
const ChevronLeft = __webpack_require__(18972);
const ChevronUp = __webpack_require__(68804);
const ChevronDown = __webpack_require__(40589);
const Close = __webpack_require__(80046);
const Collapse = __webpack_require__(56099);
const Comment = __webpack_require__(56807);
const CopyLink = __webpack_require__(25601);
const Dot = __webpack_require__(60261);
const DownloadCloud = __webpack_require__(66087);
const DownloadWeb = __webpack_require__(39392);
const Email = __webpack_require__(57942);
const EmailFilled = __webpack_require__(62410);
const Expand = __webpack_require__(58332);
const Enlarge = __webpack_require__(83476);
const Facebook = __webpack_require__(69192);
const Filmstrip = __webpack_require__(50694);
const Flipboard = __webpack_require__(50907);
const GoogleNews = __webpack_require__(24596);
const Gallery = __webpack_require__(39336);
const Grid = __webpack_require__(49776);
const Headphone = __webpack_require__(53636);
const Instagram = __webpack_require__(7994);
const LargeChevron = __webpack_require__(79350);
const LeftChevron = __webpack_require__(65234);
const Like = __webpack_require__(35483);
const LikeFilled = __webpack_require__(74771);
const Line = __webpack_require__(8990);
const LinkedIn = __webpack_require__(25534);
const OK = __webpack_require__(22650);
const Paperclip = __webpack_require__(13150);
const List = __webpack_require__(61852);
const Maximize = __webpack_require__(30110);
const Menu = __webpack_require__(15447);
const NativeShare = __webpack_require__(28828);
const Newsletter = __webpack_require__(60779);
const NewsletterArrow = __webpack_require__(65102);
const Pause = __webpack_require__(13148);
const Pinterest = __webpack_require__(24888);
const Play = __webpack_require__(11118);
const Passkey = __webpack_require__(57946);
const Playlist = __webpack_require__(85026);
const PhotoStack = __webpack_require__(5232);
const PlayOutlined = __webpack_require__(25856);
const Print = __webpack_require__(40641);
const RatingFilled = __webpack_require__(35149);
const RatingHalf = __webpack_require__(36928);
const RatingOutlined = __webpack_require__(85323);
const Replay = __webpack_require__(81055);
const Rss = __webpack_require__(29454);
const Search = __webpack_require__(36652);
const SlimHeadphone = __webpack_require__(20855);
const Share = __webpack_require__(69657);
const Shopping = __webpack_require__(64964);
const Snapchat = __webpack_require__(74170);
const SocialHandle = __webpack_require__(89281);
const Spotify = __webpack_require__(59596);
const Subscribe = __webpack_require__(86522);
const Telegram = __webpack_require__(46119);
const Timestamp = __webpack_require__(92566);
const Tiktok = __webpack_require__(50610);
const Triangle = __webpack_require__(90040);
const TriangleUp = __webpack_require__(15497);
const TriangleDown = __webpack_require__(82652);
const Tumblr = __webpack_require__(32262);
const Twitter = __webpack_require__(33189);
const Threads = __webpack_require__(29011);
const VerificationBadge = __webpack_require__(192);
const Vero = __webpack_require__(34214);
const Viber = __webpack_require__(16576);
const Video = __webpack_require__(12037);
const VolumeHigh = __webpack_require__(29186);
const VolumeMute = __webpack_require__(3711);
const VK = __webpack_require__(52783);
const WeChat = __webpack_require__(85858);
const Weibo = __webpack_require__(93470);
const Whatsapp = __webpack_require__(90370);
const Xing = __webpack_require__(36216);
const YandexZen = __webpack_require__(51716);
const YouTube = __webpack_require__(92459);
module.exports = {
    Account,
    AgeGate,
    Arrow,
    Article,
    Bookmark,
    BookmarkActivated,
    BookmarkNew,
    BlueSky,
    CartFilled,
    CartOutlined,
    Check,
    ChevronRight,
    ChevronFill,
    ChevronLeft,
    ChevronUp,
    ChevronDown,
    Close,
    Collapse,
    Comment,
    CopyLink,
    Dot,
    DownloadCloud,
    DownloadWeb,
    Email,
    EmailFilled,
    Expand,
    Enlarge,
    Facebook,
    Filmstrip,
    Flipboard,
    GoogleNews,
    Gallery,
    Grid,
    Headphone,
    Instagram,
    LargeChevron,
    LeftChevron,
    Like,
    LikeFilled,
    Line,
    LinkedIn,
    OK,
    List,
    Maximize,
    Menu,
    NativeShare,
    Newsletter,
    NewsletterArrow,
    Paperclip,
    Pause,
    Pinterest,
    Play,
    Passkey,
    Playlist,
    PhotoStack,
    PlayOutlined,
    Print,
    RatingFilled,
    RatingHalf,
    RatingOutlined,
    Replay,
    Rss,
    Search,
    Share,
    Shopping,
    SlimHeadphone,
    Snapchat,
    SocialHandle,
    Spotify,
    Subscribe,
    Telegram,
    Timestamp,
    Tiktok,
    Threads,
    Triangle,
    TriangleUp,
    TriangleDown,
    Tumblr,
    Twitter,
    VerificationBadge,
    Vero,
    Viber,
    Video,
    VolumeHigh,
    VolumeMute,
    VK,
    WeChat,
    Weibo,
    Whatsapp,
    Xing,
    YandexZen,
    YouTube
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 63104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Account = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-account'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.account)),
        React.createElement("circle", { cx: "8", cy: "5", r: "3.5", stroke: "black" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7 9H9C11.2091 9 13 10.7909 13 13V15H14V13C14 10.2386 11.7614 8 9 8H7C4.23858 8 2 10.2386 2 13V15H3V13C3 10.7909 4.79086 9 7 9Z", fill: "black" })));
};
Account.propTypes = {
    className: PropTypes.string
};
module.exports = Account;
//# sourceMappingURL=Account.js.map

/***/ }),

/***/ 83383:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const AgeGate = (props) => {
    const { formatMessage } = useIntl();
    const { className, secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-age-gate'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ageGate)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.365 9.017c0 .857.709 1.37 1.803 1.37 1.088 0 1.803-.513 1.803-1.37 0-.547-.283-.953-.77-1.108.399-.148.683-.56.683-1.053 0-.777-.696-1.263-1.716-1.263-1.026 0-1.715.486-1.715 1.263 0 .493.27.905.668 1.053-.486.155-.756.56-.756 1.108ZM5.352 7.382v2.904H6.44V5.694h-.946c0 .567-.203.83-1.114.83v.858h.972Zm3.816.142c.412 0 .675-.23.675-.574 0-.358-.27-.58-.675-.58-.412 0-.675.222-.675.58 0 .344.277.574.675.574Zm.736 1.418c0 .385-.297.635-.736.635s-.736-.25-.736-.635c0-.378.31-.628.736-.628.44 0 .736.25.736.628Zm4.04-2.455h-.984v1.056h-1.056v.985h1.056v1.055h.985V8.528H15v-.985h-1.055V6.487Z", fill: "#2B2B2B" }),
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M7.894 14.789a6.91 6.91 0 0 0 6.09-3.658h-1.657c-.168.23-.355.447-.559.65a5.487 5.487 0 1 1 .751-6.841h1.606A6.886 6.886 0 0 0 7.895 1a6.894 6.894 0 1 0 0 13.789Z", fill: "#000" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
AgeGate.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = AgeGate;
//# sourceMappingURL=AgeGate.js.map

/***/ }),

/***/ 4262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Arrow = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-arrow'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.arrow)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.707 8 8.354 1.646l-.708.708L12.793 7.5H1v1h11.793l-5.147 5.146.708.708L14.707 8Z" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { d: "M0 0h16v16H0z" })))));
};
Arrow.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Arrow;
//# sourceMappingURL=Arrow.js.map

/***/ }),

/***/ 87793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Article = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-article'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.article)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 2.5h12v1H1v-1Zm0 5h14v1H1v-1Zm9 5H1v1h9v-1Z", fill: "#000" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: "#fff", d: "M0 0h16v16H0z" })))));
};
Article.propTypes = {
    className: PropTypes.string
};
module.exports = Article;
//# sourceMappingURL=Article.js.map

/***/ }),

/***/ 72942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const BlueSky = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bluesky'), focusable: "false", height: "24", viewBox: "0 0 16 16", width: "24", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.bluesky)),
        React.createElement("path", { d: "M4.601 3.711C5.977 4.744 7.457 6.838 8 7.962c.543-1.124 2.023-3.218 3.399-4.25.993-.746 2.601-1.323 2.601.512 0 .367-.21 3.079-.333 3.519-.429 1.53-1.99 1.921-3.378 1.685 2.427.413 3.044 1.781 1.711 3.15-2.532 2.598-3.64-.653-3.923-1.486C8.025 10.94 8 10.868 8 10.93c0-.06-.025.01-.077.163-.283.833-1.39 4.084-3.923 1.485-1.333-1.368-.716-2.736 1.711-3.15-1.388.237-2.95-.153-3.378-1.684C2.21 7.303 2 4.591 2 4.224c0-1.835 1.608-1.258 2.601-.513Z", fill: "#000" })));
};
BlueSky.propTypes = {
    className: PropTypes.string
};
module.exports = BlueSky;
//# sourceMappingURL=BlueSky.js.map

/***/ }),

/***/ 70931:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 * @param {string} [props.className] - Optional prop to add a custom classname
 */
const Bookmark = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || formatMessage(translations.bookmark)),
        React.createElement("path", { className: "icon-bookmark-fill", fill: primaryFill, fillRule: "evenodd", d: "M2.5 1.5H8.5V2.5H3.5V13.1169L8 10.4169L12.5 13.1169V9.5H13.5V14.8831L8 11.5831L2.5 14.8831V1.5Z", clipRule: "evenodd" }),
        React.createElement("path", { className: "icon-bookmark-stroke", fill: primaryFill, fillRule: "evenodd", d: "M12.5 7V1H13.5V7H12.5Z", clipRule: "evenodd" }),
        React.createElement("path", { className: "icon-bookmark-stroke", fill: primaryFill, fillRule: "evenodd", d: "M16 4.5L10 4.5L10 3.5L16 3.5L16 4.5Z", clipRule: "evenodd" })));
};
Bookmark.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = Bookmark;
//# sourceMappingURL=Bookmark.js.map

/***/ }),

/***/ 64736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 * @param {string} [props.className] - Optional prop to add a custom classname
 */
const BookmarkActivated = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark icon-bookmark--activated'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || formatMessage(translations.bookmarkActivated)),
        React.createElement("path", { className: "icon-bookmark-fill icon-bookmark--activated-outline", fill: "black", fillRule: "evenodd", d: "M2.5 1.5H8.5V2.5H3.5V13.1169L8 10.4169L12.5 13.1169V8.5H13.5V14.8831L8 11.5831L2.5 14.8831V1.5Z", clipRule: "evenodd" }),
        React.createElement("path", { className: "icon-bookmark-fill icon-bookmark--activated-checkmark", fill: "black", fillRule: "evenodd", d: "M8.00001 7.2929L13.6465 1.64645L14.3536 2.35356L8.00001 8.70711L4.64645 5.35356L5.35356 4.64645L8.00001 7.2929Z", clipRule: "evenodd" })));
};
BookmarkActivated.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string
};
module.exports = BookmarkActivated;
//# sourceMappingURL=BookmarkActivated.js.map

/***/ }),

/***/ 42605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.bookmarkIconTitle] - Optional prop to show custom bookmark title
 * @param {string} [props.className] - Optional prop to add a custom classname
 */
const BookmarkNew = (props) => {
    const { formatMessage } = useIntl();
    const { bookmarkIconTitle, primaryFill = 'black', className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-bookmark'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, bookmarkIconTitle || formatMessage(translations.bookmark)),
        React.createElement("g", null,
            React.createElement("path", { d: "M7.74275 11.1543L3 14V2H13V14L8.25725 11.1543L8 11L7.74275 11.1543Z", stroke: primaryFill, strokeLinecap: "square" })),
        React.createElement("defs", null,
            React.createElement("clipPath", null,
                React.createElement("rect", { width: "12", height: "14", fill: "white", transform: "translate(2 1)" })))));
};
BookmarkNew.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    className: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = BookmarkNew;
//# sourceMappingURL=BookmarkNew.js.map

/***/ }),

/***/ 80809:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CartFilled = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-cart'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.cart)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.832 5H1V3H4.277l.227.686.407 1.232h10.247l-.296 1.233-.614 2.556-.14.584-.581.15-7.588 1.972-.907.235-.294-.889L2.832 5Zm9.886 7.788a1.173 1.173 0 0 1-2.01.846 1.172 1.172 0 1 1 2.01-.846Zm-4.769.457a1.172 1.172 0 1 0-2.18-.86 1.172 1.172 0 0 0 2.18.86Z", fill: "#000" })));
};
CartFilled.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = CartFilled;
//# sourceMappingURL=CartFilled.js.map

/***/ }),

/***/ 19751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const CartOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-cart'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.cart)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2.599 2.5H1.036v-1H3a.5.5 0 0 1 .488.392L5.401 10.5h7.222l1.714-6H7v-1h8a.5.5 0 0 1 .48.637l-2 7a.5.5 0 0 1-.48.363H5a.5.5 0 0 1-.488-.392L2.599 2.5ZM8 14a1 1 0 1 0-2 0 1 1 0 0 0 2 0Zm3-1a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z", fill: "#000" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
CartOutlined.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string,
    title: PropTypes.string
};
module.exports = CartOutlined;
//# sourceMappingURL=CartOutlined.js.map

/***/ }),

/***/ 18635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Check = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-check'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.check)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", fill: "#000", d: "m7 9.293 5.646-5.647.708.708L7 10.707 3.646 7.354l.708-.708L7 9.293Z" })));
};
Check.propTypes = {
    className: PropTypes.string
};
module.exports = Check;
//# sourceMappingURL=Check.js.map

/***/ }),

/***/ 19328:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const ChevronDown = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-down'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronDown)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 11.293 1.354 4.646l-.708.708L8 12.707l7.354-7.353-.707-.708L8 11.293Z", fill: "black" })));
};
ChevronDown.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronDown;
//# sourceMappingURL=ChevronDown.js.map

/***/ }),

/***/ 38537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const ChevronFill = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevronFill'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronFill)),
        React.createElement("rect", { width: "16", height: "16", rx: "18", fill: "black" }),
        React.createElement("path", { d: "M15 8A7 7 0 1 0 1 8a7 7 0 0 0 14 0Z", fill: "#000" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.043 8 6.77 5.729l.708-.708L10.457 8 7.48 10.979l-.708-.707L9.043 8Z", fill: "#fff" })));
};
ChevronFill.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronFill;
//# sourceMappingURL=ChevronFill.js.map

/***/ }),

/***/ 9137:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const ChevronLeft = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-left'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronLeft)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m4.707 8 6.647-6.646-.708-.708L3.293 8l7.353 7.354.707-.707L4.708 8Z", fill: "black" })));
};
ChevronLeft.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronLeft;
//# sourceMappingURL=ChevronLeft.js.map

/***/ }),

/***/ 69880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const ChevronRight = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevron)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.293 8 3.646 1.354l.708-.708L11.707 8l-7.353 7.354-.708-.707L10.293 8Z", fill: "#000" })));
};
ChevronRight.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronRight;
//# sourceMappingURL=ChevronRight.js.map

/***/ }),

/***/ 47749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const ChevronUp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-chevron-up'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevronUp)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m8 4.707 6.646 6.647.707-.708L8 3.293.646 10.646l.708.707L8 4.708Z", fill: "black" })));
};
ChevronUp.propTypes = {
    className: PropTypes.string
};
module.exports = ChevronUp;
//# sourceMappingURL=ChevronUp.js.map

/***/ }),

/***/ 76399:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Close = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-close'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.close)),
        React.createElement("g", { clipPath: "url(#a)", stroke: "#000" },
            React.createElement("path", { d: "m1 1 14 14M15 1 1 15" }))));
};
Close.propTypes = {
    className: PropTypes.string
};
module.exports = Close;
//# sourceMappingURL=Close.js.map

/***/ }),

/***/ 73672:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Collapse = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-collapse'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.collapse)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 7.5h14v1H1v-1Z", fill: "#000" })));
};
Collapse.propTypes = {
    className: PropTypes.string
};
module.exports = Collapse;
//# sourceMappingURL=Collapse.js.map

/***/ }),

/***/ 28650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Comment = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-comment'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.comment)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M.5 1.5h15v10H8.167L3.5 15v-3.5h-3v-10Zm1 1v8h3V13l3.333-2.5H14.5v-8h-13Z", fill: "#000" })));
};
Comment.propTypes = {
    className: PropTypes.string
};
module.exports = Comment;
//# sourceMappingURL=Comment.js.map

/***/ }),

/***/ 19310:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const CopyLink = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-copylink'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.copyLink)),
        React.createElement("path", { d: "M11.827 6.835a.376.376 0 0 0 .142.52.393.393 0 0 0 .531-.14l.973-1.648c.859-1.456.349-3.318-1.14-4.159-1.487-.84-3.39-.341-4.249 1.115L6.528 5.159c-.859 1.457-.349 3.319 1.14 4.16.146.082.296.152.449.209a.347.347 0 0 0 .417-.156c.128-.217-.004-.495-.239-.595a2.374 2.374 0 0 1-.239-.118 2.257 2.257 0 0 1-.854-3.119l1.556-2.637c.644-1.092 2.07-1.466 3.187-.835a2.257 2.257 0 0 1 .854 3.119l-.972 1.648Zm-6.764 2.33a.376.376 0 0 0-.142-.52.394.394 0 0 0-.531.14l-.973 1.648c-.859 1.456-.349 3.318 1.14 4.159 1.487.84 3.39.341 4.249-1.115l1.556-2.636c.859-1.457.349-3.319-1.14-4.16a3.163 3.163 0 0 0-.449-.209.347.347 0 0 0-.417.156c-.128.217.004.495.239.595.08.034.16.074.239.118a2.257 2.257 0 0 1 .854 3.119l-1.556 2.637c-.644 1.092-2.071 1.466-3.187.835a2.257 2.257 0 0 1-.854-3.119l.972-1.648Z", fill: "#000" })));
};
CopyLink.propTypes = {
    className: PropTypes.string
};
module.exports = CopyLink;
//# sourceMappingURL=CopyLink.js.map

/***/ }),

/***/ 30408:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Dot = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-dots'), viewBox: "0 0 16 16", width: "16", height: "16", fill: "#DADADA", xmlns: "http://www.w3.org/2000/svg", role: "img", ...attrs },
        React.createElement("title", null, formatMessage(translations.dots)),
        React.createElement("path", { d: "M12 8a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z", fill: "#000" })));
};
Dot.propTypes = {
    className: PropTypes.string
};
module.exports = Dot;
//# sourceMappingURL=Dot.js.map

/***/ }),

/***/ 7742:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const DownloadCloud = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-downloadCloud'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.downloadCloud)),
        React.createElement("path", { d: "M8.262 13.862V8.606h-.674v5.256L6.173 12.38l-.539.539 2.291 2.223 2.291-2.223-.539-.54-1.415 1.483ZM11.63 3.553C11.496 2.003 10.148.858 8.599.858c-1.28 0-2.494.876-2.898 2.089-.135-.068-.337-.068-.472-.068a3.02 3.02 0 0 0-3.032 3.032c0 .203 0 .337.068.54C1.389 6.854.85 7.662.85 8.606c0 1.28 1.078 2.358 2.358 2.358h2.695v-.674H3.208a1.668 1.668 0 0 1-1.685-1.684c0-.742.472-1.415 1.213-1.618l.337-.067-.067-.337c-.068-.27-.135-.471-.135-.674 0-1.28 1.078-2.358 2.358-2.358.203 0 .405 0 .674.067l.337.135.068-.337C6.51 2.34 7.52 1.531 8.598 1.531c1.28 0 2.359 1.079 2.359 2.359v.337h.337a3.02 3.02 0 0 1 3.032 3.032 3.02 3.02 0 0 1-3.032 3.032H9.946v.674h1.348C13.315 10.965 15 9.281 15 7.26c0-1.954-1.482-3.504-3.37-3.706Z", fill: "#000" })));
};
DownloadCloud.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = DownloadCloud;
//# sourceMappingURL=DownloadCloud.js.map

/***/ }),

/***/ 20821:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const DownloadWeb = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, color = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-downloadWeb'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.downloadWeb)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.584 6.646 8.5 9.73V1h-1v8.73L4.416 6.646l-.707.708L8 11.644l4.291-4.29-.707-.708ZM1 14.5h14v-1H1v1Z", fill: color })));
};
DownloadWeb.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string,
    title: PropTypes.string
};
module.exports = DownloadWeb;
//# sourceMappingURL=DownloadWeb.js.map

/***/ }),

/***/ 43403:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Email = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-email'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.email)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 4Zm-.707 0H2.707L8 9.293 13.293 4ZM2 4.707V12h12V4.707l-6 6-6-6ZM1 13V3h14v10H1Z", fill: "#000" })));
};
Email.propTypes = {
    className: PropTypes.string
};
module.exports = Email;
//# sourceMappingURL=Email.js.map

/***/ }),

/***/ 68579:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const EmailFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-email-filled'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.email)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 9.03 1.61 3h12.778L8.001 9.03ZM1 13V3.629l7.002 6.607L15 3.63V13H1Z", fill: "#000" })));
};
EmailFilled.propTypes = {
    className: PropTypes.string
};
module.exports = EmailFilled;
//# sourceMappingURL=EmailFilled.js.map

/***/ }),

/***/ 28717:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Enlarge = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-enlarge'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.expand)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fill: primaryFill, fillRule: "evenodd", d: "m1.778 12.978 4.444-4.445L7.556 9.69 3.11 14.133h3.111v1.778H0V9.69h1.778v3.289Zm12.444-9.956L9.778 7.467 8.444 6.31l4.445-4.444H9.778V0H16v6.222h-1.778v-3.2Z", clipRule: "evenodd" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Enlarge.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Enlarge;
//# sourceMappingURL=Enlarge.js.map

/***/ }),

/***/ 93467:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Expand = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-expand'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.expand)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 7.5V1h-1v6.5H1v1h6.5V15h1V8.5H15v-1H8.5Z", fill: primaryFill })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Expand.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Expand;
//# sourceMappingURL=Expand.js.map

/***/ }),

/***/ 23871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Facebook = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-facebook'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.facebook)),
        React.createElement("path", { d: "M6.418 3.712v1.927H5v2.357h1.418V15h2.914V7.996h1.956s.183-1.13.271-2.366H9.344V4.02c0-.24.317-.566.631-.566h1.588V1h-2.16C6.348 1 6.419 3.359 6.419 3.712Z", fill: "#000" })));
};
Facebook.propTypes = {
    className: PropTypes.string
};
module.exports = Facebook;
//# sourceMappingURL=Facebook.js.map

/***/ }),

/***/ 85803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Filmstrip = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-filmstrip-collapsed'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.filmstrip)),
        React.createElement("path", { fill: primaryFill, fillRule: "evenodd", d: "M8 3H3v10h5V3Zm1-1v12H2V2h7Zm1.75 12V2h1v12h-1ZM13.5 2v12h1V2h-1Z", clipRule: "evenodd" })));
};
Filmstrip.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Filmstrip;
//# sourceMappingURL=Filmstrip.js.map

/***/ }),

/***/ 76702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Flipboard = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-flipboard'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.flipboard)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { d: "M1 1v14h14V1H1Zm11.2 5.6H9.4v2.8H6.6v2.8H3.8V3.8h8.4v2.8Z", fill: primaryFill })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Flipboard.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Flipboard;
//# sourceMappingURL=Flipboard.js.map

/***/ }),

/***/ 20381:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Gallery = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-gallery'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.gallery)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 4H3v7h1V5h8V4Zm1 1h1v8H4v-1H2V3h11v2ZM5 6h8v6H5V6Z", fill: "#000" })));
};
Gallery.propTypes = {
    className: PropTypes.string
};
module.exports = Gallery;
//# sourceMappingURL=Gallery.js.map

/***/ }),

/***/ 25727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const GoogleNews = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-googlenews'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", style: { marginTop: '16px' }, ...attrs },
        React.createElement("title", null, formatMessage(translations.googlenews)),
        React.createElement("path", { d: "M13.406 13.091a.358.358 0 0 1-.358.357H2.951a.358.358 0 0 1-.358-.357V5.458a.358.358 0 0 1 .358-.357h10.097a.358.358 0 0 1 .358.357v7.633Zm-1.769-1.995V10.4a.046.046 0 0 0-.029-.043.046.046 0 0 0-.018-.004H8.456v.794h3.134a.048.048 0 0 0 .034-.014.048.048 0 0 0 .013-.034v-.002Zm.477-1.51v-.7a.046.046 0 0 0-.013-.033.047.047 0 0 0-.033-.015H8.456v.795h3.611a.046.046 0 0 0 .043-.028.045.045 0 0 0 .004-.017v-.003.002Zm-.477-1.509v-.703a.046.046 0 0 0-.014-.034.047.047 0 0 0-.033-.013H8.456v.794h3.134a.048.048 0 0 0 .047-.046v.002Zm-5.883.84v.715h1.032c-.085.437-.47.754-1.032.754a1.153 1.153 0 0 1 0-2.304c.271-.004.534.098.73.286l.546-.544a1.832 1.832 0 0 0-1.276-.497 1.907 1.907 0 1 0 0 3.813c1.102 0 1.827-.775 1.827-1.865 0-.121-.01-.242-.03-.361l-1.797.003Zm-3.43-3.728a.36.36 0 0 1 .358-.358h7.09l-.74-2.036a.347.347 0 0 0-.434-.223L1.214 5.26a.346.346 0 0 0-.188.452l1.298 3.565V5.189Zm0 0a.36.36 0 0 1 .358-.358h7.09l-.74-2.036a.347.347 0 0 0-.434-.223L1.214 5.26a.346.346 0 0 0-.188.452l1.298 3.565V5.189Zm12.432-.181L9.621 3.626l.438 1.205h3.258a.358.358 0 0 1 .357.358v5.13l1.31-4.88a.345.345 0 0 0-.228-.431Zm-2.622-.977V2.354A.356.356 0 0 0 11.777 2H4.222a.356.356 0 0 0-.359.353v1.655l4.894-1.78a.346.346 0 0 1 .433.226l.318.874 2.626.703Z", fill: "#000" })));
};
GoogleNews.propTypes = {
    className: PropTypes.string
};
module.exports = GoogleNews;
//# sourceMappingURL=GoogleNews.js.map

/***/ }),

/***/ 36355:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Grid = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-grid'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.grid)),
        React.createElement("path", { stroke: "#000", d: "M1.5 1.5h5v5h-5zM1.5 9.5h5v5h-5zM9.5 1.5h5v5h-5zM9.5 9.5h5v5h-5z" })));
};
Grid.propTypes = {
    className: PropTypes.string
};
module.exports = Grid;
//# sourceMappingURL=Grid.js.map

/***/ }),

/***/ 43657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.headphoneIconTitle] - Optional prop to show custom title
 */
const Headphone = (props) => {
    const { formatMessage } = useIntl();
    const { headphoneIconTitle, className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-headphone'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, headphoneIconTitle || formatMessage(translations.headphone)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 1a7 7 0 0 0-7 7v3.194C1 13.272 2.728 15 4.806 15h.613v-1.1a1.53 1.53 0 0 0 .958-1.429V9.916a1.53 1.53 0 0 0-.958-1.43V7.387h-.613a3.775 3.775 0 0 0-2.58.99V8C2.226 4.84 4.84 2.226 8 2.226c3.16 0 5.774 2.615 5.774 5.774v.377a3.775 3.775 0 0 0-2.58-.99h-.613v1.1a1.53 1.53 0 0 0-.958 1.43v2.554c0 .626.372 1.198.958 1.43V15h.613C13.272 15 15 13.272 15 11.194V8a7 7 0 0 0-7-7Z", fill: primaryFill })));
};
Headphone.propTypes = {
    className: PropTypes.string,
    headphoneIconTitle: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = Headphone;
//# sourceMappingURL=Headphone.js.map

/***/ }),

/***/ 25965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Information = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-information'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.information)),
        React.createElement("path", { d: "M7.125 5.156c0-.36.295-.656.656-.656h.438c.36 0 .656.295.656.656v.438c0 .36-.295.656-.656.656H7.78a.658.658 0 0 1-.656-.656v-.438ZM9.75 11.5h-3.5v-.875h.875V8H6.25v-.875h2.625v3.5h.875v.875Z" }),
        React.createElement("path", { d: "M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1Zm0 12.688A5.687 5.687 0 1 1 8 2.313a5.687 5.687 0 0 1 0 11.374Z" })));
};
Information.propTypes = {
    className: PropTypes.string
};
module.exports = Information;
//# sourceMappingURL=Information.js.map

/***/ }),

/***/ 25855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Instagram = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-instagram'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.instagram)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fill: primaryFill, fillRule: "evenodd", d: "M8 1c1.901 0 2.14.009 2.886.042.745.034 1.254.152 1.699.325.46.179.851.419 1.24.808.39.389.629.779.808 1.24.173.445.29.954.325 1.7.034.746.042.984.042 2.885 0 1.901-.009 2.14-.042 2.886-.034.745-.152 1.254-.325 1.699-.176.467-.452.89-.808 1.24-.389.39-.779.629-1.24.808-.445.173-.954.29-1.7.325C10.14 14.992 9.902 15 8 15c-1.901 0-2.14-.009-2.886-.042-.745-.034-1.254-.152-1.699-.325a3.432 3.432 0 0 1-1.24-.808 3.432 3.432 0 0 1-.807-1.24c-.174-.445-.292-.954-.326-1.7C1.009 10.14 1 9.902 1 8c0-1.901.009-2.14.042-2.886.034-.745.152-1.254.325-1.699.179-.46.419-.851.808-1.24.389-.39.779-.629 1.24-.807.445-.174.954-.292 1.7-.326C5.86 1.009 6.098 1 8 1Zm0 1.75c-1.71 0-1.913.006-2.587.038-.625.028-.964.132-1.19.22a1.983 1.983 0 0 0-.735.479 1.966 1.966 0 0 0-.48.736c-.087.226-.192.565-.22 1.19-.032.674-.038.877-.038 2.587 0 1.71.006 1.913.038 2.587.028.625.132.964.22 1.19.116.299.255.512.479.735.224.225.437.364.736.48.226.087.565.192 1.19.22.674.032.877.038 2.587.038 1.71 0 1.913-.006 2.587-.038.625-.028.964-.132 1.19-.22.299-.116.512-.255.735-.479.225-.224.364-.437.48-.736.087-.226.192-.565.22-1.19.032-.674.038-.877.038-2.587 0-1.71-.006-1.913-.038-2.587-.028-.625-.132-.964-.22-1.19a1.985 1.985 0 0 0-.479-.735 1.984 1.984 0 0 0-.736-.48c-.226-.087-.565-.192-1.19-.22C9.913 2.756 9.71 2.75 8 2.75Zm0 1.547a3.703 3.703 0 1 1 0 7.406 3.703 3.703 0 0 1 0-7.406Zm0 5.775a2.072 2.072 0 1 0 0-4.144 2.072 2.072 0 0 0 0 4.144Zm4.637-5.703a1.006 1.006 0 1 1-2.012 0 1.006 1.006 0 0 1 2.012 0Z", clipRule: "evenodd" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Instagram.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Instagram;
//# sourceMappingURL=Instagram.js.map

/***/ }),

/***/ 82281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LargeChevron = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-large-chevron'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.largechevron)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m2.646 6.354.708-.708L8 10.293l4.646-4.647.707.708L8 11.707 2.646 6.354Z", fill: "#000" })));
};
LargeChevron.propTypes = {
    className: PropTypes.string
};
module.exports = LargeChevron;
//# sourceMappingURL=LargeChevron.js.map

/***/ }),

/***/ 66191:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const LeftChevron = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-left_chevron'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.chevron)),
        React.createElement("path", { d: "M11 15L4 8L11 1", stroke: "black", strokeWidth: "1.5" })));
};
LeftChevron.propTypes = {
    className: PropTypes.string
};
module.exports = LeftChevron;
//# sourceMappingURL=LeftChevron.js.map

/***/ }),

/***/ 50716:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Like = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-like'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.like)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m7.29 3.886.716-.698.725.688-.715.753-.725-.743Zm1.398-1.432a69.19 69.19 0 0 1-.682.734s-.254-.26-.685-.731c-.14-.152-.297-.326-.47-.52C6.27 1.403 5.58 1 4.855 1 2.726 1 1 2.802 1 5.021a4.124 4.124 0 0 0 .678 2.28c.433.656 2.304 2.653 5.622 5.99l.706.709.705-.71c3.307-3.336 5.177-5.333 5.61-5.99A4.125 4.125 0 0 0 15 5.022C15 2.801 13.274 1 11.144 1c-.725 0-1.453.354-1.983.937-.175.193-.334.366-.473.517Zm-.683 10.128a219.613 219.613 0 0 0 3.663-3.766c1.07-1.136 1.645-1.802 1.82-2.066m-5.483 5.832a213.152 213.152 0 0 1-3.672-3.767c-1.072-1.135-1.646-1.8-1.82-2.064A3.125 3.125 0 0 1 2 5.025v-.004C2 3.314 3.318 2 4.856 2c.35 0 .795.201 1.283.641a53.57 53.57 0 0 0 1.065 1.155l.063.066.017.017.005.005.002.002.715-.698.725.688.022-.023.06-.064.231-.247c.201-.216.493-.531.857-.933.368-.405.84-.609 1.243-.609C12.682 2 14 3.313 14 5.021c0 .648-.19 1.241-.513 1.729", fill: "#000" })));
};
Like.propTypes = {
    className: PropTypes.string
};
module.exports = Like;
//# sourceMappingURL=Like.js.map

/***/ }),

/***/ 27404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LikeFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-like-filled'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.likeFilled)),
        React.createElement("path", { d: "M14.25 5.06c0 .707-.207 1.356-.556 1.89-.189.29-.78.98-1.847 2.122a227.354 227.354 0 0 1-3.842 3.985A220.585 220.585 0 0 1 4.154 9.07c-1.068-1.14-1.659-1.83-1.848-2.12a3.443 3.443 0 0 1-.556-1.888V5.06c0-1.864 1.427-3.31 3.106-3.31.44 0 .945.251 1.457.72a8.067 8.067 0 0 1 1.01 1.467l.012.023.002.004v.001l.679 1.337.662-1.344v-.001l.003-.004.011-.022.05-.095a7.449 7.449 0 0 1 .976-1.388c.41-.455.945-.698 1.426-.698 1.68 0 3.106 1.446 3.106 3.31Z", fill: "#000", stroke: "#000", strokeWidth: "1.5" })));
};
LikeFilled.propTypes = {
    className: PropTypes.string
};
module.exports = LikeFilled;
//# sourceMappingURL=LikeFilled.js.map

/***/ }),

/***/ 35105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Line = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-line'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.line)),
        React.createElement("path", { d: "M15 6.68C15 3.548 11.86 1 8 1S1 3.548 1 6.68c0 2.808 2.49 5.16 5.854 5.605.228.05.538.15.617.345.07.177.046.454.022.633l-.1.6c-.03.176-.14.692.607.377.747-.315 4.031-2.374 5.5-4.064C14.514 9.063 15 7.934 15 6.68ZM5.53 8.353a.136.136 0 0 1-.136.136H3.432a.135.135 0 0 1-.136-.136v-3.05c0-.075.061-.136.137-.136h.49c.076 0 .137.06.137.136v2.423h1.334c.075 0 .136.06.136.136v.49Zm1.184 0a.136.136 0 0 1-.136.137h-.491a.136.136 0 0 1-.136-.137v-3.05c0-.075.06-.136.136-.136h.49c.076 0 .137.06.137.136v3.05Zm3.38 0a.136.136 0 0 1-.137.137h-.49a.14.14 0 0 1-.113-.058l-1.4-1.89v1.812a.136.136 0 0 1-.136.136h-.491a.136.136 0 0 1-.136-.136v-3.05c0-.076.06-.137.136-.137h.49a.13.13 0 0 1 .113.06l1.398 1.889V5.303c0-.075.061-.136.136-.136h.491c.075 0 .136.06.136.136l.002 3.05Zm2.71-2.558a.136.136 0 0 1-.135.136h-1.335v.515h1.335c.075 0 .136.061.136.137v.49a.136.136 0 0 1-.136.137h-1.335v.516h1.335c.075 0 .136.06.136.136v.49a.136.136 0 0 1-.136.137h-1.962a.138.138 0 0 1-.136-.136v-3.05c0-.073.063-.136.136-.136h1.962c.075 0 .136.061.136.137v.49Z", fill: "#000" })));
};
Line.propTypes = {
    className: PropTypes.string
};
module.exports = Line;
//# sourceMappingURL=Line.js.map

/***/ }),

/***/ 22921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const LinkedIn = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-linkedin'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.linkedIn)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15 14.96h-2.892v-4.526c0-1.08-.02-2.468-1.502-2.468-1.506 0-1.736 1.177-1.736 2.39v4.605H5.978V5.653h2.776v1.271h.038c.387-.732 1.33-1.503 2.738-1.503 2.93 0 3.47 1.928 3.47 4.434v5.106ZM2.719 4.357A1.678 1.678 0 1 1 2.637 1a1.678 1.678 0 0 1 .082 3.355ZM1.27 14.96h2.894V5.653H1.27v9.308Z", fill: "#000" })));
};
LinkedIn.propTypes = {
    className: PropTypes.string
};
module.exports = LinkedIn;
//# sourceMappingURL=LinkedIn.js.map

/***/ }),

/***/ 25963:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const List = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-list'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.list)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15 2.5H4v1h11v-1Zm0 5H4v1h11v-1Zm-14 0h1v1H1v-1Zm1-5H1v1h1v-1Zm2 10h11v1H4v-1Zm-2 0H1v1h1v-1Z", fill: "#000" })));
};
List.propTypes = {
    className: PropTypes.string
};
module.exports = List;
//# sourceMappingURL=List.js.map

/***/ }),

/***/ 32209:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Maximize = (props) => {
    const { formatMessage } = useIntl();
    const { className, secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-maximize'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.maximize)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 1.5H1.5V6h1V2.5H6v-1Zm4 13h4.5V10h-1v3.5H10v1Zm4.5-13V6h-1V2.5H10v-1h4.5ZM1.5 10v4.5H6v-1H2.5V10h-1Z", fill: "#000" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Maximize.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Maximize;
//# sourceMappingURL=Maximize.js.map

/***/ }),

/***/ 26488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Menu = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-menu'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.menu)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 2.5h14v1H1v-1Zm0 5h14v1H1v-1Zm14 5H1v1h14v-1Z", fill: "#000" })));
};
Menu.propTypes = {
    className: PropTypes.string
};
module.exports = Menu;
//# sourceMappingURL=Menu.js.map

/***/ }),

/***/ 67977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * Native share icon.
 *
 * @param {string}  [className] - classes for svg
 * @param {func}    [onIconClick] - onClick hadler
 * @returns {ReactElement} child components
 */
const NativeShare = ({ className = '', onIconClick = () => { }, onKeyDown = () => { }, tabIndex = '-1' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: `icon ${className}`, viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", focusable: "false", onClick: onIconClick, onKeyDown: onKeyDown, tabIndex: tabIndex },
        React.createElement("title", null, formatMessage(translations.nativeShare)),
        React.createElement("path", { d: "M12.5 5.2a2.1 2.1 0 1 0-2.063-1.707l-4.98 2.904a2.1 2.1 0 1 0 0 3.204l4.98 2.905a2.1 2.1 0 1 0 .706-1.209l-4.98-2.904c.05-.26.05-.527 0-.787l4.979-2.903c.367.31.84.497 1.358.497Z", fill: "#000" })));
};
NativeShare.propTypes = {
    className: PropTypes.string,
    onIconClick: PropTypes.func,
    onKeyDown: PropTypes.func,
    tabIndex: PropTypes.string
};
module.exports = NativeShare;
//# sourceMappingURL=NativeShare.js.map

/***/ }),

/***/ 55020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Newsletter = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-newsletter'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.newsletter)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.5 1.5h-11v5h-1v8h13v-8h-1v-5Zm-1 5.9V2.5h-9v4.9l4.5 3 4.5-3ZM2.599 8 8 11.6 13.401 8h.099v5.5h-11V8h.099ZM11 5.5H5v-1h6v1Zm-6 2h6v-1H5v1Z", fill: "#000" })));
};
Newsletter.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = Newsletter;
//# sourceMappingURL=Newsletter.js.map

/***/ }),

/***/ 66491:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const NewsletterArrow = (props) => {
    const { className, secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-newsletter icon-newsletter-arrow'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("mask", { id: "path-1-inside-1_286_5730", fill: "white" },
                React.createElement("path", { d: "M11.977 10.6866V11.6866L12.977 10.6866H11.977ZM2.75 2.37325L11.25 11.3732L12.704 10L4.20403 1L2.75 2.37325ZM12.977 10.6866V4.0092H10.977V10.6866H12.977ZM11.977 9.68662H5.32782V11.6866H11.977V9.68662Z" })),
            React.createElement("path", { d: "M11.977 10.6866V11.6866L12.977 10.6866H11.977ZM2.75 2.37325L11.25 11.3732L12.704 10L4.20403 1L2.75 2.37325ZM12.977 10.6866V4.0092H10.977V10.6866H12.977ZM11.977 9.68662H5.32782V11.6866H11.977V9.68662Z", fill: "black" }),
            React.createElement("path", { d: "M11.977 10.6866V9.68662H10.977V10.6866H11.977ZM11.977 11.6866V12.6866H12.3912L12.6841 12.3937L11.977 11.6866ZM12.977 10.6866L13.6841 11.3937L13.977 11.1008V10.6866H12.977ZM2.75 2.37325L2.06338 1.64624L1.33636 2.33286L2.02299 3.05987L2.75 2.37325ZM11.25 11.3732L10.523 12.0598L11.2096 12.7869L11.9366 12.1002L11.25 11.3732ZM12.704 10L13.3906 10.727L14.1177 10.0404L13.431 9.3134L12.704 10ZM4.20403 1L4.93104 0.313378L4.24442 -0.413638L3.5174 0.272987L4.20403 1ZM12.977 4.0092H13.977V3.0092H12.977V4.0092ZM10.977 4.0092V3.0092H9.97701V4.0092H10.977ZM10.977 10.6866H9.97701V11.6866H10.977V10.6866ZM11.977 9.68662H12.977V8.68662H11.977V9.68662ZM5.32782 9.68662V8.68662H4.32782V9.68662H5.32782ZM5.32782 11.6866H4.32782V12.6866H5.32782V11.6866ZM10.977 10.6866V11.6866H12.977V10.6866H10.977ZM12.6841 12.3937L13.6841 11.3937L12.2699 9.97952L11.2699 10.9795L12.6841 12.3937ZM12.977 9.68662H11.977V11.6866H12.977V9.68662ZM2.02299 3.05987L10.523 12.0598L11.977 10.6866L3.47701 1.68662L2.02299 3.05987ZM11.9366 12.1002L13.3906 10.727L12.0174 9.273L10.5634 10.6462L11.9366 12.1002ZM13.431 9.3134L4.93104 0.313378L3.47701 1.68662L11.977 10.6866L13.431 9.3134ZM3.5174 0.272987L2.06338 1.64624L3.43662 3.10026L4.89065 1.72701L3.5174 0.272987ZM13.977 10.6866V4.0092H11.977V10.6866H13.977ZM12.977 3.0092H10.977V5.0092H12.977V3.0092ZM9.97701 4.0092V10.6866H11.977V4.0092H9.97701ZM10.977 11.6866H12.977V9.68662H10.977V11.6866ZM11.977 8.68662H5.32782V10.6866H11.977V8.68662ZM4.32782 9.68662V11.6866H6.32782V9.68662H4.32782ZM5.32782 12.6866H11.977V10.6866H5.32782V12.6866ZM12.977 11.6866V9.68662H10.977V11.6866H12.977Z", fill: "black", mask: "url(#path-1-inside-1_286_5730)" }),
            React.createElement("path", { d: "M1 14.6866H15H1Z", fill: "black" }),
            React.createElement("path", { d: "M1 14.6866H15", stroke: "black" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
NewsletterArrow.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = NewsletterArrow;
//# sourceMappingURL=NewsletterArrow.js.map

/***/ }),

/***/ 32313:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const OK = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-ok'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ok)),
        React.createElement("path", { fill: "#000", fillRule: "evenodd", d: "M11.668 4.614a3.616 3.616 0 0 1-3.613 3.611A3.616 3.616 0 0 1 4.44 4.614 3.617 3.617 0 0 1 8.055 1a3.617 3.617 0 0 1 3.613 3.614Zm-2.117 0c0-.825-.671-1.496-1.496-1.496s-1.496.67-1.496 1.496c0 .824.671 1.495 1.496 1.495.824 0 1.496-.671 1.496-1.495Zm-.035 6.559 2.02 2.02.002.002a1.057 1.057 0 0 1-.002 1.495h-.001a1.057 1.057 0 0 1-1.495 0l-1.986-1.985L6.07 14.69a1.059 1.059 0 0 1-1.498-1.497l2.02-2.02a6.772 6.772 0 0 1-2.097-.87 1.059 1.059 0 0 1-.332-1.459v-.001a1.058 1.058 0 0 1 1.46-.331c1.478.93 3.383.93 4.864 0V8.51a1.058 1.058 0 0 1 1.127 1.793c-.645.405-1.354.7-2.098.869Z", clipRule: "evenodd" })));
};
OK.propTypes = {
    className: PropTypes.string
};
module.exports = OK;
//# sourceMappingURL=OK.js.map

/***/ }),

/***/ 19775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Share = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-paperclip'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.share)),
        React.createElement("g", { clipPath: "url(#clip0_157_406)" },
            React.createElement("path", { d: "M3.95 8C3.95 7.145 4.645 6.45 5.5 6.45H7.5V5.5H5.5C4.12 5.5 3 6.62 3 8C3 9.38 4.12 10.5 5.5 10.5H7.5V9.55H5.5C4.645 9.55 3.95 8.855 3.95 8ZM6 8.5H10V7.5H6V8.5ZM10.5 5.5H8.5V6.45H10.5C11.355 6.45 12.05 7.145 12.05 8C12.05 8.855 11.355 9.55 10.5 9.55H8.5V10.5H10.5C11.88 10.5 13 9.38 13 8C13 6.62 11.88 5.5 10.5 5.5Z", fill: "black" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "clip0_157_406" },
                React.createElement("rect", { width: "10", height: "5", fill: "white", transform: "translate(3 5.5)" })))));
};
Share.propTypes = {
    className: PropTypes.string
};
module.exports = Share;
//# sourceMappingURL=Paperclip.js.map

/***/ }),

/***/ 23971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Passkey = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-passkey'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.passkey)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.61 8.626s.004 1.1.46 1.598c.489.53.989.658.989.658v2.636H1V11.87C1 9.68 5.39 8.576 7.588 8.576c.264 0 .7.017 1.021.05Zm2.272-4.332a3.293 3.293 0 1 1-6.588 0 3.293 3.293 0 1 1 6.588 0Zm1.84 1.977c-1.282.014-2.319 1.023-2.334 2.268a2.159 2.159 0 0 0 1.416 2.068l-.04 3.339c-.002.1.029.185.106.257l.603.574a.235.235 0 0 0 .318-.007l1.126-1.096c.1-.101.098-.239.004-.334l-.635-.612.91-.89a.222.222 0 0 0-.002-.327l-.866-.85c1.065-.448 1.66-1.243 1.672-2.175.015-1.241-1-2.23-2.279-2.215Zm.96 2.306a.988.988 0 1 1-1.976 0 .988.988 0 0 1 1.976 0Z", fill: "#000" })));
};
Passkey.propTypes = {
    className: PropTypes.string
};
module.exports = Passkey;
//# sourceMappingURL=Passkey.js.map

/***/ }),

/***/ 57561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Pause = (props) => {
    const { formatMessage } = useIntl();
    const { className, title, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-pause'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.pause)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6 2H3v12h3V2Zm4 0h3v12h-3V2Z", fill: "#000" })));
};
Pause.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = Pause;
//# sourceMappingURL=Pause.js.map

/***/ }),

/***/ 26407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const PhotoStack = (props) => {
    const { formatMessage } = useIntl();
    const { title, className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-photoStack'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.photoStack)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1 1h9v9H1V1Zm1 1v7h7V2H2Z", fill: "#0879BF" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.5 1v11.5H1v-1h10.5V1h1Z", fill: "#0879BF" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.5 3v11.5H3v-1h10.5V3h1Z", fill: "#0879BF" })));
};
PhotoStack.propTypes = {
    className: PropTypes.string,
    title: PropTypes.string
};
module.exports = PhotoStack;
//# sourceMappingURL=PhotoStack.js.map

/***/ }),

/***/ 16401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Pinterest = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-pinterest'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.pinterest)),
        React.createElement("path", { fill: "#000", fillRule: "evenodd", d: "M7.523 10.142c-.33 1.44-.651 2.826-1.353 3.92-.215.335-.432.757-.8.938-.542-2.794.593-5.145 1.041-7.494-.571-1.166-.216-3.14 1.008-3.365 1.773-.324 1.306 1.815 1.006 2.809-.167.546-.463 1.068-.419 1.667.1 1.26 1.686 1.343 2.498.693 1.166-.929 1.504-2.723 1.39-4.198-.173-2.244-2.715-3.36-4.96-2.463-1.158.462-2.208 1.525-2.36 3.087-.079.823.093 1.48.417 1.944.048.07.216.195.242.383.05.38-.175.79-.382 1.073-1.15-.331-1.743-1.363-1.837-2.669-.22-2.975 2.224-5.236 5.097-5.448 3.068-.225 5.499 1.546 5.725 4.128.168 1.92-.514 3.85-1.595 4.89-.814.781-2.542 1.547-3.955.8-.313-.166-.453-.37-.763-.695Z", clipRule: "evenodd" })));
};
Pinterest.propTypes = {
    className: PropTypes.string
};
module.exports = Pinterest;
//# sourceMappingURL=Pinterest.js.map

/***/ }),

/***/ 69433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Play = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-play'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.play)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m2 1 12.25 7L2 15V1Z" })));
};
Play.propTypes = {
    className: PropTypes.string
};
module.exports = Play;
//# sourceMappingURL=Play.js.map

/***/ }),

/***/ 77067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const PlayOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-play-outlined'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playOutlined)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 1v14l12.25-7L2 1Zm1 1.723v10.554L12.234 8 3 2.723Z" })));
};
PlayOutlined.propTypes = {
    className: PropTypes.string
};
module.exports = PlayOutlined;
//# sourceMappingURL=PlayOutlined.js.map

/***/ }),

/***/ 65469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const PlaylistIcon = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-playlist'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.playlist)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.2 1.5H1v1h11.2v-1Zm0 4H1v1h11.2v-1ZM1 9.5h7.467v1H1v-1ZM15 11l-5-3v6l5-3Z", fill: "#000" })));
};
PlaylistIcon.propTypes = {
    className: PropTypes.string
};
module.exports = PlaylistIcon;
//# sourceMappingURL=Playlist.js.map

/***/ }),

/***/ 19368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Print = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-print'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.print)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.5 2.5H11.5V5.5H14.5V11.5H11.5V13.5H4.5V11.5H1.5V5.5H4.5V2.5ZM4.5 10.5V8.5H11.5V10.5H13.5V6.5H11.5H4.5H2.5V10.5H4.5ZM10.5 3.5V5.5H5.5V3.5H10.5ZM5.5 12.5V9.5H10.5V12.5H5.5Z", fill: primaryFill })));
};
Print.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = Print;
//# sourceMappingURL=Print.js.map

/***/ }),

/***/ 60614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingFilled = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-rating-filled', className), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ratingFilled)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fill: primaryFill, fillRule: "evenodd", d: "M8 12.573 3.674 15l.858-5.077L1 6.347l4.857-.709L8 1l2.143 4.638 4.857.71-3.533 3.575.86 5.077L8 12.573Z", clipRule: "evenodd" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
RatingFilled.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = RatingFilled;
//# sourceMappingURL=RatingFilled.js.map

/***/ }),

/***/ 60703:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingHalf = (props) => {
    const { formatMessage } = useIntl();
    const { className, showTitle = true, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-rating-half', className), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        showTitle ? (React.createElement("title", null, formatMessage(translations.ratingHalf))) : null,
        React.createElement("path", { fill: primaryFill, d: "M4.789 9.391a.551.551 0 0 1 .184.604L3.564 14.58a.324.324 0 0 0 .193.403.29.29 0 0 0 .28-.044l3.657-2.809A.517.517 0 0 1 8 12.025V1a.315.315 0 0 0-.271.219L6.32 5.646a.516.516 0 0 1-.481.368H1.307A.306.306 0 0 0 1 6.329a.297.297 0 0 0 .123.254L4.789 9.39Z" }),
        React.createElement("path", { fill: secondaryFill, d: "m8.307 12.13 3.657 2.809a.3.3 0 0 0 .429-.07.36.36 0 0 0 .043-.289l-1.408-4.585a.55.55 0 0 1 .183-.604l3.667-2.808a.324.324 0 0 0-.042-.538.28.28 0 0 0-.133-.031h-4.515a.516.516 0 0 1-.49-.368L8.289 1.22A.289.289 0 0 0 8 1v11.025c.111.001.218.038.307.105Z" })));
};
RatingHalf.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string,
    showTitle: PropTypes.bool
};
module.exports = RatingHalf;
//# sourceMappingURL=RatingHalf.js.map

/***/ }),

/***/ 85348:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const RatingOutlined = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-rating-outlined', className), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.ratingOutlined)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fill: primaryFill, fillRule: "evenodd", clipRule: "evenodd", d: "m8 11.426 2.992 1.678-.596-3.519L12.9 7.05l-3.437-.502L8 3.384 6.538 6.55 3.1 7.05l2.503 2.534-.595 3.52L8 11.425ZM3.674 15l.858-5.077L1 6.347l4.857-.709L8 1l2.143 4.638 4.857.71-3.533 3.575.86 5.077L8 12.573 3.674 15Z" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
RatingOutlined.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = RatingOutlined;
//# sourceMappingURL=RatingOutlined.js.map

/***/ }),

/***/ 39184:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Replay = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-replay'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.replay)),
        React.createElement("path", { d: "M4.133 7.463C4.41 5.245 6.378 3.5 8.8 3.5c2.614 0 4.7 2.033 4.7 4.5s-2.086 4.5-4.7 4.5a4.791 4.791 0 0 1-3.296-1.293l-.686.728A5.791 5.791 0 0 0 8.8 13.5c3.13 0 5.7-2.444 5.7-5.5s-2.57-5.5-5.7-5.5c-2.791 0-5.138 1.945-5.613 4.534L1.91 5.211l-.825.578 2.33 3.323L6.87 6.87l-.54-.833-2.197 1.425Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
Replay.propTypes = {
    className: PropTypes.string
};
module.exports = Replay;
//# sourceMappingURL=Replay.js.map

/***/ }),

/***/ 42223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Rss = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-rss'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.rss)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fill: primaryFill, d: "M2.925 11.15c1.05 0 1.75.875 1.925 1.925 0 1.05-.875 1.925-1.925 1.925A1.942 1.942 0 0 1 1 13.075c0-1.05.875-1.925 1.925-1.925Zm-1.75-5.425c5.075 0 9.1 4.025 9.1 9.1V15H7.65v-.175c0-3.5-2.8-6.475-6.475-6.475H1l.175-2.625Zm0-4.725C8.7 1 15 7.125 15 14.825V15h-2.625v-.175c0-6.125-5.075-11.2-11.2-11.2H1L1.175 1Z" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Rss.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Rss;
//# sourceMappingURL=Rss.js.map

/***/ }),

/***/ 73767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Search = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-search'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", "data-testid": "iconSearch", ...attrs },
        React.createElement("title", null, formatMessage(translations.search)),
        React.createElement("path", { fill: primaryFill, fillRule: "evenodd", clipRule: "evenodd", d: "M12 7A5 5 0 1 1 2 7a5 5 0 0 1 10 0Zm-1.126 4.582a6 6 0 1 1 .707-.707l3.773 3.771-.707.708-3.773-3.772Z" })));
};
Search.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = Search;
//# sourceMappingURL=Search.js.map

/***/ }),

/***/ 44244:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Share = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-share'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.share)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.354 4.646 8 1.293 4.646 4.646l.708.708L7.5 3.207V10h1V3.207l2.146 2.147.708-.708ZM3.5 6.5H6v1H4.5v6h7v-6H10v-1h2.5v8h-9v-8Z", fill: "#000" })));
};
Share.propTypes = {
    className: PropTypes.string
};
module.exports = Share;
//# sourceMappingURL=Share.js.map

/***/ }),

/***/ 61599:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Shopping = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-shopping'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.shopping)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.5 4a1.5 1.5 0 1 1 3 0h-3Zm-1 0a2.5 2.5 0 0 1 5 0H15v10H1V4h4.5ZM2 13V5h12v8H2Z", fill: primaryFill })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Shopping.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Shopping;
//# sourceMappingURL=Shopping.js.map

/***/ }),

/***/ 8550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
/**
 * @param {object} props - React props
 * @param {string} [props.title] - Optional prop to show custom title
 */
const SlimHeadphone = (props) => {
    const { formatMessage } = useIntl();
    const { title, ...attrs } = props;
    const className = '';
    return (React.createElement("svg", { className: `icon ${className}`, width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", focusable: "false", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, title || formatMessage(translations.headphone)),
        React.createElement("mask", { id: "a", fill: "#fff" },
            React.createElement("path", { d: "M13.92 7.632a5.895 5.895 0 0 0-11.79 0L2 12l-.606-.214V7.632a6.632 6.632 0 0 1 13.263 0v4.135l-.737-.451V7.632Z" })),
        React.createElement("path", { d: "m2.13 7.632 1 .03v-.03h-1Zm-.736 4.154h-1v.707l.667.236.333-.943ZM2 12l-.333.943 1.292.456.04-1.37L2 12Zm11.92-.684h-1v.56l.478.292.522-.852Zm.737.451-.523.853 1.523.933v-1.786h-1Zm-6.632-9.03a4.895 4.895 0 0 1 4.895 4.895h2A6.895 6.895 0 0 0 8.025.737v2ZM3.131 7.632a4.895 4.895 0 0 1 4.894-4.895v-2a6.895 6.895 0 0 0-6.894 6.895h2ZM8.025 2a5.632 5.632 0 0 1 5.632 5.632h2A7.632 7.632 0 0 0 8.025 0v2ZM2.394 7.632A5.632 5.632 0 0 1 8.025 2V0A7.632 7.632 0 0 0 .394 7.632h2Zm-2 0v4.154h2V7.632h-2Zm.737-.03-.13 4.368L3 12.03l.13-4.369-1.999-.06Zm-.07 5.127.606.214.666-1.886-.606-.214-.666 1.886Zm11.86-5.097v3.684h2V7.632h-2Zm.477 4.536.736.452 1.045-1.705-.736-.452-1.045 1.705Zm2.259-.4V7.631h-2v4.135h2Z", fill: "#000", mask: "url(#a)" }),
        React.createElement("mask", { id: "b", fill: "#fff" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.078 8.389v6.59a3.316 3.316 0 1 1 0-6.591Z" })),
        React.createElement("path", { d: "m5.078 14.98.11.994.89-.099v-.895h-1Zm0-6.591h1v-.896l-.89-.098-.11.994Zm1 6.59V8.39h-2v6.59h2Zm-1.11-.993c-.085.01-.17.014-.258.014v2c.16 0 .32-.009.478-.026l-.22-1.988ZM4.71 14a2.316 2.316 0 0 1-2.316-2.316h-2A4.316 4.316 0 0 0 4.71 16v-2Zm-2.316-2.316A2.316 2.316 0 0 1 4.71 9.368v-2a4.316 4.316 0 0 0-4.316 4.316h2ZM4.71 9.368c.087 0 .173.005.258.015l.22-1.988a4.353 4.353 0 0 0-.478-.027v2Z", fill: "#000", mask: "url(#b)" }),
        React.createElement("mask", { id: "c", fill: "#fff" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.973 14.98V8.389a3.316 3.316 0 1 1 0 6.591Z" })),
        React.createElement("path", { d: "m10.973 8.389-.11-.994-.89.098v.896h1Zm0 6.59h-1v.896l.89.099.11-.994Zm-1-6.59v6.59h2V8.39h-2Zm1.11.994c.084-.01.17-.015.258-.015v-2c-.161 0-.32.01-.478.027l.22 1.988Zm.258-.015a2.316 2.316 0 0 1 2.316 2.316h2a4.316 4.316 0 0 0-4.316-4.316v2Zm2.316 2.316A2.316 2.316 0 0 1 11.34 14v2a4.316 4.316 0 0 0 4.316-4.316h-2ZM11.34 14c-.088 0-.174-.005-.258-.014l-.22 1.988c.157.017.317.026.478.026v-2Z", fill: "#000", mask: "url(#c)" }),
        React.createElement("path", { d: "M4.341 9.105c1.221 0 2.21.99 2.21 2.21v.738c0 1.22-.989 2.21-2.21 2.21V9.105ZM11.71 14.263a2.21 2.21 0 0 1-2.21-2.21v-.737c0-1.221.989-2.21 2.21-2.21v5.157Z", fill: "#000" })));
};
SlimHeadphone.propTypes = {
    title: PropTypes.string
};
module.exports = SlimHeadphone;
//# sourceMappingURL=SlimHeadphone.js.map

/***/ }),

/***/ 37193:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Snapchat = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-snapchat'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.snapchat)),
        React.createElement("path", { fill: primaryFill, fillRule: "evenodd", clipRule: "evenodd", d: "M8.135 1H8.1l-.242.003c-.577 0-2.535.16-3.458 2.23-.31.697-.237 1.88-.177 2.83l.022.342a.558.558 0 0 1-.272.06c-.185 0-.401-.059-.645-.173a.52.52 0 0 0-.222-.045c-.285 0-.627.188-.68.467-.039.202.052.496.7.752.059.024.129.046.204.07.267.085.672.213.782.471.057.135.034.307-.068.514l-.006.014c-.036.083-.893 2.036-2.795 2.35a.29.29 0 0 0-.243.302.36.36 0 0 0 .031.13c.143.334.746.58 1.842.75.036.049.075.224.098.33.023.105.046.214.08.33a.325.325 0 0 0 .34.246c.09 0 .195-.02.316-.044.183-.035.433-.085.746-.085.174 0 .354.016.535.045.354.06.655.272 1.003.518.5.352 1.063.752 1.921.752.025 0 .049 0 .072-.003.027.002.063.003.102.003.86 0 1.424-.4 1.921-.752.35-.246.65-.459 1.005-.518a3.3 3.3 0 0 1 .535-.045c.298 0 .535.038.745.079.132.026.239.04.316.04h.017a.316.316 0 0 0 .323-.243 5.2 5.2 0 0 0 .08-.325c.023-.107.062-.28.098-.33 1.097-.17 1.7-.414 1.842-.747a.386.386 0 0 0 .031-.131.29.29 0 0 0-.242-.303c-1.904-.313-2.76-2.267-2.795-2.35a.187.187 0 0 0-.007-.013c-.102-.207-.124-.38-.067-.514.11-.258.514-.386.782-.472.075-.023.145-.046.203-.069.475-.187.713-.417.708-.684-.004-.209-.167-.395-.426-.488h-.001a.779.779 0 0 0-.292-.057.646.646 0 0 0-.268.055 1.616 1.616 0 0 1-.603.17.535.535 0 0 1-.236-.057l.018-.3.003-.04c.06-.952.135-2.136-.176-2.832C10.676 1.16 8.713 1 8.134 1h.001Z" })));
};
Snapchat.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = Snapchat;
//# sourceMappingURL=Snapchat.js.map

/***/ }),

/***/ 50762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const SocialHandle = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-socialHandle'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.socialHandle)),
        React.createElement("path", { d: "M10.394 4.46h1.643l-1.113 3.89c-.087.316-.15.552-.19.708-.036.149-.053.28-.053.394 0 .18.058.35.174.51.116.156.301.234.556.234.498 0 .996-.335 1.495-1.004.504-.675.756-1.568.756-2.68 0-1.643-.684-2.823-2.051-3.54-.858-.454-1.822-.681-2.894-.681-1.97 0-3.551.621-4.745 1.864-1.078 1.123-1.616 2.47-1.616 4.042 0 1.745.631 3.128 1.894 4.15 1.118.902 2.483 1.353 4.093 1.353 1.101 0 2.13-.209 3.085-.627a8.188 8.188 0 0 0 1.617-.941l.208-.152.635 1.003a9.338 9.338 0 0 1-2.677 1.506c-.956.34-1.95.511-2.98.511-2.405 0-4.268-.77-5.589-2.312C1.547 11.408 1 9.894 1 8.143c0-1.96.684-3.62 2.05-4.983C4.489 1.72 6.328 1 8.57 1c1.824 0 3.336.493 4.535 1.479C14.368 3.519 15 4.899 15 6.619c0 1.357-.4 2.522-1.2 3.496-.799.968-1.711 1.452-2.737 1.452-.533 0-.944-.155-1.234-.466-.284-.31-.426-.63-.426-.959v-.134l.018-.17c-.22.43-.467.773-.739 1.03-.492.46-1.083.69-1.773.69-.7 0-1.286-.26-1.755-.78-.464-.52-.695-1.245-.695-2.177 0-1.082.356-2.095 1.069-3.039.712-.944 1.587-1.416 2.624-1.416.608 0 1.08.173 1.417.52.254.269.425.576.512.923l.313-1.13ZM6.65 9.837c.19.27.463.404.817.404.62 0 1.126-.484 1.52-1.452.4-.974.6-1.74.6-2.295 0-.316-.093-.582-.278-.797-.186-.216-.435-.323-.747-.323-.603 0-1.122.388-1.556 1.165-.435.77-.652 1.518-.652 2.24 0 .437.099.79.296 1.058Z", fill: "#2B2B2B" })));
};
SocialHandle.propTypes = {
    className: PropTypes.string
};
module.exports = SocialHandle;
//# sourceMappingURL=SocialHandle.js.map

/***/ }),

/***/ 71369:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Spotify = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', secondaryFill = '#fff', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-spotify'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.spotify)),
        React.createElement("g", { clipPath: "url(#a)" },
            React.createElement("path", { fill: primaryFill, fillRule: "evenodd", d: "M12.14 7.205c-2.255-1.34-5.978-1.463-8.132-.809a.654.654 0 1 1-.38-1.253c2.473-.75 6.583-.605 9.181.936a.655.655 0 0 1-.668 1.127Zm-.073 1.985a.546.546 0 0 1-.75.18c-1.882-1.156-4.75-1.492-6.976-.815a.547.547 0 0 1-.317-1.045c2.542-.772 5.702-.398 7.864.93a.546.546 0 0 1 .179.75Zm-.857 1.907a.435.435 0 0 1-.6.145c-1.643-1.005-3.712-1.232-6.15-.676a.437.437 0 0 1-.194-.85c2.667-.61 4.955-.347 6.8.78a.436.436 0 0 1 .144.6ZM8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1Z", clipRule: "evenodd" })),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: "a" },
                React.createElement("path", { fill: secondaryFill, d: "M0 0h16v16H0z" })))));
};
Spotify.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Spotify;
//# sourceMappingURL=Spotify.js.map

/***/ }),

/***/ 7171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Star = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-star'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.star)),
        React.createElement("path", { d: "m8 13.124-4.944 2.543.981-5.319L0 6.602l5.551-.743L8 1l2.449 4.858L16 6.602l-4.037 3.746.981 5.319L8 13.124Z", fillRule: "evenodd", clipRule: "evenodd", fill: "black" })));
};
Star.propTypes = {
    className: PropTypes.string
};
module.exports = Star;
//# sourceMappingURL=Star.js.map

/***/ }),

/***/ 77035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Subscribe = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-subscribe'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.subscribe)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.496 8.91a1.078 1.078 0 0 1 0-1.82c.948-.626.462-2.05-.681-2.016-.809.024-1.386-.741-1.119-1.477.383-1.04-.875-1.921-1.787-1.244-.638.473-1.575.181-1.806-.56-.322-1.057-1.884-1.057-2.206 0-.231.747-1.168 1.04-1.806.56-.912-.671-2.17.21-1.787 1.244.273.73-.31 1.495-1.119 1.477C1.036 5.045.556 6.47 1.505 7.09a1.078 1.078 0 0 1 0 1.822c-.949.625-.463 2.05.68 2.014.809-.023 1.386.742 1.119 1.478-.383 1.04.875 1.915 1.787 1.244.638-.473 1.575-.181 1.806.56.322 1.057 1.884 1.057 2.206 0 .231-.747 1.168-1.04 1.806-.56.912.671 2.17-.21 1.787-1.244-.273-.73.31-1.495 1.119-1.478 1.149.03 1.629-1.395.68-2.014Zm-3.028-1.75L9.657 8.42c-.073.053-.104.14-.073.222l.693 2.044c.06.187-.158.339-.323.222L8.143 9.647a.207.207 0 0 0-.243 0l-1.812 1.261c-.164.117-.383-.04-.322-.222l.693-2.044a.187.187 0 0 0-.073-.222L4.574 7.16c-.164-.118-.079-.363.122-.363h2.237c.091 0 .17-.058.2-.14l.694-2.044c.06-.187.334-.187.395 0l.693 2.044c.03.082.11.14.2.14h2.238c.2 0 .285.245.121.362h-.006Z", fill: "#0879BF" })));
};
Subscribe.propTypes = {
    className: PropTypes.string
};
module.exports = Subscribe;
//# sourceMappingURL=Subscribe.js.map

/***/ }),

/***/ 75260:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Telegram = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-telegram'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.telegram)),
        React.createElement("path", { d: "m.994 6.727 9.532-3.932c.933-.401 4.133-1.667 4.133-1.667s1.466-.6 1.332.8c-.066.6-.4 2.599-.667 4.732l-1 6.399s-.066.933-.799 1.133c-.734.2-1.866-.6-2.066-.733-.134-.134-3.067-1.933-4.133-2.866-.266-.266-.6-.734.067-1.333 1.466-1.332 3.2-3 4.265-4.066.466-.466 1-1.667-1.067-.266L4.793 8.794s-.667.4-1.866.067C1.727 8.528.26 7.994.26 7.994s-.933-.6.734-1.267Z", fill: "black" })));
};
Telegram.propTypes = {
    className: PropTypes.string
};
module.exports = Telegram;
//# sourceMappingURL=Telegram.js.map

/***/ }),

/***/ 92550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Threads = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-threads'), focusable: "false", height: "16", viewBox: "0 0 16 16", width: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.threads)),
        React.createElement("path", { d: "M11.373 7.489a4.91 4.91 0 0 0-.184-.084c-.108-1.99-1.196-3.13-3.023-3.142h-.025c-1.093 0-2.001.466-2.56 1.315l1.004.689c.418-.634 1.074-.77 1.557-.77h.016c.602.005 1.056.18 1.35.52.213.249.356.592.427 1.025a7.687 7.687 0 0 0-1.727-.083c-1.736.1-2.853 1.113-2.778 2.52a2.17 2.17 0 0 0 1.002 1.73c.513.34 1.175.505 1.863.468.908-.05 1.621-.397 2.118-1.03.378-.482.617-1.105.722-1.891.433.261.754.605.93 1.018.302.703.32 1.857-.622 2.799-.826.824-1.818 1.18-3.317 1.192-1.663-.013-2.921-.546-3.739-1.586C3.621 11.206 3.226 9.8 3.211 8c.015-1.8.41-3.206 1.176-4.18.818-1.039 2.076-1.572 3.739-1.585 1.675.013 2.955.549 3.804 1.593.416.513.73 1.157.937 1.908l1.178-.314c-.251-.925-.646-1.721-1.183-2.382C11.774 1.7 10.182 1.014 8.13 1h-.008c-2.047.014-3.622.703-4.68 2.047C2.503 4.244 2.017 5.908 2 7.995v.01c.016 2.086.502 3.751 1.443 4.948C4.5 14.297 6.075 14.986 8.122 15h.008c1.82-.013 3.103-.49 4.16-1.545 1.383-1.381 1.34-3.113.885-4.176-.327-.762-.95-1.381-1.803-1.79ZM8.23 10.443c-.761.043-1.552-.299-1.591-1.03-.029-.543.386-1.149 1.638-1.22.143-.009.284-.013.422-.013.455 0 .88.044 1.267.129-.145 1.8-.99 2.093-1.736 2.134Z", fill: "#000" })));
};
Threads.propTypes = {
    className: PropTypes.string
};
module.exports = Threads;
//# sourceMappingURL=Threads.js.map

/***/ }),

/***/ 97057:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Tiktok = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-tiktok'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.tiktok)),
        React.createElement("path", { d: "M13.978 6.664a3.737 3.737 0 0 1-3.471-1.673v5.755a4.253 4.253 0 1 1-4.253-4.253c.088 0 .175.008.262.013v2.097c-.087-.01-.173-.027-.262-.027a2.17 2.17 0 1 0 0 4.342c1.199 0 2.258-.945 2.258-2.144L8.532 1h2.006a3.735 3.735 0 0 0 3.442 3.335v2.33", fill: "#000" })));
};
Tiktok.propTypes = {
    className: PropTypes.string
};
module.exports = Tiktok;
//# sourceMappingURL=Tiktok.js.map

/***/ }),

/***/ 49811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Timestamp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-timestamp'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.timestamp)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14 8A6 6 0 1 1 2 8a6 6 0 0 1 12 0Zm1 0A7 7 0 1 1 1 8a7 7 0 0 1 14 0Zm-6.5-.207V3h-1v5.207l3.146 3.147.708-.708L8.5 7.793Z", fill: "#000" })));
};
Timestamp.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = Timestamp;
//# sourceMappingURL=Timestamp.js.map

/***/ }),

/***/ 91583:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Triangle = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-triangle', className), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangle)),
        React.createElement("path", { fill: "#000", d: "M15 5H1l7 7 7-7Z" })));
};
Triangle.propTypes = {
    className: PropTypes.string
};
module.exports = Triangle;
//# sourceMappingURL=Triangle.js.map

/***/ }),

/***/ 84979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const TriangleDown = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-triangle-down'), focusable: "false", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangledown)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m8 10.293 6.646-6.647.707.708L8 11.707.646 4.354l.708-.708L8 10.293Z", fill: "#000" })));
};
TriangleDown.propTypes = {
    className: PropTypes.string
};
module.exports = TriangleDown;
//# sourceMappingURL=TriangleDown.js.map

/***/ }),

/***/ 1846:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const TriangleUp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames('icon icon-triangle-up', className), focusable: "false", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.triangleup)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m8 4.707-6.646 6.647-.708-.707L8 3.292l7.354 7.353-.707.708L8 4.707Z", fill: "#000" })));
};
TriangleUp.propTypes = {
    className: PropTypes.string
};
module.exports = TriangleUp;
//# sourceMappingURL=TriangleUp.js.map

/***/ }),

/***/ 10537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Tumblr = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-tumblr'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.tumblr)),
        React.createElement("path", { d: "M11.373 12.182c-.26.124-.758.232-1.13.242-1.12.03-1.338-.787-1.348-1.38V6.686h2.812v-2.12h-2.8V1H6.854c-.034 0-.093.03-.1.105C6.635 2.196 6.123 4.112 4 4.877v1.808h1.417v4.575c0 1.566 1.155 3.791 4.205 3.74 1.029-.018 2.171-.45 2.425-.821l-.674-1.997Z", fill: "black" })));
};
Tumblr.propTypes = {
    className: PropTypes.string
};
module.exports = Tumblr;
//# sourceMappingURL=Tumblr.js.map

/***/ }),

/***/ 98152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Twitter = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-twitter'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.twitter)),
        React.createElement("path", { d: "M9.15274 6.92804L14.2525 1H13.044L8.61591 6.14724L5.07919 1H1L6.34821 8.78354L1 15H2.20855L6.88474 9.56434L10.6198 15H14.699L9.15245 6.92804H9.15274ZM7.49748 8.85211L6.95559 8.07705L2.644 1.90978H4.50026L7.97976 6.88696L8.52164 7.66202L13.0446 14.1316H11.1883L7.49748 8.85241V8.85211Z", fill: primaryFill })));
};
Twitter.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string
};
module.exports = Twitter;
//# sourceMappingURL=Twitter.js.map

/***/ }),

/***/ 98276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VK = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-vk'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.vk)),
        React.createElement("path", { fill: "black", d: "M21.553 6.804c.138-.462 0-.804-.66-.804h-2.19c-.559 0-.81.294-.955.618 0 0-1.11 2.713-2.689 4.477-.51.51-.744.672-1.02.672-.138 0-.348-.162-.348-.624V6.81c0-.558-.156-.804-.618-.804h-3.44c-.347 0-.557.258-.557.504 0 .528.786.648.87 2.13v3.224c0 .708-.126.834-.408.834-.744 0-2.545-2.725-3.619-5.846-.21-.606-.42-.852-.978-.852H2.75C2.125 6 2 6.294 2 6.618c0 .582.744 3.457 3.457 7.256 1.806 2.599 4.357 4.003 6.674 4.003 1.392 0 1.56-.312 1.56-.852v-1.962c0-.625.132-.75.57-.75.324 0 .883.161 2.179 1.415 1.482 1.483 1.728 2.15 2.563 2.15h2.19c.624 0 .936-.313.756-.931-.198-.612-.906-1.506-1.848-2.563-.51-.6-1.273-1.254-1.507-1.578-.324-.42-.234-.6 0-.973 0 0 2.665-3.757 2.947-5.029h.012Z", fillRule: "evenodd", clipRule: "evenodd" })));
};
VK.propTypes = {
    className: PropTypes.string
};
module.exports = VK;
//# sourceMappingURL=VK.js.map

/***/ }),

/***/ 70417:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VerificationBadge = ({ className, color = '#EB0000', ...attrs }) => {
    const { formatMessage } = useIntl();
    return (React.createElement("svg", { className: classnames(className, 'icon icon-verification-badge'), width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.verificationBadge)),
        React.createElement("path", { d: "M14.74 8.933a2.334 2.334 0 0 1 0-1.773l.079-.186c.497-1.182-.078-2.55-1.26-3.048l-.171-.078a2.277 2.277 0 0 1-1.26-1.26l-.062-.155a2.37 2.37 0 0 0-3.063-1.26l-.156.062a2.372 2.372 0 0 1-1.788 0l-.14-.062C5.753.69 4.385 1.266 3.887 2.448l-.062.125a2.277 2.277 0 0 1-1.26 1.26l-.14.061C1.26 4.392.684 5.761 1.182 6.943l.062.14a2.333 2.333 0 0 1 0 1.772l-.062.172a2.304 2.304 0 0 0 1.259 3.032l.156.062a2.277 2.277 0 0 1 1.259 1.26l.078.171a2.323 2.323 0 0 0 3.032 1.275l.171-.077a2.372 2.372 0 0 1 1.788 0l.14.062c1.182.497 2.55-.078 3.048-1.26l.062-.124a2.277 2.277 0 0 1 1.26-1.26l.124-.047a2.321 2.321 0 0 0 1.26-3.048l-.078-.14Zm-7.4 2.1-3.033-2.55.933-1.105 1.928 1.633 3.405-4.043 1.104.933-4.338 5.132Z", fill: color })));
};
VerificationBadge.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = VerificationBadge;
//# sourceMappingURL=VerificationBadge.js.map

/***/ }),

/***/ 56765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Vero = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-vero'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.vero)),
        React.createElement("path", { d: "M13.435 2 8 11.417 7.055 9.85 11.561 2H1l7 11.98L15 2h-1.565Z", fill: "black" })));
};
Vero.propTypes = {
    className: PropTypes.string
};
module.exports = Vero;
//# sourceMappingURL=Vero.js.map

/***/ }),

/***/ 78041:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Viber = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-viber'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.viber)),
        React.createElement("path", { d: "M13.194 2.212c-.328-.298-1.742-1.187-4.693-1.2 0 0-3.494-.23-5.19 1.308-.944.932-1.262 2.319-1.297 4.011-.035 1.692-.215 4.925 2.878 5.785l-.013 2.611c0 .148.023.249.107.27.061.014.152-.017.23-.094.494-.497 2.078-2.409 2.078-2.409 2.125.139 3.816-.28 3.997-.34.429-.138 2.748-.338 3.14-3.509.406-3.27-.149-5.5-1.237-6.433Zm-1.29 7.713v.006c-.162.28-.366.532-.607.747l-.005.004c-.209.174-.414.274-.615.297a.818.818 0 0 1-.351-.035l-.007-.009c-.31-.087-.829-.306-1.691-.783a10.09 10.09 0 0 1-1.421-.939 7.453 7.453 0 0 1-.64-.567l-.021-.021-.022-.022-.021-.022-.022-.021a7.45 7.45 0 0 1-.567-.64 10.091 10.091 0 0 1-.938-1.42c-.476-.864-.695-1.382-.783-1.693l-.01-.007a.819.819 0 0 1-.034-.351c.025-.202.124-.407.298-.616l.004-.006c.215-.24.467-.445.746-.606l.006-.001c.28-.147.547-.097.728.117.002.001.377.452.539.673.166.233.32.475.462.724.184.332.069.672-.113.812l-.366.29c-.185.15-.16.428-.16.428s.542 2.054 2.569 2.572c0 0 .277.023.426-.161l.291-.366c.14-.182.48-.298.812-.113.248.142.49.296.723.462.22.162.671.539.673.539.214.181.264.448.117.728Zm-1.677-5.068c-.41-.448-.972-.692-1.718-.747a.197.197 0 1 1 .029-.394c.84.062 1.506.356 1.98.875.477.52.71 1.174.693 1.945a.197.197 0 0 1-.197.193h-.005a.197.197 0 0 1-.193-.202c.015-.674-.178-1.22-.589-1.67ZM10.2 6.182a.197.197 0 0 1-.188.207h-.01a.197.197 0 0 1-.196-.187c-.034-.67-.349-.999-.993-1.032a.197.197 0 0 1 .02-.395c.85.045 1.323.531 1.367 1.407Zm1.852.952h-.001a.197.197 0 0 1-.197-.195c-.01-1.191-.367-2.139-1.062-2.817-.697-.68-1.577-1.028-2.617-1.035a.197.197 0 0 1 .001-.395h.002c1.145.008 2.117.394 2.89 1.147.773.755 1.17 1.796 1.18 3.097a.197.197 0 0 1-.196.198Z", fill: "black" })));
};
Viber.propTypes = {
    className: PropTypes.string
};
module.exports = Viber;
//# sourceMappingURL=Viber.js.map

/***/ }),

/***/ 62524:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Video = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-video'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.video)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 1v14l12.25-7L2 1Zm1 1.723v10.554L12.234 8 3 2.723Z", fill: "#000" })));
};
Video.propTypes = {
    className: PropTypes.string
};
module.exports = Video;
//# sourceMappingURL=Video.js.map

/***/ }),

/***/ 82785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VolumeHigh = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-volume-high'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.volumeHigh)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 1.117v13.766l-6-3.6V10.5h-2v-5h2v-.783l6-3.6ZM2.5 6.5h-1v3h1v-3Zm1-1.217v5.434l4 2.4V2.883l-4 2.4ZM12.596 3.404A6.481 6.481 0 0 1 14.5 8c0 1.795-.728 3.42-1.904 4.596l-.707-.707A5.481 5.481 0 0 0 13.5 8a5.481 5.481 0 0 0-1.61-3.889l.706-.707Z", fill: "#000" }),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.666 5.25A3.495 3.495 0 0 1 12 8c0 1.115-.522 2.11-1.334 2.75l-.62-.786A2.495 2.495 0 0 0 11 8c0-.796-.372-1.505-.953-1.964l.62-.785Z", fill: "#000" })));
};
VolumeHigh.propTypes = {
    className: PropTypes.string
};
module.exports = VolumeHigh;
//# sourceMappingURL=VolumeHigh.js.map

/***/ }),

/***/ 3052:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const VolumeMute = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-volume-mute'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.volumeMute)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8.5 1.117v13.766l-6-3.6V10.5h-2v-5h2v-.783l6-3.6ZM2.5 6.5h-1v3h1v-3Zm1-1.217v5.434l4 2.4V2.883l-4 2.4ZM12.293 8l-1.647-1.646.708-.708L13 7.293l1.646-1.647.708.708L13.707 8l1.647 1.646-.708.708L13 8.707l-1.646 1.647-.708-.708L12.293 8Z", fill: "#000" })));
};
VolumeMute.propTypes = {
    className: PropTypes.string
};
module.exports = VolumeMute;
//# sourceMappingURL=VolumeMute.js.map

/***/ }),

/***/ 6133:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const WeChat = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-wechat'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.weChat)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.543 12.05c.89-.644 1.457-1.596 1.457-2.655 0-1.94-1.889-3.514-4.216-3.514-2.328 0-4.216 1.572-4.216 3.514 0 1.94 1.888 3.514 4.216 3.514.48 0 .945-.07 1.377-.193l.123-.018c.082 0 .154.026.223.066l.924.533.081.025a.14.14 0 0 0 .14-.14l-.023-.103-.191-.71-.014-.09a.288.288 0 0 1 .12-.229ZM6.06 2C3.266 2 1 3.889 1 6.216c0 1.27.682 2.415 1.749 3.188.085.06.141.161.141.274l-.018.107-.228.85-.028.124a.17.17 0 0 0 .17.169l.097-.031 1.109-.64a.537.537 0 0 1 .268-.079l.149.022a5.985 5.985 0 0 0 1.653.232l.277-.007a3.275 3.275 0 0 1-.17-1.032c0-2.125 2.066-3.846 4.615-3.846l.274.007C10.677 3.54 8.585 2 6.06 2Zm3.318 6.832a.563.563 0 1 1 0-1.126.563.563 0 0 1 0 1.126Zm2.812 0a.563.563 0 1 1 0-1.126.563.563 0 0 1 0 1.126Zm-7.816-3.29a.676.676 0 1 1 .002-1.353.676.676 0 0 1-.002 1.352Zm3.373 0a.676.676 0 0 1 0-1.35.676.676 0 0 1 0 1.35Z", fill: "black" })));
};
WeChat.propTypes = {
    className: PropTypes.string
};
module.exports = WeChat;
//# sourceMappingURL=WeChat.js.map

/***/ }),

/***/ 97575:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Weibo = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-weibo'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.weibo)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.838 2.037c2.273-.301 3.988 1.261 4.148 3.326.063.78-.071 1.718-.588 1.763-.633.056-.54-.455-.452-.949.03-.162.058-.323.061-.46.03-1.619-1.35-2.742-2.7-2.742-.069 0-.154.008-.246.017-.423.042-1.002.099-.889-.564.056-.318.301-.347.567-.378l.099-.013Zm.432 3.523c.345.405.215 1.127 0 1.685.15.082.305.158.46.233.844.413 1.66.811 1.496 2.151-.048.38-.279.89-.51 1.213-1.651 2.313-6.632 3.288-9.745 1.529C1.926 11.783.847 10.92 1.018 9.2c.141-1.48 1.138-2.626 2.113-3.6.93-.934 1.912-1.663 3.247-1.998 1.45-.364 1.879.845 1.488 2.035.236-.016.548-.102.891-.197.873-.24 1.95-.538 2.513.119Zm-5.52 6.93c1.804.119 3.608-.517 4.463-1.488.313-.357.625-.897.625-1.525C10.834 7.53 8.387 6.81 6.456 6.97c-1.056.085-1.767.308-2.507.744-.606.353-1.313.933-1.488 1.8-.394 1.953 1.73 2.872 3.288 2.976Zm6.888-5.99c.343-.021.514-.538.432-1.134-.116-.84-.848-1.525-1.841-1.447-.028.003-.059.004-.091.005-.229.01-.534.023-.534.427 0 .393.275.393.591.393.183 0 .38 0 .543.076.227.107.488.468.51.78.008.128.001.25-.005.36-.019.334-.032.569.395.54Zm-8.455 4.308c-.531-1.45.748-2.603 2.076-2.741 1.135-.12 1.979.457 2.232 1.216.833 2.519-3.512 3.69-4.308 1.525Zm2.59-.892a.298.298 0 0 0 .297-.298.298.298 0 0 0-.298-.298.298.298 0 0 0-.297.298c0 .164.134.298.297.298Zm-1.15 1.216a.738.738 0 0 0 .736-.736.738.738 0 0 0-.736-.737.738.738 0 0 0-.737.736c0 .406.332.737.737.737Z", fill: "black" })));
};
Weibo.propTypes = {
    className: PropTypes.string
};
module.exports = Weibo;
//# sourceMappingURL=Weibo.js.map

/***/ }),

/***/ 69301:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(68766)["default"]);
const Whatsapp = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-Whatsapp'), focusable: "false", width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.whatsapp)),
        React.createElement("path", { d: "M12.9583 3.03594C11.6439 1.7238 9.89389 1 8.03111 1C4.18889 1 1.05833 4.11197 1.05833 7.93613C1.05833 9.15925 1.37722 10.3514 1.98778 11.4042L1 15L4.69444 14.0362C5.71333 14.5897 6.86056 14.88 8.02722 14.88H8.03111C11.8733 14.88 15 11.768 15 7.94388C15 6.08985 14.2767 4.34808 12.9583 3.03594ZM8.03111 13.7111C6.98889 13.7111 5.97 13.4324 5.07944 12.906L4.86944 12.7821L2.67222 13.3511L3.25556 11.2223L3.11944 11.0055C2.54 10.0882 2.23278 9.02765 2.23278 7.93613C2.23278 4.75836 4.83444 2.16892 8.03111 2.16892C9.57889 2.16892 11.0333 2.76887 12.1261 3.86038C13.2189 4.95189 13.8217 6.3995 13.8217 7.94001C13.8217 11.1216 11.2239 13.7072 8.03111 13.7111ZM11.2083 9.39148C11.0333 9.30633 10.1778 8.88443 10.0183 8.82638C9.85889 8.76832 9.74222 8.74122 9.62556 8.91153C9.50889 9.08571 9.17444 9.47664 9.07333 9.59276C8.97222 9.70887 8.87111 9.72436 8.69611 9.63533C8.52111 9.55018 7.96111 9.36439 7.29611 8.77606C6.77889 8.31545 6.42889 7.75035 6.32778 7.57617C6.22667 7.40199 6.31611 7.3091 6.40556 7.22394C6.48333 7.14653 6.58056 7.02267 6.66611 6.92203C6.75167 6.8214 6.78278 6.74786 6.84111 6.63174C6.89944 6.51562 6.86833 6.41498 6.82556 6.32983C6.78278 6.24468 6.43278 5.38927 6.28889 5.04092C6.14889 4.70417 6.005 4.75062 5.89611 4.74288C5.795 4.73901 5.67833 4.73514 5.56167 4.73514C5.445 4.73514 5.25833 4.77772 5.09889 4.95189C4.93944 5.12607 4.48833 5.5441 4.48833 6.3995C4.48833 7.25491 5.11056 8.07548 5.2 8.1916C5.28556 8.30771 6.42889 10.0572 8.175 10.8081C8.59111 10.9862 8.91389 11.0946 9.16667 11.172C9.58278 11.3036 9.96389 11.2842 10.2633 11.2416C10.5978 11.1913 11.2939 10.8236 11.4378 10.4172C11.5817 10.0108 11.5817 9.6663 11.5389 9.59276C11.4961 9.51921 11.3794 9.47664 11.2083 9.39148Z", fill: "black" })));
};
Whatsapp.propTypes = {
    className: PropTypes.string
};
module.exports = Whatsapp;
//# sourceMappingURL=Whatsapp.js.map

/***/ }),

/***/ 26835:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const Xing = (props) => {
    const { formatMessage } = useIntl();
    const { className, color = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-xing'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.xing)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M13.77 1a.09.09 0 0 1 .08.135l-3.992 6.82a.088.088 0 0 0 0 .09l3.992 6.82a.09.09 0 0 1-.08.135h-2.55a.093.093 0 0 1-.08-.045l-4.043-6.91a.088.088 0 0 1 0-.09l4.043-6.91A.092.092 0 0 1 11.22 1h2.55ZM7.476 5.75a.005.005 0 0 0 .004-.008L6.005 3.217a.139.139 0 0 0-.12-.068H3.591a.135.135 0 0 0-.12.202l1.397 2.39a.005.005 0 0 1-.004.008l-.005.002L3.02 8.718c-.056.09.01.205.118.205h2.29a.139.139 0 0 0 .118-.065L7.47 5.75l.005-.002Z", fill: color })));
};
Xing.propTypes = {
    className: PropTypes.string,
    color: PropTypes.string
};
module.exports = Xing;
//# sourceMappingURL=Xing.js.map

/***/ }),

/***/ 34013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const YandexZen = (props) => {
    const { formatMessage } = useIntl();
    const { className, primaryFill = '#000', ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-yandexzen'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.yandexzen)),
        React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.512 6.512C5.462 7.65 3.887 7.737 1 7.825A6.95 6.95 0 0 1 7.825 1c0 2.887-.175 4.462-1.313 5.512ZM8.262 1c3.675.087 6.65 3.15 6.738 6.825-2.8 0-4.375-.263-5.425-1.313C8.438 5.462 8.35 3.887 8.263 1ZM1 8.263c.175 3.675 3.15 6.65 6.825 6.737-.088-2.8-.263-4.375-1.313-5.425C5.462 8.525 3.887 8.263 1 8.263Zm14 0A7.042 7.042 0 0 1 8.263 15c0-2.8.262-4.375 1.312-5.425C10.625 8.525 12.2 8.35 15 8.263Z", fill: primaryFill })));
};
YandexZen.propTypes = {
    className: PropTypes.string,
    primaryFill: PropTypes.string,
    secondaryFill: PropTypes.string
};
module.exports = YandexZen;
//# sourceMappingURL=YandexZen.js.map

/***/ }),

/***/ 55166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(68766)["default"]);
const YouTube = (props) => {
    const { formatMessage } = useIntl();
    const { className, ...attrs } = props;
    return (React.createElement("svg", { className: classnames(className, 'icon icon-youtube'), focusable: "false", viewBox: "0 0 16 16", width: "16", height: "16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...attrs },
        React.createElement("title", null, formatMessage(translations.youTube)),
        React.createElement("path", { clipRule: "evenodd", fillRule: "evenodd", d: "M14.7078 4.54C14.6286 4.24218 14.4725 3.97039 14.2552 3.75187C14.0379 3.53334 13.767 3.37575 13.4696 3.29487C12.3776 3 8 3 8 3C8 3 3.62237 3 2.53037 3.29487C2.233 3.37575 1.9621 3.53334 1.74481 3.75187C1.52751 3.97039 1.37145 4.24218 1.29225 4.54C1 5.639 1 7.9315 1 7.9315C1 7.9315 1 10.224 1.29225 11.323C1.37131 11.621 1.52732 11.893 1.74462 12.1116C1.96193 12.3303 2.2329 12.4881 2.53037 12.569C3.62237 12.8639 8 12.8639 8 12.8639C8 12.8639 12.3776 12.8639 13.4696 12.569C13.7671 12.4881 14.0381 12.3303 14.2554 12.1116C14.4727 11.893 14.6287 11.621 14.7078 11.323C15 10.2249 15 7.9315 15 7.9315C15 7.9315 15 5.639 14.7078 4.54ZM6.5685 10.0131V5.84988L10.2269 7.93238L6.5685 10.0131Z", fill: "black" })));
};
YouTube.propTypes = {
    className: PropTypes.string
};
module.exports = YouTube;
//# sourceMappingURL=YouTube.js.map

/***/ }),

/***/ 24695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Account = __webpack_require__(63104);
const AgeGate = __webpack_require__(83383);
const Arrow = __webpack_require__(4262);
const Article = __webpack_require__(87793);
const Bookmark = __webpack_require__(70931);
const BookmarkActivated = __webpack_require__(64736);
const BookmarkNew = __webpack_require__(42605);
const BlueSky = __webpack_require__(72942);
const CartFilled = __webpack_require__(80809);
const CartOutlined = __webpack_require__(19751);
const Check = __webpack_require__(18635);
const ChevronRight = __webpack_require__(69880);
const ChevronFill = __webpack_require__(38537);
const ChevronLeft = __webpack_require__(9137);
const ChevronUp = __webpack_require__(47749);
const ChevronDown = __webpack_require__(19328);
const Close = __webpack_require__(76399);
const Collapse = __webpack_require__(73672);
const Comment = __webpack_require__(28650);
const CopyLink = __webpack_require__(19310);
const Dot = __webpack_require__(30408);
const DownloadCloud = __webpack_require__(7742);
const DownloadWeb = __webpack_require__(20821);
const Email = __webpack_require__(43403);
const EmailFilled = __webpack_require__(68579);
const Enlarge = __webpack_require__(28717);
const Expand = __webpack_require__(93467);
const Facebook = __webpack_require__(23871);
const Filmstrip = __webpack_require__(85803);
const Flipboard = __webpack_require__(76702);
const Gallery = __webpack_require__(20381);
const GoogleNews = __webpack_require__(25727);
const Grid = __webpack_require__(36355);
const Headphone = __webpack_require__(43657);
const Information = __webpack_require__(25965);
const Instagram = __webpack_require__(25855);
const LargeChevron = __webpack_require__(82281);
const Like = __webpack_require__(50716);
const LikeFilled = __webpack_require__(27404);
const Line = __webpack_require__(35105);
const LinkedIn = __webpack_require__(22921);
const List = __webpack_require__(25963);
const Maximize = __webpack_require__(32209);
const Menu = __webpack_require__(26488);
const NativeShare = __webpack_require__(67977);
const Newsletter = __webpack_require__(55020);
const NewsletterArrow = __webpack_require__(66491);
const OK = __webpack_require__(32313);
const Paperclip = __webpack_require__(19775);
const Pause = __webpack_require__(57561);
const PhotoStack = __webpack_require__(26407);
const Pinterest = __webpack_require__(16401);
const Play = __webpack_require__(69433);
const Passkey = __webpack_require__(23971);
const Playlist = __webpack_require__(65469);
const PlayOutlined = __webpack_require__(77067);
const Print = __webpack_require__(19368);
const RatingFilled = __webpack_require__(60614);
const RatingHalf = __webpack_require__(60703);
const RatingOutlined = __webpack_require__(85348);
const Replay = __webpack_require__(39184);
const Rss = __webpack_require__(42223);
const Search = __webpack_require__(73767);
const Share = __webpack_require__(44244);
const Shopping = __webpack_require__(61599);
const SlimHeadphone = __webpack_require__(8550);
const Snapchat = __webpack_require__(37193);
const SocialHandle = __webpack_require__(50762);
const Spotify = __webpack_require__(71369);
const Star = __webpack_require__(7171);
const Telegram = __webpack_require__(75260);
const Threads = __webpack_require__(92550);
const Tiktok = __webpack_require__(97057);
const Timestamp = __webpack_require__(49811);
const Triangle = __webpack_require__(91583);
const TriangleDown = __webpack_require__(84979);
const TriangleUp = __webpack_require__(1846);
const Tumblr = __webpack_require__(10537);
const Twitter = __webpack_require__(98152);
const VerificationBadge = __webpack_require__(70417);
const Vero = __webpack_require__(56765);
const Viber = __webpack_require__(78041);
const Video = __webpack_require__(62524);
const VolumeHigh = __webpack_require__(82785);
const VolumeMute = __webpack_require__(3052);
const VK = __webpack_require__(98276);
const WeChat = __webpack_require__(6133);
const Weibo = __webpack_require__(97575);
const Whatsapp = __webpack_require__(69301);
const Xing = __webpack_require__(26835);
const YandexZen = __webpack_require__(34013);
const YouTube = __webpack_require__(55166);
const LeftChevron = __webpack_require__(66191);
const Subscribe = __webpack_require__(77035);
module.exports = {
    Account,
    AgeGate,
    Arrow,
    Article,
    Bookmark,
    BookmarkActivated,
    BookmarkNew,
    BlueSky,
    CartFilled,
    CartOutlined,
    Check,
    ChevronRight,
    ChevronFill,
    ChevronLeft,
    ChevronUp,
    ChevronDown,
    Close,
    Collapse,
    Comment,
    CopyLink,
    Dot,
    DownloadCloud,
    DownloadWeb,
    Email,
    EmailFilled,
    Enlarge,
    Expand,
    Facebook,
    Filmstrip,
    Flipboard,
    Gallery,
    GoogleNews,
    Grid,
    Headphone,
    Information,
    Instagram,
    LargeChevron,
    LeftChevron,
    Like,
    LikeFilled,
    Line,
    LinkedIn,
    List,
    Maximize,
    Menu,
    NativeShare,
    Newsletter,
    NewsletterArrow,
    OK,
    Paperclip,
    Pause,
    PhotoStack,
    Pinterest,
    Play,
    Passkey,
    Playlist,
    PlayOutlined,
    Print,
    RatingFilled,
    RatingHalf,
    RatingOutlined,
    Replay,
    Rss,
    Search,
    Share,
    Shopping,
    SlimHeadphone,
    Snapchat,
    SocialHandle,
    Spotify,
    Star,
    Subscribe,
    Telegram,
    Threads,
    Tiktok,
    Timestamp,
    Triangle,
    TriangleDown,
    TriangleUp,
    Tumblr,
    Twitter,
    VerificationBadge,
    Vero,
    Viber,
    Video,
    VolumeHigh,
    VolumeMute,
    VK,
    WeChat,
    Weibo,
    Whatsapp,
    Xing,
    YandexZen,
    YouTube
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 68766:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_intl_1 = __webpack_require__(46984);
exports["default"] = (0, react_intl_1.defineMessages)({
    account: {
        id: 'Icons.Account',
        defaultMessage: 'Account',
        description: 'Account icon title'
    },
    ageGate: {
        id: 'Icons.AgeGate',
        defaultMessage: 'Age Gate',
        description: 'Age Gate icon title'
    },
    arrow: {
        id: 'Icons.Arrow',
        defaultMessage: 'Arrow',
        description: 'Arrow icon title'
    },
    article: {
        id: 'Icons.Article',
        defaultMessage: 'Article',
        description: 'Article icon title'
    },
    bookmark: {
        id: 'Icons.Bookmark',
        defaultMessage: 'Save Story',
        description: 'Bookmark icon title'
    },
    bookmarkActivated: {
        id: 'Icons.BookmarkActivated',
        defaultMessage: 'Story Saved',
        description: 'BookmarkActivated icon title'
    },
    bluesky: {
        id: 'Icons.bluesky',
        defaultMessage: 'bluesky',
        description: 'BlueSky icon title'
    },
    cart: {
        id: 'Icons.Cart',
        defaultMessage: 'Cart',
        description: 'Cart icon title'
    },
    check: {
        id: 'Icons.Check',
        defaultMessage: 'Check',
        description: 'Check icon title'
    },
    chevron: {
        id: 'Icons.Chevron',
        defaultMessage: 'Chevron',
        description: 'Chevron icon title'
    },
    chevronFill: {
        id: 'Icons.chevronFill',
        defaultMessage: 'chevronFill',
        description: 'chevronFill icon title'
    },
    chevronLeft: {
        id: 'Icons.ChevronLeft',
        defaultMessage: 'Chevron Left',
        description: 'Chevron Left icon title'
    },
    chevronUp: {
        id: 'Icons.ChevronUp',
        defaultMessage: 'Chevron Up',
        description: 'Chevron Up icon title'
    },
    chevronDown: {
        id: 'Icons.ChevronDown',
        defaultMessage: 'Chevron Down',
        description: 'Chevron Down icon title'
    },
    close: {
        id: 'Icons.Close',
        defaultMessage: 'Close',
        description: 'Close icon title'
    },
    collapse: {
        id: 'Icons.Collapse',
        defaultMessage: 'Collapse',
        description: 'Collapse icon title'
    },
    comment: {
        id: 'Icons.Comment',
        defaultMessage: 'Comment',
        description: 'Comment icon title'
    },
    copyLink: {
        id: 'Icons.CopyLink',
        defaultMessage: 'CopyLink',
        description: 'CopyLink title'
    },
    dots: {
        id: 'Icons.Dots',
        defaultMessage: 'Dots',
        description: 'Dots icon title'
    },
    downloadCloud: {
        id: 'Icons.DownloadCloud',
        defaultMessage: 'DownloadCloud',
        description: 'DownloadCloud Icon Title'
    },
    downloadWeb: {
        id: 'Icons.DownloadWeb',
        defaultMessage: 'DownloadWeb',
        description: 'DownloadWeb Icon Title'
    },
    email: {
        id: 'Icons.Email',
        defaultMessage: 'Email',
        description: 'Email icon title'
    },
    expand: {
        id: 'Icons.Expand',
        defaultMessage: 'Expand',
        description: 'Expand icon title'
    },
    facebook: {
        id: 'Icons.Facebook',
        defaultMessage: 'Facebook',
        description: 'Facebook icon title'
    },
    filmstrip: {
        id: 'Icons.Filmstrip',
        defaultMessage: 'Filmstrip',
        description: 'Filmstrip icon title'
    },
    filter: {
        id: 'Icons.Filter',
        defaultMessage: 'Filter',
        description: 'Filter icon title'
    },
    flipboard: {
        id: 'Icons.Flipboard',
        defaultMessage: 'Flipboard',
        description: 'Flipboard icon title'
    },
    funny: {
        id: 'Icons.funny',
        defaultMessage: 'Funny',
        description: 'funny icon title'
    },
    gallery: {
        id: 'Icons.Gallery',
        defaultMessage: 'Gallery',
        description: 'Gallery icon title'
    },
    googlenews: {
        id: 'Icons.GoogleNews',
        defaultMessage: 'Google News',
        description: 'Google News icon title'
    },
    grid: {
        id: 'Icons.Grid',
        defaultMessage: 'Grid',
        description: 'Grid icon title'
    },
    headphone: {
        id: 'Icons.Headphone',
        defaultMessage: 'Headphone',
        description: 'Headphone icon title'
    },
    information: {
        id: 'Icons.Information',
        defaultMessage: 'Information',
        description: 'Information icon title'
    },
    instagram: {
        id: 'Icons.Instagram',
        defaultMessage: 'Instagram',
        description: 'Instagram icon title'
    },
    largechevron: {
        id: 'Icons.LargeChevron',
        defaultMessage: 'LargeChevron',
        description: 'LargeChevron icon title'
    },
    like: {
        id: 'Icons.Like',
        defaultMessage: 'Like',
        description: 'Like icon title'
    },
    likeFilled: {
        id: 'Icons.LikeFilled',
        defaultMessage: 'LikeFilled',
        description: 'LikeFilled icon title'
    },
    line: {
        id: 'Icons.Line',
        defaultMessage: 'Line',
        description: 'Line icon title'
    },
    linkedIn: {
        id: 'Icons.LinkedIn',
        defaultMessage: 'LinkedIn',
        description: 'LinkedIn icon title'
    },
    list: {
        id: 'Icons.List',
        defaultMessage: 'List',
        description: 'List icon title'
    },
    loader: {
        id: 'Icons.Loader',
        defaultMessage: 'Loader',
        description: 'Loader icon title'
    },
    maximize: {
        id: 'Icons.Maximize',
        defaultMessage: 'Maximize',
        description: 'Maximize icon title'
    },
    menu: {
        id: 'Icons.Menu',
        defaultMessage: 'Menu',
        description: 'Menu icon title'
    },
    nativeShare: {
        id: 'Icons.NativeShare',
        defaultMessage: 'Native Share',
        description: 'NativeShare icon title'
    },
    newsletter: {
        id: 'Icons.Newsletter',
        defaultMessage: 'Newsletter',
        description: 'Newsletter icon title'
    },
    ok: {
        id: 'Icons.Ok',
        defaultMessage: 'Odnoklassniki',
        description: 'Ok icon title'
    },
    share: {
        id: 'Icons.Share',
        defaultMessage: 'Share',
        description: 'Share icon title'
    },
    passkey: {
        id: 'Icons.Passkey',
        defaultMessage: 'Passkey',
        description: 'Passkey icon title'
    },
    pause: {
        id: 'Icons.Pause',
        defaultMessage: 'Pause',
        description: 'Pause icon title'
    },
    photoStack: {
        id: 'Icons.PhotoStack',
        defaultMessage: 'PhotoStack',
        description: 'PhotoStack icon title'
    },
    pinterest: {
        id: 'Icons.Pinterest',
        defaultMessage: 'Pinterest',
        description: 'Pinterest icon title'
    },
    play: {
        id: 'Icons.Play',
        defaultMessage: 'Play',
        description: 'Play icon title'
    },
    playCNE: {
        id: 'Icons.PlayCNE',
        defaultMessage: 'PlayCNE',
        description: 'PlayCNE icon title'
    },
    playlist: {
        id: 'Icons.Playlist',
        defaultMessage: 'Playlist',
        description: 'Playlist icon title'
    },
    playOutlined: {
        id: 'Icons.PlayOutlined',
        defaultMessage: 'PlayOutlined',
        description: 'PlayOutlined icon title'
    },
    print: {
        id: 'Icons.Print',
        defaultMessage: 'Print',
        description: 'Print icon title'
    },
    ratingFilled: {
        id: 'Icons.RatingFilled',
        defaultMessage: 'RatingFilled',
        description: 'RatingFilled icon title'
    },
    ratingHalf: {
        id: 'Icons.RatingHalf',
        defaultMessage: 'RatingHalf',
        description: 'RatingHalf icon title'
    },
    ratingOutlined: {
        id: 'Icons.RatingOutlined',
        defaultMessage: 'RatingOutlined',
        description: 'RatingOutlined icon title'
    },
    replay: {
        id: 'Icons.Replay',
        defaultMessage: 'Replay',
        description: 'Replay icon title'
    },
    rss: {
        id: 'Icons.Rss',
        defaultMessage: 'Rss',
        description: 'Rss icon title'
    },
    search: {
        id: 'Icons.Search',
        defaultMessage: 'Search',
        description: 'Search icon title'
    },
    shopping: {
        id: 'Icons.Shopping',
        defaultMessage: 'Shopping',
        description: 'Shopping icon title'
    },
    snapchat: {
        id: 'Icons.Snapchat',
        defaultMessage: 'Snapchat',
        description: 'Snapchat icon title'
    },
    spotify: {
        id: 'Icons.Spotify',
        defaultMessage: 'Spotify',
        description: 'Spotify icon title'
    },
    star: {
        id: 'Icons.Star',
        defaultMessage: 'Star',
        description: 'Star icon title'
    },
    socialHandle: {
        id: 'Icons.SocialHandle',
        defaultMessage: 'SocialHandle',
        description: 'SocialHandle icon title'
    },
    someWhatFunny: {
        id: 'Icons.someWhatFunny',
        defaultMessage: 'Somewhat funny',
        description: 'someWhatFunny icon title'
    },
    subscribe: {
        id: 'Icons.Subscribe',
        defaultMessage: 'Subscribe',
        description: 'Subscribe icon title'
    },
    telegram: {
        id: 'Icons.Telegram',
        defaultMessage: 'Telegram',
        description: 'Telegram icon title'
    },
    threads: {
        id: 'Icons.Threads',
        defaultMessage: 'Threads',
        description: 'Threads icon title'
    },
    tiktok: {
        id: 'Icons.Tiktok',
        defaultMessage: 'Tiktok',
        description: 'Tiktok icon title'
    },
    timestamp: {
        id: 'Icons.Timestamp',
        defaultMessage: 'Timestamp',
        description: 'Timestamp icon title'
    },
    triangle: {
        id: 'Icons.Triangle',
        defaultMessage: 'Triangle',
        description: 'Triangle icon title'
    },
    triangledown: {
        id: 'Icons.TriangleDown',
        defaultMessage: 'TriangleDown',
        description: 'TriangleDown icon title'
    },
    triangleup: {
        id: 'Icons.TriangleUp',
        defaultMessage: 'TriangleUp',
        description: 'TriangleUp icon title'
    },
    tumblr: {
        id: 'Icons.Tumblr',
        defaultMessage: 'Tumblr',
        description: 'Tumblr icon title'
    },
    twitter: {
        id: 'Icons.Twitter',
        defaultMessage: 'X',
        description: 'X icon title'
    },
    unFunny: {
        id: 'Icons.unFunny',
        defaultMessage: 'Unfunny',
        description: 'unFunny icon title'
    },
    verificationBadge: {
        id: 'Icons.VerificationBadge',
        defaultMessage: 'VerificationBadge',
        description: 'VerificationBadge icon title'
    },
    vero: {
        id: 'Icons.Vero',
        defaultMessage: 'VERO',
        description: 'Vero icon title'
    },
    video: {
        id: 'Icons.Video',
        defaultMessage: 'Video',
        description: 'Video icon title'
    },
    viber: {
        id: 'Icons.Viber',
        defaultMessage: 'Rakuten Viber',
        description: 'Viber icon title'
    },
    volumeHigh: {
        id: 'Icons.VolumeHigh',
        defaultMessage: 'Turn on the volume',
        description: 'Volume High'
    },
    volumeMute: {
        id: 'Icons.VolumeMute',
        defaultMessage: 'Turn off the volume',
        description: 'Volume Mute'
    },
    vk: {
        id: 'Icons.Vk',
        defaultMessage: 'VKonkakte',
        description: 'Vk icon title'
    },
    wavyArrow: {
        id: 'Icons.wavyarrow',
        defaultMessage: 'Wavy Arrow',
        description: 'Wavy Arrow icon title'
    },
    weblink: {
        id: 'Icons.WebLink',
        defaultMessage: 'Website Link',
        description: 'Website Link icon title'
    },
    weChat: {
        id: 'Icons.WeChat',
        defaultMessage: 'WeChat',
        description: 'WeChat icon title'
    },
    weibo: {
        id: 'Icons.Weibo',
        defaultMessage: 'Sina Weibo',
        description: 'Weibo icon title'
    },
    whatsapp: {
        id: 'Icons.Whatsapp',
        defaultMessage: 'Whatsapp',
        description: 'Whatsapp icon title'
    },
    xing: {
        id: 'Icons.Xing',
        defaultMessage: 'Xing',
        description: 'Xing icon title'
    },
    yandexzen: {
        id: 'Icons.YandexZen',
        defaultMessage: 'Yandex.Zen',
        description: 'Yandex.Zen icon title'
    },
    youTube: {
        id: 'Icons.YouTube',
        defaultMessage: 'YouTube',
        description: 'YouTube icon title'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 1829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const { useEffect } = __webpack_require__(96540);
const translations = (__webpack_require__(42018)/* ["default"] */ .A);
const { TrackComponentChannel } = __webpack_require__(78788);
const ITEM_TYPE_DEFAULT = 'item';
const ITEM_TYPE_TRANSLATIONS = {
    [ITEM_TYPE_DEFAULT]: translations.itemTypeDefault,
    character: translations.itemTypeCharacter,
    image: translations.itemTypeImage,
    photo: translations.itemTypePhoto,
    slide: translations.itemTypeSlide,
    venue: translations.itemTypeVenue
};
const GalleryIcon = __webpack_require__(39336);
const { ItemsCountWrapper, ItemsCountIcon, ItemsCountContent } = __webpack_require__(8544);
const getItemsCountContent = ({ count, intl, itemType, minCount, messageType }) => {
    // if incorrect item type, return the default 'item'
    if (!Object.prototype.hasOwnProperty.call(ITEM_TYPE_TRANSLATIONS, itemType)) {
        if (messageType) {
            return intl.formatMessage(ITEM_TYPE_TRANSLATIONS[ITEM_TYPE_DEFAULT], {
                messageType,
                count,
                minCount
            });
        }
        return intl.formatMessage(ITEM_TYPE_TRANSLATIONS[ITEM_TYPE_DEFAULT], {
            count
        });
    }
    if (messageType) {
        return intl.formatMessage(ITEM_TYPE_TRANSLATIONS[itemType], {
            messageType,
            count,
            minCount
        });
    }
    return intl.formatMessage(ITEM_TYPE_TRANSLATIONS[itemType], {
        count
    });
};
/**
 * Component to display the number of items within a piece of content (typically slides within a gallery)
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add.
 * @param {number} props.count - Required, number of items announced.
 * @param {string} [props.dangerousItemsTypeIcon] - Optional, icon for items type to display with items count
 * @param {boolean} [props.hasTextCounter] - Optional boolean to show the preTextCount, e.g. 1 /10 characters.
 * @param {string} [props.itemType] - Type of item, used as key for translations, e.g item, photo (Defaults to 'item')
 * @param {number} [props.preTextCount] - textCount, used to count number of text enter, e.g 10/11 characters
 * @param {boolean} [props.showIcon] - Optional. Set to `true` to show an icon with the items count.
 *
 * @returns {ReactElement} <div>
 */
const ItemsCount = ({ className, count, dangerousItemsTypeIcon, hasTextCounter = false, itemType = ITEM_TYPE_DEFAULT, messageType, minCount, preTextCount = 0, showIcon = true }) => {
    useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ItemsCount'
        });
    }, []);
    const intl = useIntl();
    const itemsCountContent = getItemsCountContent({
        count,
        intl,
        itemType,
        minCount,
        messageType
    });
    const handleChooseIcon = dangerousItemsTypeIcon ? (React.createElement(ItemsCountIcon, { className: "items-count__icon", dangerouslySetInnerHTML: { __html: dangerousItemsTypeIcon } })) : (React.createElement(ItemsCountIcon, { className: "items-count__icon gallery" },
        React.createElement(GalleryIcon, null)));
    return (React.createElement(ItemsCountWrapper, { className: classnames('items-count', className) },
        showIcon && handleChooseIcon,
        hasTextCounter && (React.createElement(ItemsCountContent, { className: "text-count__prefix", hasTextCounter: hasTextCounter },
            preTextCount,
            " /")),
        React.createElement(ItemsCountContent, { className: "items-count__content", hasTextCounter: hasTextCounter }, itemsCountContent)));
};
ItemsCount.propTypes = {
    className: PropTypes.string,
    count: PropTypes.number.isRequired,
    dangerousItemsTypeIcon: PropTypes.string,
    hasTextCounter: PropTypes.bool,
    itemType: PropTypes.string,
    messageType: PropTypes.string,
    minCount: PropTypes.number,
    preTextCount: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    showIcon: PropTypes.bool
};
module.exports = ItemsCount;
//# sourceMappingURL=ItemsCount.js.map

/***/ }),

/***/ 78372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(1829);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorStyles, getTypographyStyles, getLinkStyles } = __webpack_require__(26865);
const ItemsCountWrapper = styled.div.withConfig({
    displayName: 'ItemsCountWrapper'
}) `
  display: inline-flex;
  align-items: center;
`;
const ItemsCountIcon = styled(BaseText).withConfig({
    displayName: 'ItemsCountIcon'
}) `
  display: inline-block;
  margin-right: ${calculateSpacing(0.5)};
  width: 100%;
  max-width: ${calculateSpacing(3)};
  height: 100%;
  vertical-align: middle;

  .icon {
    ${({ theme }) => getColorStyles(theme, 'fill', 'colors.consumption.lead.standard.accent')};
    display: block;
    height: 100%;
  }
`;
ItemsCountIcon.defaultProps = {
    as: 'span'
};
const ItemsCountContent = styled(BaseText).withConfig({
    displayName: 'ItemsCountContent'
}) `
  display: inline-block;
  ${({ theme, typeIdentity }) => getTypographyStyles(theme, typeIdentity)}

  ${({ theme, colorToken }) => getLinkStyles(theme, colorToken)}

  ${({ theme, hasTextCounter }) => hasTextCounter &&
    getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')}

  &:hover {
    ${({ hasTextCounter }) => hasTextCounter &&
    ` 
      text-decoration: none;
    `}
  }
`;
ItemsCountContent.defaultProps = {
    as: 'span',
    colorToken: 'colors.consumption.lead.standard.heading',
    typeIdentity: 'typography.definitions.globalEditorial.numerical-small'
};
module.exports = {
    ItemsCountWrapper,
    ItemsCountIcon,
    ItemsCountContent
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 42018:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
// for documentation on plurals:
// https://formatjs.io/docs/core-concepts/icu-syntax/#plural-format
exports.A = (0, react_intl_1.defineMessages)({
    itemTypeCharacter: {
        id: 'ItemCount.ItemTypeCharacter',
        defaultMessage: `{messageType, select,
      withMinCountLimit {{count, plural,
                    one {# character}
                    other {# characters}
                  }
                  (at least 
                    {minCount ,plural,
                    one {# character}
                    other {# characters}
                  } are required)}
      other {{count, plural,
        one {# character}
        other {# characters}
    }}
  }`,
        description: 'Item type for character with plurals'
    },
    itemTypeDefault: {
        id: 'ItemCount.ItemTypeDefault',
        defaultMessage: `{count, plural,
        one {# Item}
        other {# Items}
    }`,
        description: 'Default item type for items with plurals'
    },
    itemTypeImage: {
        id: 'ItemCount.ItemTypeImage',
        defaultMessage: `{count, plural,
        one {# Image}
        other {# Images}
    }`,
        description: 'Item type for images with plurals'
    },
    itemTypePhoto: {
        id: 'ItemCount.ItemTypePhoto',
        defaultMessage: `{count, plural,
        one {# Photo}
        other {# Photos}
    }`,
        description: 'Item type for photos with plurals'
    },
    itemTypeSlide: {
        id: 'ItemCount.ItemTypeSlide',
        defaultMessage: `{count, plural,
        one {# Slide}
        other {# Slides}
    }`,
        description: 'Item type for slides with plurals'
    },
    itemTypeVenue: {
        id: 'ItemCount.ItemTypeVenue',
        defaultMessage: `{count, plural,
        one {# Venue}
        other {# Venues}
    }`,
        description: 'Item type for venues with plurals'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 32272:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { CircleWrapper } = __webpack_require__(86286);
const Circle = ({ fillColor = '#000', width = '100px', height = '100px', margin = '20px', className = '', ...props }) => (React.createElement(CircleWrapper, { style: {
        width,
        height,
        margin,
        display: 'inline-block'
    }, className: classnames(className, 'icon icon-loader'), ...props, version: "1.1", id: "L9", xmlns: "http://www.w3.org/2000/svg", x: "0px", y: "0px", viewBox: "0 0 100 100", enableBackground: "new 0 0 0 0" },
    React.createElement("path", { fill: fillColor, d: "M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50 M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50" })));
Circle.propTypes = {
    className: PropTypes.string,
    fillColor: PropTypes.string,
    height: PropTypes.string,
    margin: PropTypes.string,
    width: PropTypes.string
};
module.exports = Circle;
//# sourceMappingURL=Circle.js.map

/***/ }),

/***/ 13644:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { VogueWrapper } = __webpack_require__(86286);
/**
 * Vogue Loader component
 *
 * @returns {ReactElement} <svg>
 */
const Vogue = () => {
    return (React.createElement(VogueWrapper, { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 36", textRendering: "geometricPrecision", shapeRendering: "geometricPrecision", className: "loader-vogue" },
        React.createElement("path", { id: "E", className: "st0", d: "M23.2612,0L23.2612,11.7649C23.2612,11.8148,23.0279,11.8315,23.0279,11.7649C23.0279,11.6982,23.2612,0.333282,12.7129,0.333282L8.76346,0.333282C8.54683,0.333282,8.41352,0.36661,8.41352,0.549915L8.41352,15.231C8.41352,15.3643,8.54683,15.4476,8.76346,15.4476L10.0799,15.4476C16.3456,15.4476,15.8457,9.14859,15.8457,9.08193C15.8457,9.01528,16.0957,9.03194,16.0957,9.08193C16.0957,9.13193,16.1123,22.2966,16.1123,22.3466C16.1123,22.3966,15.929,22.4132,15.929,22.3466C15.929,22.2799,15.779,15.7809,9.94661,15.7809L8.76346,15.7809C8.56349,15.7809,8.41352,15.8476,8.41352,15.9975L8.41352,31.7951C8.41352,31.9118,8.54683,32.0117,8.76346,32.0117C9.64666,32.0117,11.9296,32.0284,12.5629,32.0284C23.8945,32.0617,23.7445,19.8969,23.7445,19.8469C23.7445,19.797,24.0278,19.797,24.0278,19.8469L24.0278,32.445L0.114794,32.445C0.0481373,32.445,0.0481373,32.0951,0.114794,32.0951L2.49776,32.0951C2.71439,32.0951,2.84771,32.0284,2.84771,31.8784C2.84771,29.1455,2.84771,0.799877,2.84771,0.549915C2.84771,0.349946,2.58108,0.333282,2.49776,0.333282C2.46443,0.333282,1.23129,0.333282,0.0148091,0.333282C0.0148091,0.333282,-0.0685114,0.166641,0.0148091,0C0.0981296,0,23.2612,0,23.2612,0", opacity: "0", transform: "translate(4.15223,1.87884)", style: { animation: 'E_o 1.5s linear infinite both' } }),
        React.createElement("path", { id: "U", className: "st0", d: "M27.1719,0.266719C25.7716,0.266719,24.3713,0.266719,24.3713,0.266719C24.3713,0.266719,24.0214,0.266719,24.0214,0.466748C24.0214,2.70041,24.0214,21.5031,24.0214,24.1868L24.0214,24.2034C24.038,30.8378,18.9372,33.0048,15.2701,33.0548L15.2701,33.0381C10.9528,33.0548,3.20169,32.338,3.20169,22.77C3.20169,22.77,3.18502,1.00016,3.16835,0.700115C3.15167,0.233381,2.55159,0.250051,2.55159,0.250051C2.55159,0.250051,0.10124,0.250051,0.017895,0.250051C-0.0654503,0.250051,-0.0487813,-0.1,0.017895,-0.1L11.9529,-0.1C12.0196,-0.1,12.003,0.250051,11.9529,0.250051C11.9029,0.250051,9.41925,0.250051,9.41925,0.250051C9.41925,0.250051,8.6358,0.216712,8.6358,0.733453C8.6358,1.46689,8.65246,25.0203,8.65246,25.8537C8.65246,29.5209,10.7361,32.7714,15.2534,32.7048C18.7873,32.638,23.6879,30.5711,23.6714,24.1868C23.6714,23.8701,23.6714,2.83376,23.6714,0.466748C23.6546,0.283389,23.3046,0.266719,23.3046,0.266719L19.9875,0.266719C19.9207,0.266719,19.9207,-0.0666619,20.004,-0.0666619C20.0208,-0.0666619,27.0885,-0.0666619,27.1719,-0.0666619C27.2385,0.100029,27.1719,0.266719,27.1719,0.266719Z", opacity: "0", transform: "translate(2.57354,1.9455)", style: { animation: 'U_o 1.5s linear infinite both' } }),
        React.createElement("path", { id: "G", className: "st0", d: "M16.5382,19.9408L19.2012,19.9408C19.2012,19.9408,19.7005,19.8909,19.7005,20.124C19.7005,20.1406,19.7005,27.7636,19.7005,27.7636C19.7005,33.6389,13.8419,33.7056,12.1941,33.5224C6.06906,32.8233,5.95255,20.1905,5.91927,16.8784C5.83605,7.85727,7.2508,0.00125154,13.4091,0.317489C20.7159,0.683659,22.63,11.1694,22.7465,11.6355C22.9962,11.7187,22.9962,11.519,22.9962,11.519L23.0127,0.0844721C23.0127,0.0844721,22.9628,-0.0153926,22.813,0.11776C22.7631,0.167692,22.6965,0.23427,22.63,0.300845C19.401,3.59637,17.7866,0.134404,13.0762,-0.0153926C7.28409,-0.198477,0.0938322,7.82398,-0.00603238,17.0947C-0.105897,26.4154,6.01913,33.6056,12.7101,33.8554C16.3385,33.9885,16.2553,32.9898,20.7324,31.5917C23.4621,30.743,24.7604,32.5904,24.8602,33.356C25.0267,33.4725,25.0434,33.2727,25.0434,33.2727L25.0434,20.1739C25.0434,19.9077,25.4094,19.9576,25.4094,19.9576L27.8729,19.9576C27.9394,19.9576,27.9394,19.5914,27.8729,19.5914L16.5216,19.5914C16.4383,19.5914,16.4383,19.9408,16.5382,19.9408", opacity: "0", transform: "translate(2.19725,0.935133)", style: { animation: 'G_o 1.5s linear infinite both' } }),
        React.createElement("path", { id: "O", className: "st0", d: "M5.92208,16.6329C5.92208,7.61677,7.65213,0.247436,14.0399,0.264071C20.9103,0.264071,22.2578,7.93283,22.2578,16.6496C22.2578,25.6659,20.9435,33.4346,14.09,33.4346C6.73721,33.4177,5.92208,26.115,5.92208,16.6329M13.9735,33.6839C20.7938,33.7005,28.1633,26.1649,28.18,16.8159C28.1965,7.01792,21.1101,0.0478142,14.09,-0.00209099C6.90356,-0.0686311,0,7.83302,0,16.8159C0,26.0983,6.52095,33.6507,13.9735,33.6839", opacity: "0", transform: "translate(2.065,1.05937)", style: { animation: 'O_o 1.5s linear infinite both' } }),
        React.createElement("path", { id: "V", className: "st0", d: "M0.0178861,0L11.7176,0C11.7843,0,11.7676,0.349993,11.7176,0.349993L9.31769,0.349993C9.31769,0.349993,8.63437,0.31666,8.85104,0.699985C8.88437,0.783317,17.1175,23.2828,17.1175,23.2828C17.1175,23.2828,17.2675,23.6662,17.3842,23.7162C17.3842,23.7162,24.7007,1.11664,24.7007,1.09998C24.7674,0.883315,25.034,0.366659,24.584,0.366659L21.9341,0.366659C21.8841,0.366659,21.8841,0.0166663,21.9341,0.0166663L28.234,0.0166663C28.284,0.0166663,28.284,0.366659,28.234,0.366659L25.884,0.366659C25.234,0.349993,25.234,0.549989,25.1174,0.883315C25.0674,1.04998,14.9342,32.616,14.9342,32.616C14.9342,32.616,14.8842,32.4827,14.8509,32.3493C10.5677,19.9663,3.93447,2.73328,3.40115,0.883315C3.25115,0.333326,3.16782,0.349993,2.83449,0.349993C2.71783,0.349993,0.101218,0.349993,0.0178861,0.349993C-0.0654455,0.349993,-0.0487792,0,0.0178861,0", opacity: "0", transform: "translate(2.03854,1.8455)", style: { animation: 'V_o 1.5s linear infinite both' } })));
};
module.exports = Vogue;
//# sourceMappingURL=Vogue.js.map

/***/ }),

/***/ 62930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Circle = __webpack_require__(32272);
const Vogue = __webpack_require__(13644);
module.exports = {
    Circle,
    Vogue
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86286:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { keyframes } = __webpack_require__(92168);
const { calculateSpacing } = __webpack_require__(26865);
const rotate = keyframes `
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
const CircleWrapper = styled.svg.withConfig({ displayName: 'CircleWrapper' }) `
  path {
    transform-origin: 50% 50%;
    animation: ${rotate} 1.2s linear infinite;
  }
`;
const VogueWrapper = styled.svg.withConfig({ displayName: 'VogueWrapper' }) `
  animation: rotate 2s linear infinite;
  width: 36px;
  height: 32px;

  & .path {
    stroke: #5652bf;
    stroke-linecap: round;
    animation: dash 1.5s ease-in-out infinite;
  }

  @keyframes E_o {
    0% {
      opacity: 0;
    }

    80.5556% {
      animation-timing-function: cubic-bezier(0, 0, 0.58, 1);
      opacity: 0;
    }

    83.3333% {
      opacity: 1;
    }

    97.2222% {
      animation-timing-function: cubic-bezier(0.42, 0, 1, 1);
      opacity: 1;
    }

    100% {
      opacity: 0;
    }
  }
  @keyframes U_o {
    0% {
      opacity: 0;
    }

    63.8889% {
      animation-timing-function: cubic-bezier(0, 0, 0.58, 1);
      opacity: 0;
    }

    66.6667% {
      opacity: 1;
    }

    80.5556% {
      animation-timing-function: cubic-bezier(0.42, 0, 1, 1);
      opacity: 1;
    }

    83.3333% {
      opacity: 0;
    }

    100% {
      opacity: 0;
    }
  }
  @keyframes G_o {
    0% {
      opacity: 0;
    }

    47.2222% {
      animation-timing-function: cubic-bezier(0, 0, 0.58, 1);
      opacity: 0;
    }

    50% {
      opacity: 1;
    }

    63.8889% {
      animation-timing-function: cubic-bezier(0.42, 0, 1, 1);
      opacity: 1;
    }

    66.6667% {
      opacity: 0;
    }

    100% {
      opacity: 0;
    }
  }
  @keyframes O_o {
    0% {
      opacity: 0;
    }

    30.5556% {
      animation-timing-function: cubic-bezier(0, 0, 0.58, 1);
      opacity: 0;
    }

    33.3333% {
      opacity: 1;
    }

    47.2222% {
      animation-timing-function: cubic-bezier(0.42, 0, 1, 1);
      opacity: 1;
    }

    50% {
      opacity: 0;
    }

    100% {
      opacity: 0;
    }
  }
  @keyframes V_o {
    0% {
      opacity: 0;
    }

    13.8889% {
      animation-timing-function: cubic-bezier(0, 0, 0.58, 1);
      opacity: 0;
    }

    16.6667% {
      animation-timing-function: cubic-bezier(0, 0, 0.58, 1);
      opacity: 1;
    }

    30.5556% {
      animation-timing-function: cubic-bezier(0.42, 0, 1, 1);
      opacity: 1;
    }

    33.3333% {
      opacity: 0;
    }

    100% {
      opacity: 0;
    }
  }
`;
const LoaderWrapper = styled.div.withConfig({ displayName: 'LoaderWrapper' }) `
  padding-top: ${calculateSpacing(6)};
  text-align: center;
`;
module.exports = {
    VogueWrapper,
    LoaderWrapper,
    CircleWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 13447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useEffect, useState } = __webpack_require__(96540);
const { MessageBannerContent, MessageBannerWrapper, MessageBannerTitle, MessageBannerCloseButton, MessageBannerCTA } = __webpack_require__(8070);
const { TrackComponentChannel } = __webpack_require__(78788);
const CloseIcon = __webpack_require__(76399);
const { storageFactory } = __webpack_require__(60663);
const localStore = storageFactory(() => window.localStorage);
/**
 * MessageBanner component
 *
 * @param {string} props.children - message content to show in banner (example component prop)
 * @param {string} [props.className] - additional classes for the component
 * @param {Function} [props.buttonClickHandler] - some func
 * @param {string} [props.buttonHref] - optional button href
 * @param {string} [props.contentAlign] - the alignment of the content within the banner
 * @param {Function} [props.closeButtonCallback] - function called when close Button is clicked
 * @param {number} [props.delayDuration] - amount of milliseconds to wait before hiding the banner
 * @param {boolean} [props.isFixed] - enables the message banner to be fixed to the bottom of the screen
 * @param {number} [props.hasBoxShadow] - Optional to add box-shadow property
 * @param {string} [props.position] - Optional to apply styles on positioning of the banner
 * @param {boolean} [props.title] - message banner content with title
 * @param {boolean} [props.shouldUseDescriptionToken] - Use Description token for message content
 * @param {boolean} [props.shouldHideBannerOnButtonClick] - Optional to hide banner after button is clicked
 * @param {boolean} [props.shouldOrderCloseButtonLast] - Optional position close button after other elements
 * @param {boolean} [props.hasBorderRadius] - Optional prop to apply border radius to the message banner
 *
 * @returns {ReactElement} <div>
 */
const MessageBanner = ({ btnSize, btnStyle, buttonHref, buttonLabel, children, className, closeButtonCallback, contentAlign = 'left', delayDuration = 0, hasBorderRadius = false, hasBoxShadow = false, isFixed = false, shouldAddButton, buttonClickHandler, isDisclaimer = false, shouldShowCloseButton, title, position, shouldHideBannerOnButtonClick = false, shouldOrderCloseButtonLast = false, shouldUseDescriptionToken = false }) => {
    const [hideBanner, setHideBanner] = React.useState(false);
    React.useEffect(() => {
        // Comment this below condition when needed
        if (true) {
            localStore.removeItem('alreadyShown');
        }
        // Use below logic to show banner disclaimer for only
        // an instance and hide for later for a domain
        // if (isDisclaimer &&
        //   !shouldRememberAlreadyShown &&
        //   window.localStorage.getItem('alreadyShown')
        // ) {
        //   setHideBanner(true);
        // }
        // setLoading(false);
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'MessageBanner'
        });
    }, []);
    const [hideDelayTimeout, setHideDelayTimeout] = useState();
    const [isHidden, setIsHidden] = useState(false);
    useEffect(() => {
        if (delayDuration > 0 && !hideDelayTimeout) {
            setHideDelayTimeout(setTimeout(() => {
                setIsHidden(true);
            }, delayDuration));
        }
        return () => {
            clearTimeout(hideDelayTimeout);
        };
    }, [hideDelayTimeout, delayDuration]);
    if (isHidden) {
        return null;
    }
    return (!hideBanner && (React.createElement(MessageBannerWrapper, { className: className, "data-testid": "message-banner", isFixed: isFixed, isDisclaimer: isDisclaimer, shouldShowCloseButton: shouldShowCloseButton, position: position, hasBoxShadow: hasBoxShadow, hasBorderRadius: hasBorderRadius },
        title && (React.createElement(MessageBannerTitle, { contentAlign: contentAlign }, title)),
        React.createElement(MessageBannerContent, { contentAlign: contentAlign, isDisclaimer: isDisclaimer, shouldUseDescriptionToken: shouldUseDescriptionToken }, children),
        shouldShowCloseButton && (React.createElement(MessageBannerCloseButton, { ButtonIcon: CloseIcon, onClickHandler: () => {
                closeButtonCallback && closeButtonCallback();
                setHideBanner(true);
                setIsHidden(true);
            }, role: "button", "aria-expanded": CloseIcon, label: "", isIconButton: true, btnStyle: "text", shouldOrderCloseButtonLast: shouldOrderCloseButtonLast })),
        shouldAddButton && (React.createElement(MessageBannerCTA, { role: "button", label: buttonLabel, btnStyle: btnStyle, size: btnSize, inputKind: buttonHref && 'link', href: buttonHref, onClickHandler: (e) => {
                buttonClickHandler && buttonClickHandler(e);
                shouldHideBannerOnButtonClick && setHideBanner(true);
                shouldHideBannerOnButtonClick && setIsHidden(true);
            } })))));
};
MessageBanner.propTypes = {
    btnSize: PropTypes.string,
    btnStyle: PropTypes.string,
    buttonClickHandler: PropTypes.func,
    buttonHref: PropTypes.string,
    buttonLabel: PropTypes.string,
    children: PropTypes.node.isRequired,
    className: PropTypes.string,
    closeButtonCallback: PropTypes.func,
    contentAlign: PropTypes.oneOf(['left', 'center']),
    delayDuration: PropTypes.number,
    hasBorderRadius: PropTypes.bool,
    hasBoxShadow: PropTypes.bool,
    isDisclaimer: PropTypes.bool,
    isFixed: PropTypes.bool,
    position: PropTypes.oneOf(['top-left', 'top-right', 'top-centre']),
    shouldAddButton: PropTypes.bool,
    shouldHideBannerOnButtonClick: PropTypes.bool,
    shouldOrderCloseButtonLast: PropTypes.bool,
    shouldShowCloseButton: PropTypes.bool,
    shouldUseDescriptionToken: PropTypes.bool,
    title: PropTypes.string
};
MessageBanner.displayName = 'MessageBanner';
module.exports = MessageBanner;
//# sourceMappingURL=MessageBanner.js.map

/***/ }),

/***/ 62282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const MessageBanner = __webpack_require__(13447);
module.exports = asConfiguredComponent(MessageBanner, 'MessageBanner');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8070:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { getColorStyles, calculateSpacing, getColorToken, getTypographyStyles, minScreen } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const Button = __webpack_require__(73730);
const { BREAKPOINTS } = __webpack_require__(96472);
const getTopValues = () => `
  top: 156px;
  @media (max-width: 1023px) {
    top: 132px;
  }
`;
const applyPositions = ({ position, isDisclaimer }) => {
    if (isDisclaimer) {
        switch (position) {
            case 'top-right':
                return `
        ${getTopValues()}
        @media (max-width: 768px) {
          right: 16px;
          left: auto;
          width: 80%
        }
        @media (max-width: 550px) {
          right: 16px;
          left: auto;
          width: 90%;
        }
          right: 16px;
          left: auto;
          margin: 0;
        `;
            case 'top-left':
                return `
        ${getTopValues()}
        @media (max-width: 768px) {
          right: auto;
          left: 16px;
          width: 80%
        }
        @media (max-width: 550px) {
          right: auto;
          left: 16px;
          width: 90%;
        }
         
          left: 16px;
          right: auto;
          margin: 0;
        `;
            case 'top-centre':
                return `
        ${getTopValues()}
        @media (max-width: 768px) {
          left: 50%;
          right: auto;
          transform: translateX(-50%);
          width: 80%
        }
        @media (max-width: 550px) {
          left: 50%;
          right: auto;
          transform: translateX(-50%);
          width: 90%;
        }
          left: 50%;
          transform: translateX(-50%);
          right: auto;
          margin: 0;
        `;
            default:
                return '';
        }
    }
    return '';
};
const MessageBannerWrapper = styled.div.withConfig({
    displayName: 'MessageBannerWrapper'
}) `
  ${({ shouldShowCloseButton }) => shouldShowCloseButton && `display: flex;`}

  ${({ hasBorderRadius }) => hasBorderRadius && `border-radius: ${calculateSpacing(1)};`}

  ${({ theme }) => getColorStyles(theme, 'background', 'colors.interactive.base.white')};
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.divider')};

  ${({ isDisclaimer }) => !isDisclaimer &&
    `
    border-width: 1px;
    border-style: solid;
    box-sizing: border-box;
    padding: ${calculateSpacing(1.5, `px`)} ${calculateSpacing(2, `px`)};
    ${minScreen(BREAKPOINTS.md)} {
      padding: ${calculateSpacing(2, `px`)};
    }
  `}

  ${({ isDisclaimer, position }) => isDisclaimer &&
    `
    display: flex;
    position: fixed;
    top: 50px;
    right: 50px;
    bottom: 50px;
    left: 50px;
    flex-direction: row;
    align-items: flex-start;
    margin: auto;
    margin-right: auto;
    margin-left: auto;
    border-width: 1px;
    border-style: solid;
    padding: 0;
    width: ${calculateSpacing(87.5, `px`)};
    height: fit-content;
    box-sizing: border-box;
    @media (max-width: 768px) {
      right: ${calculateSpacing(3, `px`)};
      left: ${calculateSpacing(3, `px`)};
      width: auto;
      top: 120px;
    }
    ${applyPositions({ position, isDisclaimer })}
  `}

  ${({ hasBoxShadow }) => hasBoxShadow &&
    `
    box-shadow: 0px 1px 6px 0px rgba(0, 0, 0, 0.1);
  `}
  ${({ isFixed }) => {
    if (isFixed) {
        return `
          align-items: center;
          min-height: ${calculateSpacing(7)};
          z-index: 1000;
        `;
    }
    return '';
}}
`;
const MessageBannerContent = styled(BaseText).withConfig({
    displayName: 'MessageBannerContent'
}) `
  ${({ isDisclaimer }) => !isDisclaimer &&
    `
    width: 100%;
    overflow-wrap: break-word;
  `}

  ${({ isDisclaimer }) => isDisclaimer &&
    `
    margin: ${calculateSpacing(3, `px`)} 0 ${calculateSpacing(3, `px`)}
      ${calculateSpacing(3, `px`)};
    width: 100%;
    overflow-wrap: break-word;
    line-height: ${calculateSpacing(2, `px`)};
    font-size: ${calculateSpacing(1.5, `px`)};
    font-style: normal;
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')}
    color: ${getColorToken('colors.consumption.lead.standard.context-tertiary')} !important;
  `}
  ${({ theme, shouldUseDescriptionToken }) => shouldUseDescriptionToken
    ? getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.description-core')
    : getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')}

  a:link, a:visited, a:active {
    text-decoration: underline;
    color: ${getColorToken('colors.consumption.lead.standard.context-tertiary')};
  }

  text-align: ${({ contentAlign }) => contentAlign};
  /*
   * This is used for the redirect message. It might be that in the future we
   * would prefer to include it in the context only. This is to make the child
   * content sit flush to the padding at the top and bottom.
   */
  > *:first-child {
    margin-top: 0;
  }

  > *:last-child {
    margin-bottom: 0;
  }
`;
const MessageBannerTitle = styled('div').withConfig({
    displayName: 'MessageBannerTitle'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.description-feature')};
  padding: ${calculateSpacing(2, `px`)} 0;
  width: 100%;
  text-align: ${({ contentAlign }) => contentAlign};
  line-height: ${calculateSpacing(3.5, `px`)};
`;
const MessageBannerCloseButton = styled(Button.Utility).withConfig({
    displayName: 'MessageBannerCloseButton'
}) `
  ${({ shouldOrderCloseButtonLast }) => shouldOrderCloseButtonLast && `order: 1;`}
  align-self: flex-start;
  margin: ${calculateSpacing(2, `px`)};
  border-width: 0;
  width: 0;
  min-width: 0;
  height: 0;

  .icon-close {
    padding: 8px;
  }

  svg {
    max-width: fit-content;
  }

  svg path {
    fill: black;
  }
`;
MessageBannerContent.defaultProps = {
    as: 'div',
    colorToken: 'colors.consumption.lead.standard.context-tertiary',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const MessageBannerCTA = styled(Button).withConfig({
    displayName: 'MessageBannerCTA'
}) ``;
module.exports = {
    MessageBannerWrapper,
    MessageBannerContent,
    MessageBannerTitle,
    MessageBannerCloseButton,
    MessageBannerCTA
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 52627:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const LargeChevronIcon = __webpack_require__(708);
const { TrackComponentChannel } = __webpack_require__(78788);
const { AssistiveText, NavigationDropdownWrapper, NavigationDropdownLink, NavigationDropdownListItem, NavigationDropdownListWrapper, NavigationDropdownButton } = __webpack_require__(77906);
const { useSelectReducer, useKeyboardEvents, useMouseEvents, useCallbacks } = __webpack_require__(37690);
const { useRef } = React;
/**
 * NavigationDropdown
 * A dropdown to navigate a user.
 *
 * @param {object} props - React props
 * @param {object} [props.align] - Optional. Sets the align of the dropdown. Default to "left"
 * @param {string} [props.assistiveLabel] - A label to describe navigation dropdown for assistive devices
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object} [props.direction] - Optional. Set the direction the dropdown opens. Defaults to "down"
 * @param {string} [props.id] - Optional id to append to internal ids
 * @param {Array} props.options - Available options for the navigation
 * @param {boolean} [props.showLabel] - Display label instead of selected value
 * @param {string} [props.label] - An alternative label to display
 * @param {object} [props.navItemAttrs] - Additional attributes to be applied to navigation links
 * @param {object} [props.buttonAttrs] - Additional attributes to be applied to button that toggles the dropdown
 * @param {bool} [props.isInverted] - Optional apply the inverted theme
 */
const NavigationDropdown = ({ align = 'left', assistiveLabel, className, id = 'navigation-dropdown', label, buttonAttrs, direction = 'down', navItemAttrs, options, showLabel, isInverted = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NavigationDropdown'
        });
    }, []);
    const toggleRef = useRef(null);
    const listBoxRef = useRef(null);
    const optionsRefs = useRef([]);
    const [state, dispatch] = useSelectReducer();
    const { onSelectOpen, onOptionFocus, onClose } = useCallbacks(state, dispatch, listBoxRef, optionsRefs);
    useKeyboardEvents(state, onClose, onOptionFocus, optionsRefs, toggleRef);
    useMouseEvents(state, onClose, listBoxRef);
    const getDefaultValue = (navOptions) => {
        const option = navOptions?.find((opt) => opt.selected);
        if (option?.name) {
            return option.name;
        }
        return null;
    };
    const buttonId = `menu-button-${id}`;
    const labelId = `assistive-label-${id}`;
    const aligns = typeof align === 'string' ? { sm: align } : align;
    return (React.createElement(NavigationDropdownWrapper, { className: className },
        React.createElement(AssistiveText, { id: labelId }, assistiveLabel),
        React.createElement(NavigationDropdownButton, { ref: toggleRef, "aria-expanded": state.isOpen, "aria-haspopup": "true", isInverted: isInverted, onClick: (evt) => {
                evt.stopPropagation();
                onSelectOpen();
            }, "aria-labelledby": `${labelId}`, "aria-describedby": `${labelId} ${buttonId}`, id: buttonId, ...buttonAttrs },
            React.createElement("span", null, showLabel ? label : getDefaultValue(options)),
            React.createElement("span", { "aria-hidden": "true" },
                React.createElement(LargeChevronIcon, { width: 12, height: 7 }))),
        React.createElement(NavigationDropdownListWrapper, { ref: listBoxRef, isOpen: state.isOpen, aligns: aligns, direction: direction, role: "menu", "aria-labelledby": labelId }, options.map(({ name, url, selected = false, ...rest }, index) => (React.createElement(NavigationDropdownListItem, { key: name, isSelected: selected },
            React.createElement(NavigationDropdownLink, { ref: (el) => {
                    optionsRefs.current[index] = el;
                }, href: url, isSelected: selected, ...rest, ...navItemAttrs }, name)))))));
};
NavigationDropdown.propTypes = {
    align: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.oneOf(['left', 'right'])
    ]),
    assistiveLabel: PropTypes.string,
    buttonAttrs: PropTypes.object,
    className: PropTypes.string,
    direction: PropTypes.oneOf(['down', 'up']),
    id: PropTypes.string,
    isInverted: PropTypes.bool,
    label: PropTypes.string,
    navItemAttrs: PropTypes.object,
    options: PropTypes.array,
    showLabel: PropTypes.bool
};
module.exports = NavigationDropdown;
//# sourceMappingURL=NavigationDropdown.js.map

/***/ }),

/***/ 37690:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useCallbacks = exports.useSelectReducer = exports.useMouseEvents = exports.useKeyboardEvents = void 0;
const React = __webpack_require__(96540);
const debounce = __webpack_require__(38221);
const { useEffect, useReducer, useCallback } = React;
// Focuses the next available option
const focusNextOption = (onOptionFocus, focusedOptionIndex, optionsRefs, onClose, keyEvent) => {
    const index = Number(focusedOptionIndex) + 1;
    const downIndex = Math.min(index, optionsRefs.current.length - 1);
    onOptionFocus(downIndex, true, keyEvent);
    if (focusedOptionIndex === optionsRefs.current.length - 1) {
        onClose();
    }
};
// Focuses the previous available option
const focusPrevOption = (onOptionFocus, focusedOptionIndex, onClose, keyEvent) => {
    const index = Number(focusedOptionIndex) - 1;
    const upIndex = Math.max(index, 0);
    onOptionFocus(upIndex, true, keyEvent);
    if (focusedOptionIndex === 0) {
        onClose();
    }
};
let searchQuery = '';
const resetQuery = debounce(() => {
    searchQuery = '';
}, 500);
function useKeyboardEvents({ isOpen, focusedOptionIndex }, onClose, onOptionFocus, optionsRefs, toggleRef) {
    // Handle any user key press when
    // the options list is open
    useEffect(() => {
        const onKeyDown = (evt) => {
            if (!isOpen)
                return;
            let values;
            let matchIndex;
            switch (evt.key) {
                case 'Enter':
                    break;
                case 'Escape':
                    evt.preventDefault();
                    // close the menu
                    // and focus to the toggle
                    evt.stopPropagation();
                    toggleRef.current.focus();
                    onClose();
                    break;
                case 'ArrowDown':
                    evt.preventDefault();
                    focusNextOption(onOptionFocus, focusedOptionIndex, optionsRefs, onClose);
                    break;
                case 'ArrowUp':
                    evt.preventDefault();
                    focusPrevOption(onOptionFocus, focusedOptionIndex, onClose);
                    break;
                case 'Tab':
                    if (evt.shiftKey) {
                        focusPrevOption(onOptionFocus, focusedOptionIndex, onClose, evt.key);
                        break;
                    }
                    focusNextOption(onOptionFocus, focusedOptionIndex, optionsRefs, onClose, evt.key);
                    break;
                case 'Home':
                    evt.preventDefault();
                    onOptionFocus(0, true);
                    break;
                case 'End':
                    evt.preventDefault();
                    onOptionFocus(optionsRefs.current.length - 1, true);
                    break;
                default:
                    evt.preventDefault();
                    // Search for options that start with the
                    // user's input. Clear the query if the user
                    // stops typing, scroll to element if found
                    searchQuery += evt.key.toLowerCase();
                    values = optionsRefs.current.map((ref) => ref.textContent ? ref.textContent.toLowerCase() : 'sign out');
                    matchIndex = values.findIndex((value) => value.startsWith(searchQuery));
                    if (matchIndex === -1) {
                        searchQuery = '';
                        return;
                    }
                    onOptionFocus(matchIndex, true);
                    resetQuery();
            }
        };
        document.addEventListener('keydown', onKeyDown);
        return () => document.removeEventListener('keydown', onKeyDown);
    }, [
        onClose,
        isOpen,
        toggleRef,
        onOptionFocus,
        focusedOptionIndex,
        optionsRefs
    ]);
}
exports.useKeyboardEvents = useKeyboardEvents;
function useMouseEvents({ isOpen }, onClose, listBoxRef) {
    // Close the options list if the user
    // clicked outside of it
    useEffect(() => {
        const onMouseClick = (evt) => {
            if (!isOpen)
                return;
            if (!listBoxRef.current.contains(evt.target)) {
                onClose();
            }
        };
        document.addEventListener('click', onMouseClick);
        return () => document.removeEventListener('click', onMouseClick);
    }, [isOpen, listBoxRef, onClose]);
    useEffect(() => {
        window.addEventListener('scroll', onClose, {
            passive: true
        });
        return () => window.removeEventListener('scroll', onClose);
    }, [onClose]);
}
exports.useMouseEvents = useMouseEvents;
function useSelectReducer() {
    const initialState = {
        isOpen: false,
        focusedOptionIndex: -1
    };
    const reducer = (state, action) => {
        switch (action.type) {
            case 'setOpen':
                return {
                    ...state,
                    isOpen: action.isOpen
                };
            case 'setFocusedOptionIndex':
                return {
                    ...state,
                    focusedOptionIndex: action.index
                };
            case 'close':
                return {
                    ...state,
                    isOpen: false,
                    focusedOptionIndex: -1
                };
            default:
                throw new Error(`Unsupported action "${action.type}".`);
        }
    };
    return useReducer(reducer, initialState);
}
exports.useSelectReducer = useSelectReducer;
function useCallbacks(state, dispatch, listBoxRef, optionsRefs) {
    const onClose = () => {
        if (state.isOpen) {
            dispatch({
                type: 'close'
            });
        }
    };
    const onOptionFocus = useCallback((index, scrollToElement = false, keyEvent = '') => {
        if (!optionsRefs.current[index])
            return;
        dispatch({
            type: 'setFocusedOptionIndex',
            index
        });
        if (keyEvent !== 'Tab')
            optionsRefs.current[index]?.focus();
        if (scrollToElement && listBoxRef.current?.scrollTo) {
            listBoxRef.current.scrollTo({
                top: index * optionsRefs.current[index].parentElement.offsetHeight
            });
        }
    }, [dispatch, listBoxRef, optionsRefs]);
    // Returns a set of memoized callbacks
    // to be used inside the component
    const onSelectOpen = useCallback(() => {
        dispatch({
            type: 'setOpen',
            isOpen: !state.isOpen
        });
        if (!state.isOpen) {
            setTimeout(() => {
                const index = state.selectedOptionIndex > -1 ? state.selectedOptionIndex : 0;
                onOptionFocus(index, true);
            }, 0);
        }
    }, [dispatch, state.isOpen, state.selectedOptionIndex, onOptionFocus]);
    return { onSelectOpen, onClose, onOptionFocus };
}
exports.useCallbacks = useCallbacks;
//# sourceMappingURL=hooks.js.map

/***/ }),

/***/ 36062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(13382);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 77906:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssistiveText = exports.NavigationDropdownButton = exports.NavigationDropdownLink = exports.NavigationDropdownListItem = exports.NavigationDropdownListWrapper = exports.NavigationDropdownWrapper = void 0;
const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getColorToken, getZIndex } = __webpack_require__(26865);
const { BaseLink } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const { isInverted, resolveMenuKey } = __webpack_require__(70698);
exports.NavigationDropdownWrapper = styled.div.withConfig({
    displayName: 'NavigationDropdownWrapper'
}) `
  display: inline-block;
  position: relative;
  z-index: ${getZIndex('dropdown')};
`;
exports.NavigationDropdownListWrapper = styled.ul.withConfig({
    displayName: 'NavigationDropdownListWrapper'
}) `
  ${({ theme }) => getColorStyles(theme, 'background-color', resolveMenuKey(theme, 'colors.foundation.menu-bg.collapsed'))};

  display: ${({ isOpen }) => (isOpen ? 'block' : 'none')};
  position: absolute;
  flex-direction: column;
  align-items: start;
  margin: 0;
  margin-top: ${calculateSpacing(0.5)};
  box-shadow: -2px 2px 5px rgba(0, 0, 0, 0.1);
  padding: ${calculateSpacing(0.5)};
  min-width: ${calculateSpacing(15)};
  max-height: ${calculateSpacing(31)};
  overflow: auto;
  text-align: left;
  white-space: nowrap;
  /* TODO either update getColorStyles to support, or refactor  */
  scrollbar-color: ${({ theme }) => `
    ${getColorToken(theme, `colors.interactive.base.${isInverted(theme) ? 'light' : 'dark'}`)} ${getColorToken(theme, `colors.interactive.base.${isInverted(theme) ? 'dark' : 'light'}`)}`};
  scrollbar-width: thin;

  ${({ aligns }) => aligns &&
    Object.keys(aligns).map((breakpoint) => {
        const align = aligns[breakpoint];
        return `
        @media (min-width: ${BREAKPOINTS[breakpoint]}) {
          left: ${align === 'left' ? calculateSpacing(-0.5) : 'auto'};
          right: ${align === 'right' ? calculateSpacing(-0.5) : 'auto'};
        }
      `;
    })}

  ${({ direction }) => direction === 'up' &&
    `
      margin-top: 0;
      top: ${calculateSpacing(-0.5)};
      transform: translateY(-100%);
    `}

  ::-webkit-scrollbar {
    width: 5px;
  }

  ::-webkit-scrollbar-track {
    ${({ theme }) => getColorStyles(theme, 'background', `colors.interactive.base.${isInverted(theme) ? 'dark' : 'light'}`)};
  }

  ::-webkit-scrollbar-thumb {
    ${({ theme }) => getColorStyles(theme, 'background', `colors.interactive.base.${isInverted(theme) ? 'light' : 'dark'}`)};
  }
`;
exports.NavigationDropdownListItem = styled.li.withConfig({
    displayName: 'NavigationDropdownListItem'
}) `
  display: flex;
  position: relative;
  align-items: center;
  transition: all 500ms ease;
  width: 100%;
  height: ${calculateSpacing(6)};
  ${({ theme, isSelected }) => isSelected &&
    `
      &::before {
        background-color: ${getColorToken(theme, resolveMenuKey(theme, 'colors.foundation.collapsed-menu.nav-link.hover'))};
        content: '';
        height: 100%;
        left: -${calculateSpacing(0.5)};
        position: absolute;
        width: ${calculateSpacing(0.5)};
      }
    `}
`;
exports.NavigationDropdownListItem.defaultProps = {
    role: 'none'
};
exports.NavigationDropdownLink = styled(BaseLink)
    .withConfig({
    displayName: 'NavigationDropdownLink'
})
    .attrs(({ theme, colorSecondaryLinkToken, colorStaticLinkToken }) => ({
    colorSecondaryLinkToken: colorSecondaryLinkToken ||
        resolveMenuKey(theme, 'colors.foundation.collapsed-menu.nav-link.hover'),
    colorStaticLinkToken: colorStaticLinkToken ||
        resolveMenuKey(theme, 'colors.foundation.collapsed-menu.nav-link.default')
})) `
  padding: ${calculateSpacing(1.5)} ${calculateSpacing(1)};
  width: 100%;
  text-decoration: none;
  word-break: normal;

  &:link,
  &:visited {
    ${({ isSelected, colorSecondaryLinkToken }) => isSelected && `color: ${getColorToken(colorSecondaryLinkToken)};}`}
  }

  &:hover,
  &:focus {
    text-decoration: none;
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    padding-right: ${calculateSpacing(2)};
    padding-left: ${calculateSpacing(2)};
  }
`;
exports.NavigationDropdownLink.defaultProps = {
    linkStyle: 'default',
    role: 'menuitem',
    typeToken: 'typography.definitions.foundation.link-primary'
};
exports.NavigationDropdownButton = styled(exports.NavigationDropdownLink).withConfig({ displayName: 'NavigationDropdownButton' }) `
  display: flex;
  align-items: center;
  border: ${({ theme, colorBorderToken }) => colorBorderToken && `1px solid ${getColorToken(theme, colorBorderToken)}`};
  background: transparent;
  cursor: pointer;
  width: auto;

  span {
    margin-right: ${calculateSpacing(0.5)};

    &:last-child {
      margin-right: 0;
    }
  }

  svg {
    path,
    g,
    polygon {
      transition-duration: 0.2s;
      transition-timing-function: ease-in-out;
      transition-property: fill, stroke;
      fill: currentColor;
      stroke: currentColor;
    }
  }

  ${({ theme }) => isInverted(theme) &&
    `
      color : ${getColorToken(theme, resolveMenuKey(theme, 'colors.consumption.lead.inverted.link'))};
      &:hover,
      &:focus { 
        color : ${getColorToken(theme, resolveMenuKey(theme, 'colors.consumption.lead.inverted.link-hover'))};
        }`}
`;
exports.NavigationDropdownButton.defaultProps = {
    as: 'button',
    role: 'button'
};
exports.AssistiveText = styled.h6.withConfig({
    displayName: 'AssistiveText'
}) `
  position: absolute;
  clip-path: inset(100%);
  clip: rect(1px, 1px, 1px, 1px);
  width: 1px;
  height: 1px;
  overflow: hidden;
  white-space: nowrap;
`;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 13382:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const NavigationDropdown = __webpack_require__(52627);
NavigationDropdown.Footer = asVariation(NavigationDropdown, 'NavigationDropdownFooter', {}, {
    align: 'right',
    buttonAttrs: {
        colorBorderToken: 'colors.foundation.footer.accent',
        colorSecondaryLinkToken: 'colors.foundation.footer.links.primary',
        colorStaticLinkToken: 'colors.foundation.footer.links.primary',
        typeToken: 'typography.definitions.utility.input-core'
    },
    direction: 'up',
    navItemAttrs: {
        typeToken: 'typography.definitions.utility.input-core'
    }
});
module.exports = NavigationDropdown;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 78413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { NewsletterCardWrapper, NewsletterCardPreviewWrapper, NewsletterCardStyledCheckbox, NewsletterCardNativeCheckbox, NewsletterCardHed, NewsletterCardAsset, NewsletterCardAlertBadge, NewsletterCardPreviewFrequencyBadge, NewsletterCardPreviewLink, NewsletterCardDek } = __webpack_require__(20970);
const { TrackComponentChannel } = __webpack_require__(78788);
const ResponsiveAsset = __webpack_require__(86157);
/**
 * NewsletterCard component
 *
 * @param {object} props - React props
 * @param {string} [props.alertBadge] -  alert Badge context text
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dangerousDek] - Optional dangerous selection dek
 * @param {string} props.dangerousHed - Dangerous selection hed
 * @param {string} [props.descriptor] - Optional text used as display name in validation messages
 * @param {string} [props.frequencyBadge] - frequency Badge for the newletter
 * @param {string} props.formName - Parent form name
 * @param {boolean} [props.hasValidSailthruId] - Optional flag whether sailthruId is base64 encoded
 * @param {number} props.index - Index in a fieldset list to help create unique ids
 * @param {string} [props.image] - Photo containing image sources for a ResponsiveAsset
 * @param {object} [props.inputAttributes] - Optional attributes to add to input element i.e. disabled
 * @param {Map} [props.invalidElements] - Optional Map of invalid element ids from parent form. Will set invalid state if ID matches.
 * @param {string} props.isAuthenticated - Optional flag whether user is authenticated
 * @param {bool} [props.isChecked] - Optional flag whether input is checked. Use if this should be a fully controlled component.
 * @param {bool} [props.isDefaultChecked] - Optional status of checkbox. Use if component is uncontrolled.
 * @param {bool} [props.isTrackedUser] - Optional flag whether anonymous user has subscribed to any newsletter
 * @param {string} props.name - Input name
 * @param {string} props.inputType - Input type
 * @param {Function} [props.onChangeHandler] - Optional handler for change event
 * @param {string} [props.previewLinkText] - preview LinkText for the newletter
 * @param {string} [props.previewURL] - preview URL redirect to preview to respective newsletter
 * @param {string} props.value - Input value
 * @param {string} props.cookiePref - Saved Preferences
 * @param {number} props.id - NewsletterId
 * @returns {ReactElement} <label>
 */
const NewsletterCard = ({ alertBadge = '', className, dangerousDek, dangerousHed, descriptor, formName, hasValidSailthruId, id: newsletterId, index, inputAttributes, invalidElements, image, isAuthenticated, isChecked, isDefaultChecked, isTrackedUser, name, onChangeHandler, previewURL, value, inputType = 'checkbox', frequencyBadge, previewLinkText = 'Preview ', cookiePref = [] }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'NewsletterCard'
        });
    }, []);
    const id = `${formName}-newsletter-card-${name}-${index}`;
    const isSubscribed = cookiePref.some((prefs) => prefs.newsletterId === newsletterId);
    const nativeInputProps = {
        ...inputAttributes,
        'aria-describedby': invalidElements && invalidElements.has(id)
            ? invalidElements.get(id)
            : undefined,
        'data-descriptor': descriptor,
        checked: isChecked,
        defaultChecked: isDefaultChecked,
        id,
        name,
        onChange: onChangeHandler,
        type: inputType,
        value,
        inputType,
        'aria-label': 'Sign up',
        autoComplete: 'off',
        disabled: (isAuthenticated && isChecked) ||
            (hasValidSailthruId && isChecked) ||
            (isTrackedUser && isChecked && isSubscribed)
    };
    const handleCheckbox = (ev) => {
        if (ev.key === 'Enter') {
            document.activeElement.click();
        }
    };
    return (React.createElement(NewsletterCardWrapper, { htmlFor: id },
        image && React.createElement(NewsletterCardAsset, { ...image }),
        React.createElement(React.Fragment, null,
            React.createElement(NewsletterCardNativeCheckbox, { ...nativeInputProps, onKeyUp: handleCheckbox }),
            React.createElement(NewsletterCardStyledCheckbox, { onKeyUp: handleCheckbox, inputType: inputType, className: classnames('checkbox', className) })),
        alertBadge.length > 0 && (React.createElement(NewsletterCardAlertBadge, { dangerouslySetInnerHTML: { __html: alertBadge } })),
        dangerousHed && (React.createElement(NewsletterCardHed, { dangerouslySetInnerHTML: { __html: dangerousHed } })),
        dangerousDek && (React.createElement(NewsletterCardDek, { alertBadge: alertBadge, dangerouslySetInnerHTML: { __html: dangerousDek } })),
        React.createElement(NewsletterCardPreviewWrapper, null,
            frequencyBadge && (React.createElement(NewsletterCardPreviewFrequencyBadge, { dangerouslySetInnerHTML: { __html: frequencyBadge } })),
            React.createElement(NewsletterCardPreviewLink, { href: previewURL, rel: "nofollow noopener noreferrer", target: "_blank", "aria-label": "Opens in a new window", dangerouslySetInnerHTML: { __html: previewLinkText } }),
            React.createElement(React.Fragment, null,
                React.createElement(NewsletterCardNativeCheckbox, { ...nativeInputProps, onKeyUp: handleCheckbox }),
                React.createElement(NewsletterCardStyledCheckbox, { inputType: inputType, onKeyUp: handleCheckbox, className: classnames('checkbox', className) })))));
};
NewsletterCard.propTypes = {
    alertBadge: PropTypes.string,
    className: PropTypes.string,
    cookiePref: PropTypes.array,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    descriptor: PropTypes.string,
    formName: PropTypes.string.isRequired,
    frequencyBadge: PropTypes.string,
    hasValidSailthruId: PropTypes.bool,
    id: PropTypes.number,
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    index: PropTypes.number.isRequired,
    inputAttributes: PropTypes.object,
    inputType: PropTypes.string,
    invalidElements: PropTypes.instanceOf(Map),
    isAuthenticated: PropTypes.bool,
    isChecked: PropTypes.bool,
    isDefaultChecked: PropTypes.bool,
    isTrackedUser: PropTypes.bool,
    name: PropTypes.string.isRequired,
    onChangeHandler: PropTypes.func,
    previewLinkText: PropTypes.string,
    previewURL: PropTypes.string,
    value: PropTypes.string.isRequired
};
module.exports = NewsletterCard;
//# sourceMappingURL=NewsletterCard.js.map

/***/ }),

/***/ 85430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(78413);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getColorToken } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText } = __webpack_require__(18730);
const { INTERACTIVE: { timingButtonDefault } } = __webpack_require__(96472);
const ResponsiveAsset = __webpack_require__(86157);
const selectionControlStyledInput = ({ selectionControlBackgroundColor, selectionControlBorderColor }) => {
    return css `
    position: relative;
    transition-property: background, border;
    transition-duration: ${timingButtonDefault};
    transition-timing-function: ease-in;
    border-width: 2px;
    border-style: solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', selectionControlBorderColor)};
    ${({ theme }) => getColorStyles(theme, 'background-color', selectionControlBackgroundColor)};
    border-radius: 50%;
    padding: ${calculateSpacing(1.2)};
    width: 2.25rem;
    height: 2.25rem;
    font-weight: bold;
    pointer-events: none;
  `;
};
const NewsletterCardStyledCheckbox = styled.div.withConfig({
    displayName: 'NewsletterCardStyledCheckbox'
}) `
  grid-area: 1 / 2 / span 2 / -1;
  justify-self: end;

  ${selectionControlStyledInput({
    selectionControlBackgroundColor: 'colors.interactive.base.white',
    selectionControlBorderColor: 'colors.interactive.base.brand-primary'
})}

  &::before,
  &::after {
    position: absolute;
    top: 50%;
    left: 50%;
    transition: transform ${timingButtonDefault} ease-in-out;
    background-color: ${getColorToken('colors.interactive.base.brand-primary')};
    width: 2px;
    height: 10px;
    content: '';
  }

  &::before {
    transform: translate(-50%, -50%);
  }

  &::after {
    transform: translate(-50%, -50%) rotate(90deg);
  }
`;
const selectionControlNativeInput = ({ selectionControlBackgroundColor, theme }) => {
    return `
  &:focus
  {
   + ${NewsletterCardStyledCheckbox} {
      outline: 1px solid;
      outline-color: ${getColorToken('colors.interactive.base.brand-secondary')};
      outline-offset: 1px;
    }
  }
  &:hover
  {
   + ${NewsletterCardStyledCheckbox} {
      @media (min-width: ${BREAKPOINTS.md}) {
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.brand-primary')};
        &::before,
        &::after {
          ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
        }
      }
    }
  }
    &:checked,
    &:active {
      + ${NewsletterCardStyledCheckbox} {
        
        ${getColorStyles(theme, 'background-color', selectionControlBackgroundColor)};

        ${getColorStyles(theme, 'border-color', selectionControlBackgroundColor)};

        &::before,
        &::after {
          ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
        }
        &::before {
          transform: translate(55%, -50%) rotate(45deg);
          height: 15px;
          border-width: 8px;
        }
        &::after {
          transform: translate(0, 0) rotate(-50deg);
          height: 8px;
          border-left: 0;
          border-bottom: 0;
          background: white;
          left: 30%;
          top: 45%;
        }
      }
    }
  `;
};
const getNativeInputCommonStyles = ({ theme, disabled }) => {
    return disabled
        ? css `
        ${selectionControlNativeInput({
            selectionControlBackgroundColor: 'colors.interactive.base.deemphasized',
            theme
        })}
      `
        : css `
        ${selectionControlNativeInput({
            selectionControlBackgroundColor: 'colors.interactive.base.brand-primary',
            theme
        })}
      `;
};
const NewsletterCardNativeCheckbox = styled.input.withConfig({
    displayName: 'NewsletterCardNativeCheckbox'
}) `
  ${({ theme, disabled }) => getNativeInputCommonStyles({ theme, disabled })}
`;
const NewsletterCardWrapper = styled.div.withConfig({
    displayName: 'NewsletterCardWrapper'
}) `
  display: grid;
  position: relative;
  grid-auto-rows: min-content;
  grid-template-columns: 1fr auto;
  border: 1px solid ${getColorToken('colors.foundation.menu.dividers')};
  padding: ${calculateSpacing(1.5)};
  gap: ${calculateSpacing(1.5)};

  input[type='checkbox'] {
    top: 12px;
    right: 12px;
    left: auto;
    cursor: pointer;
    width: 2.25rem;
    height: 2.25rem;
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    min-height: 260px;
  }

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    input[type='checkbox'] {
      top: auto;
      right: 12px;
      bottom: 12px;
      left: auto;
      width: 2.25rem;
      height: 2.25rem;
    }

    > input[type='checkbox'],
    > .checkbox {
      display: none;
    }
  }
`;
const NewsletterCardHed = styled(BaseText).withConfig({
    displayName: 'NewsletterCardHed'
}) `
  grid-column: 1/2;
`;
NewsletterCardHed.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.black',
    typeIdentity: 'typography.definitions.utility.card-heading'
};
const NewsletterCardAsset = styled(ResponsiveAsset).withConfig({
    displayName: 'NewsletterCardAsset'
}) `
  max-width: 4rem;

  img {
    max-width: 100%;
    height: auto;
    aspect-ratio: 1/1;
    object-fit: cover;
  }

  @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
    grid-column: 2 / -1;
    grid-row: 1 / 4;
  }
`;
const NewsletterCardAlertBadge = styled(BaseText).withConfig({
    displayName: 'NewsletterCardAlertBadge'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid ${getColorToken('colors.interactive.base.border')};
  border-radius: ${calculateSpacing(3.5)};
  padding: ${calculateSpacing(0.5)} ${calculateSpacing(1)};
  max-width: fit-content;
`;
NewsletterCardAlertBadge.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.deemphasized',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const NewsletterCardDek = styled(BaseText).withConfig({
    displayName: 'NewsletterCardDek'
}) `
  grid-column: 1/-1;
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-bottom: ${calculateSpacing(4)};
  }
  @media (max-width: ${BREAKPOINTS.md}) {
    ${({ alertBadge }) => alertBadge.length < 1 &&
    css `
        grid-column: 1/2;
      `}
  }
`;
NewsletterCardDek.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.body',
    typeIdentity: 'typography.definitions.utility.body'
};
const NewsletterCardPreviewWrapper = styled.div.withConfig({
    displayName: 'NewsletterCardPreviewWrapper'
}) `
  display: flex;

  grid-column: 1/3;
  align-items: center;
  gap: ${calculateSpacing(1.2)};

  @media (min-width: ${BREAKPOINTS.md}) {
    position: absolute;
    bottom: 0;
    grid-column: 1/-1;
    margin: ${calculateSpacing(0.5)} 0 ${calculateSpacing(1)};

    > input[type='checkbox'],
    > .checkbox {
      display: none;
    }
  }
`;
const NewsletterCardPreviewFrequencyBadge = styled(BaseText).withConfig({
    displayName: 'NewsletterCardPreviewFrequencyBadge'
}) `
  &::after {
    border-right: 1px solid ${getColorToken('colors.interactive.base.border')};
    padding-right: ${calculateSpacing(1.3)};
    content: '';
  }
`;
NewsletterCardPreviewFrequencyBadge.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.deemphasized',
    typeIdentity: 'typography.definitions.utility.button-bulletin'
};
const NewsletterCardPreviewLink = styled(BaseText).withConfig({
    displayName: 'NewsletterCardPreviewLink'
}) `
  flex: 1;
  outline-color: ${getColorToken('colors.interactive.base.brand-secondary')};
  text-decoration: none;
`;
NewsletterCardPreviewLink.defaultProps = {
    as: 'a',
    colorToken: 'colors.interactive.base.brand-primary',
    typeIdentity: 'typography.definitions.utility.button-bulletin'
};
module.exports = {
    NewsletterCardWrapper,
    NewsletterCardStyledCheckbox,
    NewsletterCardNativeCheckbox,
    NewsletterCardAsset,
    NewsletterCardAlertBadge,
    NewsletterCardHed,
    NewsletterCardPreviewLink,
    NewsletterCardPreviewWrapper,
    NewsletterCardPreviewFrequencyBadge,
    NewsletterCardDek
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 12723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { shouldRenderNothing } = __webpack_require__(29670);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * PaymentGateway component
 *
 * @param {object} props - React props
 * @param {ReactElement} props.children - The children of this component
 * @param {string} props.group - component group name
 * @param {object} props.payment - payment state
 *
 * @returns {ReactElement} <div>
 */
const PaymentGateway = ({ children, group, payment }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'PaymentGateway'
        });
    }, []);
    // external configuration overrides default component behavior when present
    if (payment && payment.gateway && payment.gateway.groupsToRender) {
        if (payment.gateway.groupsToRender.includes(group)) {
            return children;
        }
        return null;
    }
    // default component behavior
    if (shouldRenderNothing(group, payment)) {
        return null;
    }
    return children;
};
PaymentGateway.propTypes = {
    children: PropTypes.oneOfType([
        PropTypes.arrayOf(PropTypes.node),
        PropTypes.node
    ]).isRequired,
    group: PropTypes.string.isRequired,
    payment: PropTypes.shape({
        form: PropTypes.string,
        gateway: PropTypes.shape({
            groupsToRender: PropTypes.arrayOf(PropTypes.string)
        }),
        groupsToRender: PropTypes.arrayOf(PropTypes.string)
    }).isRequired
};
module.exports = PaymentGateway;
//# sourceMappingURL=PaymentGateway.js.map

/***/ }),

/***/ 29670:
/***/ ((module) => {

const shouldBeRendered = (group, payment) => group &&
    payment &&
    payment.groupsToRender &&
    payment.groupsToRender.includes(group);
const shouldRenderNothing = () => false;
module.exports = {
    shouldBeRendered,
    shouldRenderNothing
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 92807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { connectDomain } = __webpack_require__(57744);
const PaymentGateway = __webpack_require__(12723);
const connectPayment = connectDomain('payment');
const connectFeatureFlags = connectDomain('featureFlags');
const withAdsGating = __webpack_require__(26701);
module.exports = {
    PaymentGateway: connectPayment(connectFeatureFlags(withAdsGating(PaymentGateway)))
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 26701:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useState, useEffect } = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const decode = (__webpack_require__(79712)["default"]);
const { getCookie } = __webpack_require__(56892);
const adFree = (scope) => scope.match(/adfree$/i);
const acceptsBothSubAndPass = (acceptableForms = []) => {
    return (acceptableForms.filter((form) => form === 'sub' || form === 'pass')
        .length === 2);
};
const shouldHideAds = (payment) => {
    try {
        const pass = getCookie('pay_ent_pass');
        const sub = getCookie('pay_ent_sub');
        const payload = decode(pass);
        const { scopes = [] } = payload || {};
        const hasLegacySubToken = acceptsBothSubAndPass(payment.acceptableForms) && !!sub && !pass;
        return scopes.find(adFree) || hasLegacySubToken;
    }
    catch (e) {
        return false;
    }
};
/**
 * withAdsGating
 *
 * A higher order component that handles the rendering of Ads Payment Gateways.
 * This HOC works as a Journey hardcoded override to handle ad-free and ad-rich
 * experiences without relying on the legacy Payment Negotiation.
 *
 * The AdsGating override occurs when:
 * - The PaymentGateway group is ads
 * - The pass token and the ad-free or ad-rich scopes are present
 * - The sub token is present
 * - The sub and the pass token are present
 *
 * @param {ReactComponent} Component - A React component
 * @returns {ReactElement|null} Component - A React element
 */
const withAdsGating = (Component) => {
    const componentName = Component.displayName;
    const AdsGate = (props) => {
        const { payment = {} } = props;
        const [shouldGate, setShouldGate] = useState(false);
        useEffect(() => {
            if (props.group !== 'ads')
                return;
            const shouldHide = shouldHideAds(payment);
            if (shouldGate === shouldHide)
                return;
            setShouldGate(shouldHide);
        }, [props.group, shouldGate, payment]);
        if (shouldGate)
            return null;
        return React.createElement(Component, { ...props });
    };
    AdsGate.propTypes = {
        group: PropTypes.string,
        payment: PropTypes.object
    };
    AdsGate.displayName = componentName;
    return AdsGate;
};
module.exports = withAdsGating;
//# sourceMappingURL=withAdsGating.js.map

/***/ }),

/***/ 22315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { PaymentGateway } = __webpack_require__(92807);
/**
 * withPaymentGateway
 *
 * A factory that creates a higher-order component that wraps
 * the component parameter inside a payment gateway if a
 * paymentGroup property is provided. If such property is not
 * present then the original component is returned.
 *
 * @param {object} Component - component to wrap
 * @returns {Function} - higher-order component
 */
const withPaymentGateway = (Component) => {
    const Wrapper = ({ paymentGroup, ...props }) => {
        const component = React.createElement(Component, { ...props });
        if (!paymentGroup) {
            return component;
        }
        return React.createElement(PaymentGateway, { group: paymentGroup }, component);
    };
    Wrapper.propTypes = {
        paymentGroup: PropTypes.string
    };
    return Wrapper;
};
module.exports = {
    withPaymentGateway
};
//# sourceMappingURL=withPaymentGateway.js.map

/***/ }),

/***/ 40523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const { connect } = __webpack_require__(67851);
const translations = (__webpack_require__(76896)/* ["default"] */ .A);
const Button = __webpack_require__(73730);
const { BookmarkIcon } = __webpack_require__(72964);
const { TrackComponentChannel } = __webpack_require__(78788);
const { getDiscountPercentage } = __webpack_require__(74148);
const { handleLinkClick } = __webpack_require__(43428);
const { getAmazonAffiliateAttributes } = __webpack_require__(82063);
const { ProductOfferWrapper, ProductOfferPriceBlock, ProductOfferPrice, ProductOfferPriceWrapper, ProductOfferReducedPrice, ProductOfferSellerName, ProductOfferCtaBlock, ProductOfferVenueSeller, ProductOfferBookmark } = __webpack_require__(61366);
const { usePhotoBookmarkingContext } = __webpack_require__(50624);
const { extractTrackingParameters } = __webpack_require__(25203);
/**
 * Product offer block in slide caption
 *
 * @param {object} props - React props
 * @param {string} [props.btnStyle] - Button style used of setting up button styling from one of these ['fixed','outlined','text']
 * @param {string} [props.buttonVariation] - Button variation to use for buy button
 * @param {object} [props.bookmarkDetails] - Optional prop containing bookmark details
 * @param {string} [props.className] - Optional classname to add to the offer element
 * @param {string} [props.ctaHref] - Optional text used for CTA button href
 * @param {string} [props.copilotID] - Optional copilot id of the item for fetching bookmark details
 * @param {string} [props.contentType] - optional content type
 * @param {string} [props.defaultCTAText] - Text to put inside buy button, when price is rendered separately
 * @param {string} [props.defaultTextForEmbedSize] - optional label to show when product embed sizes are enabled
 * @param {string} [props.dataAttrs] - Optional data attributes for button
 * @param {string} [props.embedSize] - Optional property to know the size of product embeds
 * @param {Function} [props.iconButtonOnclickHandler] - called when user clicks on bookmark icon
 * @param {boolean} [props.isCtaInternal] - Optional boolean to mark cta as no-follow
 * @param {boolean} [props.isVenueCardItemContainer] - Optional boolean to mark cta as no-follow
 * @param {boolean} [props.hasBookmarkingEnabled] - Optional boolean to show bookmark button
 * @param {Bool} [props.hasGallerySlideBackground] - optional flag for gallery product background
 * @param {boolean} [props.hasPriceSection] - Optional boolean to show price label
 * @param {bool} [props.showOfferButtonSideBySide] - Optional to have offer Buttons SideBySide
 * @param {string} props.offerUrl - Optional
 * @param {Function} [props.onClickHandler] - Function to execute on button click
 * @param {position} props.position - get the postion of the button
 * @param {string} props.price - Text to display as product price
 * @param {string} props.productId - product id of each product type
 * @param {string} [props.reducedPrice] - Optional text to display as reduced priced for products on sale
 * @param {string} props.sellerName - HTML text containing seller name
 * @param {boolean} [props.venueSeller] - Optional prop to determine whether sellers name is displayed outside of a button
 * @param {boolean} props.hasMultipleLines - Boolean value that helps in clamping text on button to two line and ellipsis when the sentences is more than two lines
 * @param {boolean} props.showOfferUrl - Determines whether offerUrl should be displayed or not
 * @param {boolean} props.showPriceOnButton - Determines whether product price is displayed inside or outsied of a button
 * @param {boolean} props.showSellerNameBelowButton - Determines whether seller name is displayed is displayed below button
 * @param {object} [props.variations] - Optional variation properties used in rendering the component
 * @param {object} [props.variations.contentAlign] - Optional variation properties used in rendering the component
 * @param {object} [props.variations.hasDivider] - Optional variation properties used in rendering the component
 * @param {string} [props.venueSellerPreviewText] - optional string value to prepend venueSellerName
 * @param {boolean} props.isExternalProduct - boolean value representing if the product is internal or external
 * @param {boolean} [props.shouldConsiderPriceText] - Optional, to consider price text on offer buttons
 * @param {func} [props.updateBookmark] - Optional function to update the bookmark details
 * @param {string} [props.urlToBookmark] - Optional url string to send to bookmark icon
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {boolean} props.showSellerNameBelowPrice - Optional prop to display seller name below price
 * @param {string} [props.ctaAtRetailerName] - Optional cta at text when price is not present
 * @param {string} [props.gtmTrackOnClick] - function to track the GTM on product price click
 * @param {boolean} [props.isProductSummaryGridOffer] - optional prop for product offer with product summary grid component
 * @param {boolean} [props.isCttEnabled] - optional flag to enable commerce type tokens
 * @param {boolean} [props.shouldUseOutlinedButton] - Optional prop to fetch the experiment variable
 * @param {boolean} [props.shouldUseBlackButton] - Optional prop to fetch the experiment variable
 * @param {boolean} [props.shouldColorChangeBlueToBlack] - Optional prop to fetch the experiment variable
 * @param {boolean} [props.shouldColorChangeBlackToYellow] - Optional prop to fetch the experiment variable
 * @param {boolean} [props.isActionIdEnabledForComponent] -Optional prop to enable mapping actionId to snowplow and affiliate link on user click
 * @param {object} [props.image] - image object for collection drawer
 * @param {string} [props.component] - Optional prop to fetch the component name
 * @param {string} [props.contentTitle] - Optional content hed for item
 * @param {boolean} [props.isFullyRoundedButtonEnabled] - Optional boolean to enable fully rounded buttons in the product grid (now from Redux)
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @param {string} [props.amazonAffiliateTag] - Optional Amazon affiliate tag from tenant config
 * @param {boolean} [props.showDiscountPercentLabel] - Optional prop to show discount percentage label
 * @param {string} [props.offerId] - Optional prop to fetch the offer id

 *
 * @returns {ReactElement} <figcaption>
 */
const ProductOffer = ({ amazonAffiliateTag, bookmarkDetails, buttonVariation = 'Primary', btnStyle = 'outlined', copilotID, className, ctaHref, ctaAtRetailerName, contentTitle, contentType, defaultCTAText = 'Buy', defaultTextForEmbedSize, shouldConsiderPriceText = false, dataAttrs, embedSize, gtmTrackOnClick = () => '', image, isCtaInternal = false, isVenueCardItemContainer = false, hasBookmarkingEnabled = false, hasGallerySlideBackground, hasMultipleLines = false, hasPriceSection = false, offerUrl, onClickHandler = () => '', position = 0, price, productId, reducedPrice, sellerName, showDiscountPercentLabel = false, showOfferButtonSideBySide = false, showOfferUrl, showPriceOnButton = false, showSellerNameBelowButton = false, showSellerNameBelowPrice = false, variations = { contentAlign: null, hasDivider: false }, venueSeller, venueSellerPreviewText, isExternalProduct, updateBookmark, urlToBookmark, variationName, subtype, isProductSummaryGridOffer = false, isCttEnabled, shouldUseOutlinedButton, shouldUseBlackButton, shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, isActionIdEnabledForComponent, component, isFullyRoundedButtonEnabled, offerId }) => {
    const { contentAlign, hasDivider } = variations;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ProductOffer',
            variation: variationName
        });
    }, [variationName]);
    const { formatMessage } = useIntl();
    const { openCollectionsDrawer } = usePhotoBookmarkingContext();
    const bookmarkLink = {
        label: formatMessage(translations.productOffersaveBookmarkLabel),
        url: urlToBookmark || '#',
        network: 'bookmark',
        behavior: 'bookmark'
    };
    const discountPercentage = getDiscountPercentage(price, reducedPrice);
    /**
     * Renders the discount percentage for Amazon products when showDiscountPercentLabel is true
     * @returns {string} HTML string containing the discount percentage or empty string
     */
    const renderDiscount = () => {
        if (!showDiscountPercentLabel ||
            typeof discountPercentage !== 'number' ||
            isNaN(discountPercentage) ||
            discountPercentage <= 0) {
            return '';
        }
        return ` <span>(${formatMessage(translations.productOfferDiscountPercentageLabel, {
            percentage: discountPercentage
        })})</span>`;
    };
    /**
     * Renders price display with optional discount information
     * @param {string} price - Original price
     * @param {string} reducedPrice - Reduced/sale price (optional)
     * @returns {string} HTML string containing formatted price display
     */
    const renderPrice = (price, reducedPrice) => {
        if (reducedPrice) {
            // When there's a reduced price, show original price struck through,
            // reduced price, and discount percentage if showDiscountPercentLabel is enabled
            const discountHtml = showDiscountPercentLabel ? renderDiscount() : '';
            return `<del>${price}</del> <span>${reducedPrice}</span>${discountHtml}`;
        }
        // When there's no reduced price, show only the original price
        // (no discount percentage even if showDiscountPercentLabel is true)
        return `<span>${price}</span>`;
    };
    const finalPrice = renderPrice(price, reducedPrice);
    const bookmarkOnlyWithPriceOnButton = showPriceOnButton && hasBookmarkingEnabled;
    const getCtaTextForSellerBelowPriceVariation = (priceText) => {
        if (sellerName && !price) {
            return `<p>${formatMessage(translations.productOfferVariationSellerNameString)}
        </p>
        <p class="price-above-seller-name">${sellerName}</p>`;
        }
        if (!sellerName && price) {
            return `${priceText} <p>${formatMessage(translations.productOffeVariationrDefaultCTA)}</p>`;
        }
        if (!sellerName && !price) {
            return formatMessage(translations.productOffeVariationrDefaultCTA);
        }
        return `${priceText} <p class="price-above-seller-name">${sellerName}</p>`;
    };
    const getCtaText = (priceText) => {
        if (showSellerNameBelowPrice) {
            return getCtaTextForSellerBelowPriceVariation(priceText);
        }
        if (!showPriceOnButton || (!price && !sellerName) || hasPriceSection) {
            return defaultTextForEmbedSize || defaultCTAText;
        }
        if (sellerName && !price) {
            return formatMessage(translations.productOfferPriceString, {
                priceValue: ctaAtRetailerName || defaultCTAText,
                sellerName
            });
        }
        if (!defaultTextForEmbedSize && !price) {
            return formatMessage(translations.productOfferPriceString, {
                priceValue: defaultCTAText,
                sellerName
            });
        }
        if (!sellerName) {
            // if no seller name then show default CTA text in place of seller name
            if (hasMultipleLines) {
                return formatMessage(translations.productOfferDefaultPriceString, {
                    priceValue: `${priceText}`,
                    sellerName: defaultCTAText
                });
            }
            return `${priceText}`;
        }
        if (defaultTextForEmbedSize && !price && sellerName) {
            return sellerName;
        }
        const priceString = price && shouldConsiderPriceText
            ? translations.productOfferDefaultPriceString
            : translations.productOfferPriceString;
        return formatMessage(priceString, {
            priceValue: priceText,
            sellerName
        });
    };
    const getUrl = (showOfferUri) => (showOfferUri ? offerUrl : ctaHref);
    const currentOfferUrl = getUrl(showOfferUrl);
    const ctaText = getCtaText(finalPrice);
    const ButtonComponent = Button[buttonVariation];
    // Get Amazon affiliate attributes for the actual offer URL (not the affiliate link)
    const amazonAffiliateAttributes = getAmazonAffiliateAttributes(offerUrl, amazonAffiliateTag);
    const enableActionIdMapping = currentOfferUrl?.includes('cna.st') && isActionIdEnabledForComponent;
    const getAriaId = () => {
        const ctaTextString = getCtaText(reducedPrice || price);
        return ctaTextString.replace(/(<([^>]+)>)/gi, '').replace(/ /g, '');
    };
    const handleClick = (event) => {
        event.stopPropagation();
        const hrefValue = event?.currentTarget?.getAttribute('href');
        const queryParams = extractTrackingParameters();
        if (enableActionIdMapping && hrefValue) {
            event.preventDefault();
            handleLinkClick({
                event,
                onClickHandler,
                gtmTrackOnClick,
                linkProps: hrefValue,
                setLinkProps: (newHref) => {
                    window.open(newHref, '_blank', 'noopener, noreferrer');
                },
                label: getCtaText(reducedPrice || price),
                position,
                link: getUrl(showOfferUrl),
                type: 'upcEmbedded',
                component,
                queryParams
            });
        }
        else {
            onClickHandler({
                label: getCtaText(reducedPrice || price),
                position,
                link: getUrl(showOfferUrl),
                event
            });
            gtmTrackOnClick(event, null, null, null, position);
        }
    };
    return (React.createElement(ProductOfferWrapper, { contentAlign: contentAlign, hasBookmarkingEnabled: bookmarkOnlyWithPriceOnButton, showPriceOnButton: showPriceOnButton, showSellerNameBelowPrice: showSellerNameBelowPrice, className: classnames(className, 'product-offer'), isProductSummaryGridOffer: isProductSummaryGridOffer, isCttEnabled: isCttEnabled, "data-testid": "product-offer-wrapper" },
        !showPriceOnButton && (React.createElement(ProductOfferPriceBlock, { hasBookmarkingEnabled: bookmarkOnlyWithPriceOnButton, showPriceOnButton: showPriceOnButton, className: "product-offer__seller-price", contentAlign: contentAlign },
            price && !reducedPrice && (React.createElement(ProductOfferPrice, { contentAlign: contentAlign }, price)),
            price && reducedPrice && (React.createElement(ProductOfferPriceWrapper, { contentAlign: contentAlign },
                React.createElement(ProductOfferPrice, { as: "del", contentAlign: contentAlign }, price),
                React.createElement(ProductOfferReducedPrice, { showPriceOnButton: showPriceOnButton, contentAlign: contentAlign }, reducedPrice))),
            React.createElement(ProductOfferSellerName, { contentAlign: contentAlign, dangerouslySetInnerHTML: { __html: sellerName } }))),
        ctaText && (React.createElement(ProductOfferCtaBlock, { className: "product-offer__cta-block", contentAlign: contentAlign, embedSize: embedSize, showPriceOnButton: showPriceOnButton, hasMultipleLines: hasMultipleLines, hasPriceSection: hasPriceSection, hasDivider: hasDivider, hasGallerySlideBackground: hasGallerySlideBackground, showSellerNameBelowPrice: showSellerNameBelowPrice, isCttEnabled: isCttEnabled, id: `button_label_${getAriaId()}`, shouldUseOutlinedButton: shouldUseOutlinedButton, shouldUseBlackButton: shouldUseBlackButton, shouldColorChangeBlueToBlack: shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow: shouldColorChangeBlackToYellow, isFullyRoundedButtonEnabled: isFullyRoundedButtonEnabled, showDiscountPercentLabel: showDiscountPercentLabel },
            React.createElement(ButtonComponent, { id: offerId, className: classnames('product-offer__buy-button', {
                    'product-offer__buy-button-side': showOfferButtonSideBySide
                }), btnStyle: btnStyle, ariaLabel: showSellerNameBelowPrice ? '' : getCtaText(reducedPrice || price), ariaLabelledby: showSellerNameBelowPrice
                    ? `upc_${productId} button_label_${getAriaId()}`
                    : '', ariaDescribedby: showSellerNameBelowPrice ? '' : productId, dataAttrs: {
                    ...dataAttrs,
                    'data-buy-button': true,
                    'data-offer-retailer': sellerName,
                    'data-offer-url': offerUrl,
                    ...amazonAffiliateAttributes
                }, hasPriceSection: hasPriceSection, hasMultipleLines: hasMultipleLines, href: getUrl(showOfferUrl), onClickHandler: handleClick, priceLabel: finalPrice, rel: isCtaInternal ? 'noopener' : 'sponsored noopener', target: isExternalProduct ? '_blank' : '_self', label: ctaText, inputKind: "link" }),
            showSellerNameBelowButton && (React.createElement(ProductOfferSellerName, { contentAlign: contentAlign, dangerouslySetInnerHTML: { __html: sellerName }, showSellerNameBelowButton: showSellerNameBelowButton, isCttEnabled: isCttEnabled })))),
        bookmarkOnlyWithPriceOnButton && (React.createElement(ProductOfferBookmark, { hasBookmarkingEnabled: bookmarkOnlyWithPriceOnButton, hasDivider: hasDivider, className: "product-offer__bookmark", bookmarkDetails: bookmarkDetails },
            React.createElement(BookmarkIcon, { bookmarkDetails: bookmarkDetails, bookmarkTrackingType: "productOffer", link: bookmarkLink, theme: "standard", type: "standard", isUrlBookmark: true, isBookmarkButton: true, copilotID: copilotID, contentType: contentType, subtype: subtype, contentTitle: contentTitle, isPageScoped: !hasBookmarkingEnabled, updateBookmark: updateBookmark, openCollectionsDrawer: openCollectionsDrawer, image: image }))),
        venueSeller && (React.createElement(ProductOfferVenueSeller, { contentAlign: contentAlign, isVenueCardItemContainer: isVenueCardItemContainer },
            venueSellerPreviewText && `${venueSellerPreviewText} `,
            venueSeller))));
};
ProductOffer.propTypes = {
    amazonAffiliateTag: PropTypes.string,
    bookmarkDetails: PropTypes.shape({
        contentId: PropTypes.string,
        contentType: PropTypes.string,
        bookmarkId: PropTypes.number,
        isUrlBookmark: PropTypes.bool
    }),
    btnStyle: PropTypes.oneOf(['filled', 'outlined', 'text']),
    buttonVariation: PropTypes.oneOf(['Primary', 'Utility', 'UtilityInverted']),
    className: PropTypes.string,
    component: PropTypes.string,
    contentTitle: PropTypes.string,
    contentType: PropTypes.string,
    copilotID: PropTypes.string,
    ctaAtRetailerName: PropTypes.string,
    ctaHref: PropTypes.string,
    dataAttrs: PropTypes.object,
    defaultCTAText: PropTypes.string,
    defaultTextForEmbedSize: PropTypes.string,
    embedSize: PropTypes.string,
    gtmTrackOnClick: PropTypes.func,
    hasBookmarkingEnabled: PropTypes.bool,
    hasGallerySlideBackground: PropTypes.bool,
    hasMultipleLines: PropTypes.bool,
    hasPriceSection: PropTypes.bool,
    image: PropTypes.object,
    isActionIdEnabledForComponent: PropTypes.bool,
    isCtaInternal: PropTypes.bool,
    isCttEnabled: PropTypes.bool,
    isExternalProduct: PropTypes.bool,
    isFullyRoundedButtonEnabled: PropTypes.bool,
    isProductSummaryGridOffer: PropTypes.bool,
    isVenueCardItemContainer: PropTypes.bool,
    offerId: PropTypes.string,
    offerUrl: PropTypes.string,
    onClickHandler: PropTypes.func,
    position: PropTypes.number,
    price: PropTypes.string,
    productId: PropTypes.string,
    reducedPrice: PropTypes.string,
    sellerName: PropTypes.string,
    shouldColorChangeBlackToYellow: PropTypes.bool,
    shouldColorChangeBlueToBlack: PropTypes.bool,
    shouldConsiderPriceText: PropTypes.bool,
    shouldUseBlackButton: PropTypes.bool,
    shouldUseOutlinedButton: PropTypes.bool,
    showDiscountPercentLabel: PropTypes.bool,
    showOfferButtonSideBySide: PropTypes.bool,
    showOfferUrl: PropTypes.bool,
    showPriceOnButton: PropTypes.bool,
    showSellerNameBelowButton: PropTypes.bool,
    showSellerNameBelowPrice: PropTypes.bool,
    subtype: PropTypes.string,
    updateBookmark: PropTypes.func,
    urlToBookmark: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        contentAlign: PropTypes.oneOf(['center', 'left', 'right']),
        hasDivider: PropTypes.bool
    }),
    venueSeller: PropTypes.string,
    venueSellerPreviewText: PropTypes.string
};
ProductOffer.displayName = 'ProductOffer';
const mapStateToProps = (state) => ({
    amazonAffiliateTag: state.commercePlatform?.amazonAffiliateTag,
    isFullyRoundedButtonEnabled: state.commercePlatform?.isFullyRoundedButtonEnabled
});
module.exports = connect(mapStateToProps)(ProductOffer);
//# sourceMappingURL=ProductOffer.js.map

/***/ }),

/***/ 87586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getColorToken } = __webpack_require__(26865);
const determineColor = (shouldUseOutlinedButton, shouldUseBlackButton, theme) => {
    if (shouldUseOutlinedButton) {
        return getColorToken(theme, 'colors.consumption.lead.standard.context-signature');
    }
    if (shouldUseBlackButton) {
        return getColorToken(theme, 'colors.interactive.base.white');
    }
    return getColorToken(theme, 'colors.interactive.base.black');
};
module.exports = {
    determineColor
};
//# sourceMappingURL=glm-experiment-utils.js.map

/***/ }),

/***/ 74148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { normalizePrice } = __webpack_require__(65947);
/**
 * Calculates the discount percentage between an original price and a reduced price.
 *
 * @param {string} price - The original price string
 * @param {string} reducedPrice - The reduced price string
 * @returns {number|null} The discount percentage as a rounded integer, or null if invalid
 *
 * @example
 * getDiscountPercentage("$100.00", "$80.00") // returns 20
 * getDiscountPercentage("invalid", "$80.00") // returns null
 * getDiscountPercentage("$100.00", "$100.00") // returns 0
 * getDiscountPercentage("$100.00", "$0.00") // returns null (100% discounts are filtered out)
 */
const getDiscountPercentage = (price, reducedPrice) => {
    if (price && reducedPrice) {
        const originalPrice = normalizePrice(price);
        const discountedPrice = normalizePrice(reducedPrice);
        // normalizePrice returns null for all invalid inputs, so we only need to check for null
        if (originalPrice !== null &&
            discountedPrice !== null &&
            originalPrice > 0) {
            const percentOff = ((originalPrice - discountedPrice) / originalPrice) * 100;
            const roundedPercentOff = Math.round(percentOff);
            if (roundedPercentOff >= 100) {
                return null;
            }
            return roundedPercentOff;
        }
    }
    return null;
};
module.exports = {
    getDiscountPercentage
};
//# sourceMappingURL=helper.js.map

/***/ }),

/***/ 36314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(32882);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 61366:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const isEmpty = __webpack_require__(62193);
const { calculateSpacing, getTypographyStyles, getColorStyles, getColorToken, minScreen, minMaxScreen } = __webpack_require__(26865);
const { ButtonIconWrapper, ButtonWrapper, ButtonLabel } = __webpack_require__(18974);
const { BaseText } = __webpack_require__(18730);
const { BREAKPOINTS } = __webpack_require__(96472);
const { getButtonStylesOnExperiment, getEmbedButtonLblColor, getEmbedButtonLblHoverColor } = __webpack_require__(85585);
const { determineColor } = __webpack_require__(87586);
const ProductOfferWrapper = styled.div.withConfig({
    displayName: 'ProductOfferWrapper'
}) `
  ${({ contentAlign }) => contentAlign === 'center' &&
    `
      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.numerical-small')}
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.subhed')};
    `};
  ${({ hasBookmarkingEnabled, showPriceOnButton }) => !showPriceOnButton &&
    hasBookmarkingEnabled &&
    `
      display: grid;
      grid-template-columns: 1fr 46px;
      column-gap: 16px;
      row-gap: 0;
      align-items: end;
    `};
  ${({ hasBookmarkingEnabled, showPriceOnButton }) => showPriceOnButton &&
    hasBookmarkingEnabled &&
    `
      display: grid;
      grid-template-columns: 1fr 46px;
      column-gap: 16px;
      justify-content: space-between;
    `};

  ${({ isProductSummaryGridOffer }) => isProductSummaryGridOffer &&
    `
        @media (min-width: 1600px) {
          max-width: ${calculateSpacing(30)};
        }
      `};

  ${({ showSellerNameBelowPrice, isProductSummaryGridOffer, isCttEnabled }) => showSellerNameBelowPrice && !isProductSummaryGridOffer && isCttEnabled
    ? `
          margin-bottom: ${calculateSpacing(1)};
          ${getTypographyStyles('typography.definitions.commerce.call-to-action')};
           
    `
    : `margin-bottom: ${calculateSpacing(1)};`}
`;
const ProductOfferBookmark = styled.div.withConfig({
    displayName: 'ProductOfferBookmark'
}) `
  ${({ hasBookmarkingEnabled, bookmarkDetails }) => {
    if (hasBookmarkingEnabled) {
        if (isEmpty(bookmarkDetails)) {
            return `visibility: hidden;`;
        }
        return `
        width: auto;
        overflow: hidden;
        ${ButtonIconWrapper} {
          .icon {
            path {
              fill: #FFFFFF;
              stroke: none;
            }
          }
        }
      `;
    }
    return ``;
}}
  ${({ hasDivider }) => hasDivider &&
    `
      padding: 1.75rem 0;
      margin-top: 1.5rem;
    `};
  ${ButtonWrapper},
  .button {
    margin: 0;
    border: none;
    background: ${getColorToken('colors.interactive.base.black')};
    padding: ${calculateSpacing(1)};
    min-width: auto;

    &:hover {
      ${({ theme }) => getColorStyles(theme, 'background', 'colors.interactive.social.primary-hover')};
    }

    ${ButtonIconWrapper} {
      padding: 0;
    }

    ${ButtonLabel} {
      display: none;
    }
  }
`;
const ProductOfferPriceBlock = styled.div.withConfig({
    displayName: 'ProductOfferPriceBlock'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.numerical-small')}
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.subhed')};
  ${({ contentAlign }) => contentAlign === 'center' &&
    `
      display: flex;
      flex: 1;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: center;
      margin: ${calculateSpacing(2)} 0;
      @media (min-width: 768px) {
        justify-content: left;
        margin: ${calculateSpacing(2)} 0 ${calculateSpacing(2)} ${calculateSpacing(4)};
      }
    `};
  ${({ hasBookmarkingEnabled, showPriceOnButton }) => hasBookmarkingEnabled &&
    !showPriceOnButton &&
    `
      grid-column: 1/-1;
    `};
`;
const ProductOfferPrice = styled.span.withConfig({
    displayName: 'ProductOfferPrice'
}) `
  ${({ contentAlign }) => contentAlign === 'center' &&
    `
      order: 2;
      margin-right: ${calculateSpacing(1)};
  `};
`;
const ProductOfferReducedPrice = styled.span.withConfig({
    displayName: 'ProductOfferReducedPrice'
}) `
  display: inline;
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.accent')};
  ${({ contentAlign }) => contentAlign === 'center' &&
    `
      color: unset;
  `};
`;
const ProductOfferSellerName = styled.div.withConfig({
    displayName: 'ProductOfferSellerName'
}) `
  ${({ theme, showSellerNameBelowButton }) => {
    if (showSellerNameBelowButton) {
        return `
      ${getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')};
      ${getColorStyles(theme, 'color', 'colors.consumption.body.standard.body-deemphasized')};
        padding: ${calculateSpacing(1.25)} 1px;
        min-height: 30px;
        `;
    }
    return `${getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-secondary')}
    ${getColorStyles(theme, 'color', 'colors.consumption.body.standard.subhed')};
    `;
}}
  margin-right: ${calculateSpacing(1)};
  ${({ contentAlign }) => contentAlign === 'center' && `order: 1;`};
`;
const ProductOfferCtaBlock = styled.div.withConfig({
    displayName: 'ProductOfferCtaBlock'
}) `
  .price-above-seller-name {
    padding-top: 2px;
  }

  ${({ embedSize }) => {
    if (embedSize === 'feature-large') {
        return `
    grid-template-columns: 1fr;
    grid-template-rows: 1fr;`;
    }
    if (embedSize === 'feature-small') {
        return `
      margin-top: -${calculateSpacing(2)};
      `;
    }
    return `width: 100%;
    `;
}}

  > div[data-bonsai-product-link-wrapper] {
    width: 100%;
  }
  ${({ hasGallerySlideBackground }) => hasGallerySlideBackground &&
    `${ButtonLabel}{
     padding:${calculateSpacing(1)} ${calculateSpacing(2)} 0;
     margin-bottom: ${calculateSpacing(1)};
  }`}

  ${({ shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme }) => getButtonStylesOnExperiment(shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme)}

  .product-offer__buy-button {
    /* Apply overflow protection only for UPC discount percentage buttons */
    ${({ showDiscountPercentLabel }) => showDiscountPercentLabel &&
    `
      ${ButtonLabel} {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
    `}

    ${({ theme, embedSize, shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow }) => {
    if (embedSize === 'feature-large' || embedSize === 'feature-medium') {
        return `height: 35px;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;
      ${getEmbedButtonLblColor(shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme)}
      ${getTypographyStyles(theme, 'typography.definitions.utility.button-core')}
      ${minMaxScreen(BREAKPOINTS.md, BREAKPOINTS.lg)}{
        width: 266px;
        grid-column: 1/ span 5;
      }
      ${minMaxScreen(BREAKPOINTS.lg, BREAKPOINTS.xl)}{
        width: 288px;
        grid-column: 2/ span 4;
      }
      ${minMaxScreen(BREAKPOINTS.xl, BREAKPOINTS.xxl)}{
        width: 264px;
        grid-column: 2/ span 3;
      }
      ${minScreen(BREAKPOINTS.fullBleed)}{
        width: 343px;
        grid-column: 2/ span 3;
      }
      &:focus,
      &:active,
      &:hover {
        ${getEmbedButtonLblHoverColor(shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme)}
      `;
    }
    if (embedSize === 'feature-small') {
        return `all: revert;
        ${getColorStyles(theme, 'color', 'colors.interactive.base.brand-primary')};
        && {
          text-decoration: underline;
        }
        ${getTypographyStyles(theme, 'typography.definitions.foundation.meta-primary')}`;
    }
    return '';
}}
    margin-top: ${calculateSpacing(4)};
    ${({ theme, showSellerNameBelowPrice, isCttEnabled, shouldUseOutlinedButton, shouldUseBlackButton }) => showSellerNameBelowPrice &&
    `
        border-width: 1px;
        border-color: ${shouldUseOutlinedButton
        ? getColorToken(theme, 'colors.consumption.lead.standard.context-signature')
        : getColorToken(theme, 'colors.interactive.base.black')};
        background-color : ${shouldUseBlackButton
        ? getColorToken(theme, 'colors.interactive.base.black')
        : getColorToken(theme, 'colors.interactive.base.white')};
        

        .button__label {
          min-width: 0
        }

        span {
           color: ${determineColor(shouldUseOutlinedButton, shouldUseBlackButton, theme)};
        }

        p {
          margin-block-end: 0;
          margin-block-start: 0;
          overflow: hidden;
          text-overflow: ellipsis;
          white-space: nowrap;
        }
        & {
        padding : ${calculateSpacing(2)} ${calculateSpacing(0.75)};
        }
        
        ${getTypographyStyles(theme, isCttEnabled
        ? 'typography.definitions.commerce.call-to-action'
        : 'typography.definitions.utility.button-core')}

        ${getColorStyles(theme, 'color', 'colors.interactive.base.white')};

        &:hover {
          border-style: solid;
          background-color : 
          ${shouldUseOutlinedButton || shouldUseBlackButton
        ? getColorToken(theme, 'colors.consumption.lead.standard.context-signature')
        : getColorToken(theme, 'colors.interactive.base.black')};
          border-color : 
          ${shouldUseOutlinedButton || shouldUseBlackButton
        ? getColorToken(theme, 'colors.consumption.lead.standard.context-signature')
        : getColorToken(theme, 'colors.interactive.base.black')};

          span {
            ${getColorStyles(theme, 'color', 'colors.interactive.base.white')};
          }
        }
      `}
    ${({ showPriceOnButton, hasPriceSection, embedSize }) => showPriceOnButton &&
    `
        margin: 0;
        padding: ${!hasPriceSection &&
        embedSize !== 'feature-small' &&
        calculateSpacing(2)};
        width: 100%;
      `};
    ${({ showPriceOnButton, hasMultipleLines }) => showPriceOnButton &&
    hasMultipleLines &&
    `display: flex;
      padding: 0`}
    ${({ showPriceOnButton, contentAlign }) => !showPriceOnButton &&
    contentAlign === 'center' &&
    `
        margin-top: 0;
        width: 100%;
        &:focus,
        &:link,
        &:visited,
        &:hover {
          text-decoration: none;
        }
        transition-timing-function: ease-in;
        transition-property: color, background, border;
        ${minScreen(BREAKPOINTS.md)}{
          min-width: ${calculateSpacing(16)};
        }
      `};

    ${({ isFullyRoundedButtonEnabled }) => isFullyRoundedButtonEnabled && `border-radius: 50px;`};
  }
  ${({ hasDivider, theme }) => {
    if (hasDivider) {
        return `
        padding: ${calculateSpacing(3.5)} 0;
        margin-top: ${calculateSpacing(3)};
        ${getColorStyles(theme, 'color', 'colors.consumption.body.standard.divider')};
        border-bottom-style: solid;
        border-bottom-width: 1px;
        border-top-style: solid;
        border-top-width: 1px;
    
        .product-offer__buy-button {
          margin-top: 0;
          ${minScreen(BREAKPOINTS.md)}{
            max-width: 275px;
          }
        }
      `;
    }
    return '';
}}
`;
const ProductOfferVenueSeller = styled(BaseText).withConfig({
    displayName: 'ProductOfferVenueSeller'
}) `
  ${({ theme, typeToken }) => getTypographyStyles(theme, typeToken)}
  ${({ isVenueCardItemContainer, theme }) => isVenueCardItemContainer &&
    `${getTypographyStyles(theme, 'typography.definitions.utility.input-core')}`}

  display: block;
  margin-top: ${calculateSpacing(1.6)};
  width: 100%;
  text-align: ${({ contentAlign }) => contentAlign || 'center'};
  ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)};
`;
const ProductOfferPriceWrapper = styled.div.withConfig({
    displayName: 'ProductOfferPriceWrapper'
}) `
  ${({ contentAlign }) => contentAlign === 'center' &&
    `
    order: 2;
  `}
`;
ProductOfferVenueSeller.defaultProps = {
    as: 'span',
    colorToken: 'colors.consumption.body.standard.body-deemphasized',
    typeToken: 'typography.definitions.utility.assistive-text'
};
ProductOfferCtaBlock.defaultProps = {
    colorToken: 'colors.consumption.body.standard.divider'
};
module.exports = {
    ProductOfferWrapper,
    ProductOfferPriceBlock,
    ProductOfferPrice,
    ProductOfferPriceWrapper,
    ProductOfferReducedPrice,
    ProductOfferSellerName,
    ProductOfferCtaBlock,
    ProductOfferVenueSeller,
    ProductOfferBookmark
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 76896:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    productOfferPriceString: {
        id: 'ProductOffer.price',
        defaultMessage: '{priceValue} at {sellerName}',
        description: 'price string for product offer button'
    },
    productOfferDefaultPriceString: {
        id: 'ProductOffer.defaultPriceString',
        defaultMessage: '{priceValue} {sellerName}',
        description: 'default price string for product offer button'
    },
    productOffersaveBookmarkLabel: {
        id: 'ProductOffer.productOffersaveBookmarkLabel',
        defaultMessage: 'Save story',
        description: 'Label for the bookmark icon'
    },
    productOfferVariationSellerNameString: {
        id: 'ProductOffer.variationSellerNameString',
        defaultMessage: 'Shop at',
        description: 'Seller name string'
    },
    productOffeVariationrDefaultCTA: {
        id: 'ProductOffer.variationDefaultCTA',
        defaultMessage: 'Shop Now',
        description: 'Default CTA string'
    },
    productOfferDiscountPercentageLabel: {
        id: 'ProductOffer.productOfferDiscountPercentageLabel',
        defaultMessage: '{percentage}% off',
        description: 'Discount Percentage label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 32882:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const ProductOffer = __webpack_require__(40523);
ProductOffer.PriceOutsideCenter = asVariation(ProductOffer, 'PriceOutsideCenter', {
    contentAlign: 'center'
});
ProductOffer.AlignLeft = asVariation(ProductOffer, 'AlignLeft', {
    contentAlign: 'left'
});
ProductOffer.AlignLeftWithDivider = asVariation(ProductOffer, 'AlignLeftWithDivider', {
    contentAlign: 'left',
    hasDivider: true
});
ProductOffer.ButtonWithPriceSection = asVariation(ProductOffer, 'ButtonWithPriceSection', {
    contentAlign: 'left'
}, {
    buttonVariation: 'Utility',
    btnStyle: 'filled',
    showPriceOnButton: true,
    hasPriceSection: true,
    showSellerNameBelowButton: true
});
ProductOffer.ButtonWithSellerBelowPrice = asVariation(ProductOffer, 'ButtonWithSellerBelowPrice', {}, {
    showPriceOnButton: true,
    showSellerNameBelowPrice: true
});
module.exports = ProductOffer;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 85585:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getColorToken, getColorStyles } = __webpack_require__(26865);
const { ButtonWrapper } = __webpack_require__(18974);
const getButtonStylesOnExperiment = (shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme) => {
    let borderColor;
    let backgroundColor;
    let hoverBorderColor;
    let hoverBackgroundColor;
    let labelColor;
    let labelHoverColor;
    if (shouldColorChangeBlueToBlack) {
        borderColor = getColorToken(theme, 'colors.interactive.base.brand-primary');
        backgroundColor = borderColor;
        hoverBorderColor = getColorToken(theme, 'colors.interactive.base.body');
        hoverBackgroundColor = hoverBorderColor;
        labelColor = getColorToken(theme, 'colors.interactive.base.white');
    }
    else if (shouldColorChangeBlackToYellow) {
        borderColor = getColorToken(theme, 'colors.interactive.base.body');
        backgroundColor = borderColor;
        hoverBorderColor = getColorToken(theme, 'colors.interactive.feedback.notice-primary');
        hoverBackgroundColor = hoverBorderColor;
        labelColor = getColorToken(theme, 'colors.interactive.base.white');
        labelHoverColor = getColorToken(theme, 'colors.interactive.base.body');
    }
    return `
    ${ButtonWrapper} {
      border-color: ${borderColor};
      background-color: ${backgroundColor};
      &:hover {
        border-color: ${hoverBorderColor};
        background-color: ${hoverBackgroundColor};
      }
    }
    a {
      color: ${labelColor};
      ${shouldColorChangeBlackToYellow
        ? `
        &:hover {
          color: ${labelHoverColor};
        }
      `
        : ''}
    }
  `;
};
const getEmbedButtonLblColor = (shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme) => {
    if (shouldColorChangeBlueToBlack || shouldColorChangeBlackToYellow) {
        return getColorStyles(theme, 'color', 'colors.interactive.base.white');
    }
    return getColorStyles(theme, 'color', 'colors.interactive.base.brand-primary');
};
const getEmbedButtonLblHoverColor = (shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, theme) => {
    if (shouldColorChangeBlueToBlack) {
        return getColorStyles(theme, 'color', 'colors.interactive.base.white');
    }
    if (shouldColorChangeBlackToYellow) {
        return getColorStyles(theme, 'color', 'colors.interactive.base.body');
    }
    return getColorStyles(theme, 'color', 'colors.interactive.base.white');
};
module.exports = {
    getButtonStylesOnExperiment,
    getEmbedButtonLblColor,
    getEmbedButtonLblHoverColor
};
//# sourceMappingURL=wrd-experiment-utils.js.map

/***/ }),

/***/ 76241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { PullQuoteEmbedWrapper, PullquoteDecorativeBorder } = __webpack_require__(9865);
const { asConfiguredComponent } = __webpack_require__(12892);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * PullquoteEmbed component
 *
 * @param {object} props - React props
 * @param {object} [props.attributes] - Optional attributes to add top level i.e. aria-*, role, etc.
 * @param {string|ReactElement} props.children - The quote content to display.
 * @param {string} [props.className] - Optional top-level class to add.
 * @param {boolean} [props.shouldEnableFullArticleInverted] - Optional flag to enable full article inverted
 * @param {object} [props.variations] - Optional. Variation properties used in rendering the component.
 * @param {boolean} [props.variations.isAggressive] - Optional variation that determines whether or not the pull quote is aggressive
 * @param {boolean} [props.variations.isUnderlined] - Optional (default: false). Whether or not to underline the pull quote text
 * @param {string} [props.variations.textAlign] - [`center`, `left`] Optional. Sets the text alignment of textual content block. Defaults to `left`
 * @param {boolean} [props.variations.hasBackgroundColor] - Optional (default: false). Whether or not the pull quote has a background color
 * @param {boolean} [props.variations.hasLeftBorder] - Optional (default: true). Whether or not the pull quote text has a left border
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <aside>
 */
const PullquoteEmbed = ({ attributes, children, className, shouldEnableFullArticleInverted, variations = {
    hasLeftBorder: true,
    hasTopSpacing: true,
    isAggressive: false,
    isUnderlined: false,
    textAlign: 'left',
    hasBackgroundColor: false
}, variationName }) => {
    const { isAggressive, isUnderlined, textAlign, hasBackgroundColor, hasLeftBorder, hasTopSpacing } = variations;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'PullquoteEmbed',
            variation: variationName
        });
    }, [variationName]);
    return (React.createElement(PullQuoteEmbedWrapper, { ...attributes, "aria-hidden": "true", textAlign: textAlign, isAggressive: isAggressive, isUnderlined: isUnderlined, hasLeftBorder: hasLeftBorder, hasBackgroundColor: hasBackgroundColor, hasTopSpacing: hasTopSpacing, className: className, shouldEnableFullArticleInverted: shouldEnableFullArticleInverted, "data-testid": `pullquote-embed${variationName ? `-${variationName.toLowerCase()}` : ''}` },
        hasLeftBorder && React.createElement(PullquoteDecorativeBorder, null),
        children));
};
PullquoteEmbed.propTypes = {
    attributes: PropTypes.object,
    children: PropTypes.oneOfType([
        PropTypes.arrayOf(PropTypes.node),
        PropTypes.node
    ]).isRequired,
    className: PropTypes.string,
    shouldEnableFullArticleInverted: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        hasBackgroundColor: PropTypes.bool,
        hasLeftBorder: PropTypes.bool,
        hasTopSpacing: PropTypes.bool,
        isAggressive: PropTypes.bool,
        isUnderlined: PropTypes.bool,
        textAlign: PropTypes.oneOf(['center', 'left'])
    })
};
PullquoteEmbed.displayName = 'PullquoteEmbed';
module.exports = asConfiguredComponent(PullquoteEmbed, 'PullquoteEmbed');
//# sourceMappingURL=PullquoteEmbed.js.map

/***/ }),

/***/ 40007:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(5433);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9865:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles, getColorStyles, getColorToken } = __webpack_require__(26865);
const PullquoteDecorativeBorder = styled.div.withConfig({
    displayName: 'PullQuoteDecorativeBorder-sc'
}) `
  grid-area: pullquote-border;
  border-width: 0 0 0 4px;
  border-style: solid;
  content: ' ';
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.display-signature')};
`;
const PullQuoteEmbedContent = styled.div.withConfig({
    displayName: 'PullQuoteEmbedContent-sc'
}) `
  grid-area: pullquote-content;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.display-small')};
  margin: 0 auto;
  width: 100%;

  p {
    margin-block-start: ${calculateSpacing(2)};
    margin: 0;
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.body')};
  }
`;
const PullQuoteEmbedCredit = styled.div.withConfig({
    displayName: 'PullQuoteEmbedCredit-sc'
}) `
  grid-area: pullquote-credit;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-core')};
  margin-top: ${calculateSpacing(3)};
  width: 100%;
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.body')};

  &::before {
    margin-right: ${calculateSpacing(1)};
    content: '';
  }
`;
const pullQuoteEmbedUnderlineStyles = css `
  ${PullQuoteEmbedContent},
  ${PullQuoteEmbedContent} > p {
    text-decoration: underline;
    ${({ theme }) => getColorStyles(theme, 'text-decoration-color', 'colors.consumption.body.standard.display-signature')};
  }
`;
const PullQuoteEmbedWrapper = styled.aside.withConfig({
    displayName: 'PullQuoteEmbedWrapper-sc'
}) `
  display: grid;
  grid-template-areas:
    'pullquote-border pullquote-content .'
    'pullquote-border pullquote-credit .';
  grid-template-columns: auto 1fr auto;
  margin-block-start: ${({ hasTopSpacing = false }) => hasTopSpacing ? calculateSpacing(5) : calculateSpacing(1.2)};
  margin-block-end: ${calculateSpacing(5)};
  column-gap: ${calculateSpacing(3)};

  ${({ hasBackgroundColor, hasLeftBorder }) => {
    if (hasBackgroundColor) {
        return css `
        background-color: ${getColorToken('colors.background.brand')};
        padding-top: ${calculateSpacing(5)};
        padding-right: ${calculateSpacing(2)};
        padding-bottom: ${calculateSpacing(5)};
        padding-left: ${calculateSpacing(hasLeftBorder ? 5 : 2)};
      `;
    }
    return '';
}}

  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.display-texture')};

  text-align: ${(props) => props.textAlign};
  ${({ textAlign }) => textAlign === 'center'
    ? css `
          text-align: center;

          ${PullQuoteEmbedCredit} {
            ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.citation')};
            display: inline-block;
            width: 100%;
            text-decoration: none;

            &::before {
              display: none;
            }
          }
        `
    : ''}

  ${({ isUnderlined }) => isUnderlined && pullQuoteEmbedUnderlineStyles};

  ${({ shouldEnableFullArticleInverted, theme }) => shouldEnableFullArticleInverted &&
    `
  ${PullQuoteEmbedContent} p {
  color: ${getColorToken(theme, 'colors.consumption.body.inverted.body')};
}

  ${PullQuoteEmbedCredit} {
  color: ${getColorToken(theme, 'colors.consumption.body.inverted.body')};
}
`}
`;
module.exports = {
    PullquoteDecorativeBorder,
    PullQuoteEmbedContent,
    PullQuoteEmbedCredit,
    PullQuoteEmbedWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 5433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const PullquoteEmbed = __webpack_require__(76241);
PullquoteEmbed.Center = asVariation(PullquoteEmbed, 'Center', {
    hasLeftBorder: false,
    isAggressive: false,
    hasBackgroundColor: false,
    isUnderlined: false,
    textAlign: 'center'
});
PullquoteEmbed.Deemphasized = asVariation(PullquoteEmbed, 'Deemphasized', {
    hasLeftBorder: false,
    isAggressive: false,
    hasBackgroundColor: false,
    isUnderlined: false,
    textAlign: 'left',
    hasTopSpacing: false
});
PullquoteEmbed.CenterUnderline = asVariation(PullquoteEmbed, 'CenterUnderline', {
    hasLeftBorder: false,
    isAggressive: false,
    hasBackgroundColor: false,
    isUnderlined: true,
    textAlign: 'center'
});
PullquoteEmbed.Aggressive = asVariation(PullquoteEmbed, 'Aggressive', {
    hasLeftBorder: true,
    isAggressive: true,
    isUnderlined: false,
    hasBackgroundColor: true,
    textAlign: 'left'
});
PullquoteEmbed.LeftBorder = asVariation(PullquoteEmbed, 'LeftBorder', {
    hasLeftBorder: true,
    isAggressive: false,
    isUnderlined: false,
    hasBackgroundColor: false,
    textAlign: 'left'
});
module.exports = PullquoteEmbed;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 6605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
const injectRecaptchaHelpers = __webpack_require__(48141);
/**
 * ReCaptcha component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} props.recaptchaCallback - callback to pass the response from recaptcha service
 * @param {string} props.recaptchaSiteKey - recaptcha site key
 * @param {string} props.recaptchaSize - recaptcha size
 * @param {string} props.widgetId - Id of DOM node that recaptcha widget will live in
 *
 * @returns {ReactElement} <div>
 */
class ReCaptcha extends React.PureComponent {
    componentDidMount() {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ReCaptcha'
        });
        const { recaptchaCallback, recaptchaSiteKey, recaptchaSize = 'invisible', widgetId } = this.props;
        if ( true && recaptchaSiteKey) {
            injectRecaptchaHelpers
                .injectV2RecaptchaScript()
                .then(() => {
                injectRecaptchaHelpers.generateRecaptchaWidget(widgetId, {
                    sitekey: recaptchaSiteKey,
                    size: recaptchaSize,
                    callback: recaptchaCallback
                });
            })
                .catch(() => {
                console.warn('Error: adding ReCAPTCHA in componentDidMount failed');
            });
        }
    }
    render() {
        const { className, widgetId } = this.props;
        return (React.createElement("div", { className: classnames('re-captcha', className), id: widgetId }));
    }
}
ReCaptcha.propTypes = {
    className: PropTypes.string,
    recaptchaCallback: PropTypes.func,
    recaptchaSiteKey: PropTypes.string.isRequired,
    recaptchaSize: PropTypes.oneOf(['invisible', 'normal', 'compact']),
    widgetId: PropTypes.string.isRequired
};
module.exports = ReCaptcha;
//# sourceMappingURL=ReCaptcha.js.map

/***/ }),

/***/ 48141:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { waitForElm } = __webpack_require__(79815);
/**
 * Injects Recaptcha script onto web page for Recaptcha V2 Invisible
 *
 * @see {@link https://developers.google.com/recaptcha/docs/invisible}
 * @returns {Promise<undefined>} Promise
 */
function injectV2RecaptchaScript() {
    if (!document.getElementById('recaptcha-api')) {
        const script = document.createElement('script');
        script.id = 'recaptcha-api';
        script.src = 'https://www.google.com/recaptcha/api.js?render=explicit';
        script.async = true;
        script.defer = true;
        document.body.appendChild(script);
        return new Promise((resolve, reject) => {
            script.addEventListener('load', () => {
                resolve();
            });
            script.addEventListener('error', () => {
                reject();
            });
        });
    }
    return Promise.resolve();
}
/**
 * center aligns recaptcha challenge
 *
 * @returns {undefined} undefined
 */
function centerAlignRecaptchaChallenge() {
    waitForElm('[src^="https://www.google.com/recaptcha/api2/bframe"]').then((recaptchaIframe) => {
        if (recaptchaIframe) {
            const parentElStyle = recaptchaIframe.parentNode.style;
            parentElStyle.position = 'fixed';
            parentElStyle.left = '50%';
            parentElStyle.top = '50%';
            parentElStyle.right = 'auto';
            parentElStyle.transform = 'translate(-50%, -50%)';
        }
    });
}
/**
 * Renders the Recaptcha widget in a div specified by `widgetId`
 *
 * @param {string} widgetId - div #id to render the widget in
 * @param {string} sitekey - the tenent and env specific ReCAPTCHA site key
 * @param {Function} callback - the callback for google to call when the
 *  recaptcha challenge is complete. The callback will receive as a param the
 *  recaptcha response token string.
 *
 * @see {@link https://developers.google.com/recaptcha/docs/invisible}
 * @returns {Promise<undefined>} Promise
 */
function generateRecaptchaWidget(widgetId, { sitekey, callback, size } = {}) {
    const grecaptcha = window.grecaptcha || false;
    if (grecaptcha) {
        grecaptcha.ready(() => {
            grecaptcha.render(widgetId, {
                sitekey,
                size,
                callback
            });
        });
    }
}
/**
 * Calls grecaptcha.execute to trigger the recaptcha challenge
 *
 * @see {@link https://developers.google.com/recaptcha/docs/invisible}
 * @returns {undefined} undefined
 */
function executeV2Recaptcha() {
    if (!window.grecaptcha) {
        return;
    }
    const { grecaptcha } = window;
    if (grecaptcha.getResponse()) {
        grecaptcha.reset();
    }
    window.grecaptcha.execute();
}
module.exports = {
    centerAlignRecaptchaChallenge,
    executeV2Recaptcha,
    generateRecaptchaWidget,
    injectV2RecaptchaScript
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 59376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(6605);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 67829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const { useState, useEffect, useRef } = __webpack_require__(96540);
const PlayIcon = __webpack_require__(11118);
const PauseIcon = __webpack_require__(87574);
const AspectRatio = __webpack_require__(60448);
const { getOptimalSource, getDefaultSource } = __webpack_require__(99424);
const translations = (__webpack_require__(20017)/* ["default"] */ .A);
const { TrackComponentChannel } = __webpack_require__(78788);
const { ResponsiveClipWrapper, ResponsiveClipPlayPauseButton, ResponsiveClipVideoContainer, ResponsiveClipEventLayer } = __webpack_require__(91783);
const Breakpoints = __webpack_require__(99906);
/**
 * ResponsiveClip component
 *
 * @param {object} props - React props
 * @param {string} props.altText - Required text description
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} [props.onLoadedMetadata] - Optional function to callback when video's metadata is loaded
 * @param {object} props.segmentedSources - Object containing sources for clips with width, height, & url.
 * @param {boolean} [props.shouldAutoPlay] - Optional boolean set to true to start playing video clip once component is
 *   rendered, setting to false will only play video clip when hovering.
 * @param {boolean} [props.shouldEnableExternalControl] - Optional flag to control play/pause through parent component. Default: FALSE
 * @param {boolean} [props.shouldLoadAsset] - Optional flag indicating the clip should load. Default: TRUE.
 * @param {boolean} [props.shouldPause] - Optional flag to pause video. Default: FALSE.
 * @param {boolean} [props.shouldYieldControlOfVideoPlayPause] - Optional flag indicating if the component should not
 *   control the play/pause of video
 * @param {object} [props.sources] - Object containing sources for clips with width, height, & url.
 * @param {boolean} [props.videoElementRef] - Optional React Ref to the video element.
 *
 * @returns {ReactElement} <div>
 */
const ResponsiveClip = ({ segmentedSources, sources, altText, className, masterAspectRatio, shouldEnableExternalControl = false, shouldLoadAsset = true, shouldPause = false, shouldRestrictCropping, shouldUseMediumBreakpoint, onLoadedMetadata, shouldAutoPlay = true, shouldYieldControlOfVideoPlayPause, videoElementRef }) => {
    const shouldPlayVideoOnHover = !shouldAutoPlay && !shouldYieldControlOfVideoPlayPause;
    const shouldHidePlayPauseButton = !shouldAutoPlay || shouldYieldControlOfVideoPlayPause;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ResponsiveClip'
        });
    }, []);
    const { formatMessage } = useIntl();
    const defaultAvailableSources = segmentedSources
        ? [...segmentedSources.sm, ...segmentedSources.lg]
        : Object.values(sources);
    const videoNode = useRef(null);
    const [playing, setPlaying] = useState(shouldAutoPlay);
    const [availableSources] = React.useState(defaultAvailableSources);
    const { src } = getDefaultSource(availableSources);
    useEffect(() => {
        return () => {
            if (videoNode.current) {
                videoNode.current.removeEventListener('loadedmetadata', 
                // eslint-disable-next-line  @typescript-eslint/no-use-before-define
                onVideoMetaDataLoaded);
            }
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const onMouseEnterToPlay = () => {
        videoNode.current && videoNode.current.play();
    };
    const onMouseLeaveToPause = () => {
        videoNode.current && videoNode.current.pause();
    };
    const onVideoPaused = () => {
        setPlaying(false);
    };
    const onVideoPlayed = () => {
        setPlaying(true);
    };
    /**
     * Handler for when the ref for the video container DOM node is available.
     * Creates the inner video element, sets listeners, appends it.
     *
     * @param {DOMElement} container - element DOM node
     * @returns {undefined} undefined
     */
    function onVideoContainerLoaded(container) {
        if (!container || videoNode.current) {
            return;
        }
        const { src: source } = getOptimalSource(availableSources, container);
        // eslint-disable-next-line prefer-destructuring
        const parentNode = container.parentNode;
        // We're creating the video element manually, and appending it manually.
        // Why? Because https://github.com/facebook/react/issues/10389
        videoNode.current = document.createElement('video');
        videoNode.current.autoplay = shouldAutoPlay;
        videoNode.current.loop = true;
        videoNode.current.muted = true;
        videoNode.current.className = 'responsive-clip__video';
        videoNode.current.setAttribute('playsinline', 'true');
        // eslint-disable-next-line  @typescript-eslint/no-use-before-define
        videoNode.current.addEventListener('loadedmetadata', onVideoMetaDataLoaded);
        videoNode.current.addEventListener('play', onVideoPlayed);
        videoNode.current.addEventListener('pause', onVideoPaused);
        // Mobile iOS Safari doesn't display preview thumbnail until you tap on the video
        // Media Fragments helps iOS to preload and show the video thumbnail
        videoNode.current.src = shouldAutoPlay ? source : `${source}#t=0.001`;
        parentNode.replaceChild(videoNode.current, container);
        if (videoElementRef) {
            videoElementRef.current = videoNode.current;
        }
        /**
         * Checks the shouldPause flag and pauses the video accordingly.
         */
        if (shouldPause) {
            videoNode.current.pause();
        }
    }
    useEffect(() => {
        /**
         * Enables external control of the video's play/pause state.
         * If shouldPause is true, video is paused and playing state is set to false.
         * If shouldPause is false, video is played and playing state is set to true.
         */
        if (videoNode.current && shouldEnableExternalControl) {
            if (shouldPause) {
                videoNode.current.pause();
                setPlaying(false);
            }
            else {
                videoNode.current.play();
                setPlaying(true);
            }
        }
    }, [shouldPause, shouldEnableExternalControl]);
    /**
     * Event listener for the toggle button being clicked.
     *
     * @param {object} event - click event
     * @returns {undefined} undefined
     */
    const onPlayPauseToggle = (event) => {
        // Prevents default event if video is linked
        event.preventDefault();
        if (playing) {
            videoNode.current.pause();
            setPlaying(false);
        }
        else {
            videoNode.current.play();
            setPlaying(true);
        }
    };
    /**
     * Event listener for the `<video>.loadedmetadata` event.
     *
     * @returns {undefined} undefined
     */
    function onVideoMetaDataLoaded() {
        const videoContainerEl = videoNode.current;
        if (videoContainerEl) {
            onLoadedMetadata && onLoadedMetadata(videoContainerEl);
        }
    }
    return (React.createElement(ResponsiveClipWrapper, { className: classnames('responsive-clip', className), "data-testid": "ResponsiveClipWrapper" },
        React.createElement(AspectRatio, { shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, breakpoints: Breakpoints, segmentedSources: segmentedSources, masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping }, shouldLoadAsset ? (React.createElement(ResponsiveClipVideoContainer, { "data-testid": "ResponsiveClipVideoContainer" },
            shouldHidePlayPauseButton ? null : (React.createElement(ResponsiveClipPlayPauseButton, { "data-testid": "ResponsiveClipPlayPauseButton", ariaLabel: formatMessage(translations.clipAriaLabel), className: "responsive-clip__play-pause", onClickHandler: onPlayPauseToggle, ButtonIcon: playing ? PauseIcon : PlayIcon, isIconButton: true, label: formatMessage(translations.clipLabel) })),
            React.createElement("video", { ref: onVideoContainerLoaded, "aria-label": altText, autoPlay: shouldAutoPlay, className: "responsive-clip__video lazyload", loop: true }))) : (React.createElement(ResponsiveClipVideoContainer, { as: "noscript", "data-testid": "ResponsiveClipVideoContainer" },
            React.createElement("video", { ref: videoElementRef, "aria-label": altText, autoPlay: shouldAutoPlay, className: "responsive-clip__video", loop: true, muted: true, src: shouldAutoPlay ? src : `${src}#t=0.001`, onPause: onVideoPaused, onPlay: onVideoPlayed })))),
        shouldPlayVideoOnHover && (React.createElement(ResponsiveClipEventLayer, { onTouchStart: onMouseEnterToPlay, onTouchEnd: onMouseLeaveToPause, onMouseEnter: onMouseEnterToPlay, onMouseLeave: onMouseLeaveToPause }))));
};
const sourcePropType = PropTypes.shape({
    aspectRatio: PropTypes.string,
    height: PropTypes.number,
    width: PropTypes.number,
    url: PropTypes.string.isRequired
});
ResponsiveClip.propTypes = {
    altText: PropTypes.string.isRequired,
    className: PropTypes.string,
    masterAspectRatio: PropTypes.string,
    onLoadedMetadata: PropTypes.func,
    segmentedSources: PropTypes.shape({
        sm: PropTypes.arrayOf(sourcePropType),
        lg: PropTypes.arrayOf(sourcePropType)
    }),
    shouldAutoPlay: PropTypes.bool,
    shouldEnableExternalControl: PropTypes.bool,
    shouldLoadAsset: PropTypes.bool,
    shouldPause: PropTypes.bool,
    shouldRestrictCropping: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    shouldYieldControlOfVideoPlayPause: PropTypes.bool,
    sources: PropTypes.objectOf(PropTypes.shape({ sourcePropType })),
    videoElementRef: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.shape({ current: PropTypes.object })
    ])
};
module.exports = ResponsiveClip;
//# sourceMappingURL=ResponsiveClip.js.map

/***/ }),

/***/ 17637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ResponsiveClip = __webpack_require__(67829);
module.exports = ResponsiveClip;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99424:
/***/ ((module) => {

/**
 * This is the vertical pixel value for the preferred default video size.
 * For fallbacks, we will try to get the closest video to this size.
 */
const PREFERRED_DEFAULT_SIZE = 720;
/**
 * Utility function which translates { url, width, height } to { src, type }.
 *
 * @param {object} obj - Since source object for a Clip
 * @returns {object} object containing correct props for the source tag.
 */
function mapSource(obj) {
    if (!obj || !obj.url) {
        return {};
    }
    const { url } = obj;
    const extension = url.split('.').pop();
    return {
        src: url,
        type: `video/${extension}`
    };
}
/**
 * Gets most optimal source according to container width. The optimal source has enough
 * media width for the placement (e.g. the video placement is 500px, so we need a source
 * of width >= 500px).
 *
 * @param {Array<object>} sourcesArray - Array containing source objects of form { height, width, url }
 * @param {DOMElement} domElement - the containing element for the media
 * @returns {object} single mapped source object of form { src, type }
 */
function getOptimalSource(sourcesArray, domElement) {
    const { width } = domElement.getBoundingClientRect();
    const bestMatchingSource = sourcesArray.reduce((acc, source) => {
        // Use this if it's wide enough, and it's not wider than another contender.
        return source.width >= width && (!acc || source.width < acc.width)
            ? source
            : acc;
    }, null);
    let widestSource;
    if (sourcesArray.length) {
        widestSource = sourcesArray.reduce((acc, source) => (source.width > acc.width ? source : acc), { width: 0, url: sourcesArray[0].url || '' });
    }
    else {
        widestSource = {};
    }
    const source = bestMatchingSource || widestSource;
    return mapSource(source);
}
/**
 * Gets the default version of an asset, for fallbacks.
 *
 * @param {Array<object>} sourcesArray - Array containing source objects of form { height, width, url }
 * @returns {object} single mapped source object of form { src, type }
 */
function getDefaultSource(sourcesArray) {
    const sourceHeights = sourcesArray
        .map((source) => source.height)
        .filter(Boolean);
    if (!sourceHeights.length)
        return {};
    const closestHeight = sourceHeights.reduce((acc, size) => Math.abs(size - PREFERRED_DEFAULT_SIZE) <
        Math.abs(acc - PREFERRED_DEFAULT_SIZE)
        ? size
        : acc);
    return mapSource(sourcesArray.reduce((acc, source) => (source.height === closestHeight ? source : acc), { width: Infinity }));
}
module.exports = {
    getOptimalSource,
    getDefaultSource
};
//# sourceMappingURL=sources-helper.js.map

/***/ }),

/***/ 91783:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { calculateSpacing, getColorToken, getColorStyles } = __webpack_require__(26865);
const Button = __webpack_require__(73730);
const { ButtonIcon } = __webpack_require__(18974);
const ResponsiveClipWrapper = styled.div.withConfig({
    displayName: 'ResponsiveClipWrapper'
}) `
  display: inline-block;
  position: relative;
  width: 100%;
`;
const ResponsiveClipEventLayer = styled.div.withConfig({
    displayName: 'ResponsiveClipEventLayer'
}) `
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2;
  width: 100%;
  height: 100%;
`;
const ResponsiveClipVideoContainer = styled.div.withConfig({
    displayName: 'ResponsiveClipVideoContainer'
}) `
  width: 100%;
  height: 100%;

  video {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
`;
const ResponsiveClipPlayPauseButton = styled(Button.Utility).withConfig({
    displayName: 'ResponsiveClipPlayPauseButton'
}) `
  position: absolute;
  right: ${calculateSpacing(2)};
  bottom: ${calculateSpacing(2)};
  z-index: 3;
  border: unset;
  border-radius: 50%;
  padding: ${calculateSpacing(1)};
  width: ${calculateSpacing(6)};
  height: ${calculateSpacing(6)};
  pointer-events: auto;

  && {
    background-color: rgba(
      ${({ theme }) => getColorToken(theme, 'colors.interactive.base.black', {
    rgbOnly: true
})},
      0.85
    );
  }

  &:focus {
    outline: 0;
    border: unset;
    box-shadow: 0 0 3pt 2pt rgba(94, 158, 214, 1);
  }

  &:hover {
    border: unset;
  }

  svg {
    display: block;

    path {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
    }
  }
  ${ButtonIcon} {
    margin-left: 2px;
    width: auto;
    height: auto;
  }
`;
module.exports = {
    ResponsiveClipWrapper,
    ResponsiveClipEventLayer,
    ResponsiveClipPlayPauseButton,
    ResponsiveClipVideoContainer
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 20017:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    clipAriaLabel: {
        id: 'ResponsiveClip.ClipAriaLabel',
        defaultMessage: 'Play/Pause',
        description: 'ARIA label for responsive clip button'
    },
    clipLabel: {
        id: 'ResponsiveClip.ClipLabel',
        defaultMessage: 'Play/Pause Button',
        description: 'Label for responsive clip button'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 29535:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const get = __webpack_require__(58156);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Breakpoints = __webpack_require__(99906);
const helpers = __webpack_require__(96165);
const LightboxContext = __webpack_require__(82185);
const AspectRatio = __webpack_require__(60448);
const ActionBar = __webpack_require__(72014);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNavigationEvent } = __webpack_require__(14307);
const { Enlarge } = __webpack_require__(24695);
const { BrandIcon, BrandLogo, EnlargeIconWrapper, ResponsiveImageContainer, ResponsiveImagePicture } = __webpack_require__(7228);
/**
 * ResponsiveImage component
 *
 * @param {object} props - React props
 * @param {string} props.altText - Required text description to be added to the image `alt` attribute
 * @param {string} [props.className] - Optional top-level class to add to component
 * @param {string} [props.id] - Optional unique image identification in lightbox context
 * @param {object} [props.imageAttributes] - Optional attributes to add to the img element
 * @param {Function} [props.onAssetLoaded] - Optional function to callback on img.onload
 * @param {object} props.segmentedSources - An object containing split arrays for mobile and desktop, containing source objects.
 * @param {boolean} [props.shouldHoldImageSpace] - Optional boolean to hold image space based on aspect ratio prior to loading - to avoid layout shifts. Requires parent container to have a fixed width for proper calculation.
 * @param {boolean} [props.shouldLoadAsset] - Optional flag indicating we should load the image. Default: TRUE.
 * @param {string} [props.sizes] - Optional image sizes attribute e.g. '100vw' or '(min-width: 769px) 50vw, 100vw'
 * @param {object} props.sources - Transformed urls (with correct ratio and size) to render as sources. Usually these urls are formatted vulcan urls with the correct aspect ratio and size parameters.
 * @param {bool} [props.shouldUseMediumBreakpoint] - Optional. Set to `true` will enable a third medium breakpoint.
 * @param {string} [props.signalType] - Specifying the icon to be displayed.
 * @param {object} [props.actionBarConfig] - Config for Actionbar
 * @param {object} [props.brandDetail] - Contains the brand logo, brand icon and brand name for experiment
 * @returns {ReactElement} <picture>
 */
class ResponsiveImage extends React.Component {
    constructor(props) {
        super(props);
        /**
         * Callback when the `<img>` ref is received. We'll check for image completeness
         * and listen for load if needed.
         *
         * @param {HTMLImageElement} img - a DOM node representing the `<img>`
         * @returns {undefined} undefined
         */
        this.handleImgRef = (img) => {
            this.img = img;
            // ref arguments can potentially be null and we only need the ref if we're
            // being asked to callback when it's loaded
            if (!this.img || !this.props.onAssetLoaded) {
                return;
            }
            // If the image was in cache and is ready to go
            if (this.img.complete) {
                this.onImageLoaded();
                return;
            }
            this.img.addEventListener('load', this.handleImgLoad);
        };
        /**
         * Callback when the `<picture>` ref is received.
         * If the image is not loaded, we'll try to determine the height based
         * on the picture's width and the image aspect ratio and dimensions
         *
         * @param {HTMLImageElement} picture - a DOM node representing the `<picture>`
         * @returns {undefined} undefined
         */
        this.handlePictureRef = (picture) => {
            const getSource = () => {
                if (this.props.segmentedSources) {
                    if (window.innerWidth < Breakpoints.minThresholds.lg) {
                        return this.props.segmentedSources.sm[0];
                    }
                    return this.props.segmentedSources.lg[0];
                }
                return Object.values(this.props.sources).pop();
            };
            const pictureWidth = (picture && picture.offsetWidth) || 0;
            if (pictureWidth > 0 && !this.state.loaded) {
                this.setState({
                    loadingHeight: helpers.calculateLoadingHeight(getSource(), pictureWidth)
                });
            }
        };
        /**
         * Callback when the inner `<img>` completes loading.
         *
         * @returns {undefined} undefined
         */
        this.handleImgLoad = () => {
            this.img.removeEventListener('load', this.handleImgLoad);
            this.onImageLoaded();
        };
        /**
         * Generates the data structure required to create <source> elements.
         *
         * @param {object} segmentedSources - Object containing sources for clips with width, height, & url.
         * @param {object} Breakpoints - Object containing dimensions for different breakpoints.
         * @param {string} sizes - String specifying viewport width.
         * @param {bool} shouldUseMediumBreakpoint - Flag to define whether generate a medium breakpoint.
         *
         * @returns {Array} Array of objects with media, source, and sizes properties.
         */
        this.generateSources = (segmentedSources = {}, Breakpoints = {}, sizes = '', shouldUseMediumBreakpoint = false) => {
            const items = [];
            if (segmentedSources?.sm) {
                items.push({
                    media: `(max-width: ${Breakpoints.maxThresholds.md}px)`,
                    sources: Object.values(segmentedSources.sm),
                    sizes: segmentedSources.sm[0]?.sizes || sizes,
                    srcset: segmentedSources.sm[0]?.srcset
                });
            }
            if (shouldUseMediumBreakpoint) {
                if (segmentedSources?.md) {
                    items.push({
                        media: `(max-width: ${Breakpoints.maxThresholds.lg}px)`,
                        sources: Object.values(segmentedSources.md),
                        sizes: segmentedSources.md[0]?.sizes || sizes,
                        srcset: segmentedSources.md[0]?.srcset
                    });
                }
                if (segmentedSources?.lg) {
                    items.push({
                        media: `(min-width: ${Breakpoints.minThresholds.xl}px)`,
                        sources: Object.values(segmentedSources.lg),
                        sizes: segmentedSources.lg[0]?.sizes || sizes,
                        srcset: segmentedSources.lg[0]?.srcset
                    });
                }
            }
            else if (segmentedSources?.lg) {
                items.push({
                    media: `(min-width: ${Breakpoints.minThresholds.lg}px)`,
                    sources: Object.values(segmentedSources.lg),
                    sizes: segmentedSources.lg[0]?.sizes || sizes,
                    srcset: segmentedSources.lg[0]?.srcset
                });
            }
            return items;
        };
        this.state = { loadingHeight: null, loaded: false };
    }
    componentDidMount() {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ResponsiveImage'
        });
    }
    componentWillUnmount() {
        if (this.img) {
            this.img.removeEventListener('load', this.handleImgLoad);
        }
    }
    onImageLoaded() {
        // Use natural dimensions if defined and fallback to calculated values.
        // Natural dimensions are the true sizes of the image whereas width/height
        // are calculated from styles or attributes on the image.
        const width = this.img.naturalWidth || this.img.width;
        const height = this.img.naturalHeight || this.img.height;
        this.props.onAssetLoaded({
            width,
            height
        });
        this.setState({ loadingHeight: null, loaded: true });
    }
    render() {
        const { id, aspectRatioOverride, altText, className, imageAttributes, itemProp, masterAspectRatio = '', shouldHoldImageSpace = false, shouldRestrictCropping = false, segmentedSources, shouldLoadAsset = true, sizes = '100vw', sources, shouldUseMediumBreakpoint, signalType, actionBarConfig, brandDetail } = this.props;
        const innerClassName = 'responsive-image__image';
        // TODO: optimize the output.
        //
        // If the aspect ratios for sm and lg are the same, then we don't need the full markup
        // with two sources, etc.  we just need a single <img> tag. So the right course here
        // is not to branch on `segmentedSources` but a new variable, `hasBreakpoints`.
        // And if there are no breakpoints, then merge the sources into a single <img>.
        const baseSources = segmentedSources
            ? {
                sm: get(segmentedSources.sm, '0', null),
                lg: get(segmentedSources.lg, '0', null)
            }
            : { sm: Object.values(sources).pop() };
        const legacySources = segmentedSources
            ? []
            : Breakpoints.sizesDescending.map((bp) => sources[bp]).filter(Boolean);
        const items = this.generateSources(segmentedSources, Breakpoints, sizes, shouldUseMediumBreakpoint);
        const altAll = typeof altText !== 'string' ? '' : altText;
        const innerElements = segmentedSources ? (React.createElement(React.Fragment, null,
            items.map(({ media, sources, sizes, srcset }, index) => (React.createElement("source", { key: `${index + 1}`, media: media, srcSet: srcset || helpers.buildSourceSet(sources), sizes: sizes }))),
            baseSources.lg && (React.createElement(ResponsiveImageContainer, { ...imageAttributes, itemProp: itemProp || undefined, alt: altAll, className: innerClassName, ref: this.handleImgRef, src: helpers.encodeImageURI(baseSources.lg.url) })))) : (React.createElement(ResponsiveImageContainer, { ...imageAttributes, itemProp: itemProp || undefined, aspectRatioOverride: aspectRatioOverride, alt: altAll, className: innerClassName, ref: this.handleImgRef, src: helpers.encodeImageURI(baseSources.sm.url), srcSet: helpers.buildSourceSet(legacySources), sizes: sizes }));
        const { loadingHeight, loaded } = this.state;
        const pictureStyle = loadingHeight && !loaded ? { height: `${loadingHeight}px` } : {};
        const trackSnowplowEvent = () => {
            const trackImageUrl = segmentedSources
                ? segmentedSources.lg[0].url
                : sources.sm.url;
            const eventData = {
                type: 'open',
                subject: 'lightbox_gallery_slide',
                items: [
                    {
                        content_id: id,
                        content_type: 'photo',
                        content_url: trackImageUrl || ''
                    }
                ]
            };
            trackNavigationEvent(eventData);
        };
        // If this element `shouldLoadAsset`, then we output the image as normal.
        // Otherwise, we put the output in a `<noscript>`.
        return (React.createElement(LightboxContext.Consumer, null, (context) => {
            const { expandHandler, isInSlides, showEnlargeIcon } = context || {};
            const expandable = isInSlides && isInSlides(id);
            const handleOnClick = () => {
                expandHandler(id);
                trackSnowplowEvent();
            };
            const handlers = expandable
                ? {
                    onClick: handleOnClick
                }
                : {};
            const KeyboardAccessibility = expandable
                ? {
                    tabIndex: '0',
                    role: 'button',
                    onKeyDown: (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            handleOnClick();
                        }
                    }
                }
                : {};
            return (React.createElement(React.Fragment, null,
                shouldHoldImageSpace && (React.createElement(AspectRatio, { shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, breakpoints: Breakpoints, segmentedSources: segmentedSources, masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping },
                    React.createElement(ResponsiveImagePicture, { ...handlers, style: pictureStyle, ref: this.handlePictureRef, isExpandable: expandable, className: classnames(className, 'responsive-image', {
                            'responsive-image--expandable': expandable
                        }), ...KeyboardAccessibility },
                        brandDetail && (React.createElement(React.Fragment, null,
                            brandDetail.brandIcon && (React.createElement(BrandIcon, null,
                                React.createElement("img", { alt: brandDetail.brandName, src: brandDetail.brandIcon }))),
                            brandDetail.brandLogo &&
                                Object.keys(brandDetail.brandLogo).length !== 0 && (React.createElement(BrandLogo, { largeBg: brandDetail.brandLogo.large, smallBg: brandDetail.brandLogo.small })))),
                        actionBarConfig && signalType && (React.createElement(ActionBar.IconWithoutInteraction, { actionButtons: [signalType], actionBarConfig: actionBarConfig })),
                        shouldLoadAsset ? (innerElements) : (React.createElement("noscript", null, innerElements))))),
                !shouldHoldImageSpace && (React.createElement(ResponsiveImagePicture, { ...handlers, style: pictureStyle, ref: this.handlePictureRef, isExpandable: expandable, className: classnames(className, 'responsive-image', {
                        'responsive-image--expandable': expandable
                    }), ...KeyboardAccessibility },
                    shouldLoadAsset ? (innerElements) : (React.createElement(AspectRatio, { shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, breakpoints: Breakpoints, segmentedSources: segmentedSources, masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping },
                        React.createElement("noscript", null, innerElements))),
                    signalType && (React.createElement(ActionBar.IconWithoutInteraction, { actionButtons: [signalType], actionBarConfig: actionBarConfig })),
                    expandable && showEnlargeIcon && (React.createElement(EnlargeIconWrapper, null,
                        React.createElement(Enlarge, null)))))));
        }));
    }
}
const sourcePropType = PropTypes.shape({
    height: PropTypes.number,
    width: PropTypes.number,
    url: PropTypes.string
});
ResponsiveImage.propTypes = {
    actionBarConfig: PropTypes.object,
    altText: PropTypes.string.isRequired,
    aspectRatioOverride: PropTypes.string,
    brandDetail: PropTypes.object,
    className: PropTypes.string,
    id: PropTypes.string,
    imageAttributes: PropTypes.object,
    itemProp: PropTypes.string,
    masterAspectRatio: PropTypes.string,
    onAssetLoaded: PropTypes.func,
    segmentedSources: PropTypes.shape({
        sm: PropTypes.arrayOf(sourcePropType),
        lg: PropTypes.arrayOf(sourcePropType)
    }),
    shouldHoldImageSpace: PropTypes.bool,
    shouldLoadAsset: PropTypes.bool,
    shouldRestrictCropping: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    signalType: PropTypes.string,
    sizes: PropTypes.string,
    sources: PropTypes.shape({
        xxxl: sourcePropType,
        xxl: sourcePropType,
        xl: sourcePropType,
        lg: sourcePropType,
        md: sourcePropType,
        sm: sourcePropType
    })
};
module.exports = ResponsiveImage;
//# sourceMappingURL=ResponsiveImage.js.map

/***/ }),

/***/ 46674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const get = __webpack_require__(58156);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Breakpoints = __webpack_require__(99906);
const helpers = __webpack_require__(96165);
const LightboxContext = __webpack_require__(82185);
const AspectRatio = __webpack_require__(60448);
const ActionBar = __webpack_require__(72014);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNavigationEvent } = __webpack_require__(14307);
const { Enlarge } = __webpack_require__(24695);
const { BrandIcon, BrandLogo, EnlargeIconWrapper, ResponsiveImageContainer, ResponsiveImagePicture } = __webpack_require__(7228);
const BrandDetailComponent = ({ brandDetail }) => {
    if (!brandDetail)
        return null;
    return (React.createElement(React.Fragment, null,
        brandDetail.brandIcon && (React.createElement(BrandIcon, null,
            React.createElement("img", { alt: brandDetail.brandName, src: brandDetail.brandIcon }))),
        brandDetail.brandLogo &&
            Object.keys(brandDetail.brandLogo).length !== 0 && (React.createElement(BrandLogo, { largeBg: brandDetail.brandLogo.large, smallBg: brandDetail.brandLogo.small }))));
};
// Extract action bar rendering to a separate component
const ActionBarComponent = ({ actionBarConfig, signalType }) => {
    if (!actionBarConfig || !signalType)
        return null;
    return (React.createElement(ActionBar.IconWithoutInteraction, { actionButtons: [signalType], actionBarConfig: actionBarConfig }));
};
/**
 * ResponsiveImageNext component
 *
 * @param {object} props - React props
 * @param {string} [props.aspectRatioOverride] - Optional attributes to add to the img aspect ratio
 * @param {string} props.altText - Required text description to be added to the image `alt` attribute
 * @param {string} [props.className] - Optional top-level class to add to component
 * @param {string} [props.id] - Optional unique image identification in lightbox context
 * @param {object} [props.imageAttributes] - Optional attributes to add to the img element
 * @param {string} [props.itemProp] - Optional string value to pass to the image
 * @param {string} [props.masterAspectRatio] - aspect ratio for image
 * @param {bool} [props.shouldHoldImageSpace] - Optional for image
 * @param {bool} [props.shouldRestrictCropping] - Optional for image
 * @param {Function} [props.onAssetLoaded] - Optional function to callback on img.onload
 * @param {object} props.segmentedSources - An object containing split arrays for mobile and desktop, containing source objects.
 * @param {string} [props.sizes] - Optional image sizes attribute e.g. '100vw' or '(min-width: 769px) 50vw, 100vw'
 * @param {object} props.sources - Transformed urls (with correct ratio and size) to render as sources. Usually these urls are formatted vulcan urls with the correct aspect ratio and size parameters.
 * @param {bool} [props.shouldUseMediumBreakpoint] - Optional. Set to `true` will enable a third medium breakpoint.
 * @param {string} [props.signalType] - Specifying the icon to be displayed.
 * @param {object} [props.actionBarConfig] - Config for Actionbar
 * @param {object} [props.brandDetail] - Contains the brand logo, brand icon and brand name for experiment
 * @param {bool} [props.shouldEagerLoad] - props for eagerly image load
 * @returns {ReactElement} <picture>
 */
const ResponsiveImageNext = ({ id, aspectRatioOverride, altText, className, imageAttributes, itemProp, masterAspectRatio = '', shouldHoldImageSpace = false, shouldRestrictCropping = false, segmentedSources, sizes = '100vw', sources, shouldUseMediumBreakpoint, signalType, actionBarConfig, brandDetail, shouldEagerLoad }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ResponsiveImageNext'
        });
    }, []);
    const contextData = React.useContext(LightboxContext);
    const { expandHandler, isInSlides, showEnlargeIcon } = contextData || {};
    /**
     *  Generates the data structure required to create <source> elements.
     *
     * @param {object} segmentedSources - Object containing sources for clips with width, height, & url.
     * @param {object} Breakpoints - Object containing dimensions for different breakpoints.
     * @param {string} sizes - String specifying viewport width.
     * @param {bool} shouldUseMediumBreakpoint - Flag to define whether generate a medium breakpoint.
     * @returns {Array} Array of objects with media, source, and sizes properties.
     */
    const generateSources = (segmentedSources = {}, Breakpoints = {}, sizes = '', shouldUseMediumBreakpoint = false) => {
        const items = [];
        if (segmentedSources?.sm) {
            items.push({
                media: `(max-width: ${Breakpoints.maxThresholds.md}px)`,
                sources: Object.values(segmentedSources.sm),
                sizes: segmentedSources.sm[0]?.sizes || sizes,
                srcset: segmentedSources.sm[0]?.srcset
            });
        }
        if (shouldUseMediumBreakpoint) {
            if (segmentedSources?.md) {
                items.push({
                    media: `(max-width: ${Breakpoints.maxThresholds.lg}px)`,
                    sources: Object.values(segmentedSources.md),
                    sizes: segmentedSources.md[0]?.sizes || sizes,
                    srcset: segmentedSources.md[0]?.srcset
                });
            }
            if (segmentedSources?.lg) {
                items.push({
                    media: `(min-width: ${Breakpoints.minThresholds.xl}px)`,
                    sources: Object.values(segmentedSources.lg),
                    sizes: segmentedSources.lg[0]?.sizes || sizes,
                    srcset: segmentedSources.lg[0]?.srcset
                });
            }
        }
        else if (segmentedSources?.lg) {
            items.push({
                media: `(min-width: ${Breakpoints.minThresholds.lg}px)`,
                sources: Object.values(segmentedSources.lg),
                sizes: segmentedSources.lg[0]?.sizes || sizes,
                srcset: segmentedSources.lg[0]?.srcset
            });
        }
        return items;
    };
    const innerClassName = 'responsive-image__image';
    const loadingAttr = shouldEagerLoad ? 'eager' : 'lazy';
    const altAll = typeof altText !== 'string' ? '' : altText;
    const baseSources = segmentedSources
        ? {
            sm: get(segmentedSources.sm, '0', null),
            lg: get(segmentedSources.lg, '0', null)
        }
        : { sm: Object.values(sources).pop() };
    const legacySources = segmentedSources
        ? []
        : Breakpoints.sizesDescending.map((bp) => sources[bp]).filter(Boolean);
    const items = generateSources(segmentedSources, Breakpoints, sizes, shouldUseMediumBreakpoint);
    const innerElements = segmentedSources ? (React.createElement(React.Fragment, null,
        items.map(({ media, sources, sizes, srcset }, index) => (React.createElement("source", { key: `${index + 1}`, media: media, srcSet: srcset || helpers.buildSourceSet(sources), sizes: sizes }))),
        baseSources.lg && (React.createElement(ResponsiveImageContainer, { ...imageAttributes, itemProp: itemProp || undefined, alt: altAll, loading: loadingAttr, className: innerClassName, src: helpers.encodeImageURI(baseSources.lg.url) })))) : (React.createElement(ResponsiveImageContainer, { ...imageAttributes, itemProp: itemProp || undefined, aspectRatioOverride: aspectRatioOverride, alt: altAll, loading: loadingAttr, className: innerClassName, src: helpers.encodeImageURI(baseSources.sm.url), srcSet: helpers.buildSourceSet(legacySources), sizes: sizes }));
    const trackSnowplowEvent = () => {
        const trackImageUrl = segmentedSources
            ? segmentedSources.lg[0].url
            : sources.sm.url;
        const eventData = {
            type: 'open',
            subject: 'lightbox_gallery_slide',
            items: [
                {
                    content_id: id,
                    content_type: 'photo',
                    content_url: trackImageUrl || ''
                }
            ]
        };
        trackNavigationEvent(eventData);
    };
    const expandable = isInSlides && isInSlides(id);
    const handleOnClick = () => {
        expandHandler(id);
        trackSnowplowEvent();
    };
    const interactionProps = expandable
        ? {
            onClick: handleOnClick,
            tabIndex: '0',
            role: 'button',
            onKeyDown: (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleOnClick();
                }
            }
        }
        : {};
    const createResponsiveImagePicture = (withAspectRatio = false) => {
        const pictureElement = (React.createElement(ResponsiveImagePicture, { ...interactionProps, isExpandable: expandable, className: classnames(className, 'responsive-image', {
                'responsive-image--expandable': expandable
            }) }, withAspectRatio ? (React.createElement(React.Fragment, null,
            React.createElement(BrandDetailComponent, { brandDetail: brandDetail }),
            React.createElement(ActionBarComponent, { actionBarConfig: actionBarConfig, signalType: signalType }),
            innerElements)) : (React.createElement(React.Fragment, null,
            innerElements,
            React.createElement(ActionBarComponent, { actionBarConfig: actionBarConfig, signalType: signalType }),
            expandable && showEnlargeIcon && (React.createElement(EnlargeIconWrapper, null,
                React.createElement(Enlarge, null)))))));
        if (withAspectRatio) {
            return (React.createElement(AspectRatio, { shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, breakpoints: Breakpoints, segmentedSources: segmentedSources, masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping }, pictureElement));
        }
        return pictureElement;
    };
    return shouldHoldImageSpace
        ? createResponsiveImagePicture(true)
        : createResponsiveImagePicture(false);
};
BrandDetailComponent.propTypes = {
    brandDetail: PropTypes.object
};
ActionBarComponent.propTypes = {
    actionBarConfig: PropTypes.object,
    signalType: PropTypes.string
};
const sourcePropType = PropTypes.shape({
    height: PropTypes.number,
    width: PropTypes.number,
    url: PropTypes.string,
    srcset: PropTypes.string,
    sizes: PropTypes.string
});
ResponsiveImageNext.propTypes = {
    actionBarConfig: PropTypes.object,
    altText: PropTypes.string.isRequired,
    aspectRatioOverride: PropTypes.string,
    brandDetail: PropTypes.object,
    className: PropTypes.string,
    id: PropTypes.string,
    imageAttributes: PropTypes.object,
    itemProp: PropTypes.string,
    masterAspectRatio: PropTypes.string,
    onAssetLoaded: PropTypes.func,
    segmentedSources: PropTypes.shape({
        sm: PropTypes.arrayOf(sourcePropType),
        lg: PropTypes.arrayOf(sourcePropType),
        md: PropTypes.arrayOf(sourcePropType)
    }),
    shouldEagerLoad: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldRestrictCropping: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    signalType: PropTypes.string,
    sizes: PropTypes.string,
    sources: PropTypes.shape({
        xxxl: sourcePropType,
        xxl: sourcePropType,
        xl: sourcePropType,
        lg: sourcePropType,
        md: sourcePropType,
        sm: sourcePropType
    })
};
module.exports = ResponsiveImageNext;
//# sourceMappingURL=ResponsiveImageNext.js.map

/***/ }),

/***/ 96165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getFirstTruthyValue } = __webpack_require__(82692);
function encodeImageURI(url = '') {
    let imageOverlayWarning;
    const splitUrl = url.split('/');
    const imageName = splitUrl.pop();
    const hasOverlayParams = imageName.split('?overlay=');
    if (hasOverlayParams.length > 1) {
        imageOverlayWarning = hasOverlayParams[1];
    }
    const encodeImageName = encodeURI(hasOverlayParams[0]);
    const imageUri = [...splitUrl, encodeImageName]
        .join('/')
        .replace(/,/g, '%2C');
    if (imageOverlayWarning) {
        return `${imageUri}?overlay=${imageOverlayWarning}`;
    }
    return imageUri;
}
/**
 * Accepts an array of source objects, with keys { width, url }, and returns a
 * formatted `srcset` string value.
 *
 * @param {Array<object>} sources - array of { width, url } objects
 * @returns {string} srcset
 */
function buildSourceSet(sources) {
    // following code will return srcset when segmentedSources are not available
    // it uses legacySources
    const source = getFirstTruthyValue(sources);
    if (source && source.srcset) {
        return source.srcset;
    }
    return sources
        .filter((source) => source && source.width)
        .reduce((srcset, source) => {
        // We encode commas, because Vulcan uses them in URL parameters, but they're also
        // a delimiter for the `srcset` attribute.
        srcset.push(`${encodeImageURI(source.url)} ${source.width}w`);
        return srcset;
    }, [])
        .join(', ');
}
function calculateLoadingHeight(source, pictureWidth) {
    if (!source)
        return 0;
    const { aspectRatio = 'master' } = source;
    let ratio;
    if (aspectRatio.includes(':')) {
        const [width, height] = aspectRatio.split(':');
        ratio = width / height;
    }
    else if (source.height && source.width) {
        const { width, height } = source;
        ratio = width / height;
    }
    else {
        return 0;
    }
    return Math.round(pictureWidth / ratio);
}
module.exports = {
    buildSourceSet,
    calculateLoadingHeight,
    encodeImageURI
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 43608:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(29535);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7228:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled } = __webpack_require__(92168);
const { calculateSpacing, minScreen, getColorToken } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const fitImageInAspectRatio = (aspectRatioOverride) => aspectRatioOverride &&
    css `
    ${minScreen(BREAKPOINTS.md)} {
      object-fit: cover;
      aspect-ratio: ${aspectRatioOverride};
    }
  `;
const ResponsiveImagePicture = styled.picture.withConfig({
    displayName: 'ResponsiveImagePicture'
}) `
  display: inline-block;
  position: relative;
  width: fill-available;
  ${({ isExpandable }) => (isExpandable ? `cursor: zoom-in` : ``)}
`;
const ResponsiveImageContainer = styled.img.withConfig({
    displayName: 'ResponsiveImageContainer'
}) `
  ${({ aspectRatioOverride }) => fitImageInAspectRatio(aspectRatioOverride)}
`;
const EnlargeIconWrapper = styled.div.withConfig({
    displayName: 'EnlargeIconWrapper'
}) `
  display: flex;
  position: absolute;
  top: ${calculateSpacing(2)};
  right: ${calculateSpacing(2)};
  align-items: center;
  justify-content: center;
  width: ${calculateSpacing(3.5)};
  height: ${calculateSpacing(3.5)};
  line-height: 0;

  & {
    background-color: rgba(
      ${getColorToken('colors.interactive.base.black', { rgbOnly: true })},
      0.4
    );
  }

  .icon-enlarge path {
    fill: ${getColorToken('colors.interactive.base.white')};
  }
`;
const BrandIcon = styled.span.withConfig({
    displayName: 'BrandIcon'
}) `
  position: absolute;
  right: ${calculateSpacing(0.5)};
  bottom: ${calculateSpacing(0.5)};
  background: transparent;
  width: ${calculateSpacing(3)};
  height: ${calculateSpacing(3)};

  img {
    vertical-align: baseline;
  }
`;
const BrandLogo = styled(BrandIcon).withConfig({
    displayName: 'BrandLogo'
}) `
  background: url(${({ smallBg }) => smallBg}) no-repeat right;
  width: 100%;
  height: ${calculateSpacing(2)};

  ${minScreen(BREAKPOINTS.lg)} {
    background: url(${({ largeBg }) => largeBg}) no-repeat right;
    height: ${calculateSpacing(3)};
  }
`;
module.exports = {
    BrandIcon,
    BrandLogo,
    EnlargeIconWrapper,
    ResponsiveImageContainer,
    ResponsiveImagePicture
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 51330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
const { RubricWrapper, RubricIcon, RubricLink, RubricName } = __webpack_require__(6613);
/**
 * Rubric component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add.
 * @param {Function} [props.clickHandler] - called when user clicks on link
 * @param {string} [props.dangerousIcon] - Optional, icon displayed alongside name
 * @param {string} [props.fullPageTheme] - Optional theme prop - standard or inverted, standard by default
 * @param {boolean} [props.hideRubricLink] - [`bool`] Optional. Set `true` for hide rubrics link, set `false` for show rubrics link.
 * @param {string} props.name - Required, name value to display with optional url and icon
 * @param {string} [props.url] - Optional, url string
 * @param {object} [props.variations] - Optional. Variation properties used in rendering the component.
 * @param {boolean} [props.variations.displayLink] - Optional. set to `false` if rubric needs to be rendered as text/without hyperlinked
 * @param {boolean} [props.variations.hasBackground] - Optional. Set to `true` if rubric will have a background.
 * @param {boolean} [props.variations.isDiscovery] - Optional. Set to `true` if rubric will have use discovery tokens.
 * @param {boolean} [props.variations.isInverted] - Optional. Set to `true` if rubric will have inverted colors.
 * @param {boolean} [props.variations.hasSponsor] - Optional. Set to `true` if sponsor name will be displayed next to rubric
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
const Rubric = ({ className, clickHandler, dangerousIcon, fullPageTheme, hideRubricLink = false, name, isSpecial, url, variations = {
    displayLink: true,
    hasBackground: false,
    isDiscovery: false,
    isInverted: false
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Rubric',
            variation: variationName
        });
    }, [variationName]);
    const isInverted = variations.isInverted || fullPageTheme === 'inverted';
    const { displayLink, hasBackground, isDiscovery } = variations;
    if (!name) {
        return null;
    }
    return (React.createElement(RubricWrapper, { className: classnames('rubric', {
            'rubric--with-bg': variations.hasBackground,
            'rubric--discovery': variations.isDiscovery
        }, className), hasBackground: hasBackground, isDiscovery: isDiscovery },
        dangerousIcon && (React.createElement(RubricIcon, { dangerouslySetInnerHTML: { __html: dangerousIcon }, hasBackground: hasBackground, isDiscovery: isDiscovery, isInverted: isInverted })),
        !hideRubricLink && displayLink && url ? (React.createElement(RubricLink, { className: "rubric__link", hasBackground: hasBackground, href: url, isInverted: isInverted, onClick: clickHandler },
            React.createElement(RubricName, { className: "rubric__name", dangerouslySetInnerHTML: { __html: name }, isSpecial: isSpecial }))) : (React.createElement(RubricName, { className: "rubric__name", dangerouslySetInnerHTML: { __html: name }, isInverted: isInverted, isSpecial: isSpecial }))));
};
Rubric.propTypes = {
    className: PropTypes.string,
    clickHandler: PropTypes.func,
    dangerousIcon: PropTypes.string,
    fullPageTheme: PropTypes.string,
    hideRubricLink: PropTypes.bool,
    isSpecial: PropTypes.bool,
    name: PropTypes.string.isRequired,
    url: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        displayLink: PropTypes.bool,
        hasBackground: PropTypes.bool,
        isDiscovery: PropTypes.bool,
        isInverted: PropTypes.bool,
        hasSponsor: PropTypes.bool
    })
};
module.exports = Rubric;
//# sourceMappingURL=Rubric.js.map

/***/ }),

/***/ 34187:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(53933);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6613:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const RubricName = styled.span.withConfig({ displayName: 'RubricName' }) `
  ${({ isInverted, theme }) => isInverted &&
    css `
      ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-texture')};
    `}

  ${({ isSpecial, theme }) => isSpecial &&
    css `
      ${getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
    `}
  ${({ isSpecial, theme }) => isSpecial &&
    css `
      ${getTypographyStyles(theme, 'typography.definitions.foundation.title-secondary')}
    `}
`;
const RubricLink = styled.a.withConfig({ displayName: 'RubricLink' }) `
  display: inline-block;
  vertical-align: middle;
  text-decoration: none;
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-signature')};
  ${({ hasBackground, isInverted, theme }) => (hasBackground || isInverted) &&
    css `
      ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-texture')};
    `}

  &:hover {
    text-decoration: underline;
  }
`;
RubricLink.displayName = 'RubricLink';
const RubricIcon = styled.span.withConfig({ displayName: 'RubricIcon' }) `
  display: inline-block;
  margin-right: ${calculateSpacing(1)};
  vertical-align: middle;

  svg {
    ${({ theme }) => getColorStyles(theme, 'fill', 'colors.consumption.lead.standard.context-signature')};
    vertical-align: middle;

    ${({ hasBackground, theme }) => hasBackground &&
    css `
        ${getColorStyles(theme, 'fill', 'colors.consumption.lead.standard.divider')};
      `}

    ${({ isInverted, theme }) => isInverted &&
    css `
        ${getColorStyles(theme, 'fill', 'colors.consumption.lead.standard.context-texture')};
      `}
  }
`;
const RubricWrapper = styled.div.withConfig({ displayName: 'RubricWrapper' }) `
  display: inline-block;

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};

  ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-signature')};

  ${({ hasBackground, theme }) => hasBackground
    ? css `
          ${getColorStyles(theme, 'background-color', 'colors.consumption.lead.standard.context-signature')};
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-texture')};
          padding: ${calculateSpacing(1)};
        `
    : ''}

  ${({ isDiscovery, theme }) => isDiscovery
    ? css `
          background-color: transparent;
          ${getColorStyles(theme, 'color', 'colors.discovery.body.white.context-signature')};
          padding: unset;
        `
    : ''}

  ${({ hasBackground, isDiscovery, theme }) => isDiscovery && hasBackground
    ? css `
          ${getColorStyles(theme, 'background-color', 'colors.discovery.body.white.context-signature')};
          ${getColorStyles(theme, 'color', 'colors.discovery.body.white.context-texture')};
          padding: ${calculateSpacing(1)};
        `
    : ''}
`;
module.exports = {
    RubricName,
    RubricLink,
    RubricIcon,
    RubricWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 53933:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const Rubric = __webpack_require__(51330);
Rubric.Item = asVariation(Rubric, 'Item', {
    displayLink: true,
    hasBackground: false,
    isDiscovery: false
});
Rubric.Inverted = asVariation(Rubric, 'Inverted', {
    displayLink: true,
    isInverted: true
});
Rubric.Card = asVariation(Rubric, 'Card', {
    displayLink: true,
    hasBackground: true,
    isDiscovery: false
});
Rubric.InvertedCard = asVariation(Rubric, 'InvertedCard', {
    displayLink: true,
    hasBackground: true,
    isDiscovery: false,
    isInverted: true
});
Rubric.DiscoveryItem = asVariation(Rubric, 'DiscoveryItem', {
    displayLink: true,
    hasBackground: false,
    isDiscovery: true
});
Rubric.DiscoveryCard = asVariation(Rubric, 'DiscoveryCard', {
    displayLink: true,
    hasBackground: true,
    isDiscovery: true
});
Rubric.ItemAsText = asVariation(Rubric, 'ItemAsText', {
    displayLink: false,
    hasBackground: false,
    isDiscovery: false
});
module.exports = Rubric;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 3833:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const prop_types_1 = __importDefault(__webpack_require__(5556));
const react_1 = __importDefault(__webpack_require__(96540));
const styles_1 = __webpack_require__(65344);
/**
 * SkeletonScreen component
 *
 * @param {object} props - React props
 * @param {string} [props.animation] - Optional value to indicate the existence and type of the animation. (default: 'pulse')
 * @param {string} [props.children] - Optional React children
 * @param {string} [props.height] - Optional height for the component. (default: '100px')
 * @param {string} [props.variant] - Optional variant/type of the skeleton screen to use. (default: 'box')
 * @param {string} [props.width] - Optional width for the component. (default: 'auto')
 *
 * @returns {ReactElement} <div>
 */
const SkeletonScreen = ({ animation = 'pulse', children, height = '100px', variant = 'box', width = 'auto', ...rest }) => {
    if (!variant)
        return null;
    return (react_1.default.createElement(styles_1.SkeletonScreenWrapper, { "data-testid": "skeleton-screen-wrapper", animation: animation, height: height, width: width, variant: variant, ...rest }, children));
};
SkeletonScreen.propTypes = {
    animation: prop_types_1.default.oneOf([false, 'pulse']),
    children: prop_types_1.default.node,
    height: prop_types_1.default.string,
    variant: prop_types_1.default.oneOf(['box', 'circle']),
    width: prop_types_1.default.string
};
exports["default"] = SkeletonScreen;
//# sourceMappingURL=SkeletonScreen.js.map

/***/ }),

/***/ 90340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(3833);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 65344:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkeletonScreenWrapper = void 0;
const styled_components_1 = __importStar(__webpack_require__(92168));
const { getColorToken } = __webpack_require__(26865);
const getBorderRadiusByVariant = (variant) => {
    const borderRadiusValues = {
        circle: '50%',
        box: '0'
    };
    return borderRadiusValues[variant] || '0';
};
const getInitialDimensions = (variant) => {
    const values = {
        circle: {
            width: '50px',
            height: '50px'
        },
        box: {
            width: '100px',
            height: '100px'
        }
    };
    return values[variant] || '0';
};
const animationTypes = {
    pulse: (0, styled_components_1.keyframes) `
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`
};
const SkeletonScreenWrapper = styled_components_1.default.div.withConfig({
    displayName: 'SkeletonScreenWrapper'
}) `
  ${({ height, variant, width }) => {
    const dimensions = getInitialDimensions(variant);
    return `height: ${height || dimensions.height}; width: ${width || dimensions.width};`;
}}
  ${({ variant }) => `border-radius: ${getBorderRadiusByVariant(variant)};`}
  display: block;
  ${({ variant, theme }) => variant &&
    `background-color: ${getColorToken(theme, 'colors.interactive.base.light')};`}
  ${({ animation = false }) => animation &&
    (0, styled_components_1.css) `
      transform: scale(1, 0.75);
      animation: 1.5s ease-in-out 0.5s infinite normal none running
        ${animationTypes[animation]};
      margin-bottom: 0;
    `};

  &:empty::before {
    content: '${'\\00a0'}';
  }
`;
exports.SkeletonScreenWrapper = SkeletonScreenWrapper;
SkeletonScreenWrapper.defaultProps = {
    backgroundColor: 'colors.interactive.base.light'
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 31481:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const stickyPosition = __webpack_require__(46886);
const isEqual = __webpack_require__(2404);
const throttle = __webpack_require__(7350);
const some = __webpack_require__(42426);
const { TrackComponentChannel } = __webpack_require__(78788);
const { StickyBoxWrapper, StickyBoxPrimary, StickyBoxPlaceholder } = __webpack_require__(77307);
/* globals MutationObserver */
class StickyBox extends React.Component {
    /**
     * Constructor
     *
     * @param {object} props - passed props
     * @returns {undefined} undefined
     */
    constructor(props) {
        super(props);
        /**
         * Fires onChange event if prop exists
         *
         * @returns {undefined} undefined
         */
        this._fireOnChange = () => {
            const { onChange } = this.props;
            if (onChange) {
                onChange(this.isSticky);
            }
        };
        /**
         * Configures sticky behavior polyfill based on props and instantiates listeners to enable sticking to begin
         *
         * @returns {undefined} undefined
         */
        this._enableSticking = () => {
            const { onChange, shouldComputeWidth } = this.props;
            // if onChange handler exists, tells stickyPosition to always use polyfill
            // otherwise fallback to whatever forcePolyfill is set as
            const shouldForcePolyfill = this.props.shouldForcePolyfill || !!onChange;
            const isSupported = shouldForcePolyfill ? false : undefined;
            const { stickyBoxPrimaryNode } = this;
            this.sticky = stickyPosition({
                primary: stickyBoxPrimaryNode,
                placeholder: this.stickyBoxPlaceholder,
                wrapper: this.stickyBoxWrapper,
                computeWidth: shouldComputeWidth,
                isSupported
            });
            // to detect whether or not sticky has begun
            this.isSticky = stickyBoxPrimaryNode.style.position === 'fixed';
            this._fireOnChange();
            this.observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    this.isSticky = mutation.target.style.position === 'fixed';
                });
                this._fireOnChange();
            });
            this.observer.observe(stickyBoxPrimaryNode, {
                attributes: true,
                attributeFilter: ['style']
            });
        };
        this.handleScroll = throttle(this.handleScroll.bind(this), 150);
        this.state = {
            hasMoved: true,
            isIntersecting: false
        };
    }
    /**
     * ComponentDidMount
     *
     * @returns {undefined} undefined
     */
    componentDidMount() {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'StickyBox'
        });
        this._enableSticking();
        window.addEventListener('scroll', this.handleScroll);
    }
    shouldComponentUpdate(nextProps, nextState) {
        return !isEqual(this.props, nextProps) || !isEqual(this.state, nextState);
    }
    /**
     * Component Will Unmount
     *
     * @returns {undefined} undefined
     */
    componentWillUnmount() {
        this.sticky.destroy();
        this.observer.disconnect();
        window.removeEventListener('scroll', this.handleScroll);
    }
    handleScroll() {
        const node = this.stickyBoxWrapper;
        const { fadingOffset } = this.props;
        this.setState({
            hasMoved: this.hasMoved(node),
            isIntersecting: this.anyIntersecting(node, this.fullWidthElements(), fadingOffset)
        });
    }
    hasMoved(node) {
        const styleTop = parseFloat(window.getComputedStyle(node).top);
        const clientTop = node.getBoundingClientRect().top;
        return Math.abs(clientTop - styleTop) >= 1;
    }
    anyIntersecting(node, elements, verticlaOffset) {
        const boxRect = node.getBoundingClientRect();
        const withOffset = {
            left: boxRect.left,
            right: boxRect.right,
            top: boxRect.top - verticlaOffset,
            bottom: boxRect.bottom + verticlaOffset
        };
        return some(elements, (element) => this.areRectanglesIntersecting(withOffset, element.getBoundingClientRect()));
    }
    areRectanglesIntersecting(a, b) {
        return (a.top <= b.bottom &&
            b.top <= a.bottom &&
            a.left <= b.right &&
            b.left <= a.right);
    }
    fullWidthElements() {
        const { fullWidthSelector } = this.props;
        return fullWidthSelector && document.querySelectorAll(fullWidthSelector);
    }
    render() {
        const { children, className, interlude, isExpanded, tagName, shouldFadeOnMove, hasStickyBoxIndexPosition, hasAdjacentStickyVideo } = this.props;
        const { hasMoved, isIntersecting } = this.state;
        const hideBox = isIntersecting || (shouldFadeOnMove && hasMoved);
        const classes = classnames('sticky-box', className);
        return (React.createElement(StickyBoxWrapper, { as: tagName, className: classes, ref: (ref) => {
                this.stickyBoxWrapper = ref;
            }, isHidden: hideBox, hasStickyBoxIndexPosition: hasStickyBoxIndexPosition, isExpanded: isExpanded, hasAdjacentStickyVideo: hasAdjacentStickyVideo, hasInterlude: interlude },
            React.createElement(StickyBoxPrimary, { className: "sticky-box__primary", ref: (ref) => {
                    this.stickyBoxPrimaryNode = ref;
                } }, children),
            React.createElement(StickyBoxPlaceholder, { ref: (ref) => {
                    this.stickyBoxPlaceholder = ref;
                } })));
    }
}
StickyBox.propTypes = {
    children: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    className: PropTypes.string,
    fadingOffset: PropTypes.number,
    fullWidthSelector: PropTypes.string,
    hasAdjacentStickyVideo: PropTypes.bool,
    hasStickyBoxIndexPosition: PropTypes.bool,
    interlude: PropTypes.oneOfType([PropTypes.object, PropTypes.number]),
    isExpanded: PropTypes.bool,
    onChange: PropTypes.func,
    shouldComputeWidth: PropTypes.bool,
    shouldFadeOnMove: PropTypes.bool,
    shouldForcePolyfill: PropTypes.bool,
    tagName: PropTypes.string
};
StickyBox.defaultProps = {
    className: '',
    fadingOffset: 20,
    fullWidthSelector: '',
    hasAdjacentStickyVideo: false,
    isExpanded: false,
    shouldComputeWidth: true,
    shouldFadeOnMove: false,
    shouldForcePolyfill: false,
    tagName: 'div'
};
module.exports = StickyBox;
//# sourceMappingURL=StickyBox.js.map

/***/ }),

/***/ 28433:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(31481);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 77307:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { ZINDEX_MAP } = __webpack_require__(96472);
const { calculateSpacing } = __webpack_require__(26865);
const { SummaryCollectionGridItem } = __webpack_require__(4534);
const StickyBoxWrapper = styled.div.withConfig({
    displayName: 'StickyBoxWrapper'
}) `
  position: sticky;
  transition: opacity 0.1s;
  opacity: 1;
  ${({ hasStickyBoxIndexPosition }) => hasStickyBoxIndexPosition && `z-index:${ZINDEX_MAP.navFixed};`}

  ${({ isHidden }) => isHidden &&
    `
          opacity: 0;
          pointer-events: none;

          &:focus-within {
            opacity: 1;
            pointer-events: auto;
          }
        `}

  ${({ isExpanded }) => isExpanded && 'display: inline-block;'}

  @media print {
    display: none;
  }

  ${({ hasAdjacentStickyVideo, hasInterlude }) => {
    const top = hasInterlude ? 10 : 18;
    return `.grid-layout__aside && {
      top: ${calculateSpacing(hasAdjacentStickyVideo ? 28 : top)};
      margin-bottom: ${calculateSpacing(5)};
    }`;
}}

  .river__chunk-aside &,
  ${SummaryCollectionGridItem} & {
    top: ${calculateSpacing(16)};
    margin-bottom: ${calculateSpacing(4)};
  }
`;
const StickyBoxPrimary = styled.div.withConfig({
    displayName: 'StickyBoxPrimary'
}) ``;
const StickyBoxPlaceholder = styled.div.withConfig({
    displayName: 'StickyBoxPlaceholder'
}) ``;
module.exports = {
    StickyBoxWrapper,
    StickyBoxPrimary,
    StickyBoxPlaceholder
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 8833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isNumber = __webpack_require__(98023);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(95748)/* ["default"] */ .A);
const { asConfiguredComponent } = __webpack_require__(12892);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNavigationEvent } = __webpack_require__(14307);
const { TagCloudWrapper, TagCloudSectionHeader, TagCloudName, TagCloudLink } = __webpack_require__(64050);
/**
 * TagCloud component
 *
 * @param {string} [className] - Optional top-level class to add
 * @param {boolean} [hasFilledBackground] - Optional background style on tags, defaults to false
 * @param {boolean} [hasRoundBorder] - Optional rounded border on tags, defaults to false
 * @param {number} [maxCountTags] - Optional max count tags for render
 * @param {string} [sectionHeader] - Optional headline for tag cloud (ie: 'Keywords')
 * @param {boolean} [shouldIncreaseTagLinkBottomSpacing] - Optional prop to increase bottom spacing for tag link
 * @param {boolean} [shouldTagLinkHaveFullLengthInMobile] - Optional prop to make tag link one per line in mobile view
 * @param {boolean} [shouldUseInteractiveBrandColor] - Optional boolean to conditionally apply brand color
 * @param {boolean} [shouldLink] - If true, tags render as <a>
 * @param {Array} tags - Required tag data to be used to populate the tag cloud
 * @param {string} [dividerColor] - Optional prop to get divider color for article page from copilot
 *
 * @returns {ReactElement} <div>
 */
const TagCloud = ({ className, hasFilledBackground = false, hasBorderBottom = true, hasBorderTop = true, hasRoundBorder = false, maxCountTags = null, sectionHeader, shouldIncreaseTagLinkBottomSpacing = false, shouldTagLinkHaveFullLengthInMobile = false, shouldUseInteractiveBrandColor = false, shouldLink = true, dividerColor, tags }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'TagCloud'
        });
    }, []);
    let maxCount = 0;
    if (tags && tags.length) {
        maxCount = isNumber(maxCountTags) ? maxCountTags : tags.length;
    }
    const { formatMessage } = useIntl();
    const trackSnowplowEvent = (tagItem) => {
        const eventData = {
            type: 'click',
            label: tagItem.tag || tagItem.dangerousHed,
            subject: 'tag',
            placement: 'content_footer'
        };
        trackNavigationEvent(eventData);
    };
    return (maxCount > 0 && (React.createElement(TagCloudWrapper, { "data-testid": "TagCloudWrapper", className: className, hasBorderTop: hasBorderTop, hasBorderBottom: hasBorderBottom, hasRoundBorder: hasRoundBorder, shouldTagLinkHaveFullLengthInMobile: shouldTagLinkHaveFullLengthInMobile, dividerColor: dividerColor },
        sectionHeader !== '' && (React.createElement(TagCloudSectionHeader, null, sectionHeader || formatMessage(translations.sectionHeader))),
        tags.slice(0, maxCount).map((item) => {
            const tag = item.tag || item.dangerousHed;
            return item.url && shouldLink ? (React.createElement(TagCloudLink, { key: tag, href: item.url, hasFilledBackground: hasFilledBackground, shouldUseInteractiveBrandColor: shouldUseInteractiveBrandColor, hasRoundBorder: hasRoundBorder, shouldIncreaseTagLinkBottomSpacing: shouldIncreaseTagLinkBottomSpacing, onClick: () => trackSnowplowEvent(item) },
                React.createElement(TagCloudName, { dangerouslySetInnerHTML: { __html: tag } }))) : (React.createElement(TagCloudName, { key: tag, dangerouslySetInnerHTML: { __html: tag } }));
        }))));
};
TagCloud.propTypes = {
    className: PropTypes.string,
    dividerColor: PropTypes.string,
    hasBorderBottom: PropTypes.bool,
    hasBorderTop: PropTypes.bool,
    hasFilledBackground: PropTypes.bool,
    hasRoundBorder: PropTypes.bool,
    maxCountTags: PropTypes.number,
    sectionHeader: PropTypes.string,
    shouldIncreaseTagLinkBottomSpacing: PropTypes.bool,
    shouldLink: PropTypes.bool,
    shouldTagLinkHaveFullLengthInMobile: PropTypes.bool,
    shouldUseInteractiveBrandColor: PropTypes.bool,
    tags: PropTypes.arrayOf(PropTypes.shape({
        tag: PropTypes.string.isRequired,
        url: PropTypes.string
    }).isRequired)
};
TagCloud.displayName = 'TagCloud';
module.exports = asConfiguredComponent(TagCloud, 'TagCloud');
//# sourceMappingURL=TagCloud.js.map

/***/ }),

/***/ 6494:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(8833);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 64050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText, BaseLink } = __webpack_require__(76955);
const { getColorStyles, calculateSpacing, minMaxScreen, getColorToken } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { applyCustomDividerColor } = __webpack_require__(1123);
const returnRightBottomMargins = (right, bottom) => `margin-right: ${calculateSpacing(right)}; margin-bottom: ${calculateSpacing(bottom)};`;
const TagCloudWrapper = styled.div.withConfig({
    displayName: 'TagCloudWrapper'
}) `
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;

  ${({ theme, hasBorderTop, hasBorderBottom, dividerColor }) => {
    let wrapperReturn = '';
    if (hasBorderTop || hasBorderBottom) {
        wrapperReturn += `
        border-style: solid;
        border-width: 0px;
        ${dividerColor
            ? `${applyCustomDividerColor(dividerColor)};`
            : `${getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.divider')};`}
      `;
    }
    if (hasBorderTop) {
        wrapperReturn += `
        border-top-width: 1px;
      `;
    }
    if (hasBorderBottom) {
        wrapperReturn += `
        ${dividerColor
            ? `border-bottom-width: 0px;`
            : `border-bottom-width: 1px;`}
      `;
    }
    return wrapperReturn;
}};

  padding: ${calculateSpacing(2)} 0 0;
  ${({ hasRoundBorder }) => hasRoundBorder && `padding-bottom: ${calculateSpacing()};`}

  ${minMaxScreen(BREAKPOINTS.sm, `calc(${BREAKPOINTS.md} - 1px)`)} {
    ${({ shouldTagLinkHaveFullLengthInMobile }) => shouldTagLinkHaveFullLengthInMobile && `flex-direction: column;`}
  }
`;
const TagCloudSectionHeader = styled(BaseText).withConfig({
    displayName: 'TagCloudSectionHeader'
}) `
  ${returnRightBottomMargins(2, 2)}

  @media (min-width: ${BREAKPOINTS.md}) {
    ${returnRightBottomMargins(4, 2)}
  }
`;
TagCloudSectionHeader.defaultProps = {
    as: 'span',
    colorToken: 'colors.consumption.body.standard.body-deemphasized',
    typeIdentity: 'typography.definitions.globalEditorial.tags'
};
const TagCloudName = styled(BaseText).withConfig({
    displayName: 'TagCloudName'
}) `
  ${returnRightBottomMargins(2, 3)}
  @media (min-width: ${BREAKPOINTS.md}) {
    ${returnRightBottomMargins(4, 2)}
  }
`;
TagCloudName.defaultProps = {
    as: 'span',
    typeIdentity: 'typography.definitions.globalEditorial.tags'
};
const TagCloudLink = styled(BaseLink).withConfig({
    displayName: 'TagCloudLink'
}) `
  ${returnRightBottomMargins(2, 2)}
  line-height: 0;

  ${TagCloudName} {
    ${returnRightBottomMargins(0, 0)}
    color: inherit;
  }

  @media (min-width: ${BREAKPOINTS.md}) {
    ${({ shouldIncreaseTagLinkBottomSpacing }) => {
    const bottomSpace = shouldIncreaseTagLinkBottomSpacing ? 4 : 2;
    return returnRightBottomMargins(4, bottomSpace);
}}
  }

  @media (min-width: ${BREAKPOINTS.sm}) {
    ${({ shouldIncreaseTagLinkBottomSpacing }) => {
    const bottomSpace = shouldIncreaseTagLinkBottomSpacing ? 3 : 2;
    return returnRightBottomMargins(4, bottomSpace);
}}
  }

  ${({ theme, hasFilledBackground, hasRoundBorder, shouldUseInteractiveBrandColor }) => {
    if (hasFilledBackground) {
        return css `
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.brand-primary')};
        border-width: 1px;
        border-style: solid;
        ${hasRoundBorder && 'border-radius: 20px;'}
        ${getColorStyles(theme, 'border-color', 'colors.interactive.base.brand-primary')};
        padding: 5px 12px;
        transition-property: color, background-color, border-color;

        ${shouldUseInteractiveBrandColor &&
            css `
          background-color: rgba(
            ${getColorToken('colors.background.brand', {
                rgbOnly: true
            })},
            0.2
          );
          ${getColorStyles(theme, 'border-color', 'colors.interactive.base.white')};
        `}

        &:link {
          ${shouldUseInteractiveBrandColor
            ? getColorStyles(theme, 'color', 'colors.interactive.base.body')
            : getColorStyles(theme, 'color', 'colors.interactive.base.white')};
          text-decoration: none;
        }

        &:hover,
        &:focus {
          ${getColorStyles(theme, 'background-color', 'colors.interactive.base.dark')};
          ${shouldUseInteractiveBrandColor &&
            css `
            background-color: rgba(
              ${getColorToken('colors.background.brand', {
                rgbOnly: true
            })},
              0.2
            );
          `}
          outline-offset: 4px;
          border-width: 1px;
          border-style: solid;
          ${getColorStyles(theme, 'border-color', 'colors.interactive.base.dark')};
        }

        @media (min-width: ${BREAKPOINTS.sm}) {
          ${returnRightBottomMargins(1, 1)}
        }
      `;
    }
    return '';
}};
`;
TagCloudLink.defaultProps = {
    colorSecondaryLinkToken: 'colors.consumption.body.standard.link-hover',
    colorStaticLinkToken: 'colors.consumption.body.standard.subhed',
    hasUnderline: false
};
module.exports = {
    TagCloudWrapper,
    TagCloudSectionHeader,
    TagCloudName,
    TagCloudLink
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 95748:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    sectionHeader: {
        id: 'TagCloud.SectionHeader',
        defaultMessage: 'Topics',
        description: 'TagCloud component section header',
        isConfigurable: true
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 17385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { ToggleButton, ToggleSlider } = __webpack_require__(29479);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * ToggleSwitch component
 *
 * @param {object} props - React props
 * @param {node} [props.children] - SVG icon which has to be inside the toggle switch label
 * @param {string} [props.describedBy] - optional field that identifies the element described
 * @param {string} [props.id] - optional field to show the component id
 * @param {bool} [props.isChecked] - Optional flag whether input is checked
 * @param {bool} [props.isControlled] - Optional flag whether input is controlled from parent component
 * @param {boolean} [props.isDisabled] - Optional input disabled attribute
 * @param {boolean} [props.isSuccess] - Optional flag whether the toggle has a success state
 * @param {Function} [props.onChange] - Optional onChange event handler
 *
 * @returns {ReactElement} <div>
 */
const ToggleSwitch = ({ children, describedBy, id, isChecked = false, isDisabled = false, isSuccess = false, onChange, isControlled = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ToggleSwitch'
        });
    }, []);
    const [checked, setChecked] = React.useState(isChecked);
    const onClick = () => {
        const currentState = !checked;
        if (!isControlled) {
            setChecked(currentState);
        }
        if (onChange) {
            const changeEvent = new CustomEvent('change', {
                detail: { checked: currentState }
            });
            onChange(changeEvent);
        }
    };
    React.useEffect(() => {
        setChecked(isChecked);
    }, [isChecked]);
    return (React.createElement(ToggleButton, { type: "button", role: "switch", id: id, "aria-checked": checked, disabled: isDisabled, "data-success": isSuccess, onClick: onClick, "aria-describedby": describedBy },
        children,
        React.createElement(ToggleSlider, null)));
};
ToggleSwitch.propTypes = {
    children: PropTypes.node,
    describedBy: PropTypes.string,
    id: PropTypes.string,
    isChecked: PropTypes.bool,
    isControlled: PropTypes.bool,
    isDisabled: PropTypes.bool,
    isSuccess: PropTypes.bool,
    onChange: PropTypes.func
};
ToggleSwitch.displayName = 'ToggleSwitch';
module.exports = ToggleSwitch;
//# sourceMappingURL=ToggleSwitch.js.map

/***/ }),

/***/ 85253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(17385);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 29479:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorToken } = __webpack_require__(26865);
const ToggleSlider = styled.span.withConfig({
    displayName: 'ToggleSlider'
}) `
  position: relative;
  transform: translateX(0);
  opacity: 1;
  margin: 0;
  border: 1px solid ${getColorToken('colors.interactive.base.white')};
  border-radius: 50%;
  background: ${getColorToken('colors.interactive.base.white')};
  width: 21px;
  height: 21px;
`;
const ToggleButton = styled.button.withConfig({ displayName: 'ToggleButton' }) `
  display: flex;
  position: relative;
  align-items: center;
  border: none;
  border-radius: 15.5px;
  cursor: pointer;
  padding: 2.5px;
  width: 51px;
  height: 27px;

  svg {
    position: absolute;
    left: 0;
    align-self: center;
    width: 27px;
    height: 18px;
    fill: ${getColorToken('colors.interactive.base.white')};
  }

  &[aria-checked='false'] {
    background: ${getColorToken('colors.interactive.base.dark')};

    svg {
      opacity: 0;
    }
  }

  &[aria-checked='true'] {
    transition: all 0.2s ease-in-out;
    background: ${getColorToken('colors.interactive.base.brand-primary')};

    svg {
      opacity: 1;
    }

    ${ToggleSlider} {
      transform: translateX(24px);
      transition: all 0.2s ease-in-out;
    }
  }

  &[aria-checked='true'][data-success='true'] {
    transition: all 0.4s ease-in-out;
    width: 27px;
    transition-delay: 0.2s;

    svg {
      transition: 0.4s ease-in-out;
      width: 100%;
      height: 22px;
      transition-property: all;
      transition-delay: 0.2s;
    }

    ${ToggleSlider} {
      animation: fadeIn 0.1s forwards linear;
      animation-delay: 0.2s;
    }
  }

  @keyframes fadeIn {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 0;
    }
  }
`;
module.exports = {
    ToggleButton,
    ToggleSlider
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 61248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
const { UtilityBodyTextContainer, UtilityBodyTextContent } = __webpack_require__(40437);
/**
 * UtilityBodyText component
 *
 * @param {object} props - React props
 * @param {ReactElement} [props.children] - Optional React children
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} props.dangerousText - Dangerous HTML that will appear in pattern
 * @param {boolean} [props.hideDangerousText] - Optional prop to show dangerousText
 * @param {object} [props.variations] - Optional variation properties used in rendering the component.
 * @param {object} [props.variations.contentAlign] - Optional alignment of content [center, left, right]
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
const UtilityBodyText = ({ children, className, dangerousText, hideDangerousText, variations = {
    contentAlign: 'center'
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'UtilityBodyText',
            variation: variationName
        });
    }, [variationName]);
    const showUtilityBodyText = !hideDangerousText;
    if (!showUtilityBodyText) {
        return null;
    }
    return (React.createElement(UtilityBodyTextContainer, { className: classnames(className, 'utility-body-text') },
        React.createElement(UtilityBodyTextContent, { className: "utility-body-text__content", contentAlign: variations.contentAlign, dangerouslySetInnerHTML: {
                __html: dangerousText
            } }),
        children));
};
UtilityBodyText.propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,
    dangerousText: PropTypes.string.isRequired,
    hideDangerousText: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        contentAlign: PropTypes.oneOf(['center', 'left', 'right'])
    })
};
module.exports = UtilityBodyText;
//# sourceMappingURL=UtilityBodyText.js.map

/***/ }),

/***/ 27755:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(60141);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 40437:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseText } = __webpack_require__(18730);
const UtilityBodyTextContainer = styled.div.withConfig({
    displayName: 'UtilityBodyTextContainer'
}) ``;
const UtilityBodyTextContent = styled(BaseText).withConfig({
    displayName: 'UtilityBodyTextContent'
}) `
  text-align: ${({ contentAlign }) => contentAlign};

  a {
    color: inherit;
  }
`;
UtilityBodyTextContent.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
module.exports = {
    UtilityBodyTextContainer,
    UtilityBodyTextContent
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 60141:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const UtilityBodyText = __webpack_require__(61248);
UtilityBodyText.ContentCenter = asVariation(UtilityBodyText, 'ContentCenter', {
    contentAlign: 'center'
});
UtilityBodyText.ContentLeft = asVariation(UtilityBodyText, 'ContentLeft', {
    contentAlign: 'left'
});
UtilityBodyText.ContentRight = asVariation(UtilityBodyText, 'ContentRight', {
    contentAlign: 'right'
});
module.exports = UtilityBodyText;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 68606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const Comment = __webpack_require__(34577);
const { CommentsCountDisplay, CommentsCountDisplayWrapper } = __webpack_require__(27490);
/**
 * @param {object} props - React props
 * @param {number} [props.totalCommentsCount] - prop which has count of total number of comments added to the story
 *
 * @returns {ReactElement} <StoryCommentsCountDisplay>
 */
const StoryCommentsCountDisplay = ({ totalCommentsCount }) => {
    let formattedCommentsCount = totalCommentsCount;
    let commentsCount = '';
    if (!totalCommentsCount || totalCommentsCount === 0)
        return commentsCount;
    if (totalCommentsCount > 0) {
        formattedCommentsCount = new Intl.NumberFormat('en', {
            notation: 'compact',
            maximumSignificantDigits: 3
        }).format(totalCommentsCount);
        commentsCount = (React.createElement(CommentsCountDisplayWrapper, null,
            React.createElement(Comment, null),
            React.createElement(CommentsCountDisplay, null, formattedCommentsCount)));
    }
    return commentsCount;
};
StoryCommentsCountDisplay.propTypes = {
    totalCommentsCount: PropTypes.number
};
module.exports = StoryCommentsCountDisplay;
//# sourceMappingURL=StoryCommentsCountDisplay.js.map

/***/ }),

/***/ 23261:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { connect } = __webpack_require__(67851);
const { useEffect, useState } = __webpack_require__(96540);
const bookmark = __webpack_require__(48373);
const { TrackComponentChannel } = __webpack_require__(78788);
const { UtilityFeaturesWrapper } = __webpack_require__(27490);
const { BookmarkIcon } = __webpack_require__(72964);
const PhotoBookmark = __webpack_require__(43211);
const StoryCommentsCountDisplay = __webpack_require__(68606);
/**
 * UtilityFeatures component
 *
 * @param {object} props - React Props
 * @param {string} [props.contentType] - Content Type of the item
 * @param {string} [props.copilotID] - optional copilot id of the item
 * @param {string} [props.organizationID] - Optional organization id for fetching bookmark details
 * @param {number} [props.totalCommentsCount] - prop which has count of total number of comments added to the story
 * @param {string} [props.urlToBookmark] - optional url string to pass into bookmark icon
 * @param {object} [props.user] - Optional user details for fetching bookmark details
 * @param {Array} [props.shouldLimitSavingToContentTypes] - flag to determine if only recipes should be processed
 * @param {object} [props.userPlatform] - Optional user platform details for fetching bookmark details
 * @param {boolean} [props.shouldEnableCardLevelBookmark] - flag to show the utility bookmark option
 * @param {boolean} [props.shouldEnableCommentsCount] - flag to show the comments count
 * @param {boolean} [props.shouldUseBookmarkV3] - Feature flag to define whether to use bookmark v3
 * @param {object} [props.snowplowEvent] - snowplow event data passed to utility features
 * @param {string} [props.subject] - describes the content of the subject.
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @param {boolean} [props.isPageScoped] - flag to decide bookmark at the page level/item level
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - flag to enable bookmark drawer functionality
 *
 * @returns {ReactElement} <UtilityFeatures>
 */
const UtilityFeatures = ({ contentType, copilotID, isPageScoped, organizationID, shouldEnableBookmarkDrawers = false, shouldEnableCardLevelBookmark = false, shouldEnableCommentsCount = false, shouldUseBookmarkV3, snowplowEvent, subject, subtype, totalCommentsCount, urlToBookmark, shouldLimitSavingToContentTypes, user, userPlatform }) => {
    const [bookmarkDetails, setBookmarkDetails] = useState({});
    useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'UtilityFeatures'
        });
    }, []);
    const shouldShowBookmarkIcon = shouldEnableCardLevelBookmark &&
        (shouldLimitSavingToContentTypes === undefined ||
            (Array.isArray(shouldLimitSavingToContentTypes) &&
                shouldLimitSavingToContentTypes?.includes(contentType)));
    const bookmarkLink = {
        label: '',
        url: urlToBookmark || '#',
        network: 'bookmark',
        behavior: 'bookmark'
    };
    useEffect(() => {
        const fetchBookmarkDetails = async () => {
            if (!user.amguuid) {
                setBookmarkDetails({
                    bookmarkId: null,
                    isUrlBookmark: null,
                    contentId: copilotID,
                    organizationID,
                    contentType,
                    subtype
                });
                return;
            }
            try {
                const bookmarkHelper = bookmark(shouldUseBookmarkV3);
                const bookmarkStatus = await bookmarkHelper.getBookmarkStatus({
                    amgUUID: user.amguuid,
                    copilotID,
                    documentUrl: `${window.location.origin}${urlToBookmark}`,
                    organizationID,
                    federatedGraphqlUrl: userPlatform.federatedGraphqlUrl,
                    siteCode: userPlatform.siteCode,
                    userPlatformProxy: userPlatform.userPlatformProxy,
                    xClientID: userPlatform.xClientID
                });
                setBookmarkDetails({
                    ...bookmarkStatus,
                    contentId: copilotID,
                    contentType,
                    subtype
                });
            }
            catch (error) {
                console.error(error);
            }
        };
        if (shouldEnableCardLevelBookmark)
            fetchBookmarkDetails();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [shouldEnableCardLevelBookmark]);
    const updateBookmark = (bookmarkStatus) => {
        setBookmarkDetails({
            ...bookmarkStatus,
            contentId: copilotID,
            contentType
        });
    };
    return (React.createElement(UtilityFeaturesWrapper, { "data-testid": "utility-features-wrapper" },
        shouldEnableCommentsCount && (React.createElement(StoryCommentsCountDisplay, { totalCommentsCount: totalCommentsCount })),
        shouldShowBookmarkIcon && !shouldEnableBookmarkDrawers && (React.createElement(BookmarkIcon, { bookmarkDetails: bookmarkDetails, link: bookmarkLink, theme: "standard", type: "standard", isUrlBookmark: true, isBookmarkButton: true, isIconButton: true, copilotID: copilotID, contentType: contentType, isPageScoped: isPageScoped, shouldUseBookmarkV3: shouldUseBookmarkV3, updateBookmark: updateBookmark, subject: subject, snowplowEvent: snowplowEvent })),
        shouldEnableBookmarkDrawers && shouldShowBookmarkIcon && (React.createElement(PhotoBookmark, { copilotID: copilotID, contentType: contentType, subtype: subtype }))));
};
UtilityFeatures.propTypes = {
    contentType: PropTypes.string.isRequired,
    copilotID: PropTypes.string.isRequired,
    isPageScoped: PropTypes.bool,
    organizationID: PropTypes.string.isRequired,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldEnableCardLevelBookmark: PropTypes.bool,
    shouldEnableCommentsCount: PropTypes.bool,
    shouldLimitSavingToContentTypes: PropTypes.oneOfType([
        PropTypes.array,
        PropTypes.string
    ]),
    shouldUseBookmarkV3: PropTypes.bool,
    snowplowEvent: PropTypes.object,
    subject: PropTypes.string,
    subtype: PropTypes.string,
    totalCommentsCount: PropTypes.number,
    urlToBookmark: PropTypes.string,
    user: PropTypes.object,
    userPlatform: PropTypes.object
};
const mapStateToProps = (state) => {
    const { coreDataLayer = {}, user, userPlatform } = state;
    return {
        organizationID: coreDataLayer?.site?.orgId || '',
        user,
        userPlatform
    };
};
module.exports = connect(mapStateToProps, null)(UtilityFeatures);
//# sourceMappingURL=UtilityFeatures.js.map

/***/ }),

/***/ 27490:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { SocialIconButton } = __webpack_require__(51000);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const UtilityFeaturesWrapper = styled.div.withConfig({
    displayName: 'UtilityFeaturesWrapper'
}) `
  display: flex;
  flex-direction: row;
  margin-top: ${calculateSpacing(1)};

  .button__icon-container {
    margin-left: auto;
    cursor: pointer;
  }

  ${SocialIconButton} {
    display: contents;

    .icon-bookmark {
      padding: 3px;
      width: ${calculateSpacing(3)};
      height: ${calculateSpacing(3)};
    }
  }
`;
const CommentsCountDisplay = styled(BaseText).withConfig({
    displayName: 'CommentsCountDisplay'
}) `
  align-self: center;
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.deemphasized')};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  padding-left: ${calculateSpacing(0.5)};
`;
const CommentsCountDisplayWrapper = styled.div.withConfig({
    displayName: 'CommentsCountDisplayWrapper'
}) `
  display: flex;
  cursor: default;

  .icon-comment {
    padding: 3px;
    width: ${calculateSpacing(3)};
    height: ${calculateSpacing(3)};
  }
`;
module.exports = {
    CommentsCountDisplay,
    CommentsCountDisplayWrapper,
    UtilityFeaturesWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 73237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const React = __webpack_require__(96540);
const ResponsiveAsset = __webpack_require__(73275);
const { TrackComponentChannel } = __webpack_require__(78788);
const { UtilityLedeHeader, UtilityLedeWrapper, UtilityLedeHedText, UtilityLedeDekText, UtilityLedeImage } = __webpack_require__(79055);
/**
 * UtilityLede component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.ariaLive] - Optional aria-live attribute
 * @param {string} [props.dangerousDek] - Optional page lede dangerousdek
 * @param {string} props.dangerousHed - Page lede dangerousHed
 * @param {boolean}[props.hasInverted] - optional style
 * @param {ResponsiveAsset.propTypes.media} [props.image] - Optional image that contains altText, attributes, and source urls
 * @param {boolean} [props.shouldUseAlternativeStyle] - Whether component has alternative styles
 * @param {object} [props.variations] - Optional variations
 * @param {string} [props.variations.contentAlign] - Optional content alignment variation ['left', 'right', 'center']
 * @param {boolean} [props.variations.hasBackground] - Whether component has background
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {boolean} [props.hasAlternateNewsletterStyle] - Flag to display new newsletter hub template
 * @returns {ReactElement} <div>
 */
const UtilityLede = ({ ariaLive, className, dangerousDek, dangerousHed, image, shouldUseAlternativeStyle = false, hasAlternateNewsletterStyle, hasInverted, variations = {
    contentAlign: 'center',
    hasBackground: true
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'UtilityLede',
            variation: variationName
        });
    }, [variationName]);
    const hasImage = image && Object.keys(image).length > 0;
    return (React.createElement(UtilityLedeHeader, { "data-testid": "utility-lede-wrapper", className: classnames('utility-lede', className), "aria-live": ariaLive, "aria-label": "UtilityPageHeader", contentAlign: variations.contentAlign, hasBackground: variations.hasBackground, hasImage: hasImage, alternativeStyle: shouldUseAlternativeStyle },
        image && React.createElement(UtilityLedeImage, { hasImage: hasImage, ...image }),
        React.createElement(UtilityLedeWrapper, { alternativeStyle: shouldUseAlternativeStyle },
            React.createElement(UtilityLedeHedText, { "data-testid": "UtilityLedeHedText", hasImage: hasImage, dangerouslySetInnerHTML: { __html: dangerousHed }, hasInverted: hasInverted, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle }),
            dangerousDek && (React.createElement(UtilityLedeDekText, { "data-testid": "UtilityLedeDekText", hasImage: hasImage, dangerouslySetInnerHTML: { __html: dangerousDek }, hasAlternateNewsletterStyle: hasAlternateNewsletterStyle })))));
};
UtilityLede.propTypes = {
    ariaLive: PropTypes.string,
    className: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    hasAlternateNewsletterStyle: PropTypes.bool,
    hasInverted: PropTypes.bool,
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    shouldUseAlternativeStyle: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        contentAlign: PropTypes.oneOf(['center', 'left', 'right']),
        hasBackground: PropTypes.bool
    })
};
module.exports = UtilityLede;
//# sourceMappingURL=UtilityLede.js.map

/***/ }),

/***/ 50829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(93707);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 79055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const ResponsiveAsset = __webpack_require__(73275);
const applyAlignment = (contentAlign) => `
  text-align: ${contentAlign};
`;
const applyBackground = (theme) => `
  ${getColorStyles(theme, 'background-color', 'colors.discovery.body.white.background')};
`;
const UtilityLedeHeader = styled.header.withConfig({
    displayName: 'UtilityLedeHeader'
}) `
  ${({ contentAlign }) => (contentAlign ? applyAlignment(contentAlign) : ``)}
  ${({ theme, hasBackground }) => (hasBackground ? applyBackground(theme) : ``)}
  ${({ hasImage }) => hasImage
    ? `
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-column-gap: 1.5rem;
      align-items: center;
      padding: ${calculateSpacing(12)} 0 ${calculateSpacing(100)} 0;
      @media  (min-width: 0) and (max-width: ${BREAKPOINTS.md}){
          grid-gap: ${calculateSpacing(2)};
          grid-template-columns: repeat(4, 1fr);
          padding: ${calculateSpacing(5)} 0 ${calculateSpacing(5)} 0;
          justify-items: center;
      }
      `
    : ``}
  ${({ alternativeStyle }) => alternativeStyle
    ? `
    grid-gap: ${calculateSpacing(2)} 0;
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}){
      grid-gap: ${calculateSpacing(4)} 0;
    }
    `
    : ``}
`;
const UtilityLedeWrapper = styled.div.withConfig({
    displayName: 'UtilityLedeWrapper'
}) `
  grid-auto-flow: row;
  grid-column: 4 / span 5;

  @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
    grid-gap: ${calculateSpacing(2)} 0;
    grid-column: 1 / span 4;
  }

  ${(props) => props.alternativeStyle === true
    ? `
        grid-gap: ${calculateSpacing(2)} 0;
        @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}){
            grid-gap: ${calculateSpacing(4)} 0;
        }
        `
    : ''}
`;
const UtilityLedeHedText = styled(BaseText).withConfig({
    displayName: 'UtilityLedeHedText'
}) `
  ${({ hasAlternateNewsletterStyle }) => hasAlternateNewsletterStyle &&
    css `
      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.heading')};
    `}
  ${(props) => props.alternativeStyle === true
    ? `
        ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.hed')};
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.page-hed-section')};
        `
    : ''}
  ${(props) => props.hasImage === true
    ? `
        margin: 0;
        `
    : `margin: 0 0 ${calculateSpacing(2, 'px')};`}

  ${(props) => props.hasInverted === true &&
    css `
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.context-texture')};
      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')};
      line-height: 25px;
      font-size: 20px;
    `}
`;
UtilityLedeHedText.defaultProps = {
    as: 'h1',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.hed-break-out'
};
const UtilityLedeDekText = styled(BaseText).withConfig({
    displayName: 'UtilityLedeDekText'
}) `
  a {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.accent')};
    ${(props) => props.hasAlternateNewsletterStyle === true
    ? css `
            ${getColorStyles('color', 'colors.foundation.expanded-utility.nav-link.default')};
            text-decoration: none;
          `
    : ''}
  }

  p {
    margin: 0; /* overwrite native browser margins for paragraph tags */
  }
  ${(props) => props.alternativeStyle === true
    ? `
        ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.description')};
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.description.feature')};
        a {
          ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.description')};
        }
        `
    : ''}

  ${(props) => props.hasImage === true
    ? `
        margin: 0;
        `
    : `margin: ${calculateSpacing(2, 'px')} 0 0;`}

  @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
    grid-row: 2;
  }

  ${(props) => props.hasAlternateNewsletterStyle === true
    ? css `
          ${getTypographyStyles('typography.definitions.utility.description')}
        `
    : ''}
`;
UtilityLedeDekText.defaultProps = {
    as: 'h2',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.consumptionEditorial.body-core'
};
const UtilityLedeImage = styled(ResponsiveAsset).withConfig({
    displayName: 'UtilityLedeImage'
}) `
  grid-column: 1 / span 3;
  @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
    grid-column: 2 / span 2;
    grid-row: 1;
  }
  ${(props) => props.hasImage === true
    ? `
      @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}){
        padding-bottom: 0;
      }
      `
    : ''}
`;
module.exports = {
    UtilityLedeHeader,
    UtilityLedeWrapper,
    UtilityLedeHedText,
    UtilityLedeDekText,
    UtilityLedeImage
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 93707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const UtilityLede = __webpack_require__(73237);
UtilityLede.ContentCenterNoBackground = asVariation(UtilityLede, 'ContentCenterNoBackground', { contentAlign: 'center', hasBackground: false });
UtilityLede.ContentRightNoBackground = asVariation(UtilityLede, 'ContentRightNoBackground', { contentAlign: 'right', hasBackground: false });
UtilityLede.ContentLeftNoBackground = asVariation(UtilityLede, 'ContentLeftNoBackground', { contentAlign: 'left', hasBackground: false });
module.exports = UtilityLede;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 22698:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { UtilitySelectionControlLabelWrapper, UtilitySelectionControlNativeCheckbox, UtilitySelectionControlNativeRadio, UtilitySelectionControlStyledRadio, UtilitySelectionControlStyledCheckbox, UtilitySelectionControlLabelTrailingIcon, UtilitySelectionControlLabel, UtilitySelectionControlAssistiveText } = __webpack_require__(20404);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * UtilitySelectionControl component
 *
 * @param {object} props - React Props
 * @param {string} [props.ariaDescribedBy] - Optional aria-describedby value
 * @param {string} [props.assistiveText] - Optional dangerous selection assistive text
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.descriptor] - Optional text used as display name in validation messages
 * @param {string} props.formName - Parent form name
 * @param {number} props.index - Index in a fieldset list to help create unique ids
 * @param {object} [props.inputAttributes] - Optional attributes to add to input element i.e. disabled
 * @param {Function} [props.inputRef] - Optional input node ref function
 * @param {Map} [props.invalidElements] - Optional Map of invalid element ids from parent form. Will set invalid state if ID matches.
 * @param {bool} [props.isChecked] - Optional flag whether input is checked. Use if this should be a fully controlled component.
 * @param {bool} [props.isDefaultChecked] - Optional status of checkbox. Use if component is uncontrolled.
 * @param {boolean} [props.isDisabled] - Optional input disabled attribute
 * @param {boolean} [props.isRequired] - Whether input is required
 * @param {string} [props.label] - Optional dangerous selection label
 * @param {string} props.name - Input name
 * @param {Function} [props.onChangeHandler] - Optional handler for change event
 * @param {Function} [props.TrailingIcon] - Optional trailing icon component
 * @param {string} props.value - Input value
 * @param {object} props.variations - Variation properties used in rendering the component.
 * @param {string} props.variations.inputType - [`checkbox`, `radio`] Sets the type of the input control.
 * @param {string} props.variations.theme - [`inverted`, `standard`] Sets the color theme.
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <label>
 */
const UtilitySelectionControl = ({ ariaDescribedBy, assistiveText, className, descriptor, formName, index, inputAttributes, inputRef, invalidElements, isChecked, isDefaultChecked, isDisabled, isRequired, label, name, onChangeHandler, TrailingIcon, value, variations = {
    inputType: 'checkbox',
    theme: 'standard'
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Utility',
            variation: variationName
        });
    }, [variationName]);
    const id = `${formName}-utility-selection-control-${name}-${index}`;
    const { inputType, theme } = variations;
    const isInverted = theme === 'inverted';
    const nativeInputProps = {
        ...inputAttributes,
        'aria-describedby': invalidElements && invalidElements.has(id)
            ? invalidElements.get(id)
            : ariaDescribedBy,
        'data-descriptor': descriptor,
        checked: isChecked,
        defaultChecked: isDefaultChecked,
        disabled: isDisabled,
        id,
        name,
        onChange: onChangeHandler,
        ref: inputRef,
        required: isRequired,
        type: inputType,
        value,
        inputType,
        isInverted
    };
    return (React.createElement(UtilitySelectionControlLabelWrapper, { className: classnames('utility-selection-control', className), isDisabled: isDisabled, inputType: inputType, htmlFor: id },
        inputType === 'checkbox' && (React.createElement(React.Fragment, null,
            React.createElement(UtilitySelectionControlNativeCheckbox, { ...nativeInputProps }),
            React.createElement(UtilitySelectionControlStyledCheckbox, { inputType: inputType, isInverted: isInverted }))),
        inputType === 'radio' && (React.createElement(React.Fragment, null,
            React.createElement(UtilitySelectionControlNativeRadio, { ...nativeInputProps }),
            React.createElement(UtilitySelectionControlStyledRadio, { inputType: inputType, isInverted: isInverted }))),
        label &&
            (TrailingIcon ? (React.createElement(UtilitySelectionControlLabelTrailingIcon, { isDisabled: isDisabled, isInverted: isInverted },
                React.createElement(UtilitySelectionControlLabel, { className: "utility-selection-control__label", dangerouslySetInnerHTML: { __html: label }, isDisabled: isDisabled, isInverted: isInverted }),
                React.createElement(TrailingIcon, { className: "utility-selection-control__trailing-icon" }))) : (React.createElement(UtilitySelectionControlLabel, { className: "utility-selection-control__label", dangerouslySetInnerHTML: { __html: label }, isDisabled: isDisabled, isInverted: isInverted }))),
        assistiveText && (React.createElement(UtilitySelectionControlAssistiveText, { dangerouslySetInnerHTML: { __html: assistiveText }, isDisabled: isDisabled, isInverted: isInverted }))));
};
UtilitySelectionControl.propTypes = {
    ariaDescribedBy: PropTypes.string,
    assistiveText: PropTypes.string,
    className: PropTypes.string,
    descriptor: PropTypes.string,
    formName: PropTypes.string.isRequired,
    index: PropTypes.number.isRequired,
    inputAttributes: PropTypes.object,
    inputRef: PropTypes.func,
    invalidElements: PropTypes.instanceOf(Map),
    isChecked: PropTypes.bool,
    isDefaultChecked: PropTypes.bool,
    isDisabled: PropTypes.bool,
    isRequired: PropTypes.bool,
    label: PropTypes.string,
    name: PropTypes.string.isRequired,
    onChangeHandler: PropTypes.func,
    TrailingIcon: PropTypes.func,
    value: PropTypes.string.isRequired,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        inputType: PropTypes.oneOf(['checkbox', 'radio']),
        theme: PropTypes.oneOf(['inverted', 'standard'])
    })
};
module.exports = UtilitySelectionControl;
//# sourceMappingURL=UtilitySelectionControl.js.map

/***/ }),

/***/ 67685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(97635);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles, getColorStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(18730);
const { INTERACTIVE: { timingButtonDefault } } = __webpack_require__(96472);
const utiltySelectionControlSize = '20px';
const utilityCheckboxIconBorderWidth = '2px';
const utilitySelectionControlTrailingIconSize = '15px';
const selectionControlStyledInput = ({ selectionControlBackgroundColor, selectionControlBorderColor, selectionControlSize }) => {
    return css `
    transition-property: background, border;
    transition-duration: ${timingButtonDefault};
    transition-timing-function: ease-in;
    position: relative;
    border-width: 1px;
    border-style: solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', selectionControlBorderColor)};
    ${({ theme }) => getColorStyles(theme, 'background-color', selectionControlBackgroundColor)};
    width: ${selectionControlSize};
    height: ${selectionControlSize};
    pointer-events: none;

    &::before {
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      transition-property: background, border;
      transition-duration: ${timingButtonDefault};
      transition-timing-function: ease-in;
      opacity: 0;
      content: '';
    }
  `;
};
const selectionControlCheckbox = ({ checkboxIconBorderWidth, checkboxIconColor }) => {
    return css `
    transform: translate(-50%, -60%) rotate(45deg);
    border-width: 0 ${checkboxIconBorderWidth} ${checkboxIconBorderWidth} 0;
    border-style: solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', checkboxIconColor)};
    width: 25%;
    height: 75%;
  `;
};
const selectionControlRadio = ({ radioIconColor, theme }) => {
    return `
    border-radius: 100%;
    transform: translate(-50%, -50%);
    border-radius: 100%;
    ${getColorStyles(theme, 'background-color', radioIconColor)};
    width: 50%;
    height: 50%;
  `;
};
const UtilitySelectionControlStyledCheckbox = styled.div.withConfig({
    displayName: 'UtilitySelectionControlStyledCheckbox'
}) `
  ${selectionControlStyledInput({
    selectionControlBackgroundColor: 'colors.interactive.base.white',
    selectionControlBorderColor: 'colors.interactive.base.black',
    selectionControlSize: utiltySelectionControlSize
})}

  &::before {
    ${selectionControlCheckbox({
    checkboxIconBorderWidth: utilityCheckboxIconBorderWidth,
    checkboxIconColor: 'colors.interactive.base.white'
})}
  }

  ${({ isInverted }) => isInverted &&
    css `
      ${selectionControlStyledInput({
        selectionControlBackgroundColor: 'colors.interactive.base.black',
        selectionControlBorderColor: 'colors.interactive.base.white',
        selectionControlSize: utiltySelectionControlSize
    })}

      &::before {
        ${selectionControlCheckbox({
        checkboxIconBorderWidth: utilityCheckboxIconBorderWidth,
        checkboxIconColor: 'colors.interactive.base.black'
    })}
      }
    `}
`;
const UtilitySelectionControlStyledRadio = styled.div.withConfig({
    displayName: 'UtilitySelectionControlStyledRadio'
}) `
  ${selectionControlStyledInput({
    selectionControlBackgroundColor: 'colors.interactive.base.white',
    selectionControlBorderColor: 'colors.interactive.base.black',
    selectionControlSize: utiltySelectionControlSize
})}

  border-radius: 100%;

  &::before {
    ${({ theme }) => selectionControlRadio({
    radioIconColor: 'colors.interactive.base.black',
    theme
})}
  }

  ${({ isInverted, theme }) => isInverted &&
    css `
      ${selectionControlStyledInput({
        selectionControlBackgroundColor: 'colors.interactive.base.black',
        selectionControlBorderColor: 'colors.interactive.base.white',
        selectionControlSize: utiltySelectionControlSize
    })}

      &::before {
        ${selectionControlRadio({
        radioIconColor: 'colors.interactive.base.white',
        theme
    })}
      }
    `}
`;
const selectionControlNativeInput = ({ selectionControlBackgroundColor, theme }) => {
    return `
    &:checked,
    &:active {
      + ${UtilitySelectionControlStyledRadio}::before {
        opacity: 1;
      }
      + ${UtilitySelectionControlStyledCheckbox} {
        &::before {
          opacity: 1;
        }
        ${getColorStyles(theme, 'border-color', selectionControlBackgroundColor)};
        ${getColorStyles(theme, 'background-color', selectionControlBackgroundColor)}
        ;
      }
    }

    &:disabled {
      + ${UtilitySelectionControlStyledRadio},
        + ${UtilitySelectionControlStyledCheckbox} {
          ${getColorStyles(theme, 'border-color', 'colors.interactive.base.light')};
      }
    }

    &:disabled:checked {
      + ${UtilitySelectionControlStyledCheckbox} {
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.light')};
      }

      + ${UtilitySelectionControlStyledRadio}::before {
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.light')};
      }
    }
  `;
};
const UtilitySelectionControlAssistiveText = styled(BaseText).withConfig({
    displayName: 'UtilitySelectionControlAssistiveText'
}) `
  transition-property: color, stroke;
  transition-duration: ${timingButtonDefault};
  transition-timing-function: ease-in;
  ${({ theme, typeToken }) => getTypographyStyles(theme, typeToken)}
  grid-column-start: 2;
  align-self: center;
  ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)};

  ${({ isDisabled, theme }) => isDisabled &&
    `
      ${getColorStyles(theme, 'color', 'colors.interactive.base.dark')};
    `}

  ${({ isInverted, theme }) => isInverted &&
    `
      ${getColorStyles(theme, 'color', 'colors.interactive.base.light')};
    `}
`;
UtilitySelectionControlAssistiveText.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.dark',
    typeToken: 'typography.definitions.utility.assistive-text'
};
const UtilitySelectionControlLabel = styled(BaseText).withConfig({
    displayName: 'UtilitySelectionControlLabel'
}) `
  transition-property: color, stroke;
  transition-duration: ${timingButtonDefault};
  transition-timing-function: ease-in;
  ${({ theme, typeToken }) => getTypographyStyles(theme, typeToken)}
  display: block;
  ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)};

  ${({ isDisabled, theme }) => isDisabled &&
    `
      ${getColorStyles(theme, 'color', 'colors.interactive.base.dark')};
    `}

  ${({ isInverted, theme }) => isInverted &&
    `
      ${getColorStyles(theme, 'color', 'colors.interactive.base.white')};
    `}

  ${({ isInverted, isDisabled, theme }) => isInverted &&
    isDisabled &&
    `
      ${getColorStyles(theme, 'color', 'colors.interactive.base.light')};
    `}
`;
UtilitySelectionControlLabel.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.black',
    typeToken: 'typography.definitions.utility.label'
};
const UtilitySelectionControlLabelTrailingIcon = styled.div.withConfig({
    displayName: 'UtilitySelectionControlLabelTrailingIcon'
}) `
  ${UtilitySelectionControlLabel} {
    display: inline-block;
  }

  .utility-selection-control__trailing-icon {
    transition-property: color, stroke;
    transition-duration: ${timingButtonDefault};
    transition-timing-function: ease-in;
    margin-left: ${calculateSpacing(2)};
    width: ${utilitySelectionControlTrailingIconSize};
    height: ${utilitySelectionControlTrailingIconSize};
  }

  .utility-selection-control__trailing-icon-path {
    ${({ theme }) => getColorStyles(theme, 'stroke', 'colors.interactive.base.black')};

    ${({ isDisabled, theme }) => isDisabled &&
    `
        ${getColorStyles(theme, 'stroke', 'colors.interactive.base.dark')};
      `}

    ${({ isInverted, theme }) => isInverted &&
    `
        ${getColorStyles(theme, 'stroke', 'colors.interactive.base.white')};
      `}

    ${({ isInverted, isDisabled, theme }) => isInverted &&
    isDisabled &&
    `
        ${getColorStyles(theme, 'stroke', 'colors.interactive.base.light')};
      `}
  }
`;
const getNativeInputCommonStyles = ({ theme, isInverted }) => {
    return css `
    ${selectionControlNativeInput({
        selectionControlBackgroundColor: 'colors.interactive.base.black',
        theme
    })}
    ${isInverted &&
        selectionControlNativeInput({
            selectionControlBackgroundColor: 'colors.interactive.base.white',
            theme
        })}
  `;
};
const UtilitySelectionControlNativeRadio = styled.input.withConfig({
    displayName: 'UtilitySelectionControlNativeRadio'
}) `
  ${({ theme, isInverted }) => getNativeInputCommonStyles({ theme, isInverted })}
`;
const UtilitySelectionControlNativeCheckbox = styled.input.withConfig({
    displayName: 'UtilitySelectionControlNativeCheckbox'
}) `
  ${({ theme, isInverted }) => getNativeInputCommonStyles({ theme, isInverted })}
`;
const UtilitySelectionControlLabelWrapper = styled.label.withConfig({
    displayName: 'UtilitySelectionControlLabelWrapper'
}) `
  display: grid;
  position: relative;
  grid-column-gap: ${calculateSpacing(2)};
  grid-template-columns: ${utiltySelectionControlSize} auto;
  grid-row-gap: ${calculateSpacing(0.5)};

  &:hover {
    ${UtilitySelectionControlStyledCheckbox} {
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.brand-primary')};
    }
    ${UtilitySelectionControlNativeCheckbox}:checked + ${UtilitySelectionControlStyledCheckbox} {
      ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.brand-primary')};
    }
  }

  ${({ isDisabled }) => isDisabled &&
    `
      cursor: default;
      pointer-events: none;
    `};
`;
module.exports = {
    UtilitySelectionControlLabel,
    UtilitySelectionControlLabelWrapper,
    UtilitySelectionControlStyledCheckbox,
    UtilitySelectionControlStyledRadio,
    UtilitySelectionControlAssistiveText,
    UtilitySelectionControlNativeCheckbox,
    UtilitySelectionControlNativeRadio,
    UtilitySelectionControlLabelTrailingIcon
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 97635:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const withInvalidElementMapping = __webpack_require__(63050);
const UtilitySelectionControl = __webpack_require__(22698);
const WithInvalidElementMapping = withInvalidElementMapping(UtilitySelectionControl);
UtilitySelectionControl.Checkbox = asVariation(WithInvalidElementMapping, 'Checkbox', {
    inputType: 'checkbox',
    theme: 'standard'
});
UtilitySelectionControl.InvertedCheckbox = asVariation(WithInvalidElementMapping, 'InvertedCheckbox', {
    inputType: 'checkbox',
    theme: 'inverted'
});
UtilitySelectionControl.Radio = asVariation(WithInvalidElementMapping, 'Radio', {
    inputType: 'radio',
    theme: 'standard'
});
UtilitySelectionControl.InvertedRadio = asVariation(WithInvalidElementMapping, 'InvertedRadio', {
    inputType: 'radio',
    theme: 'inverted'
});
module.exports = UtilitySelectionControl;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 64090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(34365)/* ["default"] */ .A);
const { UtilityValidationDescriptionWrapper, UtilityValidationDescriptionHeading, UtilityValidationDescriptionErrors, UtilityValidationDescriptionError } = __webpack_require__(69195);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * UtilityValidationDescription component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object[]} props.errors - Errors to be displayed
 * @param {boolean} props.shouldHideErrorText - Wheather not to display `props.errors[].text`
 *
 * @returns {ReactElement} <div>
 */
const UtilityValidationDescription = ({ className, errors, shouldHideErrorText = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'UtilityValidationDescription'
        });
    }, []);
    const { formatMessage } = useIntl();
    return (React.createElement(UtilityValidationDescriptionWrapper, { "aria-live": "assertive", className: classnames('utility-validation-description', className), "data-testid": "utility-validation-description" },
        React.createElement(UtilityValidationDescriptionHeading, { className: "utility-validation-description__heading", "data-testid": "utility-validation-description-heading" }, formatMessage(translations.heading)),
        React.createElement(UtilityValidationDescriptionErrors, { className: "utility-validation-description__errors", "data-testid": "utility-validation-description-errors" }, errors.map(({ id, messages, text }) => (React.createElement(UtilityValidationDescriptionError, { "data-testid": "utility-validation-description-error", id: id, key: id || text, tabIndex: "-1" },
            !shouldHideErrorText && (React.createElement(React.Fragment, null,
                React.createElement("span", { dangerouslySetInnerHTML: { __html: text } }),
                ' ')),
            messages && `${messages.join(', ')}.`))))));
};
UtilityValidationDescription.propTypes = {
    className: PropTypes.string,
    errors: PropTypes.arrayOf(PropTypes.shape({
        id: PropTypes.string,
        messages: PropTypes.arrayOf(PropTypes.string),
        text: PropTypes.string.isRequired
    })).isRequired,
    shouldHideErrorText: PropTypes.bool
};
module.exports = UtilityValidationDescription;
//# sourceMappingURL=UtilityValidationDescription.js.map

/***/ }),

/***/ 17249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(64090);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 69195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseText } = __webpack_require__(76955);
const { hideVisually } = __webpack_require__(52813);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const UtilityValidationDescriptionWrapper = styled.div.withConfig({
    displayName: 'UtilityValidationDescriptionWrapper'
}) `
  margin-bottom: ${calculateSpacing(2)};
  background: none;
  padding: ${calculateSpacing(2)};
  text-align: center;
  ${({ theme }) => getColorStyles(theme, 'color', `colors.interactive.feedback.invalid-primary`)}
  p {
    &:first-of-type {
      margin-top: 0;
    }

    &:last-of-type {
      margin-bottom: 0;
    }
  }

  &.utility-validation-description--background-disabled {
    background: none;
  }
`;
const UtilityValidationDescriptionHeading = styled(BaseText).withConfig({
    displayName: 'UtilityValidationDescriptionHeading'
}) `
  ${hideVisually}
`;
UtilityValidationDescriptionHeading.defaultProps = {
    as: 'h2'
};
const UtilityValidationDescriptionErrors = styled.ul.withConfig({
    displayName: 'UtilityValidationDescriptionErrors'
}) `
  margin: 0;
  padding: 0;
  list-style: none;
`;
const UtilityValidationDescriptionError = styled(BaseText).withConfig({
    displayName: 'UtilityValidationDescriptionError'
}) `
  ${({ theme, typeIdentity }) => getTypographyStyles(theme, typeIdentity)}

  &::first-letter {
    text-transform: capitalize;
  }

  a {
    ${({ theme, colorToken }) => getColorStyles(theme, 'color', colorToken)}
  }
`;
UtilityValidationDescriptionError.defaultProps = {
    as: 'li',
    colorToken: 'colors.interactive.feedback.invalid-primary',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
module.exports = {
    UtilityValidationDescriptionWrapper,
    UtilityValidationDescriptionHeading,
    UtilityValidationDescriptionErrors,
    UtilityValidationDescriptionError
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 34365:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    heading: {
        id: 'UtilityValidationDescription.Heading',
        defaultMessage: 'Errors',
        description: 'UtilityValidationDescription component heading text'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 317:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { VerboseTextWrapper, VerboseTextLongerLink, VerboseTextShorterLink } = __webpack_require__(8);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * VerboseText component
 *
 * @param {object} props - React props
 * @param {string} props.text - text string
 * @param {string} props.verboseText - verbose text string
 *
 * @returns {ReactElement} <span>
 */
const VerboseText = ({ text, verboseText }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'VerboseText'
        });
    }, []);
    return (React.createElement(VerboseTextWrapper, { "data-testid": "verbose-text-wrapper" },
        React.createElement(VerboseTextShorterLink, { "aria-hidden": "true", "data-testid": "shorter-text" }, text),
        React.createElement(VerboseTextLongerLink, { "data-testid": "longer-text" }, verboseText)));
};
VerboseText.propTypes = {
    text: PropTypes.string.isRequired,
    verboseText: PropTypes.string.isRequired
};
module.exports = VerboseText;
//# sourceMappingURL=VerboseText.js.map

/***/ }),

/***/ 34252:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(317);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseText } = __webpack_require__(18730);
const { hideVisually } = __webpack_require__(52813);
const VerboseTextShorterLink = styled.span.withConfig({
    displayName: 'VerboseTextShorterLink'
}) ``;
const VerboseTextLongerLink = styled.span.withConfig({
    displayName: 'VerboseTextLongerLink'
}) `
  ${hideVisually};

  &:active,
  &:focus {
    position: static;
    margin: 0;
    width: auto;
    height: auto;
    overflow: visible;
    clip: auto;
  }
`;
const VerboseTextWrapper = styled(BaseText).withConfig({
    displayName: 'VerboseTextWrapper'
}) `
  color: inherit;
`;
VerboseTextWrapper.defaultProps = {
    as: 'span'
};
module.exports = {
    VerboseTextShorterLink,
    VerboseTextLongerLink,
    VerboseTextWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 1184:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateAdNodeId = exports.useOnAdFilled = exports.attemptAdInjection = void 0;
const React = __webpack_require__(96540);
/**
 * Tell ads lib to attempt an injection
 *
 * @param {string} componentPrefix - prefix for the cnBus event
 * @returns {undefined} undefined
 */
function attemptAdInjection(componentPrefix) {
    if (true) {
        window.cnBus && window.cnBus.emit(`${componentPrefix}.componentDidUpdate`);
    }
}
exports.attemptAdInjection = attemptAdInjection;
/**
 * React hook encapsulating common ad filled logic/updates. Provides css classes for showing/hiding ads based on ad filled state. Provides a callback that can be passed to an <Ad onFilled={callback} /> component that will update ad filled state
 *
 * @param {string} [suffix] - css show/hide class name suffix
 * @returns {[boolean, string, Function]} - [isFilled, adClass, setAdFilled]
 */
function useOnAdFilled(suffix = 'ad') {
    const [isFilled, setIsFilled] = React.useState(false);
    const onFilled = React.useCallback(() => {
        setIsFilled(true);
    }, []);
    const adClass = `${isFilled ? 'show' : 'hide'}-${suffix}`;
    return [isFilled, adClass, onFilled];
}
exports.useOnAdFilled = useOnAdFilled;
function generateAdNodeId() {
    return Math.random().toString(36).substring(7);
}
exports.generateAdNodeId = generateAdNodeId;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 25203:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isEmpty = __webpack_require__(62193);
const { encodeAffiliateParams, decodeAffiliateParams } = __webpack_require__(75555);
const STANDARD_UTM_PARAMS = ['utm_source', 'utm_term'];
/**
 * Extracts specified query parameters from the current URL.
 * Defaults to STANDARD_UTM_PARAMS if no keys are provided.
 * Skips parameters with empty values.
 *
 * @param {string[]} keys - Array of parameter keys to extract. Defaults to STANDARD_UTM_PARAMS
 * @returns {string} Serialized query string of extracted parameters
 */
const extractTrackingParameters = (keys = STANDARD_UTM_PARAMS) => {
    try {
        const currentUrl = new URL(window.location.href);
        const extractedParams = new URLSearchParams();
        // Extract from query parameters
        keys.forEach((key) => {
            const value = currentUrl.searchParams.get(key);
            if (!isEmpty(value) && value.trim() !== '') {
                extractedParams.set(key, value);
            }
        });
        return extractedParams.toString();
    }
    catch (error) {
        return '';
    }
};
const AFFILIATE_DOMAIN_REGEX = /^(https?:)?\/\/([a-zA-Z0-9]+\.)?cna\.st\/(p|affiliate-link)\//;
/**
 * Encode affiliate link with the query params
 * Enhanced to support both legacy and new parameter formats
 *
 * @param {string} url - Affiliate link url
 * @param {object} affiliateParams - Object containing the params to be encoded
 * @returns {string } url - Updated url
 */
const encodeAffiliateLink = (url, affiliateParams) => {
    const { extractedParams, ...restParams } = affiliateParams;
    try {
        const affiliateLink = AFFILIATE_DOMAIN_REGEX.exec(url);
        Object.assign(restParams, { channel: 'verso' });
        if (!isEmpty(restParams) && affiliateLink?.length) {
            const encode = url.replace(affiliateLink[0], '').replace(/\?.*$/, '');
            const reEncodedParams = encodeAffiliateParams(encode, restParams);
            const searchParams = new URLSearchParams(url.split('?')[1]);
            searchParams.delete('cid');
            // Add extracted tracking parameters to the search parameters
            if (extractedParams?.trim() !== '') {
                const extractedSearchParams = new URLSearchParams(extractedParams);
                extractedSearchParams.forEach((value, key) => {
                    if (value?.trim() !== '') {
                        searchParams.set(key, value);
                    }
                });
            }
            const queryString = searchParams.toString()
                ? `?${searchParams.toString()}`
                : '';
            return `${affiliateLink[0]}${reEncodedParams}${queryString}`;
        }
    }
    catch (err) {
        console.error('Failed to encode affiliate link', err);
    }
    return url;
};
/**
 * Decode affiliated URL
 *
 * @param {string} url - Encoded URL
 * @returns {string} - Returns decoded URL or original Url
 */
const decodeAffiliateLink = (url) => {
    try {
        const affiliateLink = AFFILIATE_DOMAIN_REGEX.exec(url);
        if (affiliateLink?.length) {
            const encode = url.replace(affiliateLink[0], '').replace(/\?.*$/, '');
            return decodeAffiliateParams(encode).offerUrl;
        }
    }
    catch (err) {
        console.error('Failed to decode affiliate link', err);
    }
    return url;
};
module.exports = {
    encodeAffiliateLink,
    decodeAffiliateLink,
    extractTrackingParameters,
    STANDARD_UTM_PARAMS
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 82063:
/***/ ((module) => {

/**
 * Gets Amazon affiliate attributes for a URL for NCA integration
 * @param {string} url - The URL to check
 * @param {string} [amazonAffiliateTag] - Optional Amazon affiliate tag from tenant config
 * @returns {object} - Object with Amazon affiliate attributes if applicable
 */
function getAmazonAffiliateAttributes(url, amazonAffiliateTag) {
    if (!url) {
        return {};
    }
    const asinMatch = url.match(/\/([A-Z0-9]{10})(?:\/|\?|$)/);
    const asin = asinMatch ? asinMatch[1] : '';
    if (!asin) {
        return {};
    }
    const tag = amazonAffiliateTag || '';
    return {
        'data-aps-asin': asin,
        'data-aps-asc-tag': tag
    };
}
module.exports = {
    getAmazonAffiliateAttributes
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 5143:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Generic component type detection utilities for analytics tracking
 *
 * This module provides a centralized way to determine component types
 * for event tracking, prioritizing explicit component props over context detection.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getComponentType = void 0;
/**
 * Generic component type detection utility
 * Prioritizes explicit component prop, falls back to minimal context detection
 *
 * @param {Event} event - The DOM event object
 * @param {string} explicitComponent - Explicitly passed component prop
 * @returns {string} The determined component type
 */
const getComponentType = (event, explicitComponent) => {
    // 1. Highest priority: explicit component prop
    if (explicitComponent) {
        return explicitComponent;
    }
    // 2. Minimal fallback: only detect list context (most reliable)
    return event?.target?.closest?.('li')
        ? 'affiliate_link_list'
        : 'affiliate_link_inline';
};
exports.getComponentType = getComponentType;
//# sourceMappingURL=component-detection-utils.js.map

/***/ }),

/***/ 67911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const unescape = __webpack_require__(75494);
const stripHTML = (text) => text && typeof text === 'string' && text.replace(/<[^>]*>/g, '');
/**
 * Create an object that can be passed into various components as a data-section-title attribute, useful for tracking https://cnissues.atlassian.net/browse/CG-2253
 *
 * @param {boolean} shouldEnableBundleComponentAnalytics - feature flag to enable bundle level component tracking
 * @param {string} dangerousHed - set as the property value of data-section-title
 * @param {number} [itemCount] - Optional which item is this within the container
 * @param {boolean} hasSpaceBeforeItemCount - Optional value for adding space before the item count value
 * @returns {object} an object to be destructured as the data attribute for a specific component
 */
const addDataSectionTitleAttribute = (shouldEnableBundleComponentAnalytics, dangerousHed, itemCount, hasSpaceBeforeItemCount = true) => {
    if (!shouldEnableBundleComponentAnalytics || !dangerousHed) {
        return {};
    }
    let itemCountString;
    if (hasSpaceBeforeItemCount) {
        itemCountString = Number.isInteger(itemCount) ? ` ${itemCount + 1}` : '';
    }
    else {
        itemCountString = Number.isInteger(itemCount) ? `${itemCount + 1}` : '';
    }
    return {
        'data-section-title': `${unescape(stripHTML(dangerousHed))}${itemCountString}`
    };
};
module.exports = {
    addDataSectionTitleAttribute
};
//# sourceMappingURL=component-tracking.js.map

/***/ }),

/***/ 32838:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dynamicConsentPlugin = void 0;
// Add field to caregory mappings for use in removing certain atomic fields
const FIELD_TO_CATEGORY_MAP = {
    // C0001 - Strictly Necessary Cookies (always on)
    aid: ['C0009', 'C0004'],
    tna: ['C0009', 'C0004'],
    eid: ['C0009', 'C0004'],
    page: ['C0009', 'C0004'],
    url: ['C0009', 'C0004'],
    tv: ['C0009', 'C0004'],
    sid: ['C0009', 'C0004'],
    e: ['C0009', 'C0004'],
    p: ['C0009', 'C0004'],
    duid: 'C0004',
    vid: 'C0004',
    uid: 'C0004',
    cs: ['C0009', 'C0004'],
    refr: ['C0009', 'C0004'],
    pp_mix: ['C0009', 'C0004'],
    pp_max: ['C0009', 'C0004'],
    pp_miy: ['C0009', 'C0004'],
    pp_may: ['C0009', 'C0004'],
    ti_ca: ['C0009', 'C0004'],
    ti_cu: ['C0009', 'C0004'],
    ti_nm: ['C0009', 'C0004'],
    ti_id: 'C0004',
    ti_pr: ['C0009', 'C0004'],
    ti_qu: ['C0009', 'C0004'],
    ti_sk: ['C0009', 'C0004'],
    tr_af: ['C0009', 'C0004'],
    tr_ci: ['C0009', 'C0004'],
    tr_co: ['C0009', 'C0004'],
    tr_cu: ['C0009', 'C0004'],
    tr_id: ['C0009', 'C0004'],
    tr_sh: ['C0009', 'C0004'],
    tr_st: ['C0009', 'C0004'],
    tr_tx: ['C0009', 'C0004'],
    tr_tt: ['C0009', 'C0004'],
    ttm: ['C0009', 'C0004'],
    se_category: 'C0004',
    se_action: 'C0004',
    se_label: 'C0004',
    se_property: 'C0004',
    se_value: 'C0004',
    stm: ['C0009', 'C0004'],
    dtm: ['C0009', 'C0004'],
    res: ['C0009', 'C0004'],
    cd: ['C0009', 'C0004'],
    vp: ['C0009', 'C0004'] // viewport width x height
};
// Add mapping of ENTITIES to consent statuses
const ENTITY_TO_CATEGORY_MAP = {
    'iglu:com.condenast/ad/jsonschema/': 'C0004',
    'iglu:com.condenast/audio/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/audio_player/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.snowplowanalytics.snowplow/browser_context/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/campaign/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/cart/jsonschema/': 'C0004',
    'iglu:com.condenast/click_info/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.snowplowanalytics.snowplow/client_session/jsonschema/': 'C0004',
    'iglu:com.condenast/cms_basic/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/collection/jsonschema/': 'C0004',
    'iglu:com.condenast/content/jsonschema/': ['C0009', 'C0004'],
    'iglu:nl.basjes/contexts_nl_basjes_yauaa_context/jsonschema/': 'C0004',
    'iglu:org.ietf/contexts_org_ietf_http_client_hints/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:io.snowplow.ecomm/coupon/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/customer/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/discount/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/dispute/jsonschema/': 'C0004',
    'iglu:com.condenast/encore_content/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/error_info/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/experiments/jsonschema/': 'C0004',
    'iglu:com.iab.snowplow/iab_spiders_and_robots/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:io.snowplow.ecomm/location/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.mobile/mobile_application/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.snowplowanalytics.snowplow/mobile_context/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.mobile/mobile_deep_link/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.snowplowanalytics.mobile/mobile_screen/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.snowplowanalytics.mobile/mobile_screen_summary/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:org.w3/navigation_timing/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/order/jsonschema/': 'C0004',
    'iglu:com.condenast/page/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/page_ads/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/page_template/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/payment/jsonschema/': 'C0004',
    'iglu:com.condenast/product/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/product/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/promotion/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/referrer/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/replacement/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/return/jsonschema/': 'C0004',
    'iglu:com.condenast/save/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/search/jsonschema/': 'C0004',
    'iglu:com.condenast/session/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_cart/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_page/jsonschema/': 'C0004',
    'iglu:com.condenast/site/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/store/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/syndication/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/transaction/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/ua_parser_context/jsonschema/': 'C0004',
    'iglu:com.condenast/user/jsonschema/': 'C0004',
    'iglu:com.condenast/video/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/video_player/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.snowplowanalytics.snowplow/web_page/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/cytokine_state/jsonschema/': 'C0004',
    'iglu:com.condenast/auction/jsonschema/': 'C0004',
    'iglu:com.condenast/consent/jsonschema/': ['C0009', 'C0004']
};
// Add mapping of EVENTS to consent statuses
const EVENT_TO_CATEGORY_MAP = {
    'iglu:io.snowplow.ecomm/add_discount/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/add_payment_method/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/add_shipping/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/add_to_cart/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/add_to_list/jsonschema/': 'C0004',
    'iglu:com.condenast/audio_player_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/begin_checkout/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/cancel_subscription/jsonschema/': 'C0004',
    'iglu:com.condenast/checkout_flow_event/jsonschema/': 'C0004',
    'iglu:com.condenast/click_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/click_item/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/close_dispute/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/cmp_visible/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/commerce_interaction_event/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/complete_checkout/jsonschema/': 'C0004',
    'iglu:com.condenast/content_engagement_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/cookies_action_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/copilot_component_tracking_event/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/copilot_content_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/copilot_pageload_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/create_customer/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/create_dispute/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/create_order/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/delete_customer/jsonschema/': 'C0004',
    'iglu:com.condenast/display_ad_event/jsonschema/': 'C0004',
    'iglu:com.condenast/encore_component_tracking_event/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/field_validation_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.snowplowanalytics.snowplow/link_click/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/messaging_unit_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.snowplowanalytics.mobile/mobile_deep_link_received/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.snowplowanalytics.mobile/mobile_message_notification/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.snowplowanalytics.mobile/mobile_screen_view/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/navigation_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/newsletter_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/non_url_click_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/onboarding_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/page_error_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/pause_subscription/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/remove_from_cart/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/remove_from_list/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/resolve_dispute/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/return_search/jsonschema/': 'C0004',
    'iglu:com.condenast/save_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/search_filter_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/settings_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.shopify/shopify_cart_event/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_change_form/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_checkout/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_focus_form/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_order/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_refund_event/jsonschema/': 'C0004',
    'iglu:com.shopify/shopify_submit_form/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/snowplow_application_error/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.snowplowanalytics.snowplow/consent_preferences/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:io.snowplow.ecomm/submit_search/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/update_customer/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/update_dispute/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/update_order/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/update_quantity/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/update_subscription/jsonschema/': 'C0004',
    'iglu:com.condenast/user_account_event/jsonschema/': 'C0004',
    'iglu:com.condenast/user_preferences_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/video_ad_player_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:com.condenast/video_player_event/jsonschema/': ['C0009', 'C0004'],
    'iglu:io.snowplow.ecomm/view_cart/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/view_collection/jsonschema/': 'C0004',
    'iglu:io.snowplow.ecomm/view_item/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/web_vitals/jsonschema/': [
        'C0009',
        'C0004'
    ],
    'iglu:com.condenast/system_event/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/change_form/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/focus_form/jsonschema/': 'C0004',
    'iglu:com.snowplowanalytics.snowplow/submit_form/jsonschema/': 'C0004'
};
/*
 * This is our primary plugin. It does the following:
 * 1. Gets the event payload and JSON objects
 * 2. Gets the current consent levels
 * 3. Filters `FIELD_TO_CATEGORY_MAP` so only DISALLOWED fields remain
 * 4. Uses the filtered `FIELD_TO_CATEGORY_MAP` to remove atomic fields from the payload
 * 5. Extracts the contexts from the payload JSON
 * 6. Filters `ENTITY_TO_CATEGORY_MAP` so only DISALLOWED entities remain
 * 7. Removes disallowed contexts
 * 8. Uses the `filter` function to check if the event should be tracked at all based on the consent level
 *
 * Arguments:
 * @param {Object} options - Configuration options for the plugin
 * @param {Function} options.consentCallback - A function that returns the current consent status
 *                                            The function should return an object with consent categories
 *                                            as keys (e.g., C0001, C0002, etc.) and boolean values
 *                                            indicating whether consent is granted for that category
 */
exports.dynamicConsentPlugin = {
    consentChecker(options) {
        return {
            beforeTrack(payloadBuilder) {
                const payloadToTrack = payloadBuilder.getPayload();
                const payloadJson = payloadBuilder.getJson();
                if (!options.consentCallback)
                    return;
                let currentConsent;
                try {
                    currentConsent = options.consentCallback();
                }
                catch {
                    return;
                }
                const fieldsToRemove = Object.entries(FIELD_TO_CATEGORY_MAP)
                    .filter(([_, value]) => {
                    if (Array.isArray(value)) {
                        return !value.some((cat) => currentConsent[cat]);
                    }
                    return !currentConsent[value];
                })
                    .map(([key]) => key);
                fieldsToRemove.forEach((field) => delete payloadToTrack[field]);
                let contextItems = [];
                const eventContexts = [];
                Object.values(payloadJson).forEach((value) => {
                    if (value?.json?.schema ===
                        'iglu:com.snowplowanalytics.snowplow/contexts/jsonschema/1-0-0') {
                        contextItems = Array.isArray(value.json.data)
                            ? value.json.data
                            : [];
                        contextItems.forEach((item) => {
                            if (item?.schema) {
                                const [prefix] = item.schema.split('/jsonschema/');
                                eventContexts.push({
                                    schema: `${prefix}/jsonschema/`,
                                    data: item.data,
                                    originalSchema: item.schema
                                });
                            }
                        });
                    }
                });
                const entitiesToRemove = Object.entries(ENTITY_TO_CATEGORY_MAP)
                    .filter(([_, value]) => {
                    if (Array.isArray(value)) {
                        return !value.some((cat) => currentConsent[cat]);
                    }
                    return !currentConsent[value];
                })
                    .map(([key]) => key);
                // This step removes any context entities that are not allowed based on the user's consent preferences
                // We check each context schema against our list of entities to remove (entitiesToRemove)
                // If a context's schema contains any entity name that should be removed, it will be filtered out
                // Only contexts that don't match any disallowed entities will be kept
                const allowedContexts = eventContexts.filter((context) => !entitiesToRemove.some((entity) => context.schema.includes(entity)));
                const filteredContextsData = allowedContexts.map((context) => ({
                    schema: context.originalSchema,
                    data: context.data
                }));
                // Update the payload with filtered contexts and set it back on the payloadJson object
                Object.values(payloadJson).forEach((value) => {
                    if (value?.json?.schema ===
                        'iglu:com.snowplowanalytics.snowplow/contexts/jsonschema/1-0-0') {
                        value.json.data = filteredContextsData;
                    }
                });
            },
            // Uses the `filter` function to check if the event should be tracked at all based on the consent level
            filter(payload) {
                let currentConsent;
                const consentPreferenceChecker = payload.ue_px || payload.ue_pr;
                if (consentPreferenceChecker?.includes('consent_preferences') &&
                    consentPreferenceChecker.includes('withdrawn')) {
                    return false;
                }
                try {
                    currentConsent = options.consentCallback();
                }
                catch {
                    return false;
                }
                if (['pv', 'pp', 'se'].includes(payload.e) &&
                    (currentConsent.C0009 || currentConsent.C0004)) {
                    return true;
                }
                if (payload.e === 'ue' && (payload.ue_px || payload.ue_pr)) {
                    try {
                        const dataStr = payload.ue_px ? atob(payload.ue_px) : payload.ue_pr;
                        const unstructEvent = JSON.parse(dataStr).data;
                        const { schema } = JSON.parse(dataStr);
                        if (schema ===
                            'iglu:com.snowplowanalytics.snowplow/unstruct_event/jsonschema/1-0-0') {
                            const [prefix] = unstructEvent.schema.split('/jsonschema/');
                            const lookup = `${prefix}/jsonschema/`;
                            const category = EVENT_TO_CATEGORY_MAP[lookup];
                            if (Array.isArray(category)) {
                                return category.some((cat) => currentConsent[cat]);
                            }
                            if (typeof category === 'string') {
                                return currentConsent[category] ?? false;
                            }
                        }
                    }
                    catch {
                        return false;
                    }
                }
                return false;
            }
        };
    }
};
//# sourceMappingURL=dynamicConsentPlugin.js.map

/***/ }),

/***/ 13446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FingerprintJS = exports.FPJS_ERROR_EVENT = exports.FPJS_ID_EVENT = exports.FPJS_VISITOR_EVENT = void 0;
const Fingerprint = __importStar(__webpack_require__(73396));
const cookie_1 = __importDefault(__webpack_require__(56892));
const is_bot_1 = __webpack_require__(9170);
const utils_1 = __webpack_require__(64687);
const tools_1 = __webpack_require__(34854);
exports.FPJS_VISITOR_EVENT = 'fingerprintjs.visitor';
exports.FPJS_ID_EVENT = 'fingerprintjs.id';
exports.FPJS_ERROR_EVENT = 'fingerprintjs.error';
const parseBool = (val) => (val === 'false' ? false : Boolean(val));
class FingerprintJS {
    constructor({ publicKey, isEnabled, cookieExpire }) {
        this.hasConsent = false;
        this.cookieExpire = 0;
        this.visitorId = null;
        this.incognito = null;
        this.geo = null;
        this.fpClient = Promise.resolve(null);
        this.hasConsent = (0, tools_1.hasNonAnonymousConsent)() || (0, utils_1.hasTargetingConsent)();
        this.cookieExpire = cookieExpire;
        this.setVisitor({
            visitorId: cookie_1.default.getCookie('FP_visitorID'),
            incognito: cookie_1.default.getCookie('FP_incognito')
        });
        this.geo = cookie_1.default.getCookie('CN_geo_country_code');
        if (isEnabled && this.geo === 'US' && !(0, is_bot_1.isBot)(window.navigator.userAgent)) {
            window?.cnBus?.on('journey.ready', () => {
                const visitor = this.getVisitor();
                if (visitor.visitorId) {
                    this.emitFpData(exports.FPJS_VISITOR_EVENT, visitor);
                    this.emitFpData(`${exports.FPJS_ID_EVENT}.${visitor.visitorId}`);
                }
            });
            if (!this.getVisitor().visitorId) {
                this.loadClient(publicKey);
            }
            if (this.hasConsent) {
                this.fetchVisitor();
            }
        }
    }
    loadClient(publicKey) {
        this.fpClient = Fingerprint.load({
            apiKey: publicKey,
            scriptUrlPattern: [
                '/c0d5a332bda245b9/a298b7d4e1c1836e?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>',
                FingerprintJS.defaultScriptUrlPattern
            ],
            endpoint: [
                '/c0d5a332bda245b9/e5cd4319ed4842c1?region=us',
                FingerprintJS.defaultEndpoint
            ]
        });
    }
    updateConsent(consentGroups) {
        const consentState = (0, utils_1.getConsentStateFromList)(consentGroups);
        const oldConsent = this.hasConsent;
        this.hasConsent = consentState.targeting;
        // only fetch/emit if we didn't have consent before and now we do
        if (!oldConsent && consentState.targeting) {
            this.fetchVisitor();
        }
    }
    async fetchVisitor() {
        let currentVisitor = this.getVisitor();
        if (currentVisitor.visitorId) {
            this.emitFpData(exports.FPJS_VISITOR_EVENT, currentVisitor);
            this.emitFpData(`${exports.FPJS_ID_EVENT}.${currentVisitor.visitorId}`);
            return currentVisitor;
        }
        const client = await this.fpClient;
        if (client && this.hasConsent) {
            let result;
            try {
                result = await client.get({
                    linkedId: cookie_1.default.getCookie('CN_xid'),
                    extendedResult: true
                });
                currentVisitor = this.setVisitor(result);
                this.setFPCookies(currentVisitor);
                this.emitFpData(exports.FPJS_VISITOR_EVENT, currentVisitor);
                this.emitFpData(`${exports.FPJS_ID_EVENT}.${currentVisitor.visitorId}`);
            }
            catch (err) {
                this.emitFpData(exports.FPJS_ERROR_EVENT, err.message);
            }
        }
        return this.getVisitor();
    }
    getVisitor() {
        const { visitorId, incognito } = this;
        return {
            visitorId,
            incognito
        };
    }
    setVisitor(fpData) {
        this.visitorId = fpData.visitorId || null;
        this.incognito = parseBool(fpData.incognito) || false;
        return this.getVisitor();
    }
    setFPCookies({ visitorId, incognito }) {
        document.cookie = cookie_1.default.createCookie('FP_visitorID', `${visitorId}`, {
            path: '/',
            expirationInMs: this.cookieExpire
        });
        document.cookie = cookie_1.default.createCookie('FP_incognito', `${incognito}`, {
            path: '/',
            expirationInMs: this.cookieExpire
        });
    }
    emitFpData(event, payload) {
        if (window?.cnBus && this.hasConsent) {
            window.cnBus.emit(event, payload);
        }
    }
}
exports.FingerprintJS = FingerprintJS;
//# sourceMappingURL=fingerprint.js.map

/***/ }),

/***/ 37402:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const cloneDeep = __webpack_require__(88055);
const isEqual = __webpack_require__(2404);
const paywallSourceHelper = __webpack_require__(70060);
const emittedUniqueGoogleTrackingEvents = [];
/**
 * Emits a Google Tracking event by add to the window's dataLayer.
 *
 * @param {string} event - event name
 * @param {object} variablesIn - arbitrary variables to merge into the event
 *
 * @returns {undefined} undefined
 */
const emitGoogleTrackingEvent = (event, variablesIn = {}) => {
    if (!Array.isArray(window.dataLayer)) {
        return;
    }
    const paywallSource = paywallSourceHelper.getPaywallSource();
    const variables = {
        ...variablesIn,
        ...(paywallSource && { paywallSource })
    };
    emittedUniqueGoogleTrackingEvents.push(cloneDeep({ event, variables }));
    window.dataLayer.push({
        event,
        ...variables
    });
};
/**
 * Emits a Google Tracking event by add to the window's dataLayer, only
 * if that event has not been triggered previously.
 *
 * @param {string} event - event name
 * @param {object} variables - arbitrary variables to merge into the event
 *
 * @returns {undefined} undefined
 */
const emitUniqueGoogleTrackingEvent = (event, variables = {}) => {
    const toBeEmmittedEvent = cloneDeep({
        event,
        variables
    });
    const eventPreviouslyTracked = emittedUniqueGoogleTrackingEvents.some((emittedEvent) => isEqual(emittedEvent, toBeEmmittedEvent));
    if (eventPreviouslyTracked) {
        return;
    }
    emitGoogleTrackingEvent(event, variables);
};
/**
 * Tracks a Google pageview by pushing a single event to the stack.
 *
 * @param {string} pageValue - pagination indicator (currently, only defined for slideshows).
 *
 * @returns {undefined} undefined
 */
const trackPageView = (pageValue) => emitGoogleTrackingEvent('data-layer-loaded', { content: { pageValue } });
/**
 * Add a new pageTypeProperties "|"" delimited string
 *
 * @param {string} oldTypeValues - existing pageTypeProperties
 * @param {string} newTypeValue - new type to add to pageTypeProperties
 *
 * @returns {string} - Pipe delimited string of pageTypeProperties
 */
const addPageTypeProperty = (oldTypeValues, newTypeValue) => {
    if (!oldTypeValues || typeof oldTypeValues !== 'string') {
        return newTypeValue;
    }
    return [...new Set(oldTypeValues.split('|')).add(newTypeValue)].join('|');
};
module.exports = {
    emitGoogleTrackingEvent,
    emitUniqueGoogleTrackingEvent,
    trackPageView,
    addPageTypeProperty
};
//# sourceMappingURL=google-analytics.js.map

/***/ }),

/***/ 90090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const componentTracking = __webpack_require__(67911);
const googleAnalytics = __webpack_require__(37402);
const patternTracking = __webpack_require__(42020);
module.exports = {
    componentTracking,
    googleAnalytics,
    patternTracking
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 42020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// eslint-disable-next-line global-require
const sparrow =  true && __webpack_require__(31170);
const INTERSECTION_THRESHOLD = 0.5;
const WINDOW_EVENT_TYPES = {
    CLICK: 'click',
    FOCUS: 'focus'
};
const CALL_OUT_ATTRIBUTE_PATTERN = JSON.stringify({
    pattern: 'GenericCallout'
});
/**
 * Parses raw event object as JSON.
 *
 * @param {string} rawEvent - The stringified object representing event data
 * @returns {object} The parsed object literal representing event data
 */
function getEventObj(rawEvent) {
    let parsed;
    try {
        parsed = JSON.parse(rawEvent);
    }
    catch (e) {
        console.warn('Unable to parse pattern-tracking JSON data', e);
    }
    return parsed;
}
/**
 * Reads the global experiments analytics value and returns.
 *
 * @returns {object|undefined} The experiments analytics object or undefined
 */
function getExperimentsObj() {
    return ((window.dataLayer &&
        window.dataLayer[0] &&
        window.dataLayer[0].experiments) ||
        undefined);
}
/**
 * Whether target requires that experiments data be included.
 *
 * @param {object} target - DOM element
 * @returns {boolean} Whether to include.
 */
function shouldIncludeExperiments(target) {
    return target.getAttribute('data-include-experiments') === 'true';
}
/**
 * Whether we are ready to send analytics, based on the presence or absence of experiments.
 *
 * @param {boolean} includeExperiments - Whether to include experiments data
 * @returns {boolean} Whether we are ready
 */
function readyToSend(includeExperiments) {
    if (includeExperiments) {
        if (getExperimentsObj()) {
            return true;
        }
        return false;
    }
    return true;
}
/**
 * Sends data to sparrow.
 *
 * @param {string} event - The event type, to use as key in sent data
 * @param {object} payload - The object literal representing event data, to be used as value in sent data
 * @param {boolean} includeExperiments - Whether to include experiments data
 * @returns {undefined} undefined
 */
function sendIt(event, payload, includeExperiments) {
    const payloads = {
        dim5: JSON.stringify(payload)
    };
    if (includeExperiments) {
        payloads.dim6 = JSON.stringify(getExperimentsObj());
    }
    sparrow.trackSparrowEvent('verso-pattern-tracking', event, payloads);
}
/**
 * Returns whether the target element is valid from the perspective of deriving event data from data attributes
 *
 * @param {object} target - DOM element
 * @returns {boolean} Whether the target element is valid
 */
function isValidTarget(target) {
    return target && document && target !== document && target.id !== 'root';
}
/**
 * Returns whether the target element is a valid event boundary from the perspective of present data attributes.
 *
 * @param {object} target - DOM element
 * @param {string} event - String representation of event type to gather data for
 * @returns {boolean} Whether the target element is a valid event boundary
 */
function isValidBoundary(target, event) {
    return (isValidTarget(target) &&
        target.getAttribute('data-event-boundary') &&
        target.getAttribute('data-event-boundary').indexOf(event) !== -1);
}
/**
 * Gets data from boundary element data attribute.
 *
 * @param {object} target - DOM element
 * @param {string} event - String representation of event type to gather data for
 * @returns {Array} Array of data attribute values gathered
 */
function getDataFromBoundary(target, event) {
    const data = [];
    if (isValidBoundary(target, event)) {
        const dataEvent = getEventObj(target.getAttribute(`data-event-${event}`));
        const passthrough = getEventObj(target.getAttribute('data-event-passthrough'));
        if (dataEvent) {
            data.push(dataEvent);
        }
        if (passthrough) {
            data.push(passthrough);
        }
    }
    return data;
}
/**
 * Whether to include the experiments data in the data.
 *
 * @param {object} target - DOM element
 * @param {string} event - String representation of event type to gather data for
 * @returns {boolean} includeExperiments - Whether to include experiments data
 */
function getIncludeExperimentsFromBoundary(target, event) {
    if (isValidBoundary(target, event)) {
        return shouldIncludeExperiments(target);
    }
    return false;
}
/**
 * Starting at initial event target, walks tree up to boundary element, gathering data from data attributes.
 *
 * @param {object} el - DOM element
 * @param {string} event - String representation of event type to gather data for
 * @returns {{data: Array, target: object}} Array of data attribute values gathered, DOM element of terminal (boundary) element
 */
function getDataUpToBoundary(el, event) {
    const data = [];
    let { target } = el;
    for (target; isValidTarget(target) &&
        (target.getAttribute('data-event-boundary') || '').indexOf(event) === -1; target = target.parentNode) {
        const dataEvent = getEventObj(target.getAttribute(`data-event-${event}`));
        const passthrough = getEventObj(target.getAttribute('data-event-passthrough'));
        if (dataEvent) {
            data.push(dataEvent);
        }
        if (passthrough) {
            data.push(passthrough);
        }
    }
    return { data, target };
}
/**
 * Starting at initial event target, walks tree up to boundary element, gathering data from data attributes.
 *
 * @param {object} el - DOM element
 * @returns {boolean} - Boolean value if element is child of GenericCallout
 */
function determineIfCallOutChild(el) {
    const { parentNode } = el;
    const shouldStopParentNodeRecursion = !parentNode;
    const dataEventClickAttribute = (el.getAttribute && el.getAttribute('data-event-click')) || '';
    const isCalloutElement = dataEventClickAttribute === CALL_OUT_ATTRIBUTE_PATTERN;
    if (isCalloutElement) {
        return true;
    }
    if (shouldStopParentNodeRecursion) {
        return false;
    }
    return determineIfCallOutChild(parentNode);
}
/**
 * Starting at initial event target, walks tree up to boundary element, gathering data from data attributes.
 *
 * @param {object} el - DOM element
 * @returns {object} - DOM element
 */
function findParentAnchorTarget(el) {
    const { parentNode, tagName } = el;
    const isAnchorTag = tagName === 'A';
    const dataEventClickAttribute = (el.getAttribute && el.getAttribute('data-event-click')) || '';
    const isCalloutElement = dataEventClickAttribute === CALL_OUT_ATTRIBUTE_PATTERN;
    const shouldStopParentNodeRecursion = !parentNode;
    if (isAnchorTag) {
        return el;
    }
    if (isCalloutElement) {
        return null;
    }
    if (shouldStopParentNodeRecursion) {
        return null;
    }
    return findParentAnchorTarget(parentNode);
}
/**
 * Attach event listener.
 *
 * @param {string} event - String representation of event to listen for
 * @returns {undefined} undefined
 */
function sparrowCallback(el, event) {
    const allData = [];
    const { data, target } = getDataUpToBoundary(el, event);
    allData.push(...data);
    allData.push(...getDataFromBoundary(target, event));
    const includeExperiments = getIncludeExperimentsFromBoundary(target, event);
    if (allData.length && readyToSend(includeExperiments)) {
        sendIt(event, allData, includeExperiments);
    }
}
/**
 * Will emit a data layer event if element is an anchor tag and child of a call out element
 *
 * @param {object} el - DOM element
 * @returns {undefined} undefined
 */
function callOutLinkCallback(el) {
    const anchorTarget = findParentAnchorTarget(el.target);
    if (anchorTarget) {
        const isChildOfCallOut = determineIfCallOutChild(anchorTarget);
        const dataLayerExists = Array.isArray(window.dataLayer);
        const shouldEmitDataLayerEvent = isChildOfCallOut && dataLayerExists;
        if (shouldEmitDataLayerEvent) {
            const href = anchorTarget.getAttribute('href');
            const analyticsData = {
                event: 'article-callout-click',
                'gtm.elementUrl': href
            };
            window.dataLayer.push(analyticsData);
        }
    }
}
/**
 * Will call appropriate funtions based on strategy
 *
 * @param {object} el - DOM element
 * @param {object} event - DOM event type
 * @returns {undefined} undefined
 */
const clickStrategy = (el, event) => {
    callOutLinkCallback(el);
    sparrowCallback(el, event);
};
/**
 * Will call appropriate funtions based on strategy
 *
 * @param {object} el - DOM element
 * @param {object} event - DOM event type
 * @returns {undefined} undefined
 */
const focusStrategy = (el, event) => {
    sparrowCallback(el, event);
};
const windowEventStrategies = new Map([
    [WINDOW_EVENT_TYPES.CLICK, clickStrategy],
    [WINDOW_EVENT_TYPES.FOCUS, focusStrategy]
]);
/**
 * Will emit a data layer event if element is an anchor tag and child of a call out element
 *
 * @param {string} eventType - DOM handler type
 * @returns {undefined} undefined
 */
function listen(eventType) {
    document.addEventListener(eventType, (el) => {
        const eventHandlerStrategy = windowEventStrategies.get(eventType);
        eventHandlerStrategy(el, eventType);
    }, true);
}
/**
 * Gather data from valid elements observed by IntersectionObserver.
 *
 * @param {Array<object>} entries - IntersectionObserver entries (DOM elements) to gather data from
 * @returns {undefined} undefined
 */
function observeData(entries) {
    const allData = [];
    entries.forEach((entry) => {
        if (entry.isIntersecting) {
            let { target } = entry;
            let data;
            let attribute = 'data-in-view';
            if (target.getAttribute(attribute)) {
                data = getEventObj(target.getAttribute(attribute));
            }
            else {
                attribute = 'data-child-in-view';
                target = target.parentNode;
                if (target.getAttribute(attribute)) {
                    data = getEventObj(target.getAttribute(attribute));
                }
            }
            !!data && allData.push(data);
            const includeExperiments = shouldIncludeExperiments(target);
            if (allData.length && readyToSend(includeExperiments)) {
                target.removeAttribute(attribute);
                sendIt('in-view', allData, includeExperiments);
            }
        }
    });
}
/**
 * Initialize IntersectionObserver for DOM elements with `data-in-view` attributes,
 * and for DOM elements who are children of elements with `data-child-in-view` attributes.
 *
 * @returns {undefined} undefined
 */
function observe() {
    const config = { threshold: INTERSECTION_THRESHOLD };
    const observer = new IntersectionObserver(observeData, config);
    const targets = document.querySelectorAll('*[data-in-view], *[data-child-in-view] > *');
    [].slice.call(targets).forEach((target) => {
        observer.observe(target);
    });
}
/**
 * Initialize listening & observation.
 *
 * @returns {undefined} undefined
 */
function init() {
    listen(WINDOW_EVENT_TYPES.CLICK);
    listen(WINDOW_EVENT_TYPES.FOCUS);
    observe();
}
module.exports = init;
//# sourceMappingURL=pattern-tracking.js.map

/***/ }),

/***/ 70060:
/***/ ((module) => {

/**
 * Returns an identifier representing the paywall barrier that
 * originated the traffic to the page that calls this function
 *
 * @returns {string} - the paywall barrier type
 */
const getPaywallSource = () => {
    const paywallSource = 
    /**
      URLSearchParams is not supported is iOS9. ESLint cannot detect that we
      are doing a feature detect so it is ok to ignore the rule for this case.
     */
    /* eslint-disable compat/compat */
    window.URLSearchParams &&
        new window.URLSearchParams(window.location.search).get('paywallSource');
    /* eslint-enable compat/compat */
    return ['half-barrier', 'paywall-bar-reg'].includes(paywallSource)
        ? paywallSource
        : '';
};
module.exports = {
    getPaywallSource
};
//# sourceMappingURL=paywall.js.map

/***/ }),

/***/ 14307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trackCeros = exports.trackUserAccountEvent = exports.trackContentEngagementEvent = exports.trackSearchFilterEvent = exports.trackClickEvent = exports.trackClipEvent = exports.trackConsentPending = exports.trackNavigationEvent = exports.trackAffiliateLinks = exports.handleAffiliateLinkClick = exports.trackCommerceInteractionEvent = exports.trackSaveEventWithContext = exports.buildSaveImageContext = exports.trackMessageUnitEvent = exports.trackSaveEvent = exports.trackNewsletterEvent = exports.trackCookiesEvent = exports.nonURLClickEvent = exports.trackPageErrorEvent = exports.initializeSnowplowTracker = exports.getUserConsentPreferences = exports.hasTargetConsentFromCookie = exports.getSnowplowDomainUserId = exports.setExperimentsEntity = exports.setUserContext = exports.getEmailSha = exports.getConsentGroups = exports.extractStrategyFromURL = exports.dynamicConsentSlugs = exports.affiliateDomainsList = exports.amgUserId = exports.cn_xid = exports.findNearestAnchor = exports.getSubscriptionData = exports.extractConsentGroups = exports.disableAnonymousTracking = exports.testingBrands = void 0;
const cn_snowplow_web_1 = __webpack_require__(43954);
const crypto_js_1 = __webpack_require__(21396);
const dynamicConsentPlugin_1 = __webpack_require__(32838);
const query_params_1 = __webpack_require__(12311);
const fingerprint_1 = __webpack_require__(13446);
const tools_1 = __webpack_require__(34854);
const types_1 = __webpack_require__(84410);
const jwt_decode = (__webpack_require__(6765)["default"]);
const cloneDeep = __webpack_require__(88055);
const isEqual = __webpack_require__(2404);
const queryString = __webpack_require__(86663);
const { getCookie } = __webpack_require__(56892);
const { getCookieFromPrefix } = __webpack_require__(56892);
const { storageFactory } = __webpack_require__(60663);
const oneTrustExtractConsentGroups = (cookieValue = null) => {
    const parseCookie = queryString.parse(cookieValue || getCookie('OptanonConsent'));
    // To handle cookies that doesn't have groups value
    if (!parseCookie || !parseCookie.groups)
        return null;
    const consentGroups = parseCookie.groups;
    const groupPairs = consentGroups.split(',');
    const consentedGroups = groupPairs
        .filter((pair) => pair.endsWith(':1'))
        .map((pair) => pair.split(':')[0]);
    return consentedGroups.length ? consentedGroups.join(',') : null;
};
exports.testingBrands = ['them', 'stg-them', 'cnt-de', 'stg-cnt-de'];
/**
 * disableAnonymousTracking call.
 *
 * @param {boolean} shouldDisableAnonymousTracking - Whether to disable anonymous tracking
 * @param {string} _environment - The current environment (e.g., 'production', 'staging')
 * @param {string[]} _brandSlug - List of active brand slugs (e.g., ['vogue', 'gq'])
 */
function disableAnonymousTracking(shouldDisableAnonymousTracking, _environment = 'production', _brandSlug = []) {
    const normalizedSlugs = Array.isArray(_brandSlug) ? _brandSlug : [_brandSlug];
    const cookieTestBrand = _environment !== 'production' &&
        normalizedSlugs.some((brand) => exports.testingBrands.includes(brand));
    const strategy = cookieTestBrand ? 'localStorage' : 'cookieAndLocalStorage';
    window.snowplowInitQueue.push(() => {
        if (shouldDisableAnonymousTracking) {
            window.snowplowCN('disableAnonymousTracking', {
                stateStorageStrategy: 'cookieAndLocalStorage'
            });
        }
        else {
            if (cookieTestBrand) {
                window.snowplowCN('clearUserData', {
                    preserveSession: true,
                    preserveUser: true
                });
            }
            window.snowplowCN('enableAnonymousTracking', {
                options: {
                    withServerAnonymisation: true,
                    withSessionTracking: true
                },
                stateStorageStrategy: strategy
            });
        }
    });
}
exports.disableAnonymousTracking = disableAnonymousTracking;
const extractConsentGroups = (cookieValue = null) => {
    // Could check sample & header instead
    if (window.Fides) {
        return (0, tools_1.fidesExtractConsentGroupsAsOtString)();
    }
    return oneTrustExtractConsentGroups(cookieValue);
};
exports.extractConsentGroups = extractConsentGroups;
const getSubscriptionData = () => {
    const CN_access = getCookie('CN_access') || getCookie('CN_token_access');
    let subscriptionData = {};
    if (CN_access) {
        const decoded = jwt_decode(CN_access);
        const currentDomain = window?.dataLayer[0]?.content?.brandSlug?.replace(/-/g, '');
        const filteredOrgAccess = decoded?.fct &&
            decoded?.fct['org-access']?.filter((element) => {
                const elementDomain = element?.split(':')[0];
                return currentDomain?.indexOf(elementDomain.split('.')[0]) !== -1;
            });
        subscriptionData = {
            subscriptions: (decoded?.fct && decoded?.fct['org-access']) || [],
            brand_subscription: filteredOrgAccess || []
        };
    }
    return subscriptionData;
};
exports.getSubscriptionData = getSubscriptionData;
function findNearestAnchor(initialElement) {
    let element = initialElement;
    while (element && element.tagName !== 'A') {
        element = element.parentElement;
    }
    return element;
}
exports.findNearestAnchor = findNearestAnchor;
exports.cn_xid = getCookie('CN_xid');
exports.amgUserId = getCookie('amg_user_partner');
const localStore = storageFactory(() => window.localStorage);
const OneTrustGroupCookieList = [
    'C0001',
    'C0002',
    'C0003',
    'C0004',
    'C0005',
    'C0009'
];
exports.affiliateDomainsList = [
    'amazon',
    'amzn',
    'cna.st',
    'skimresources'
];
// Below is temporary, after testing, shall be applied to all tenants
// Slugs that allow enabling the dynamic consent plugin feature
exports.dynamicConsentSlugs = [
    'houseandgarden',
    'glamour-uk',
    'vogue-uk',
    'gq-uk',
    'conde-nast-traveller-uk',
    'tatler',
    'woi',
    'ad-de',
    'cnt-de',
    'glamour-de',
    'gq-de',
    'vogue-de',
    'ad-es',
    'conde-nast-traveler-espana',
    'glamour-es',
    'gq-espana',
    'vanity-fair-es',
    'vogue-es',
    'ad-it',
    'gq-italia',
    'la-cucina-italiana-italy',
    'vanity-fair-it',
    'vogue-it',
    'wired-it'
];
function getAffiliateLinksInnerText() {
    const affiliateLinks = window?.document?.querySelectorAll('.external-link');
    const result = [];
    affiliateLinks.forEach((link) => {
        const href = link.getAttribute('href');
        if (href) {
            if (exports.affiliateDomainsList.some((domain) => href.includes(domain))) {
                result.push(link.innerText);
            }
        }
    });
    return result;
}
function getURLOrigin(href) {
    if (!href) {
        return '';
    }
    try {
        return new URL(href).origin;
    }
    catch (e) {
        return '';
    }
}
const containsAnyAffiliateDomain = (string = '', keywords = []) => keywords.some((keyword) => string.includes(keyword));
const emitUniqueNavigationEvent = [];
const emitUniqueContentEngagementEvent = [];
const isValidUUID = (uuid) => {
    const flag = uuid?.match('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$');
    return flag !== null;
};
const extractStrategyFromURL = (url) => {
    if (!url) {
        return null;
    }
    const parts = url.split('#');
    if (parts.length > 1) {
        const subparts = parts[1].split('_');
        if (subparts.length > 0) {
            return subparts.pop();
        }
    }
    return null;
};
exports.extractStrategyFromURL = extractStrategyFromURL;
const filtersOTGroupArray = (OTGroup) => {
    const resultOTGroup = OTGroup.filter((element) => OneTrustGroupCookieList.includes(element));
    return resultOTGroup;
};
const getConsentGroups = () => {
    const groupBuilder = (0, exports.extractConsentGroups)();
    if (groupBuilder) {
        const OTGroup = groupBuilder.split(',');
        return filtersOTGroupArray(OTGroup);
    }
    else if (window.OnetrustActiveGroups) {
        const OTGroup = window.OnetrustActiveGroups?.split(',')?.slice(1, -1);
        return filtersOTGroupArray(OTGroup);
    }
    return [null];
};
exports.getConsentGroups = getConsentGroups;
function getEmailSha() {
    const OTGroup = (0, exports.extractConsentGroups)()?.split(',') ||
        window.OnetrustActiveGroups?.split(',')?.slice(1, -1);
    let email_sha = null;
    if (Array.isArray(OTGroup) && OTGroup.includes('C0004')) {
        const token = getCookie('CN_token_id');
        let encodedEmail = null;
        if (token) {
            try {
                const decodedToken = JSON.parse(window.atob(token.split('.')[1] || ''));
                const email = decodedToken?.email;
                encodedEmail = email ? (0, crypto_js_1.SHA256)(email).toString() : null;
            }
            catch (error) {
                console.error(error);
            }
        }
        const queryParams = queryString.parse(window.location.search.toLowerCase());
        email_sha = encodedEmail || queryParams?.hashc || queryParams?.uid || null;
    }
    return email_sha;
}
exports.getEmailSha = getEmailSha;
const setUserContext = (props) => {
    const userObj = props[1];
    const timeZoneOffsetInMinutes = new Date().getTimezoneOffset();
    const timeZoneOffsetInHours = timeZoneOffsetInMinutes / 60;
    const searchUrlParams = new URLSearchParams(window.location.search);
    const userMbid = searchUrlParams.get('mbid');
    const user_amg_id = isValidUUID(userObj.amguuid) ? userObj.amguuid : null;
    const user_xid = isValidUUID(exports.cn_xid) ? exports.cn_xid : null;
    const currentDate = new Date();
    const otButton = document.getElementById('onetrust-pc-btn-handler');
    const otButtonStyle = otButton && window.getComputedStyle(otButton, ':after');
    const otButtonContent = otButtonStyle?.getPropertyValue('content');
    const mdwId = queryString.parse(window.location.search.toLowerCase())?.cndid || null;
    return {
        schema: 'iglu:com.condenast/user/jsonschema/11-0-0',
        data: {
            xid: user_xid,
            amg_id: user_amg_id,
            is_logged_in: user_amg_id !== null,
            bucket: parseInt(localStore.getItem('usr_bkt_eva'), 10),
            browser: window.navigator.appName,
            browser_version: window.navigator.appVersion,
            time_zone_offset: parseInt(timeZoneOffsetInHours, 10) || 0,
            monthly_visit_no: window.dataLayer[0]?.user?.monthlyVisits || 0,
            monthly_content_count: window.dataLayer[0]?.user?.contentVisits || 0,
            onetrust_active_groups: (0, exports.getConsentGroups)(),
            mdw_id: mdwId,
            local_visit_hour: currentDate.getHours(),
            mbid: userMbid,
            consent_banner_variant: window.Fides
                ? 'fides'
                : otButtonContent?.toString() || null,
            fingerprint_visitor_id: null,
            email_sha256: getEmailSha(),
            ...(0, exports.getSubscriptionData)()
        }
    };
};
exports.setUserContext = setUserContext;
const setSessionContext = () => {
    return {
        schema: 'iglu:com.condenast/session/jsonschema/2-0-2',
        data: {
            dmdid: getCookie('dmd-sid'),
            fingerprint_incognito_mode: null
        }
    };
};
const setExperimentsEntity = () => {
    let experimentsList = [];
    const dataLayer = window?.dataLayer;
    // Server side events
    if (dataLayer &&
        dataLayer[0]?.experiments &&
        Array.isArray(dataLayer[0]?.experiments)) {
        experimentsList = dataLayer[0]?.experiments;
    }
    return experimentsList?.map((item) => {
        // Server side events
        if (item.status === types_1.ExperimentAssignmentTypes.EDGE_ASSIGNMENT ||
            item.status === types_1.ExperimentAssignmentTypes.CLIENT_ASSIGNMENT) {
            return {
                experiment_id: item.experiment_id || null,
                feature_id: item.feature_id || null,
                variation: item.variation || null,
                variation_name: item.variation_name || null
            };
        }
        return {}; // shouldn't happen
    });
};
exports.setExperimentsEntity = setExperimentsEntity;
/**
 * Create context entities and add to global context
 *
 * @param {string} props - array of properties
 * @returns {undefined} undefined
 */
// eslint-disable-next-line complexity
const setGlobalContext = (props) => {
    const contentObj = props[0].content;
    const siteObj = props[0].site;
    const syndicationObj = props[0].syndication;
    const pageObj = props[0].page;
    const searchUrlParams = new URLSearchParams(window.location.search);
    const urlArr = window.location?.pathname?.split('/');
    const currentDate = new Date();
    const pubDate = new Date(contentObj.publishDate);
    const timeSincePublished = Math.ceil((currentDate - pubDate) / (1000 * 60 * 60 * 24));
    const userContext = (0, exports.setUserContext)(props);
    const pageContext = {
        schema: 'iglu:com.condenast/page/jsonschema/6-0-1',
        data: {
            functional_tags: contentObj.functionalTags,
            has_buy_button: contentObj.hasBuyButtons === 'true',
            path_level_1: urlArr[1] || '',
            path_level_2: urlArr[2] || '',
            path_level_3: urlArr[3] || '',
            path_level_4: urlArr[4] || '',
            tab_active: window.document.visibilityState === 'visible',
            canonical_url: document.querySelector("link[rel='canonical']")?.getAttribute('href') ||
                null,
            clean_url: window.location.origin + window.location.pathname
        }
    };
    const contentContext = {
        schema: 'iglu:com.condenast/content/jsonschema/2-0-1',
        data: {
            no_of_article_revisions: parseInt(contentObj.noOfRevisions, 10) || null,
            editor_name: contentObj.editorNames,
            author_name: contentObj.authorNames,
            content_id: contentObj.contentId,
            content_len: parseInt(contentObj.contentLength, 10) || null,
            content_title: contentObj.contentTitle,
            content_source: contentObj.contentSource,
            author_id: contentObj.authorIds,
            date_publish: contentObj.publishDate !== 'null' ? contentObj.publishDate : null,
            date_last_modified: contentObj.modifiedDate,
            onsite_keywords: contentObj.tags,
            content_template: window.location.href.includes('sponsored')
                ? 'native'
                : 'standard',
            content_language: contentObj.contentLang,
            gallery_name: contentObj.galleryName,
            gallery_img_tot: parseInt(contentObj.totalGalleryImages, 10) || null,
            word_count: parseInt(contentObj.wordCount, 10) || null,
            content_type: contentObj.contentType,
            content_template_type: contentObj.templateType,
            date_display: currentDate !== 'null' ? currentDate : null,
            content_primary_tag: contentObj.primaryTag || null,
            content_is_commerce: contentObj.isCommerceContent || null,
            content_time_since_publish: timeSincePublished,
            content_flag: contentObj.contentFlag,
            content_publish_hour: pubDate.getHours(),
            content_publish_weekday: pubDate.getDay().toString(),
            content_publish_month: pubDate.getMonth().toString(),
            content_page_type_properties: contentObj.pageTypeProperties,
            has_affiliate_links: contentObj.hasAffiliateLinks,
            affiliate_links_count: contentObj.affiliateLinksCount
        }
    };
    const siteContext = {
        schema: 'iglu:com.condenast/site/jsonschema/2-0-1',
        data: {
            org_id: siteObj.orgId,
            org_app_id: siteObj.orgAppId,
            site_app_version: siteObj.appVersion,
            site_env: siteObj.env,
            site_section: contentObj.section,
            site_subsection: contentObj.subsection,
            site_subsection_2: contentObj.subsection2,
            site_data_source: contentObj.dataSource
        }
    };
    const syndicationContext = {
        schema: 'iglu:com.condenast/syndication/jsonschema/3-0-1',
        data: {
            is_syndication_content: syndicationObj.content === 'true',
            syndication_original_source: syndicationObj.originalSource,
            syndication_url: pageObj.syndicatorUrl,
            syndication_original_content_lang: syndicationObj.originalContentLanguage
        }
    };
    const referrerContext = {
        schema: 'iglu:com.condenast/referrer/jsonschema/2-0-1',
        data: {
            refr_domain: document.referrer || ''
        }
    };
    const sessionContext = setSessionContext();
    const campaignContext = {
        schema: 'iglu:com.condenast/campaign/jsonschema/4-0-1',
        data: {
            mkt_id: searchUrlParams.get('utm_id'),
            mkt_mailing: searchUrlParams.get('utm_mailing'),
            mkt_social_type: searchUrlParams.get('utm_social-type'),
            mkt_test: searchUrlParams.get('utm_test'),
            mkt_brand: searchUrlParams.get('utm_brand'),
            emailsource: searchUrlParams.get('esrc'),
            itm_source: searchUrlParams.get('itm_source'),
            itm_medium: searchUrlParams.get('itm_medium'),
            itm_campaign: searchUrlParams.get('itm_campaign'),
            itm_content: searchUrlParams.get('itm_content')
        }
    };
    const experimentsContext = {
        schema: 'iglu:com.condenast/experiments/jsonschema/3-0-0',
        data: {
            experiments_list: (0, exports.setExperimentsEntity)()
        }
    };
    let consentBannerVariant = 'fides';
    if (!window.Fides) {
        const otButton = document.getElementById('onetrust-pc-btn-handler');
        const content = otButton
            ? window.getComputedStyle(otButton, '::after')?.content
            : null;
        if (content && content !== 'none') {
            consentBannerVariant = content.replace(/^["']|["']$/g, '');
        }
        else {
            consentBannerVariant = null;
        }
    }
    const consentContext = {
        schema: 'iglu:com.condenast/consent/jsonschema/1-0-0',
        data: {
            categories: (0, exports.getConsentGroups)()?.join(','),
            banner_variant: consentBannerVariant
        }
    };
    const globalContexts = [
        pageContext,
        userContext,
        contentContext,
        siteContext,
        syndicationContext,
        referrerContext,
        sessionContext,
        campaignContext,
        experimentsContext,
        consentContext
    ];
    // adding global entities to global contexts, this entities will be applied to all the snowplow events
    (0, cn_snowplow_web_1.addGlobalContexts)(globalContexts);
    const handleContextUpdate = () => {
        const newGroups = (0, exports.getConsentGroups)();
        if (userContext && userContext.data) {
            userContext.data.onetrust_active_groups = newGroups;
            userContext.data.email_sha256 = getEmailSha();
            if (window.Fides)
                userContext.data.consent_banner_variant = 'fides';
        }
        if (consentContext && consentContext.data) {
            consentContext.data.categories = newGroups.join(',');
            if (window.Fides)
                consentContext.data.banner_variant = 'fides';
        }
        window.snowplowInitQueue.push(() => {
            window.snowplowCN('removeGlobalContexts', [userContext, consentContext]);
            (0, cn_snowplow_web_1.addGlobalContexts)([userContext, consentContext]);
        });
    };
    window.addEventListener('OneTrustGroupsUpdated', handleContextUpdate);
    // Handling user context and anonymization/de-anonymization
    window.addEventListener('FidesInitialized', () => {
        disableAnonymousTracking((0, tools_1.hasNonAnonymousConsent)(), siteObj?.env, [
            contentObj?.brandSlug
        ]);
        handleContextUpdate();
    });
    window.addEventListener('FidesUpdated', () => {
        disableAnonymousTracking((0, tools_1.hasNonAnonymousConsent)(), siteObj?.env, [
            contentObj?.brandSlug
        ]);
        handleContextUpdate();
    });
    window.cnBus.on('experiments.assignments.processed', () => {
        window.snowplowInitQueue.push(() => {
            window.snowplowCN('removeGlobalContexts', [experimentsContext]);
            experimentsContext.data = {
                experiments_list: (0, exports.setExperimentsEntity)()
            };
            (0, cn_snowplow_web_1.addGlobalContexts)([experimentsContext]);
        });
    });
    window.cnBus.on('user.context.updated', () => {
        if (userContext && userContext.data) {
            userContext.data.monthly_visit_no =
                window.dataLayer[0]?.user?.monthlyVisits || 0;
            userContext.data.monthly_content_count =
                window.dataLayer[0]?.user?.contentVisits || 0;
            // Remove the old user context and add the updated one
            window.snowplowInitQueue.push(() => {
                window.snowplowCN('removeGlobalContexts', [userContext]);
                (0, cn_snowplow_web_1.addGlobalContexts)([userContext]);
            });
        }
    });
    window.cnBus.on('user.context.oneTrustLoaded', () => {
        if (userContext && userContext.data) {
            const otButton = document.getElementById('onetrust-pc-btn-handler');
            const otButtonStyle = otButton && window.getComputedStyle(otButton, ':after');
            const otButtonContent = otButtonStyle
                ?.getPropertyValue('content')
                ?.replace(/"/g, '');
            if (otButtonContent) {
                userContext.data.consent_banner_variant = otButtonContent;
                // Remove the old user context and add the updated one
                window.snowplowInitQueue.push(() => {
                    window.snowplowCN('removeGlobalContexts', [userContext]);
                    (0, cn_snowplow_web_1.addGlobalContexts)([userContext]);
                });
            }
        }
    });
    window.cnBus.on(fingerprint_1.FPJS_VISITOR_EVENT, ({ incognito, visitorId }) => {
        window.snowplowInitQueue.push(() => {
            window.snowplowCN('removeGlobalContexts', [sessionContext, userContext]);
            sessionContext.data.fingerprint_incognito_mode = incognito;
            userContext.data.fingerprint_visitor_id = visitorId;
            (0, cn_snowplow_web_1.addGlobalContexts)([sessionContext, userContext]);
        });
    });
};
const contextGenerator = (event, actionId) => {
    let linkPosition;
    let altAttribute;
    const header = window.document.getElementsByTagName('header')[0];
    const footer = window.document.getElementsByTagName('footer')[0];
    let className = event?.className ? event?.className.toString() : null;
    if (header && header.contains(event)) {
        linkPosition = 'top';
    }
    else if (footer && footer.contains(event)) {
        linkPosition = 'bottom';
    }
    else {
        linkPosition = 'middle';
    }
    if (event?.tagName.toLowerCase() === 'img') {
        altAttribute = event?.alt;
    }
    if (event?.tagName.toLowerCase() === 'svg') {
        className = event?.className?.animVal.toString();
    }
    const currentDomain = window.location.origin;
    let targetUrl = '';
    if (event?.href) {
        targetUrl = new URL(event?.href);
    }
    const isInternalLink = targetUrl.origin === currentDomain;
    const dataOfferURL = event && event.getAttribute('data-offer-url');
    if (event) {
        const hasAffiliateDomain = containsAnyAffiliateDomain(getURLOrigin(event.href), exports.affiliateDomainsList);
        return {
            schema: 'iglu:com.condenast/click_info/jsonschema/2-0-3',
            data: {
                action_id: actionId?.toString(),
                click_url: event.href?.toString(),
                click_id: event.id?.toString(),
                click_class: className,
                click_text: event.textContent?.toString().replace(/Arrow/g, ''),
                click_type: event.tagName?.toString(),
                click_target: event.target?.toString(),
                img_alt: altAttribute?.toString(),
                data_offer_url: dataOfferURL && dataOfferURL.toString(),
                img_source: event.src?.toString(),
                placement: linkPosition,
                is_external: targetUrl ? !isInternalLink : false,
                object_type: className?.split(' ').slice(-1)[0] || null,
                is_affiliate: hasAffiliateDomain,
                offer_id: event.id?.toString()
            }
        };
    }
    return null;
};
/**
 * Get Snowplow domain User ID
 *
 * @returns {string} domainUserId - Returns the Snowplow domain user ID.
 */
const getSnowplowDomainUserId = () => {
    const _spCookie = getCookieFromPrefix('_sp_id.');
    const parts = _spCookie?.split('.');
    const domainUserId = (parts && parts[0]) || null;
    return domainUserId;
};
exports.getSnowplowDomainUserId = getSnowplowDomainUserId;
/**
 * Function to read OptanonConsent cookie has C0004
 * @param {string} cookieValue
 * @returns {boolean}
 */
const hasTargetConsentFromCookie = (cookieValue = null) => {
    if (window.Fides) {
        return (0, tools_1.hasNonAnonymousConsent)();
    }
    const parseCookie = queryString.parse(cookieValue || getCookie('OptanonConsent') || '');
    const consentGroups = parseCookie.groups || '';
    const regexTarget = /0004:1/;
    return regexTarget.test(consentGroups);
};
exports.hasTargetConsentFromCookie = hasTargetConsentFromCookie;
// Get user consent preferences from either Fides or OneTrust
const getUserConsentPreferences = () => {
    const defaultConsent = OneTrustGroupCookieList.reduce((acc, key) => {
        acc[key] = key === 'C0001'; // Strictly necessary always true
        return acc;
    }, {});
    if (false) {}
    try {
        const grantedCategories = (0, exports.getConsentGroups)();
        if (!grantedCategories) {
            return defaultConsent;
        }
        return OneTrustGroupCookieList.reduce((acc, key) => {
            acc[key] = key === 'C0001' || grantedCategories.includes(key);
            return acc;
        }, {});
    }
    catch (err) {
        console.error('Error getting user consent preferences:', err);
        return defaultConsent;
    }
};
exports.getUserConsentPreferences = getUserConsentPreferences;
/**
 * Initialize snowplow tracker
 *
 * @param {string} collectorURL - snowplow collector URL
 * @param {string} slug - brand slug
 * @param {object} globalContext - global context
 * @param {object} appInfoObj - application Information
 * @param {Array} allowedCrossDomains - allowed cross domains for passing sp params
 * @returns {undefined} undefined
 */
const initializeSnowplowTracker = (collectorURL, slug, globalContext, appInfoObj, allowedCrossDomains = []) => {
    const consentPreferences = (0, exports.getUserConsentPreferences)();
    const siteEnv = globalContext?.[0]?.site?.env;
    if (!consentPreferences.C0004 &&
        !consentPreferences.C0009 &&
        (siteEnv === 'staging' || exports.dynamicConsentSlugs.includes(slug))) {
        return;
    }
    window.__snowplowAlreadyInitialized = true;
    // https://docs.snowplow.io/docs/collecting-data/collecting-from-own-applications/javascript-trackers/javascript-tracker/javascript-tracker-v3/tracker-setup/initialization-options/
    const snowplowConfig = {
        appId: slug,
        contexts: {
            clientHints: true,
            performanceNavigationTiming: true,
            webVitals: true
        },
        anonymousTracking: {
            withSessionTracking: true,
            withServerAnonymisation: true
        },
        stateStorageStrategy: siteEnv !== 'production' && exports.testingBrands.includes(slug)
            ? 'localStorage'
            : 'cookieAndLocalStorage',
        discoverRootDomain: true,
        cookieSameSite: window.location.protocol === 'https:' ? 'None' : 'Lax',
        cookieSecure: window.location.protocol === 'https:',
        eventMethod: 'post',
        postPath: '/com.condenast/yv8'
    };
    // current state of anonymouse tracking when the tracker is created based on current targeting consent
    const anonymousConfig = (0, exports.hasTargetConsentFromCookie)()
        ? {
            anonymousTracking: false,
            stateStorageStrategy: 'cookieAndLocalStorage'
        }
        : {};
    // allow anonymous config keys to override if targeting consent detected
    (0, cn_snowplow_web_1.newTracker)(collectorURL, { ...snowplowConfig, ...anonymousConfig }, appInfoObj);
    window.snowplowInitQueue.push(() => {
        const pagePlugin = {
            pageTitle: () => {
                return {
                    beforeTrack: (payloadBuilder) => {
                        payloadBuilder.add('page', window?.document?.title);
                        payloadBuilder.build();
                    }
                };
            }
        };
        // Enable plugin in staging or for allowed slugs
        if (siteEnv === 'staging' || exports.dynamicConsentSlugs.includes(slug)) {
            window.snowplowCN('addPlugin', dynamicConsentPlugin_1.dynamicConsentPlugin, 'consentChecker', [
                {
                    consentCallback() {
                        return (0, exports.getUserConsentPreferences)();
                    }
                }
            ]);
        }
        window.snowplowCN('addPlugin', pagePlugin, 'pageTitle');
    });
    if (window.snowplowInitQueue.length > 0) {
        document.body.addEventListener('click', (event) => {
            const targetLink = event.target.closest('a[href*="/auth/initiate"]');
            const domainUserId = (0, exports.getSnowplowDomainUserId)();
            const timestamp = Date.now();
            const OTGroup = (0, exports.extractConsentGroups)()?.split(',') ||
                window.OnetrustActiveGroups?.split(',')?.slice(1, -1);
            const link = findNearestAnchor(event?.target);
            const isAllowedDomain = link &&
                allowedCrossDomains.length &&
                allowedCrossDomains.some((domain) => link?.hostname.endsWith(domain));
            if (targetLink) {
                if (targetLink.href?.includes('/auth/initiate') &&
                    !targetLink.href?.includes('_sp') &&
                    domainUserId &&
                    OTGroup.includes('C0004')) {
                    targetLink.href = (0, query_params_1.appendQueryToURI)(targetLink.href, {
                        _sp: `${domainUserId}.${timestamp}`
                    });
                }
            }
            else if (link &&
                !link.href?.includes('_sp') &&
                isAllowedDomain &&
                domainUserId &&
                OTGroup.includes('C0004')) {
                link.href = (0, query_params_1.appendQueryToURI)(link.href, {
                    _sp: `${domainUserId}.${timestamp}`
                });
            }
        });
    }
    setGlobalContext(globalContext);
    (0, cn_snowplow_web_1.enableActivityTracking)({
        minimumVisitLength: 5,
        heartbeatDelay: 10
    });
    (0, cn_snowplow_web_1.enableLinkClickTracking)();
    (0, cn_snowplow_web_1.trackPageView)();
};
exports.initializeSnowplowTracker = initializeSnowplowTracker;
const trackPageErrorEvent = (errorType, errorDek) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/page_error_event/jsonschema/4-0-0',
            data: {
                type: errorType.toString(),
                error: errorDek
            }
        }
    });
};
exports.trackPageErrorEvent = trackPageErrorEvent;
const nonURLClickEvent = (ctaText, nextUrl, type, subject) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/non_url_click_event/jsonschema/3-0-0',
            data: {
                label: ctaText,
                next_url: nextUrl,
                type,
                subject
            }
        }
    });
};
exports.nonURLClickEvent = nonURLClickEvent;
const trackCookiesEvent = (label) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/cookies_action_event/jsonschema/3-0-0',
            data: {
                type: 'click',
                label
            }
        },
        context: [
            {
                schema: 'iglu:com.condenast/click_info/jsonschema/2-0-0',
                data: {
                    click_text: label
                }
            }
        ]
    });
};
exports.trackCookiesEvent = trackCookiesEvent;
const trackNewsletterEvent = (eventData) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/newsletter_event/jsonschema/5-0-0',
            data: eventData
        }
    });
};
exports.trackNewsletterEvent = trackNewsletterEvent;
const trackSaveEvent = (eventData, saveContextData = {}, errorInfo = {}) => {
    const save_event = {
        schema: 'iglu:com.condenast/save_event/jsonschema/2-0-1',
        data: eventData
    };
    const save_context = {
        schema: 'iglu:com.condenast/save/jsonschema/2-0-1',
        data: saveContextData
    };
    const hasErrorInfo = errorInfo && Object.keys(errorInfo).length > 0;
    const error_info = hasErrorInfo
        ? [
            {
                schema: 'iglu:com.condenast/error_info/jsonschema/1-0-1',
                data: errorInfo
            }
        ]
        : [];
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: save_event,
        context: [save_context, ...error_info]
    });
};
exports.trackSaveEvent = trackSaveEvent;
const trackMessageUnitEvent = (eventData) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/messaging_unit_event/jsonschema/3-0-3',
            data: eventData
        }
    });
};
exports.trackMessageUnitEvent = trackMessageUnitEvent;
/**
 * buildSaveImageContext function returns a save entity/context object
 * @param {object} props.save_location - List of objects providing information about the location of the content saved
 * @param {string} props.save_location.subject - Returns the subject or component within the overall object or feature used
 * @param {string} props.save_location.subjectId - Id of the subject
 * @param {string} props.save_location.title - Name of the location where the user has saved the pictures
 * @param {number} props.save_location.noOfItems - Number of items that are saved in the location
 * @param {string} props.save_location.sourceName - Name of the subject source
 * @param {string} props.save_location.sourceId - Id of the subject source
 * @param {boolean} props.save_location.isFromBookmark - Boolean values that returns if the save entity was created from bookmark
 * @param {boolean} props.save_location.isDefault - Boolean entity that displays if the save subject(moodboard) is a default (systems) one or not
 *
 * @returns {object}
 */
const buildSaveImageContext = ({ subject, subjectId, subjectName, noOfItems, sourceName, sourceId, isFromBookmark, isDefault, isAutoSelected }) => {
    return {
        save_location: [
            {
                subject,
                subject_id: subjectId,
                subject_name: subjectName,
                no_of_items: noOfItems,
                source_name: sourceName,
                source_id: sourceId,
                is_from_bookmark: isFromBookmark,
                is_default: isDefault,
                is_auto_selected: isAutoSelected
            }
        ]
    };
};
exports.buildSaveImageContext = buildSaveImageContext;
const trackSaveEventWithContext = ({ saveContext, eventData, errorContext = {} }) => {
    const saveContextData = (0, exports.buildSaveImageContext)(saveContext);
    (0, exports.trackSaveEvent)(eventData, saveContextData, errorContext);
};
exports.trackSaveEventWithContext = trackSaveEventWithContext;
const trackCommerceInteractionEvent = (eventData, productContextData = null, targetEvent = null, actionId = null, videoIds = []) => {
    const anchorElement = findNearestAnchor(targetEvent?.target) ||
        targetEvent?.target?.closest?.('SVG');
    const productContext = {
        schema: 'iglu:com.condenast/product/jsonschema/2-0-1',
        data: productContextData
    };
    const videoSchema = {
        schema: 'iglu:com.condenast/video/jsonschema/4-0-3',
        data: {
            video_id: ''
        }
    };
    // Create video schemas from videoIds array
    const videoSchemas = videoIds?.length
        ? videoIds.reduce((schemas, dynamicVideoId, index) => {
            schemas[index + 1] = {
                ...videoSchema,
                data: {
                    ...videoSchema.data,
                    video_id: dynamicVideoId
                }
            };
            return schemas;
        }, {})
        : {};
    const eventSchema = {
        schema: 'iglu:com.condenast/commerce_interaction_event/jsonschema/1-0-1',
        data: eventData
    };
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: eventSchema,
        context: anchorElement
            ? [
                productContext,
                contextGenerator(anchorElement, actionId),
                ...Object.values(videoSchemas)
            ]
            : [productContext, ...Object.values(videoSchemas)]
    });
};
exports.trackCommerceInteractionEvent = trackCommerceInteractionEvent;
const handleAffiliateLinkClick = (event, data = {}) => {
    const arrayOfAffiliateLinks = getAffiliateLinksInnerText();
    const element = findNearestAnchor(event?.target);
    const href = element?.getAttribute('href') || data?.link;
    const parser = new DOMParser();
    const hasAffiliateDomain = containsAnyAffiliateDomain(href, exports.affiliateDomainsList);
    if (hasAffiliateDomain) {
        const eventData = {
            type: 'click',
            subject: data?.component
        };
        const label = data?.label || element?.innerHTML;
        const productName = parser.parseFromString(label, 'text/html').body
            .textContent;
        const position = data?.position ||
            parseInt(arrayOfAffiliateLinks?.indexOf(productName), 10) + 1;
        const eventEntityProps = {
            product_name: productName,
            product_component: data?.component,
            product_type: 'product',
            product_system: 'ecommerce',
            index: typeof position === 'number' ? parseInt(position, 10) : null,
            placement: typeof position === 'string' ? position : null,
            product_ref: 'direct_link',
            page_layout: window?.dataLayer?.[0]?.content?.contentType ?? null
        };
        (0, exports.trackCommerceInteractionEvent)(eventData, eventEntityProps, event, data?.actionId);
    }
};
exports.handleAffiliateLinkClick = handleAffiliateLinkClick;
const trackAffiliateLinks = () => {
    const elements = window?.document?.querySelectorAll('.external-link');
    elements.forEach((link) => {
        link.addEventListener('click', (event) => {
            const isTriggeringLinkListEvent = event?.target?.closest('li');
            (0, exports.handleAffiliateLinkClick)(event, {
                type: 'product_affiliate_link',
                component: isTriggeringLinkListEvent
                    ? 'affiliate_link_list'
                    : 'affiliate_link_inline'
            });
        });
    });
};
exports.trackAffiliateLinks = trackAffiliateLinks;
const trackNavigationEvent = (eventData, adEntityData = null, options = {}) => {
    const { skipDuplicateEvent = true } = options;
    const toBeEmmittedEvent = cloneDeep({
        eventData
    });
    let eventDetail = {
        event: {
            schema: 'iglu:com.condenast/navigation_event/jsonschema/3-0-0',
            data: eventData
        }
    };
    if (adEntityData) {
        eventDetail = {
            ...eventDetail,
            context: [
                {
                    schema: 'iglu:com.condenast/ad/jsonschema/4-0-2',
                    data: {
                        request_type: 'interactive',
                        unit: adEntityData
                    }
                }
            ]
        };
    }
    const eventPreviouslyTracked = emitUniqueNavigationEvent.some((emittedEvent) => isEqual(emittedEvent, toBeEmmittedEvent));
    if (skipDuplicateEvent && eventPreviouslyTracked) {
        return;
    }
    emitUniqueNavigationEvent.push(cloneDeep({ eventData }));
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)(eventDetail);
};
exports.trackNavigationEvent = trackNavigationEvent;
const fidesTrackConsentPending = () => {
    if (window.Fides &&
        window.Fides.initialized &&
        window.Fides.shouldShowExperience()) {
        const otActiveGroups = (0, tools_1.fidesExtractConsentGroupsAsOtArray)();
        (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentPending', otActiveGroups);
    }
};
const oneTrustTrackConsentPending = () => {
    if (!getCookie('OptanonAlertBoxClosed')) {
        const otActiveGroups = oneTrustExtractConsentGroups()?.split(',') ||
            window?.OnetrustActiveGroups?.split(',')?.slice(1, -1);
        if (window.OneTrust && window.OneTrust.GetDomainData) {
            const { IsBannerLoaded, ShowAlertNotice } = window.OneTrust.GetDomainData();
            if (IsBannerLoaded && ShowAlertNotice) {
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentPending', otActiveGroups);
            }
        }
    }
};
const trackConsentPending = () => {
    if (window?.Fides) {
        fidesTrackConsentPending();
    }
    else {
        oneTrustTrackConsentPending();
    }
};
exports.trackConsentPending = trackConsentPending;
const videoGenerator = (id) => {
    return {
        schema: 'iglu:com.condenast/video/jsonschema/4-0-3',
        data: {
            video_id: id
        }
    };
};
const videoPlayGenerator = (clipData) => {
    if (clipData) {
        return {
            schema: 'iglu:com.condenast/video_player/jsonschema/5-0-0',
            data: {
                distribution: 'oo',
                platform: 'verso',
                loop: true,
                tab_active: true,
                volume: 0,
                fullscreen: false,
                progress_percent: parseInt(clipData.progressPercent, 10),
                inview_percent: parseInt(clipData.inviewPercent, 10),
                current_time: clipData.currentTime,
                width: clipData.width,
                height: clipData.height,
                playing_state: clipData.type
            }
        };
    }
    return null;
};
const trackClipEvent = (clipData) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/video_player_event/jsonschema/2-0-1',
            data: {
                type: clipData?.type,
                subject: 'clip_player'
            }
        },
        context: [videoGenerator(clipData?.clipId), videoPlayGenerator(clipData)]
    });
};
exports.trackClipEvent = trackClipEvent;
const trackClickEvent = (element) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/click_event/jsonschema/1-0-0',
            data: {
                type: 'click'
            }
        },
        context: [contextGenerator(element)]
    });
};
exports.trackClickEvent = trackClickEvent;
const trackSearchFilterEvent = (eventData) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/search_filter_event/jsonschema/4-0-0',
            data: eventData
        }
    });
};
exports.trackSearchFilterEvent = trackSearchFilterEvent;
const trackContentEngagementEvent = (eventData, options = {}) => {
    const { skipDuplicateEvent = true, errorInfo = null } = options;
    const context = [];
    if (errorInfo) {
        context.push({
            schema: 'iglu:com.condenast/error_info/jsonschema/1-0-1',
            data: {
                type: 'error',
                ...errorInfo
            }
        });
    }
    const toBeEmmittedEvent = cloneDeep({
        eventData
    });
    const eventPreviouslyTracked = emitUniqueContentEngagementEvent.some((emittedEvent) => isEqual(emittedEvent, toBeEmmittedEvent));
    if (skipDuplicateEvent && eventPreviouslyTracked) {
        return;
    }
    emitUniqueContentEngagementEvent.push(cloneDeep({ eventData }));
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/content_engagement_event/jsonschema/2-0-3',
            data: eventData
        },
        ...(context.length ? { context } : {})
    });
};
exports.trackContentEngagementEvent = trackContentEngagementEvent;
const trackUserAccountEvent = (eventData) => {
    (0, cn_snowplow_web_1.trackSelfDescribingEvent)({
        event: {
            schema: 'iglu:com.condenast/user_account_event/jsonschema/5-0-1',
            data: eventData
        }
    });
};
exports.trackUserAccountEvent = trackUserAccountEvent;
const trackCeros = (event) => {
    const eventDetail = event.detail;
    const cerosEvents = ['component-hover', 'component-click'];
    if (eventDetail && cerosEvents.includes(eventDetail.eventType)) {
        const { componentName, eventType } = eventDetail;
        const cerosEvent = eventType.replace(/^component-/, '');
        const componentTaxonomy = componentName.split('-');
        // componentName Taxonomy -- module template name-module identifier-user interaction-object description
        const eventData = {
            type: (componentTaxonomy?.[2] && `${cerosEvent}_${componentTaxonomy?.[2]}`) ||
                cerosEvent,
            subject: (componentTaxonomy?.[3] && `ceros_${componentTaxonomy?.[3]}`) || null,
            subject_version: componentTaxonomy?.[1] || null
        };
        const adEntityData = componentTaxonomy?.[0] || null;
        (0, exports.trackNavigationEvent)(eventData, adEntityData);
    }
};
exports.trackCeros = trackCeros;
//# sourceMappingURL=snowplow-tracking.js.map

/***/ }),

/***/ 31170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isEqual = __webpack_require__(2404);
const cloneDeep = __webpack_require__(88055);
const emittedSparrowTrackingEvents = [];
/**
 * This module uses the SparrowQueue implementation, provided by the `fast-ads`
 * repo, which also drops the Sparrow Pixel and manages brand configurations.
 *
 * In the future, it would make sense for this code and configuration to live
 * in Verso as a core dependency. This is probably a 2019 to-do.
 */
window.sparrowQueue = window.sparrowQueue || [];
/**
 * Track a single event in Sparrow.
 *
 * @param {string} campaign - campaign name for metrics segmentation, e.g. 'verso-pattern-tracking'
 * @param {string} eventName - for example, 'click'
 * @param {object} payloads - object of keys/values to pass as last argument in sparrow.track()
 * @returns {undefined} undefined
 */
const trackSparrowEvent = (campaign, eventName, payloads) => {
    // The queue is actually a DelayedQueue class with a push method.
    // We safely provide for a simple array implementation as well.
    if ((!Array.isArray(window.sparrowQueue) &&
        typeof window.sparrowQueue !== 'object') ||
        window.sparrowQueue === null) {
        return;
    }
    emittedSparrowTrackingEvents.push(cloneDeep({ campaign, eventName, payloads }));
    window.sparrowQueue.push(() => {
        window.sparrow.track(campaign, eventName, payloads);
    });
};
/**
 * Emits a Sparrow Tracking event only if that event has not been
 * sent previously.
 *
 * @param {string} campaign - Sparrow campaign name
 * @param {string} eventName - event name
 * @param {object} payloads - object of keys/values to pass as last argument in sparrow.track()
 *
 * @returns {undefined} undefined
 */
const emitUniqueSparrowTrackingEvent = (campaign, eventName, payloads) => {
    const toBeEmittedEventDescription = cloneDeep({
        campaign,
        eventName,
        payloads
    });
    const eventPreviouslyTracked = emittedSparrowTrackingEvents.some((emittedEventDescription) => isEqual(emittedEventDescription, toBeEmittedEventDescription));
    if (eventPreviouslyTracked)
        return;
    trackSparrowEvent(campaign, eventName, payloads);
};
module.exports = {
    trackSparrowEvent,
    emitUniqueSparrowTrackingEvent
};
//# sourceMappingURL=sparrow.js.map

/***/ }),

/***/ 55058:
/***/ ((module) => {

/**
 * These are the minimum threshold values mapped to each breakpoint.
 *
 * Breakpoints:
 *   sm: 0 - 319
 *   md: 320 - 767
 *   lg: 768 - 1023
 *   xl: 1024 - 1279
 *   xxl: 1280 - 1599
 *   xxxl: 1600 - Infinity
 */
const minThresholds = {
    sm: 0,
    md: 320,
    lg: 768,
    xl: 1024,
    xxl: 1280,
    xxxl: 1600
};
/**
 * These are the maximum threshold values mapped to each breakpoint.
 * Notice that each value is just calculated by taking the minimum
 *   value for the next size up.
 */
const maxThresholds = {
    sm: minThresholds.md - 1,
    md: minThresholds.lg - 1,
    lg: minThresholds.xl - 1,
    xl: minThresholds.xxl - 1,
    xxl: minThresholds.xxxl - 1
};
/**
 * This an array of breakpoint sizes in order of least to greatest.
 */
const sizesAscending = ['sm', 'md', 'lg', 'xl', 'xxl', 'xxxl'];
const sizesDescending = [...sizesAscending].reverse();
const sizesFullName = {
    small: 'sm',
    medium: 'md',
    large: 'lg',
    xLarge: 'xl',
    xxLarge: 'xxl',
    xxxLarge: 'xxxl'
};
module.exports = {
    sizes: sizesAscending,
    sizesAscending,
    sizesDescending,
    sizesFullName,
    minThresholds,
    maxThresholds
};
//# sourceMappingURL=breakpoints.js.map

/***/ }),

/***/ 99906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(55058);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 41846:
/***/ ((module) => {

/**
 * If a parent component has an 'inverted' theme, get the appropriate variation for the child Byline component
 *
 * @param {string} bylineVariation - The byline variation prop provided to the component where this is called
 * @param {string} theme - The theme prop provided to the component where this is called
 *
 * @returns {string} - The name of the byline variation
 */
const getThemedBylineVariation = ({ bylineVariation, theme }) => {
    return theme === 'inverted' ? 'Inverted' : bylineVariation;
};
module.exports = {
    getThemedBylineVariation
};
//# sourceMappingURL=byline.js.map

/***/ }),

/***/ 27053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getThemedBylineVariation } = __webpack_require__(41846);
module.exports = {
    getThemedBylineVariation
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 45966:
/***/ ((module) => {

const mapChannelName = (obj, channelMap) => {
    if (obj && obj.name) {
        return {
            ...obj,
            name: channelMap && channelMap[obj.name] ? channelMap[obj.name] : obj.name
        };
    }
    return null;
};
module.exports = { mapChannelName };
//# sourceMappingURL=channel-map.js.map

/***/ }),

/***/ 39104:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { mapChannelName } = __webpack_require__(45966);
module.exports = {
    mapChannelName
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Coppied from https://github.com/CondeNast/autopilot-vendor-interfaces/blob/master/src/conde/cne/image.js
//
// Challenge:
// CNE videos are published to copilot with a cover image
// the cover image is not available in the desired size(s)
// example: https://ad-api.aws.conde.io/cnevideos/561d6461ed5c90fd5d6127bc
//
// Proposal:
// CNE is using cloudinary web service and the url contains options similar to Vulcan
// Parse and modify the url as desired
// @see: http://cloudinary.com/documentation/image_transformations
//
const _merge = __webpack_require__(55364);
const url = __webpack_require__(88835);
// Separator in pattern between brand key and slug
const SEP_BRANDKEY_SLUG = '_';
// Separator between serialized options
const SEP_OPT = ',';
// Separator between option key and value
const SEP_OPT_VAL = '_';
// Base image path
const IMG_PATH = 'image/upload';
// Expression to match CNE image url string
// derived from reading cne repo tests
// @see https://github.com/cnerepo/cneapi/blob/098eb33f20ef3ebe79b25299c2d4774004e123c7/lib/cne/spec/libs/image_helper_spec.rb
// @example '/heru80fdn/image/upload/c_fill,d_placeholder_thescene.jpg,fl_progressive,g_center,h_360,q_80,w_640/v1444767690/architecturaldigest_avertisement-technology-design-coordinating-for-a-cause.jpg';
const RE_IMG_URL = new RegExp(`^\\/(\\w+)\\/${IMG_PATH}\\/([^\\/]+)\\/?(\\w*)\\/(\\w{2,})${SEP_BRANDKEY_SLUG}([^.]+)\\.(\\w+)$`);
// Named matches
const IMG_FIELDS = [
    'input',
    'secret',
    'options',
    'version',
    'brandKey',
    'slug',
    'format'
];
/**
 * Parse options substring from url
 * example: 'c_fill,d_placeholder_thescene.jpg,fl_progressive,g_center,h_360,q_80,w_640'
 * => { c: 'fill', d: 'placeholder_thescene.jpg', fl: 'progressive', ... }
 *
 * @private
 * @param {string} str - options string
 * @returns {object} options
 */
function _parseOptions(str) {
    if (!str || typeof str !== 'string') {
        return {};
    }
    return str.split(SEP_OPT).reduce((prev, val) => {
        const parts = val.split(SEP_OPT_VAL);
        prev[parts.shift()] = parts.join(SEP_OPT_VAL);
        return prev;
    }, {});
}
/**
 * Serialize options object
 *
 * @private
 * @param {object} opts - options
 * @returns {string} comma-separated options
 */
function _serializeOptions(opts) {
    const options = Object.keys(opts).map((key) => {
        let val = key;
        // accomodate option with no value, e.g. `pass`
        if (opts[key]) {
            val += SEP_OPT_VAL + opts[key];
        }
        return val;
    });
    return options.join(SEP_OPT);
}
/**
 * Parse CNE image url
 *
 * @public
 * @param {string} str - url string
 * @returns {object} url data
 */
exports.parse = function (str) {
    if (!str || typeof str !== 'string') {
        return { error: 'Invalid CNE Image URL' };
    }
    const data = {
        _url: url.parse(str)
    };
    const imageValues = RE_IMG_URL.exec(data._url.pathname);
    if (!imageValues || imageValues.length < 2) {
        return { error: 'Invalid CNE Image URL' };
    }
    IMG_FIELDS.reduce((prev, cur, i) => {
        prev[cur] = imageValues[i];
        return prev;
    }, data);
    data.options = _parseOptions(data.options);
    return data;
};
/**
 * Compose a CNE Image URL from data and options
 *
 * @public
 * @param {object} data - url data
 * @param {object} [opts] - options
 * @returns {string} image url
 */
exports.compose = function (data, opts) {
    if (!data || typeof data !== 'object') {
        // throw new Error('Unable to compose CNE image url. Missing required data');
        // returns an empty string instead of throwing error so the entire page won't break
        console.log('Unable to compose CNE image url. Missing required data', data);
        return '';
    }
    if (!data._url || typeof data._url !== 'object') {
        // throw new Error(
        //   'Unable to compose CNE image url. Missing required url data'
        // );
        // returns an empty string instead of throwing error so the entire page won't break
        console.log('Unable to compose CNE image url. Missing required url data', data);
        return '';
    }
    const options = _merge({}, data.options, opts);
    const optStr = _serializeOptions(options);
    const filename = `${data.brandKey}${SEP_BRANDKEY_SLUG}${data.slug}.${data.format}`;
    // update path and protocol
    data._url.pathname = [
        data.secret,
        IMG_PATH,
        optStr,
        data.version,
        filename
    ].join('/');
    data._url.protocol = 'https:';
    return url.format(data._url);
};
/**
 * Modify a url with a new set of options
 *
 * @param {string} src - url string
 * @param {object} options - image options
 * @returns {string} modified url
 */
exports.modify = function (src, options) {
    if (!options) {
        return src;
    }
    const data = exports.parse(src);
    return exports.compose(data, options);
};
//# sourceMappingURL=CNEImage.js.map

/***/ }),

/***/ 25141:
/***/ ((module) => {

const whitelist = [
    ['_markCurrentlySticky', 'state'],
    ['_onConsentUpdated', 'state'],
    ['_trackCNESparrow', 'queue'],
    ['on', 'queue'],
    ['pause', 'state']
];
const queuedFn = (queue) => (...args) => queue.push(args);
/**
 * When the CNEVideoEmbed is initialized, the CN player is set asynchronously.
 *   PlayerProxy is provided so that any logic that requires the player object
 *   immediately can be called without error. The result of these functions will
 *   be flushed to the actual CN player object once it is resolved using one of
 *   two methods (see whitelist above).
 *
 * - "state": the final call to the function will be applied to the CN player
 * - "queue": all functions will be applied to the CN player in the order they
 *            were called.
 */
class PlayerProxy {
    constructor() {
        this.cache = {};
        whitelist.forEach(([fnName]) => {
            const queue = [];
            this.cache[fnName] = queue;
            Object.defineProperty(this, fnName, {
                get() {
                    return queuedFn(queue);
                }
            });
        });
    }
    flush(player) {
        whitelist.forEach(([fnName, strategy]) => {
            const queue = this.cache[fnName];
            if (!queue.length)
                return;
            strategy === 'state'
                ? player[fnName](...queue[queue.length - 1])
                : queue.forEach((args) => player[fnName](...args));
        });
    }
}
module.exports = {
    PlayerProxy,
    whitelist
};
//# sourceMappingURL=PlayerProxy.js.map

/***/ }),

/***/ 81478:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const CNEImage = __webpack_require__(94177);
/**
 * Create a set of Cloudinary urls given image url and configuration
 *
 * @param {object} photoConfig - rendition config for this image
 * @param {string} imageUrl - the url for the cdn where the images are
 * @returns {object} sizes - dictionary of urls keyed by image size
 */
function createCloudinarySources(photoConfig, imageUrl) {
    return Object.keys(photoConfig).reduce((acc, breakpoint) => {
        acc[breakpoint] = {
            width: photoConfig[breakpoint].w,
            height: photoConfig[breakpoint].h,
            url: CNEImage.modify(imageUrl, photoConfig[breakpoint])
        };
        return acc;
    }, {});
}
exports["default"] = createCloudinarySources;
//# sourceMappingURL=create-cloudinary-sources.js.map

/***/ }),

/***/ 34446:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const initWindowCne = __webpack_require__(87348);
const { PlayerProxy } = __webpack_require__(25141);
module.exports = {
    initWindowCne,
    PlayerProxy
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 87348:
/***/ ((module) => {

/**
 * Sets the `window._cne` if it does not exist and returns
 *   the value.
 *
 * @returns {object} the value of `window._cne`
 */
const initWindowCne = () => {
    window._cne = window._cne || {};
    return window._cne;
};
module.exports = initWindowCne;
//# sourceMappingURL=initWindowCne.js.map

/***/ }),

/***/ 80504:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asConfiguredComponent = void 0;
const isEmpty_1 = __importDefault(__webpack_require__(62193));
const react_1 = __importDefault(__webpack_require__(96540));
const react_dom_1 = __webpack_require__(40961);
const redux_1 = __webpack_require__(57744);
const PresetProvider_1 = __webpack_require__(6009);
function getConfigVariation(componentConfig, innerDisplayName) {
    return ((componentConfig[innerDisplayName] &&
        componentConfig[innerDisplayName].variation) ||
        null);
}
function getConfigProps(componentConfig, innerDisplayName) {
    return ((componentConfig[innerDisplayName] &&
        componentConfig[innerDisplayName].settings) ||
        {});
}
function pascalToCamel(pascalCase) {
    return pascalCase.charAt(0).toLowerCase() + pascalCase.slice(1);
}
function getQueryConfigProps(config, innerDisplayName) {
    const displayName = pascalToCamel(innerDisplayName);
    const componentConfig = config && config[displayName];
    return componentConfig || {};
}
function getPresetConfigs(presetData, innerDisplayName) {
    let configProps = {};
    let configVariation = null;
    // get preset componentConfig for the innerDisplayName
    const componentConfigs = presetData?.componentConfigs || {};
    if (!(0, isEmpty_1.default)(componentConfigs)) {
        configProps = getConfigProps(componentConfigs, innerDisplayName);
        configVariation = getConfigVariation(componentConfigs, innerDisplayName);
    }
    return { configProps, configVariation };
}
const asConfiguredComponent = (Component, displayName) => {
    let Wrapper;
    if (!displayName) {
        throw new Error(`Missing displayName in asConfiguredComponent function from ${Component.name} component`);
    }
    class ConfiguredComponent extends react_1.default.Component {
        componentDidMount() {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.domNode = (0, react_dom_1.findDOMNode)(this); // eslint-disable-line react/no-find-dom-node
            if (this.domNode instanceof HTMLElement) {
                const analyticsData = JSON.stringify({ pattern: displayName });
                this.domNode.setAttribute('data-event-boundary', 'click');
                this.domNode.setAttribute('data-event-click', analyticsData);
                this.domNode.setAttribute('data-in-view', analyticsData);
                this.domNode.setAttribute('data-include-experiments', 'true');
            }
        }
        componentDidUpdate(prevProps) {
            const { expDataLayerUpdated } = this.props;
            if (expDataLayerUpdated !== prevProps.expDataLayerUpdated) {
                if (!!this.domNode && this.domNode instanceof HTMLElement) {
                    const includeExp = expDataLayerUpdated ? 'true' : 'false';
                    this.domNode.setAttribute('data-include-experiments', includeExp);
                }
            }
        }
        render() {
            const { props } = this;
            const { config, componentConfig, componentConfigOverride } = props;
            let configProps = {};
            let configVariation = null;
            if (!(0, isEmpty_1.default)(componentConfig)) {
                const componentConfigProps = getConfigProps(componentConfig, displayName);
                configProps = { ...componentConfigProps };
                configVariation = getConfigVariation(componentConfig, displayName);
            }
            if (!(0, isEmpty_1.default)(config)) {
                const queryConfigProps = getQueryConfigProps(config, displayName);
                configProps = { ...configProps, ...queryConfigProps };
            }
            if (!(0, isEmpty_1.default)(componentConfigOverride)) {
                configProps = { ...configProps, ...componentConfigOverride };
            }
            let Wrapped = Component;
            /*
             * If there is a variation in the component config for the current
             * component we use it, unless we have been passed variation settings.
             * If the latter is true, it means that the variation is defined at
             * the configured component level and we shouldn't try to look up
             * the variation again
             */
            if (configVariation && !props.variations) {
                /*
                 * First we try to find the variation at the configured component level.
                 * It it isn't found, we try to find it at the wrapped component level.
                 */
                Wrapped =
                    Wrapper[configVariation] || Component[configVariation] || Wrapped;
            }
            const originalProps = { ...props };
            delete originalProps.componentConfig;
            delete originalProps.expDataLayerUpdated;
            delete originalProps.featureFlags;
            const newProps = {
                ...originalProps,
                ...configProps
            };
            return (
            /*
             * If the preset context has the componentConfig for this displayName
             * It will overwrite the configVariation and merge the configProps of the preset componentConfig
             */
            react_1.default.createElement(PresetProvider_1.PresetConsumer, null, (presetData) => {
                const preset = getPresetConfigs(presetData, displayName);
                if (preset.configVariation && !props.variations) {
                    Wrapped =
                        Wrapper[preset.configVariation] ||
                            Component[preset.configVariation] ||
                            Wrapped;
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                return react_1.default.createElement(Wrapped, { ...newProps, ...preset.configProps });
            }));
        }
    }
    ConfiguredComponent.displayName = `${displayName}${ConfiguredComponent.name}`;
    Wrapper = (0, redux_1.connector)(ConfiguredComponent, {
        keysToPluck: [
            'componentConfig',
            'config',
            'expDataLayerUpdated',
            'featureFlags',
            'useTrailingSlash'
        ]
    });
    return Wrapper;
};
exports.asConfiguredComponent = asConfiguredComponent;
//# sourceMappingURL=configured-component.js.map

/***/ }),

/***/ 12892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const configuredComponentHelpers = __webpack_require__(80504);
module.exports = configuredComponentHelpers;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 87664:
/***/ ((module) => {

const getExpirationDate = (expirationInMs) => new Date(Date.now() + parseInt(expirationInMs, 10)).toUTCString();
/**
 * Simple helper for creating a valid cookie.
 * It does not set the cookie on the document object.
 *
 * @param {string} name - cookie name
 * @param {string} value - cookie value
 * @param {object} config - cookie config
 * @param {string} config.path - cookie path
 * @param {string} config.expirationInMs - cookie expiration in milliseconds
 *
 * @returns {string} cookie value
 */
module.exports.createCookie = (name, value, config) => {
    if (!name || !value) {
        return '';
    }
    const { expirationInMs, path, domain } = config || {};
    const defaultCookieExpirationTime = 1000 * 60 * 20; // 20 minutes;
    let cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
    if (expirationInMs) {
        cookie = `${cookie}; expires=${getExpirationDate(expirationInMs)}`;
    }
    if (path) {
        if (!expirationInMs) {
            cookie = `${cookie}; expires=${getExpirationDate(defaultCookieExpirationTime)}`;
        }
        cookie = `${cookie}; path=${path}`;
    }
    if (domain) {
        cookie = `${cookie}; domain=${domain};`;
    }
    return cookie;
};
//# sourceMappingURL=createCookie.js.map

/***/ }),

/***/ 36099:
/***/ ((module) => {

function deleteCookie(name, domain) {
    if (typeof document === 'undefined') {
        return;
    }
    domain
        ? (document.cookie = `${name}=; Path=/; Domain=${domain}; Expires=Thu, 01 Jan 1970 00:00:01 GMT;`)
        : (document.cookie = `${name}=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;`);
}
module.exports = {
    deleteCookie
};
//# sourceMappingURL=deleteCookie.js.map

/***/ }),

/***/ 76510:
/***/ ((module) => {

/**
 * Simple helper for finding a cookie on the window
 *
 * @param {string} name - cookie name
 *
 * @returns {string} cookie value
 */
module.exports.getCookie = function getCookie(name) {
    if (typeof document === 'undefined' || !name) {
        return '';
    }
    const cookiePieces = document.cookie.split(/;\s?/);
    let cookieValue = '';
    for (let i = 0; i < cookiePieces.length; i++) {
        // Only required values that need to be encoded are commas, semicolons and
        // whitespace. This means `=` could be unencoded.
        const parts = cookiePieces[i].split('=');
        if (parts[0] === name) {
            cookieValue = decodeURIComponent(parts.slice(1).join('='));
            break;
        }
    }
    return cookieValue;
};
//# sourceMappingURL=getCookie.js.map

/***/ }),

/***/ 88546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCookieDomainFromHostname = exports.getCookieDomain = void 0;
const tldjs_1 = __webpack_require__(96400);
/**
 * Parses the given hostname string. The returned string to be used for the domain value when working with cookies.
 *
 * @param {string} hostname - May be from the tenant config siteDomain or widow.location.hostname
 * @returns {string} - Domain value for setting, retrieving or deleting cookies
 */
const getCookieDomain = (hostname) => {
    const domain = (0, tldjs_1.getDomain)(hostname);
    return domain ? `.${domain}` : '';
};
exports.getCookieDomain = getCookieDomain;
/**
 * Uses the window.location.hostname to create a cookie domain string.
 *
 * @returns {string} - Used for the domain value when setting, retrieving or deleting cookies.
 */
const getCookieDomainFromHostname = () => {
    const hostname = window && window.location && window.location.hostname;
    if (!hostname) {
        return '';
    }
    return (0, exports.getCookieDomain)(hostname);
};
exports.getCookieDomainFromHostname = getCookieDomainFromHostname;
//# sourceMappingURL=getCookieDomain.js.map

/***/ }),

/***/ 94386:
/***/ ((module) => {

/**
 * Simple helper for finding a cookie on the window based on a prefix
 *
 * @param {string} prefix - cookie prefix
 *
 * @returns {string} cookie value
 */
module.exports.getCookieFromPrefix = function getCookieFromPrefix(prefix) {
    if (typeof document === 'undefined' || !prefix) {
        return '';
    }
    const cookiePieces = document.cookie.split(/;\s?/);
    let cookieValue = '';
    for (let i = 0; i < cookiePieces.length; i++) {
        // Only required values that need to be encoded are commas, semicolons and
        // whitespace. This means `=` could be unencoded.
        const parts = cookiePieces[i].split('=');
        const cookieName = parts[0].trim();
        if (cookieName.startsWith(prefix)) {
            cookieValue = decodeURIComponent(parts.slice(1).join('='));
            break;
        }
    }
    return cookieValue;
};
//# sourceMappingURL=getCookieFromPrefix.js.map

/***/ }),

/***/ 56892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { deleteCookie } = __webpack_require__(36099);
const { getCookie } = __webpack_require__(76510);
const { getCookieDomainFromHostname, getCookieDomain } = __webpack_require__(88546);
const { createCookie } = __webpack_require__(87664);
const { getCookieFromPrefix } = __webpack_require__(94386);
module.exports = {
    getCookieDomain,
    getCookieDomainFromHostname,
    deleteCookie,
    getCookie,
    createCookie,
    getCookieFromPrefix
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 72362:
/***/ ((module) => {

/**
 **
 * Verifies whether current device is on iOS
 * operation system (mobile). Defaults to FALSE.
 *
 * @returns {boolean} whether iOS devise renders page.
 */
const isIOSDevice = () => {
    const iOSDeviceRegex = /(iPhone|iPad|iPod)/i;
    try {
        return iOSDeviceRegex.test(window.navigator.userAgent);
    }
    catch (e) {
        return false;
    }
};
const isDesktopBrowser = () => {
    try {
        if (/(tablet|ipad|playbook|silk)|(android(?!.*mobi))/i.test(window.navigator.userAgent)) {
            return false;
        }
        if (/Mobile|iP(hone|od)|Android|BlackBerry|IEMobile|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)/.test(window.navigator.userAgent)) {
            return false;
        }
        return true;
    }
    catch (e) {
        return false;
    }
};
/**
 **
 * Verifies whether current device is a Mac device (desktop/mobile)
 * Defaults to FALSE.
 *
 * @returns {boolean} whether Mac device or not.
 */
const isMacDevice = () => {
    const macDeviceRegex = /(Mac|iPhone|iPad|iPod)/i;
    try {
        return macDeviceRegex.test(window.navigator.userAgent);
    }
    catch (e) {
        return false;
    }
};
module.exports = {
    isIOSDevice,
    isDesktopBrowser,
    isMacDevice
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57743:
/***/ ((module) => {

/**
 * Wraps fetch call with the ability to timeout a request
 *
 * @param {string} url - fetch request URL
 * @param {object|string} fetchParams - query parameter you would pass to fetch, can be a url string or Object
 * @param {number} timeout - maximum timeout in milliseconds
 * @param {string} errorMessage - message to send back when promise rejects due to timeout
 * @returns {Promise} a promise response or error
 */
function fetchWithTimeout(url, fetchParams, timeout, errorMessage = 'Request timed out') {
    return new Promise((resolve, reject) => {
        const timeoutReject = setTimeout(() => {
            reject(new Error(errorMessage));
        }, timeout);
        fetch(url, fetchParams).then((response) => {
            clearTimeout(timeoutReject);
            resolve(response);
        }, (err) => {
            clearTimeout(timeoutReject);
            reject(err);
        });
    });
}
module.exports = {
    fetchWithTimeout
};
//# sourceMappingURL=fetchWithTimeout.js.map

/***/ }),

/***/ 91250:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchWithTimeout = void 0;
const cookies_1 = __importDefault(__webpack_require__(53788));
const UserAuthenticationClient_1 = __webpack_require__(22214);
const { fetchWithTimeout: originalFetchWithTimeout } = __webpack_require__(57743);
const { oidcCookies } = cookies_1.default;
/**
 * Wraps fetchWithTimeout call with Authorization Bearer Token header, if authenticated.
 *
 * @param {string} url - fetch request URL
 * @param {object|string} fetchParams - query parameter you would pass to fetch, can be a url string or Object
 * @param {number} timeout - maximum timeout in milliseconds
 * @param {string} errorMessage - message to send back when promise rejects due to timeout
 * @returns {Promise} a promise response or error
 */
const fetchWithTimeout = async function (url, fetchParams, timeout, errorMessage = 'Request timed out') {
    const isAuthenticated = await UserAuthenticationClient_1.UserAuthenticationClient.checkAccessWithRefresh();
    if (isAuthenticated) {
        const token = UserAuthenticationClient_1.UserAuthenticationClient.getCookieValue(oidcCookies.access);
        const { headers: originalHeaders = {} } = fetchParams;
        const headers = {
            ...originalHeaders,
            Authorization: `Bearer ${token}`
        };
        return originalFetchWithTimeout(url, { ...fetchParams, headers }, timeout, errorMessage);
    }
    return originalFetchWithTimeout(url, fetchParams, timeout, errorMessage);
};
exports.fetchWithTimeout = fetchWithTimeout;
//# sourceMappingURL=userPlatformFetch.js.map

/***/ }),

/***/ 34854:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasNonAnonymousConsent = exports.fidesExtractConsentGroupsAsOtString = exports.fidesExtractConsentGroupsAsOtArray = exports.wasFidesBannerShownGtmEvent = exports.otToFidesKeyMap = exports.fidesToOtKeyMap = void 0;
const toReverseEquivalency = ([key, value]) => [value, key];
const fidesOtKeyEquivalencies = [
    ['essential', 'C0001'],
    ['analytics', 'C0002'],
    ['functional', 'C0003'],
    ['sales_sharing_targeted_advertising', 'C0004'],
    ['social_media', 'C0005'],
    ['audience_measurement', 'C0009']
];
exports.fidesToOtKeyMap = Object.fromEntries(fidesOtKeyEquivalencies);
exports.otToFidesKeyMap = Object.fromEntries(fidesOtKeyEquivalencies.map(toReverseEquivalency));
const bannerComponents = ['tcf_banner', 'banner'];
const wasFidesBannerShownGtmEvent = (gtmEvent) => gtmEvent?.event === 'FidesUIShown' &&
    bannerComponents.includes(gtmEvent.Fides.extraDetails.servingComponent);
exports.wasFidesBannerShownGtmEvent = wasFidesBannerShownGtmEvent;
const fidesExtractConsentGroupsAsOtArray = () => {
    const consented = (consentKey) => {
        let keys = consentKey;
        if (typeof consentKey === 'string') {
            keys = [consentKey];
        }
        const fidesInitialized = window.Fides?.initialized ?? false;
        const consentFlagIsTrue = (value) => value;
        const fidesDefaultConsent = { essential: true };
        const toConsentFlags = (k) => (window.Fides?.consent ?? fidesDefaultConsent)[k] ?? fidesInitialized;
        return keys.map(toConsentFlags).every(consentFlagIsTrue);
    };
    const otConsentCategories = [];
    const pushIfConsented = (otCategory, fidesKeys) => {
        if (consented(fidesKeys)) {
            otConsentCategories.push(otCategory);
        }
    };
    fidesOtKeyEquivalencies
        .map(toReverseEquivalency)
        .forEach(([otKey, fidesKey]) => pushIfConsented(otKey, fidesKey));
    return otConsentCategories;
};
exports.fidesExtractConsentGroupsAsOtArray = fidesExtractConsentGroupsAsOtArray;
const fidesExtractConsentGroupsAsOtString = () => {
    const otConsentCategories = (0, exports.fidesExtractConsentGroupsAsOtArray)();
    return otConsentCategories.join(',');
};
exports.fidesExtractConsentGroupsAsOtString = fidesExtractConsentGroupsAsOtString;
/**
 * Function to find if targeting consent is true
 * @returns {boolean} - returns true if targeting consent is present
 */
const hasNonAnonymousConsent = () => {
    if (window.Fides?.consent?.sales_sharing_targeted_advertising)
        return true;
    const otActiveGroups = (0, exports.fidesExtractConsentGroupsAsOtArray)();
    const nonAnonymousConsentGroups = ['C0004'];
    return !!otActiveGroups.some((item) => nonAnonymousConsentGroups.includes(item));
};
exports.hasNonAnonymousConsent = hasNonAnonymousConsent;
//# sourceMappingURL=tools.js.map

/***/ }),

/***/ 60162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isEmpty = __webpack_require__(62193);
const get = __webpack_require__(58156);
const { trackCommerceInteractionEvent } = __webpack_require__(14307);
const gtmEventsMapping = {
    'add-to-cart': 'add',
    'remove-from-cart': 'remove',
    'product-click': 'click',
    'product-impression': 'impressions',
    'product-detail-view': 'detail'
};
const supportedLayouts = [
    'PLP',
    'ContentCarousel',
    'GalleryShopView',
    'ProductEmbed',
    'VisualCarousel'
];
function createDynamicPLCName(layout, layoutTitle, isPDPPage = false) {
    let pageSlug = window.location.pathname?.split('/').pop();
    if (layout === 'ContentCarousel' && "object" !== 'undefined') {
        if (isPDPPage) {
            pageSlug = `pdp-product-reco-${pageSlug}`;
        }
        return `${pageSlug}-${layoutTitle}-product-carousel`;
    }
    else if (layout === 'ProductEmbed' && "object" !== 'undefined') {
        const { dataLayer } = window;
        const pageType = dataLayer[0]?.content?.contentType;
        return `${pageType}-${pageSlug}`;
    }
    else if (layout === 'VisualCarousel' && "object" !== 'undefined') {
        return `${pageSlug}-visual-carousel`;
    }
    return layout;
}
function structureGTMData(event, data) {
    const structuredData = {};
    if (Object.keys(gtmEventsMapping).includes(event)) {
        structuredData.event = event;
        const ecommerce = {};
        const { currencyCode, actionField, products, impressions, expVariationName } = data;
        ecommerce[gtmEventsMapping[event]] =
            event === 'product-impression' ? impressions : { products };
        if (currencyCode) {
            ecommerce.currencyCode = currencyCode;
        }
        if (expVariationName) {
            ecommerce.expVariationName = expVariationName;
        }
        if (actionField) {
            ecommerce[gtmEventsMapping[event]].actionField = actionField;
        }
        structuredData.ecommerce = ecommerce;
    }
    return structuredData;
}
function fetchCidFromURL(productId) {
    if (true) {
        const params = new URLSearchParams(window.location.hash.substring(1));
        const cid = params.get('cid');
        return cid;
    }
    return productId;
}
const extractNumericPrice = (price, currency) => {
    let extractPrice;
    if (currency === 'EUR') {
        const extractDefaultCurrencyPrice = price.toString().split(',');
        extractDefaultCurrencyPrice[0] = extractDefaultCurrencyPrice[0].replace('.', ',');
        extractPrice = extractDefaultCurrencyPrice.join('.');
    }
    else {
        extractPrice = price;
    }
    const numericPart = extractPrice?.toString().replace(/[^0-9.]/g, '');
    return numericPart ? parseFloat(numericPart) : null;
};
const getAssetTypeInfo = (assets, assetIndex) => {
    const asset = assets[assetIndex];
    if (!asset)
        return { assetType: null, index: null };
    const { contentType } = asset;
    let assetType;
    if (contentType === 'clip') {
        assetType = 'clip';
    }
    else if (contentType === 'cnevideo') {
        assetType = 'video';
    }
    else {
        assetType = 'image';
    }
    return { assetType, index: assetIndex };
};
const getAssetTotalIndex = (assets, totalAssetIndex) => {
    const { clipTotalIndex, videoTotalIndex } = assets.reduce((acc, { contentType }) => {
        if (contentType === 'clip')
            acc.clipTotalIndex++;
        if (contentType === 'cnevideo')
            acc.videoTotalIndex++;
        return acc;
    }, { clipTotalIndex: 0, videoTotalIndex: 0 });
    const imageTotalIndex = totalAssetIndex - (clipTotalIndex + videoTotalIndex);
    return { imageTotalIndex, clipTotalIndex, videoTotalIndex };
};
const generateProductFeatureList = (item, assetType, assetTypeIndex, imageTotalIndex, clipTotalIndex, videoTotalIndex, offerIndex) => {
    if (!item?.componentType)
        return null;
    return [
        {
            name: 'image',
            index: assetType === 'image' ? assetTypeIndex : null,
            total_index: parseInt(imageTotalIndex, 10) || null
        },
        {
            name: 'rating',
            index: parseInt(item?.rating, 10) || null,
            total_index: 10
        },
        {
            name: 'pros&cons',
            index: null,
            total_index: item?.showProsConsData ? 1 : null
        },
        {
            name: 'badges',
            index: null,
            total_index: item?.showBadge ? 1 : null
        },
        {
            name: 'clip',
            index: assetType === 'clip' ? assetTypeIndex : null,
            total_index: parseInt(clipTotalIndex, 10) || null
        },
        {
            name: 'video',
            index: assetType === 'video' ? assetTypeIndex : null,
            total_index: parseInt(videoTotalIndex, 10) || null
        },
        {
            name: 'MBB',
            index: Number.isNaN(parseInt(offerIndex, 10))
                ? null
                : parseInt(offerIndex, 10),
            total_index: parseInt(item?.offersLength, 10) || null
        }
    ];
};
function addGTMEvent(event, ecommerce, targetEvent, type, image_index, actionId, offerIndex) {
    const structuredData = structureGTMData(event, ecommerce);
    const productData = event === 'product-impression'
        ? structuredData.ecommerce?.impressions
        : structuredData.ecommerce?.click?.products;
    const eventType = event === 'product-impression' ? 'impression' : 'click';
    productData?.forEach((item) => {
        // Skip if item is null/undefined
        if (!item)
            return;
        const inputAssets = Array.isArray(item.image)
            ? item.image
            : (item.image && [item.image]) || [];
        const totalIndex = typeof item.total_index === 'number'
            ? item.total_index
            : inputAssets.length;
        // If inputAssets is longer than totalIndex, trim it.
        const selectedInputAssets = inputAssets.length > totalIndex
            ? inputAssets.slice(0, totalIndex)
            : inputAssets;
        const { assetType, index: assetTypeIndex } = getAssetTypeInfo(selectedInputAssets, image_index);
        const { imageTotalIndex, clipTotalIndex, videoTotalIndex } = getAssetTotalIndex(selectedInputAssets, totalIndex);
        const eventData = {
            type: type || eventType,
            subject: item?.component || 'product'
        };
        const videoIds = item?.videoIds;
        const featuredList = generateProductFeatureList(item, assetType, assetTypeIndex, imageTotalIndex, clipTotalIndex, videoTotalIndex, offerIndex);
        const currency = item?.currency;
        const discountPercentage = item?.sale_price &&
            (100 *
                (extractNumericPrice(item?.price, currency) -
                    extractNumericPrice(item?.sale_price, currency))) /
                extractNumericPrice(item?.price, currency);
        const eventEntityProps = {
            product_brand: item?.brand,
            product_id: item?.id,
            product_name: item?.name?.replace(/<[^>]*>/g, ''),
            index: typeof item?.index === 'number' ? parseInt(item?.index, 10) : null,
            placement: item?.placement,
            product_price: extractNumericPrice(item?.price, currency),
            is_product_discount: Boolean(item?.sale_price),
            product_discount_amount: item?.sale_price
                ? extractNumericPrice(item?.price, currency) -
                    extractNumericPrice(item?.sale_price, currency)
                : null,
            product_discount_perc: item?.sale_price
                ? Math.round(discountPercentage)
                : null,
            currency_code: item?.currency,
            product_component: item?.component,
            product_rating: typeof item?.rating === 'number' ? parseInt(item?.rating, 10) : null,
            product_category: item?.category,
            product_ref: item?.ref || null,
            hotel_location: item?.hotelLink?.split('/')[2],
            product_type: item?.type || null,
            product_system: 'commerce',
            features_list: featuredList
        };
        trackCommerceInteractionEvent(eventData, eventEntityProps, targetEvent, actionId, videoIds);
    });
    if (isEmpty(structuredData))
        return false;
    if (window.dataLayer) {
        window.dataLayer.push({ ecommerce: null });
        window.dataLayer.push(structuredData);
    }
    return true;
}
function triggerGTMEventForShopify(event, product) {
    const { title, category, productId, price, vendor, variantId, quantity, currencyCode } = product;
    const products = [
        {
            name: title,
            brand: vendor,
            variant: variantId,
            id: productId && productId.length > 0
                ? productId
                : fetchCidFromURL(productId),
            category,
            price,
            quantity
        }
    ];
    const ecommerce = {
        products,
        currencyCode
    };
    if (window?.referrer) {
        const prevousPageUrl = new URL(window.referrer);
        const pathnamePart = prevousPageUrl?.pathname?.split('/');
        const contentType = pathnamePart[1] ? `${pathnamePart[1]}-` : '';
        const list = `${contentType}${pathnamePart.pop()}`;
        ecommerce.actionField = { list };
    }
    return addGTMEvent(event, {
        ...ecommerce
    });
}
function structureTrackableData(data, window) {
    const { dangerousHed, brand, id, offers = [], categoriesPaths = [], categorySlug = '', quantity, index, rating, list, contentType, component, placement, hotelLink, total_index, componentType, showProsConsData, name, showBadge, videoIds, image, offersLength } = data;
    let productCategory;
    const variant = contentType === 'commerce-product' ? id : '';
    const type = contentType === 'venue' || contentType === 'hotel' ? 'hotel' : 'product';
    const ref = contentType === 'commerce-product' ? 'PIM' : 'Copilot';
    const categoryAncestors = get(data, 'categoriesPaths[0].ancestors', []);
    if (contentType === 'commerce-product' && !isEmpty(categoryAncestors)) {
        productCategory = categoryAncestors
            .map((ancestor) => ancestor.name)
            .join('/');
    }
    if (categorySlug) {
        return {
            brand: brand?.name,
            name: name || dangerousHed,
            id,
            price: offers[0]?.price,
            sale_price: offers[0]?.reducedPrice || offers[0]?.comparisonPrice,
            currency: offers[0]?.currency,
            category: contentType === 'commerce-product' ? productCategory : categorySlug,
            quantity,
            position: index,
            variant,
            actionField: window?.referrer,
            list,
            type,
            index,
            rating,
            component,
            placement,
            hotelLink,
            ref,
            total_index,
            componentType,
            showProsConsData,
            showBadge,
            videoIds,
            image,
            offersLength
        };
    }
    categoriesPaths.forEach((item) => {
        if (!productCategory && Array.isArray(item)) {
            item.find((category) => category.slug === 'product-category')
                ? (productCategory = item[0]?.slug)
                : (productCategory = '');
        }
    });
    return {
        brand: brand?.name,
        name: name || dangerousHed,
        id,
        price: offers[0]?.price,
        sale_price: offers[0]?.reducedPrice || offers[0]?.comparisonPrice,
        currency: offers[0]?.currency,
        category: productCategory,
        quantity,
        position: index,
        variant,
        actionField: window?.referrer,
        list,
        type,
        index,
        rating,
        component,
        placement,
        hotelLink,
        ref,
        total_index,
        componentType,
        showProsConsData,
        showBadge,
        videoIds,
        image,
        offersLength
    };
}
function formatGtmData(options) {
    const { window, product, index, actionId, layout = undefined, event = null, layoutTitle = '', type = undefined, image_index = 0, offerIndex } = options;
    if (typeof window !== 'undefined' && window.dataLayer) {
        if (isEmpty(product))
            return false;
        product.id = product.id || product.copilotID || product.variantKey;
        const { list: _, ...trackableItem } = structureTrackableData(product, window);
        const { isPDPPage } = product;
        const layoutDynamicName = createDynamicPLCName(layout, layoutTitle, isPDPPage);
        const { expVariationName } = product;
        const ecommerce = {
            actionField: { list: layoutDynamicName },
            products: [
                {
                    ...trackableItem,
                    position: index,
                    quantity: 1,
                    list: layoutDynamicName
                }
            ]
        };
        if (expVariationName) {
            ecommerce.expVariationName = expVariationName;
        }
        return addGTMEvent('product-click', ecommerce, event, type, image_index, actionId, offerIndex);
    }
    return false;
}
function elementInViewport(element) {
    const rect = element.getBoundingClientRect();
    const windowWidth = window.innerWidth || document.documentElement.clientWidth;
    const windowHeight = window.innerHeight || document.documentElement.clientHeight;
    return (windowHeight >= rect.top >= 0 &&
        windowWidth >= rect.left >= 0 &&
        windowWidth >= rect.right >= 0 &&
        (rect.right - windowWidth <= windowWidth - rect.left ||
            rect.right <= windowWidth) &&
        (rect.bottom - windowHeight <= windowHeight - rect.top ||
            rect.bottom <= windowHeight));
}
function productImpressionTracking(layout, products = [], layoutTitle = '', image_index = 0) {
    if (!supportedLayouts.includes(layout))
        return false;
    const items = [];
    let currencyCode;
    let expVariationName;
    const trackableProducts = [...products].map((item, index) => {
        const product = JSON.parse(item.getAttribute('data-item'));
        item.setAttribute('data-item', JSON.stringify({ ...product, index }));
        return item;
    });
    const hasImpressionTrackingFired = (element) => element.classList.value.split(' ').includes('impressionTrackingFired');
    const trackableItems = trackableProducts.filter((item) => !hasImpressionTrackingFired(item) && elementInViewport(item));
    if (!trackableItems.length)
        return false;
    trackableItems.forEach((item) => {
        item.classList.add('impressionTrackingFired');
        const product = JSON.parse(item.getAttribute('data-item'));
        if (!currencyCode) {
            currencyCode =
                product.offers &&
                    product.offers.find((offer) => !!offer.currency)?.currency;
        }
        if (!expVariationName) {
            ({ expVariationName } = product);
        }
        const productId = product.id || product.copilotID || product.variantKey;
        product.quantity = 1;
        product.id = productId;
        const { isPDPPage } = product;
        product.list = createDynamicPLCName(layout, layoutTitle, isPDPPage);
        items.push(structureTrackableData(product));
    });
    if (items.length) {
        const ecommerce = {
            currencyCode,
            impressions: items
        };
        if (expVariationName) {
            ecommerce.expVariationName = expVariationName;
        }
        return addGTMEvent('product-impression', ecommerce, null, null, image_index);
    }
    return false;
}
module.exports = {
    formatGtmData,
    elementInViewport,
    productImpressionTracking,
    triggerGTMEventForShopify
};
//# sourceMappingURL=gtm-model.js.map

/***/ }),

/***/ 70920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { useEffect, useState } = __webpack_require__(96540);
const { useInView } = __webpack_require__(26855);
const { useHasScrolled } = __webpack_require__(52064);
function isInIframe() {
    try {
        return window.self !== window.top;
    }
    catch (e) {
        return true;
    }
}
function getIsCloseToViewport(entry) {
    if (!entry || !entry.boundingClientRect || !entry.rootBounds) {
        return {};
    }
    const viewportHeight = window.innerHeight;
    const componentTopPosition = entry.boundingClientRect.top;
    const rootMarginTopPosition = componentTopPosition + entry.rootBounds.top;
    return {
        rootMarginIsInViewport: rootMarginTopPosition < viewportHeight,
        componentIsInViewport: componentTopPosition < viewportHeight
    };
}
function getRootMargin() {
    // return 0 on the server
    if (false) {}
    // the current viewport height
    return `${window.innerHeight}px`;
}
/*
  the root needs to be defined to work inside of iFrames

  we load the page in a iFrame in Copilot preview pages

  however setting the root as the document breaks Safari
*/
function getRoot() {
    // return nothing on the server
    if (false) {}
    if (isInIframe()) {
        return document;
    }
    return null;
}
function useLazyLoadComponent(isLazyLoaded = true) {
    const hasScrolled = useHasScrolled();
    const [showComponent, setShowComponent] = useState(!isLazyLoaded);
    const { ref, entry } = useInView({
        root: getRoot(),
        rootMargin: getRootMargin(),
        triggerOnce: true,
        skip: showComponent // disable intersection observer
    });
    const { rootMarginIsInViewport, componentIsInViewport } = getIsCloseToViewport(entry);
    useEffect(() => {
        if (showComponent) {
            return;
        }
        /*
          Two conditions to load the component:
    
          1. We want to load the component if it's in the viewport
            This would replicate a non-lazy loading behaviour.
    
          2. If we've scrolled and the component is close to the viewport
            If the user hasn't scrolled we don't want to load the component.
            Once the user has scrolled we will then check if the rootMargin
            is in the viewport.
        */
        if (componentIsInViewport || (hasScrolled && rootMarginIsInViewport)) {
            setShowComponent(true);
        }
    }, [
        hasScrolled,
        componentIsInViewport,
        rootMarginIsInViewport,
        showComponent
    ]);
    return [ref, showComponent];
}
module.exports = useLazyLoadComponent;
//# sourceMappingURL=useLazyLoadComponent.js.map

/***/ }),

/***/ 9170:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBot = void 0;
const botUserAgents = [
    'bot',
    'storebot',
    // Google Crawlers
    'googlebot',
    'adsbot-google',
    'apis-google',
    'mediapartners-google',
    'googlebot-image',
    'googlebot-news',
    'googlebot-video',
    'adsbot-google-mobile',
    'adsbot-google-mobile-apps',
    // Bing Crawlers
    'bingbot',
    'bingpreview',
    'adidxbot',
    'binglocalbot',
    'msnbot',
    'msnbot-media'
];
/**
 * Checks if the given user agent string belongs to a known bot.
 *
 * @param {string} userAgent - The user agent string to check.
 * @returns {boolean} - Returns true if the user agent is identified as a bot, otherwise false.
 */
const isBot = (userAgent) => {
    if (!userAgent) {
        return false;
    }
    const userAgentString = userAgent.toLowerCase();
    return botUserAgents.some((bot) => userAgentString.includes(bot));
};
exports.isBot = isBot;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 89738:
/***/ ((module) => {

/**
 * Attempts to get a displayName from the component being evaluated
 *
 * @param {object} Component - React Component
 * @returns {string} Component displayName
 */
function getDisplayName(Component) {
    let displayName = Component.displayName || Component.name;
    if (!displayName) {
        console.error(new Error('Component to wrap has no displayName'));
        displayName = '';
    }
    return displayName;
}
module.exports = {
    getDisplayName
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 29727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// CPP: DELETEME const { proxyApiRoutes } = require('../../../constants/apiRoutes');
// CPP: DELETEME const { fetchWithTimeout } = require('../fetch/userPlatformFetch');
const { fetchWithTimeout } = __webpack_require__(57743);
const MAX_TIMEOUT = 5000;
// CPP: DELETEME
// /**
//  * Get newsletter subscriptions for authenticated users using their amgUUID
//  * OR for non-authenticated users using a sailthruId.
//  * newsletterIds which is a string of comma separated newsletter ids is required. Optional query param is provider.
//  * For authenticated users it uses toolkit as default service or sailtrhu when provider is specified as such.
//  *
//  * @param {object} opts - newsletters subscription request options
//  * @param {string} opts.amgUUID - user amgUUID
//  * @param {string} opts.newsletterIds - string of comma separated newsletterIds
//  * @param {object} [opts.provider] - optional service provider for newsletter preferences
//  * @param {object} [opts.parseJson] - optional parseJson. Default value is set to true to return the parsed json from the response body
//  * @param {string} [opts.sailthruId] - optional sailthruId to fetch subscriptions from sailthru
//  * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
//  * @param {string} opts.xClientID - brand x-client
//  *
//  * @returns {Promise<object>} - response object includes list of newsletters with newsletterId and status
//  */
// const getNewsletterSubscriptions = async (opts) => {
//   const {
//     amgUUID,
//     newsletterIds,
//     parseJson = true,
//     provider,
//     sailthruId,
//     userPlatformProxy,
//     xClientID
//   } = opts;
//   const apiURL = `${userPlatformProxy}${
//     proxyApiRoutes.userDetails
//   }/${amgUUID}/newsletter-subscriptions?newsletterIds=${newsletterIds}${
//     provider ? `&provider=${provider}` : ''
//   }`;
//   const sailthruApiURL = `${userPlatformProxy}${proxyApiRoutes.sailthruNewsletterSubscriptions}?sailthruId=${sailthruId}&newsletterIds=${newsletterIds}`;
//   const getApiURL = sailthruId ? sailthruApiURL : apiURL;
//   const credentials = sailthruId ? 'same-origin' : 'include';
//   try {
//     const response = await fetchWithTimeout(
//       getApiURL,
//       {
//         credentials,
//         headers: {
//           'Content-Type': 'application/json',
//           'x-client': xClientID
//         },
//         method: 'GET'
//       },
//       MAX_TIMEOUT
//     );
//     const { status } = response;
//     // Sailthru user not found, so return empty prefs
//     if (provider === 'sailthru' && status === 424) {
//       const result = { status: 200, newsletterSubscriptions: { data: [] } };
//       return parseJson ? result : { json: () => result };
//     }
//     const body = parseJson && (await response.json());
//     const result = {
//       status,
//       newsletterSubscriptions: {
//         data: body.data
//       }
//     };
//     return parseJson ? result : response;
//   } catch (error) {
//     const errorStatus = error.status || 400;
//     throw new Error(
//       `${errorStatus} - Error encountered retrieving newsletter subscriptions: ${error.message}`
//     );
//   }
// };
/**
 * Get newsletter subscriptions and consents for authenticated users using their amgUUID/sailthruid/email from CPP
 *
 * @param {object} opts - newsletters subscription request options
 * @param {string} opts.amgUUID - user amgUUID
 * @param {string} opts.newsletterIds - string of comma separated newsletterIds
 * @param {object} [opts.provider] - optional service provider for newsletter preferences
 * @param {object} [opts.parseJson] - optional parseJson. Default value is set to true to return the parsed json from the response body
 * @param {string} [opts.sailthruId] - optional sailthruId to fetch subscriptions from sailthru
 * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 * @param {string} opts.xClientID - brand x-client
 *
 * @returns {Promise<object>} - response object includes list of newsletters with newsletterId/status and list of consents with id/status
 */
const getNewsletterSubscriptions = async (opts) => {
    const { xClientID, provider, parseJson = true, newsletterIds, amgUUID, sailthruId, sendAllNewsletterIds = false } = opts;
    const apiURL = '/api/fetchConsent';
    try {
        const response = await fetchWithTimeout(apiURL, {
            body: JSON.stringify({ amgUUID, sailthruId }),
            headers: {
                'Content-Type': 'application/json',
                'x-client': xClientID
            },
            method: 'POST'
        }, MAX_TIMEOUT);
        const { error, fetchConsent } = await response.json();
        if (error) {
            throw error;
        }
        // CPP-DELETEME: const { success, user } = fetchConsent.userDetail;
        const { success, users } = fetchConsent.users;
        if (!success) {
            if (provider === 'sailthru') {
                const result = { status: 200, newsletterSubscriptions: { data: [] } };
                return parseJson ? result : { json: () => result };
            }
            throw new Error(424);
        }
        const { consents, externalIds } = users[0];
        const ids = {};
        for (const externalId of externalIds) {
            const [, , type, id] = externalId.split(':');
            ids[type] = id;
        }
        const user = {
            ...ids,
            consents
        };
        const userEmail = user.email;
        const newsletterConsents = user.consents.reduce((acc, { urn, status }) => {
            const urnArr = urn.split(':');
            const id = urnArr.pop();
            const type = urnArr.pop();
            if (type.toLowerCase() === 'newsletter' &&
                (sendAllNewsletterIds || newsletterIds.includes(id)))
                acc.push({
                    type: 'newsletter-subscriptions',
                    id,
                    attributes: {
                        email: userEmail,
                        newsletterId: id,
                        status: status ? 'SUBSCRIBED' : 'UNSUBSCRIBED'
                    }
                });
            return acc;
        }, []);
        const marketingConsents = user.consents.reduce((acc, { urn, status }) => {
            const urnArr = urn.split(':');
            const id = urnArr.pop();
            const type = urnArr.pop();
            if (type.toLowerCase() === 'marketing')
                acc[id] = status;
            return acc;
        }, {});
        const result = {
            status: response.status,
            newsletterSubscriptions: {
                data: newsletterConsents
            },
            marketingConsents
        };
        return parseJson ? result : { json: () => result };
    }
    catch (error) {
        const errorStatus = error.status || 400;
        throw new Error(`${errorStatus} - Error encountered retrieving newsletter subscriptions: ${error.message}`);
    }
};
/**
 * Fetch whether a user is subscribed to a newsletter
 *
 * @param {object} [opts] - newsletters subscription request options
 * @param {string} [opts.amgUUID] - user amgUUID
 * @param {string} [opts.newsletterIds] - array of newsletterIds
 * @param {string} [opts.userPlatformProxy] - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 * @param {string} [opts.xClientID] - brand x-client
 *
 * @returns {boolean} - user subscription to a newsletter
 */
const isUserSubscribedToNewsletter = async (opts) => {
    try {
        const newsletterId = opts.newsletterIds[0];
        const newsletterSubscriptionData = await getNewsletterSubscriptions(opts);
        if (newsletterSubscriptionData.status === 200) {
            const newsletterData = newsletterSubscriptionData?.newsletterSubscriptions?.data;
            const subscribedNewsletters = newsletterData.filter((newsletter) => newsletter.attributes.newsletterId === newsletterId &&
                newsletter.attributes.status === 'SUBSCRIBED');
            return !!subscribedNewsletters.length;
        }
        return false;
    }
    catch (err) {
        return false;
    }
};
// CPP: DELETEME this function is not used anywhere
// /**
//  * Take the newsletters array and removes the user subscribed newsletters.
//  *
//  * @param {object} user - User details from redux
//  * @param {object} userPlatform - User platform details from redux
//  * @param {Array} newsletters - List of newsletters to be filtered
//  *
//  * @returns {Promise<Array>} - filtered newsletters array
//  */
// async function getUnsubscribedNewsletters(user, userPlatform, newsletters) {
//   if (newsletters.length === 0) {
//     return [];
//   }
//   const { userPlatformProxy, xClientID } = userPlatform || {};
//   if (user?.isAuthenticated) {
//     const newsletterIds = newsletters.map(
//       (newsletter) => newsletter.newsletterId
//     );
//     try {
//       const subscriptionsResponse = await getNewsletterSubscriptions({
//         amgUUID: user.amguuid,
//         newsletterIds,
//         userPlatformProxy,
//         xClientID,
//         provider: 'sailthru'
//       });
//       if (subscriptionsResponse?.status !== 200) {
//         return [];
//       }
//       const newsletterSubscriptions =
//         subscriptionsResponse.newsletterSubscriptions.data || [];
//       if (newsletterSubscriptions.length === 0) {
//         return newsletters;
//       }
//       const subscribedIds = newsletterSubscriptions.reduce(
//         (ids, subscription) => {
//           const { status, newsletterId } = subscription?.attributes || {};
//           if (status && status === 'SUBSCRIBED' && newsletterId) {
//             ids.push(newsletterId);
//           }
//           return ids;
//         },
//         []
//       );
//       return newsletters.filter(
//         (newsletter) => !subscribedIds.includes(newsletter.newsletterId)
//       );
//     } catch (error) {
//       console.error(error);
//       return [];
//     }
//   }
//   return newsletters;
// }
module.exports = {
    getNewsletterSubscriptions,
    isUserSubscribedToNewsletter
};
//# sourceMappingURL=getNewsletterSubscriptions.js.map

/***/ }),

/***/ 88511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createValidationErrorMessage = exports.trackUpdatedPrefs = void 0;
/**
 * Keep track of what checkboxes the user has selected and/or unselected.
 * Storing in state so that we can emit google analytics data with only the
 * newsletters that the user has changed.
 *
 * @param {object} opts - see below
 * @param {boolean} opts.newNewsletterStatus - desired status of newsletter subscription
 * @param {string} opts.targetNewsletter - the id of the newsletter triggering the onChange
 * @param {Array} opts.updatedPrefs - array of preferences that the user has clicked on/updated without saving
 *
 * @returns {Array} of new newsletter preferences to be submitted
 */
const trackUpdatedPrefs = ({ newNewsletterStatus, targetNewsletter, updatedPrefs }) => {
    const newPrefs = [];
    let targetIdHasRecord = false;
    if (updatedPrefs.length !== 0) {
        // User has selected/unselected newsletters on the page already, but not yet submitted
        updatedPrefs.forEach((newsletter) => {
            const { newsletterId } = newsletter;
            if (newsletterId === targetNewsletter) {
                // We have recorded an event for this newsletter already. Another click
                // would set it back to the initial preference, so just return the
                // accumulator without it (clearing the update from the list of updates)
                targetIdHasRecord = true;
                return;
            }
            // This preserves other entries in updatedPrefs
            newPrefs.push(newsletter);
        });
    }
    // This adds the subscription if no entry for it exists in updatedPrefs already
    if (!targetIdHasRecord) {
        const status = newNewsletterStatus ? 'SUBSCRIBED' : 'UNSUBSCRIBED';
        newPrefs.push({ newsletterId: targetNewsletter, status });
    }
    return newPrefs;
};
exports.trackUpdatedPrefs = trackUpdatedPrefs;
const createValidationErrorMessage = (validationErrors = []) => {
    let errorMessage = '';
    if (!validationErrors)
        return errorMessage;
    for (const error of validationErrors) {
        const text = `${error.text
            .toLowerCase()
            .charAt(0)
            .toUpperCase()}${error.text.slice(1)}`;
        let message = (error?.messages && error.messages[0]) || '';
        message = `${message.toLowerCase().charAt(0).toUpperCase()}${message.slice(1)}`;
        errorMessage += message.length === 0 ? `${text}` : `${message}`;
    }
    return errorMessage.trim();
};
exports.createValidationErrorMessage = createValidationErrorMessage;
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 26430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getNewsletterSubscriptions } = __webpack_require__(29727);
const { saveNewsletterSubscriptions } = __webpack_require__(89054);
const helpers = __webpack_require__(88511);
module.exports = {
    getNewsletterSubscriptions,
    saveNewsletterSubscriptions,
    ...helpers
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 89054:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// CPP: DELETEME const { proxyApiRoutes } = require('../../../constants/apiRoutes');
// CPP: DELETEME const { fetchWithTimeout } = require('../fetch/userPlatformFetch');
const { fetchWithTimeout } = __webpack_require__(57743);
const MAX_TIMEOUT = 5000;
// CPP: DELETEME
// /**
//  * Save newsletter subscriptions for non-authenticated users using their email.
//  * OR Update newsletter subscriptions for authenticated users using their amgUUID.
//  * Payload includes subscriptions array of brand newsletters.
//  * The list of subscriptions newsletters have keys for newsletterId and status.
//  * Optional payload keys are formName, sourceCode, recaptchaResponse and provider
//  * It uses toolkit as default service or sailthru when provider is specified as such.
//  *
//  * @param {object} opts - newsletters subscription request options
//  * @param {string} [opts.amgUUID] - optional authenticated user's amgUUID
//  * @param {object} opts.payload - request payload
//  * @param {string} [opts.payload.email] - optional unauthenticated user's email
//  * @param {string} [opts.payload.formName] - optional HTML form name
//  * @param {string} [opts.payload.recaptchaResponse] - optional recaptchaResonse from browser window recaptcha widget
//  * @param {string} opts.payload.siteCode - brand siteCode
//  * @param {string} [opts.payload.sourceCode] - optional brand subscription soruce code
//  * @param {Array<object>} opts.payload.subscriptions[] - newsletter subscription object
//  * @param {string} opts.payload.subscriptions[].status - must be either SUBSCRIBED / UNSUBSCRIBED
//  * @param {number} opts.payload.subscriptions[].newsletterId - ID of the newsletter
//  * @param {object} [opts.payload.provider] - optional service provider for newsletter preferences
//  * @param {string} opts.payload.url - url address of page where request is made
//  * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
//  * @param {string} opts.xClientID - brand x-client
//  *
//  * @returns {Promise<object>} - response object includes list of newsletters with newsletterId and status
//  */
// const saveNewsletterSubscriptions = async (opts) => {
//   const {
//     amgUUID,
//     payload: requestPayload,
//     xClientID,
//     userPlatformProxy
//   } = opts;
//   const unauthenticatedApiURL = `${userPlatformProxy}${proxyApiRoutes.newsletterSubscriptions}`;
//   const authenticatedApiURL = `${userPlatformProxy}${proxyApiRoutes.userDetails}/${amgUUID}/newsletter-subscriptions`;
//   const { email, ...defaultPayload } = requestPayload;
//   const payload = amgUUID ? defaultPayload : requestPayload;
//   const apiURL = amgUUID ? authenticatedApiURL : unauthenticatedApiURL;
//   const credentials = amgUUID ? 'include' : 'same-origin';
//   try {
//     return fetchWithTimeout(
//       apiURL,
//       {
//         body: JSON.stringify(payload),
//         credentials,
//         headers: {
//           'Content-Type': 'application/json',
//           'x-client': xClientID
//         },
//         method: 'POST'
//       },
//       MAX_TIMEOUT
//     );
//   } catch (error) {
//     const errorStatus = error.status || 400;
//     throw new Error(
//       `${errorStatus} - Error encountered saving newsletter subscriptions: ${error.message}`
//     );
//   }
// };
/**
 * Save newsletter subscriptions for non-authenticated users using their email.
 * OR Update newsletter subscriptions for authenticated users using their amgUUID.
 * Payload includes subscriptions array of brand newsletters.
 * The list of subscriptions newsletters have keys for newsletterId and status.
 * Optional payload keys are formName, sourceCode, recaptchaResponse and provider
 * It uses toolkit as default service or sailthru when provider is specified as such.
 * @param {object} opts - newsletters subscription request options
 * @param {string} [opts.amgUUID] - optional authenticated user's amgUUID
 * @param {object} opts.payload - request payload
 * @param {string} [opts.payload.email] - optional unauthenticated user's email
 * @param {string} [opts.payload.formName] - optional HTML form name
 * @param {string} [opts.payload.recaptchaResponse] - optional recaptchaResonse from browser window recaptcha widget
 * @param {object} opts.payload.marketingConsents - marketing consents
 * @param {string} opts.payload.siteCode - brand siteCode
 * @param {string} [opts.payload.sourceCode] - optional brand subscription soruce code
 * @param {string} [opts.payload.sourceCodeForCheckingReCaptcha] - optional for checking reCaptcha
 * @param {Array<object>} opts.payload.subscriptions[] - newsletter subscription object
 * @param {string} opts.payload.subscriptions[].status - must be either SUBSCRIBED / UNSUBSCRIBED
 * @param {number} opts.payload.subscriptions[].newsletterId - ID of the newsletter
 * @param {object} [opts.payload.provider] - optional service provider for newsletter preferences
 * @param {string} opts.payload.url - url address of page where request is made
 * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 * @param {string} opts.xClientID - brand x-client
 *
 * @returns {Promise<object>} - response object includes list of newsletters with newsletterId and status
 */
const saveNewsletterSubscriptions = async (opts) => {
    const { amgUUID, sailthruId, payload: { email, subscriptions, marketingConsents = {}, sourceCode: source, sourceCodeForCheckingReCaptcha = '', formName: formname = '', recaptchaResponse = '' }, xClientID } = opts;
    const metadata = {
        source,
        formname,
        client: xClientID
    };
    const timestamp = new Date().toISOString();
    const consents = [
        ...subscriptions.map(({ newsletterId: id, status }) => ({
            id,
            status: status.toLowerCase() === 'subscribed',
            type: 'newsletter',
            timestamp
        })),
        ...Object.entries(marketingConsents)
            .filter(([id, status]) => status !== null && id)
            .map(([id, status]) => ({
            id,
            status,
            type: 'marketing',
            timestamp
        }))
    ];
    const payload = {
        amgUUID,
        sailthruId,
        email,
        consents,
        metadata,
        // CPPv2: DELETEME post full reCAPTCHA rollout.
        // These fields are temporary custom flags used for reCAPTCHA validation and bot attack prevention.
        isLoggedIn: !!amgUUID,
        recaptchaResponse,
        sourceCodeForCheckingReCaptcha
    };
    const apiURL = '/api/savePreference';
    // CPP: DELETEME const credentials = amgUUID ? 'include' : 'same-origin';
    try {
        const response = await fetchWithTimeout(apiURL, {
            body: JSON.stringify(payload),
            // CPP: DELETEME credentials,
            headers: {
                'Content-Type': 'application/json',
                'x-client': xClientID
            },
            method: 'POST'
        }, MAX_TIMEOUT);
        return await response.json();
    }
    catch (error) {
        const errorStatus = error.status || 400;
        throw new Error(`${errorStatus} - Error encountered saving newsletter subscriptions: ${error.message}`);
    }
};
module.exports = {
    saveNewsletterSubscriptions
};
//# sourceMappingURL=saveNewsletterSubscriptions.js.map

/***/ }),

/***/ 15356:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const withIncognitoDetection = __webpack_require__(10927);
const withVisibilityState = __webpack_require__(68545);
const withMutationState = __webpack_require__(45516);
module.exports = {
    withIncognitoDetection,
    withVisibilityState,
    withMutationState
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 10927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const merge = __webpack_require__(55364);
/**
 * withIncognitoDetection
 *
 * This HOC provides information about browser incognito detection
 * to the wrapped component via a browser object, which includes
 * the incognitoMode property.
 *
 * The browser.incognitoMode property: it should be true only when the ads
 * library has sent an incognito detection event that specifies that
 * the user is in fact using an incognito window. Otherwise, when the
 * detection hasn't finished yet or it finished but didn't detect an
 * incognito window, it'll be false.
 *
 * @param {ReactComponent} Component - the component to be wrapped
 * @param {string} name - component's namespace
 *
 * @returns {ReactComponent} the wrapped component
 */
const withIncognitoDetection = (Component, name = 'browser') => {
    const componentName = Component.displayName || Component.name;
    class IncognitoDetection extends React.Component {
        constructor() {
            super();
            this.render = () => {
                const newProps = {
                    [name]: {
                        incognitoMode: this.state.incognitoDetected
                    }
                };
                const mergedProps = merge({}, this.props, newProps);
                return React.createElement(Component, { ...mergedProps });
            };
            this.state = { incognitoDetected: false };
        }
        componentDidMount() {
            this.updateIncognitoDetectedState();
        }
        componentWillUnmount() {
            if (this.unbindChannel) {
                this.unbindChannel();
            }
        }
        listenForIncognitoDetectionEvents() {
            if (!window.cnBus || !window.cnBus.on) {
                return;
            }
            this.unbindChannel = window.cnBus.on('ads.environment.incognito.detected.#', () => {
                this.setState({ incognitoDetected: true });
            });
        }
        updateIncognitoDetectedState() {
            const incognitoDetected = window.cnBus &&
                window.cnBus.history &&
                Boolean(window.cnBus.history('ads.environment.incognito.detected.#').length);
            if (!incognitoDetected) {
                this.listenForIncognitoDetectionEvents();
            }
            else {
                this.setState({ incognitoDetected: true });
            }
        }
    }
    IncognitoDetection.displayName = `withIncognitoDetection(${componentName})`;
    return IncognitoDetection;
};
module.exports = withIncognitoDetection;
//# sourceMappingURL=withIncognitoDetection.js.map

/***/ }),

/***/ 45516:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const merge = __webpack_require__(55364);
/**
 * withMutationState
 *
 * A factory that receives a target element and returns a higher-order component.
 *
 * This higher-order component wraps another and provides it with information
 * describing if the component wrapped has been injected by DFP or Journeys by
 * watching the subtree Mutations.
 *
 * The wrapped component receives a 'mutation' object via props, each element name
 * key will be paired to a boolean value, when this boolean is 'true' for a certain name
 * it means that the element referenced by that name has been injected by either DFP or Journeys.
 *
 * @param {object} element - a target element to be observed
 * @param {string} element.name - name of the target element
 * @param {string} element.className - class name of the target element
 * @param {object} win - the window object
 *
 * @returns {Function} - Mutation Higher-Order Component
 */
const withMutationState = (element, win) => (Component, name = 'mutation') => {
    const componentName = Component.displayName || Component.name;
    const ext = { window: win || ( true && window) };
    class MutationState extends React.Component {
        constructor(props) {
            super(props);
            this.updateMutation = (node) => {
                const hasBeenInjected = node.querySelectorAll(':not(div)').length > 0;
                this.setState({ hasBeenInjected });
            };
            this.render = () => {
                const newProps = {
                    [name]: { [this.element.name]: this.state.hasBeenInjected }
                };
                const mergedProps = merge({}, this.props, newProps);
                return React.createElement(Component, { ...mergedProps });
            };
            this.state = { hasBeenInjected: false };
            this.element = props.element || element;
        }
        componentDidMount() {
            this.attachObserver();
        }
        componentDidUpdate(prevProps) {
            if (prevProps.element !== this.props.element) {
                this.element = this.props.element || element;
                this.detachObserver();
                this.attachObserver();
            }
        }
        componentWillUnmount() {
            this.detachObserver();
        }
        attachObserver() {
            const nodes = ext.window.document.querySelectorAll(`.${this.element.className}, .${this.element.className} .consumer-marketing-unit__slot + div`);
            if (nodes.length === 0) {
                this.retryTimer = setTimeout(this.attachObserver.bind(this), 500);
                return;
            }
            const attach = (node) => {
                this.updateMutation(node);
                this.observer = new ext.window.MutationObserver(() => this.updateMutation(node));
                this.observer.observe(node, { childList: true, subtree: true });
            };
            nodes.forEach(attach);
        }
        detachObserver() {
            this.retryTimer && clearTimeout(this.retryTimer);
            this.observer && this.observer.disconnect();
        }
    }
    MutationState.displayName = `withMutationState(${componentName})`;
    MutationState.propTypes = {
        element: PropTypes.shape({
            name: PropTypes.string,
            className: PropTypes.string
        })
    };
    return MutationState;
};
module.exports = withMutationState;
//# sourceMappingURL=withMutationState.js.map

/***/ }),

/***/ 68545:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const merge = __webpack_require__(55364);
/**
 * isNodeViewable
 *
 * This function is used to detect when a DOM element is not viewable
 * due to CSS visibility manipulations such as 'visibility', 'opacity', or
 * even the element being dimensionless (zero width or height).
 *
 * @param {Window} window - the window object
 * @param {HTMLElement} node - the observed HTML element
 *
 * @returns {boolean} is the observed node viewable
 */
const isNodeViewable = (window, node) => {
    const { opacity, visibility } = window.getComputedStyle(node);
    return (!!node.offsetHeight &&
        !!node.offsetWidth &&
        opacity !== '0' &&
        visibility !== 'hidden');
};
/**
 * withVisibilityState
 *
 * A factory that receives a target element and returns a higher-order component.
 *
 * This higher-order component wraps another and provides it with information
 * describing the visibility of an element within the viewport of the client via
 * a named prop.
 *
 * The wrapped component receives a 'visibility' object via props, each element name
 * key will be paired to a boolean value, when this boolean is 'true' for a certain name,
 * it means that the element referenced by that name is completely visible for the user and
 * it is currently in their page viewport.
 *
 * @param {object} element - a target element to be observed
 * @param {string} element.name - name of the target element
 * @param {string} element.className - class name of the target element
 * @param {object} win - the window object
 *
 * @returns {Function} - Visibility Higher-Order Component
 */
const withVisibilityState = (element, win) => (Component, name = 'visibility') => {
    const componentName = Component.displayName || Component.name;
    const ext = { window: win || ( true && window) };
    class VisibilityState extends React.Component {
        constructor(props) {
            super(props);
            this.updateVisibility = (entries) => {
                const [{ isIntersecting, target }] = entries;
                const isVisible = isIntersecting && isNodeViewable(ext.window, target);
                if (this.state.isVisible !== isVisible) {
                    this.setState({ isVisible });
                }
            };
            this.render = () => {
                const newProps = {
                    [name]: { [this.element.name]: this.state.isVisible }
                };
                const mergedProps = merge({}, this.props, newProps);
                return React.createElement(Component, { ...mergedProps });
            };
            this.state = { isVisible: false };
            this.element = props.element || element;
        }
        componentDidMount() {
            this.attachObserver();
        }
        componentDidUpdate(prevProps) {
            if (prevProps.element !== this.props.element) {
                this.element = this.props.element || element;
                this.detachObserver();
                this.attachObserver();
            }
        }
        componentWillUnmount() {
            this.detachObserver();
        }
        attachObserver() {
            const node = ext.window.document.querySelector(`.${this.element.className}`);
            if (!node || !isNodeViewable(ext.window, node)) {
                this.retryTimer = setTimeout(this.attachObserver.bind(this), 500);
                return;
            }
            this.observer = new ext.window.IntersectionObserver(this.updateVisibility, { threshold: [0.001, 0.999] });
            this.observer.observe(node);
        }
        detachObserver() {
            this.retryTimer && clearTimeout(this.retryTimer);
            this.observer && this.observer.disconnect();
        }
    }
    VisibilityState.displayName = `withVisibilityState(${componentName})`;
    VisibilityState.propTypes = {
        element: PropTypes.shape({
            name: PropTypes.string,
            className: PropTypes.string
        })
    };
    return VisibilityState;
};
module.exports = withVisibilityState;
//# sourceMappingURL=withVisibilityState.js.map

/***/ }),

/***/ 56822:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Create a performance marker using the 'User Timing API'.
 * A performance mark is a named 'Performance Entry' that is created by the application.
 * The mark is a timestamp in the browser's performance timeline.
 *
 * @param {string} name - The name of the mark
 * @returns {undefined} undefined
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.perfMeasure = exports.perfMark = exports.buildMeasureName = exports.buildMarkName = void 0;
function perfMark(name) {
    if (typeof window.performance !== 'undefined' &&
        typeof window.performance.mark !== 'undefined') {
        window.performance.mark(name);
    }
}
exports.perfMark = perfMark;
/**
 * Create a performance measure using the 'User Timing API'.
 * Measure events are placed between two marks thus they are effectively a midpoint between two marks.
 *
 * @param {string} name - The measure's name
 * @param {string} startMark -  The start name of the marks the measure will be placed between.
 * @param {string} endMark -  The end name of the mark the measure will be placed between.
 * @returns {undefined} undefined
 */
function perfMeasure(name, startMark, endMark) {
    if (typeof window.performance !== 'undefined' &&
        typeof window.performance.measure !== 'undefined') {
        try {
            window.performance.measure(name, startMark, endMark);
        }
        catch (e) {
            console.error(`Error setting performance measure: ${e}`);
        }
    }
}
exports.perfMeasure = perfMeasure;
/**
 * A helper function to create a Mark name.
 *
 * @param {string} page - description of page with mark
 * @param {string} action - description of action triggering the mark
 * @returns {string} string
 */
function buildMarkName(page, action) {
    return `${page}__${action}`;
}
exports.buildMarkName = buildMarkName;
/**
 * A helper function to create a Measure name..
 *
 * @param {string} page - description of page with measure.
 * @param {string} startMark - name of the first mark.
 * @param {string} endMark - name of second mark.
 * @returns {string} string
 */
function buildMeasureName(page, startMark, endMark) {
    return `${page}__${startMark}-to-${endMark}`;
}
exports.buildMeasureName = buildMeasureName;
//# sourceMappingURL=perf-tooling.js.map

/***/ }),

/***/ 70978:
/***/ ((module) => {

/**
 * Append query paremeters to base URI
 *
 * @param {string} uri - the uri to be appended to
 * @param {object} query - an object that will be used to generate query params
 * @returns {string} - the new uri
 */
const appendQueryToURI = (uri, query) => {
    if (typeof query !== 'object') {
        return uri;
    }
    const keys = Object.keys(query);
    if (!keys.length) {
        return uri;
    }
    const queries = keys
        .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`)
        .join('&');
    return uri.includes('?') ? `${uri}&${queries}` : `${uri}?${queries}`;
};
module.exports = appendQueryToURI;
//# sourceMappingURL=appendQueryToURI.js.map

/***/ }),

/***/ 12311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const appendQueryToURI = __webpack_require__(70978);
const parseQueryParams = __webpack_require__(10604);
const stripParamsFromURI = __webpack_require__(85613);
module.exports = {
    appendQueryToURI,
    parseQueryParams,
    stripParamsFromURI
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 10604:
/***/ ((module) => {

/**
 * Parse the query params from a provided string and return an object map of param names to values.
 *
 * @param {string} searchString - location search string https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search
 * @returns {object} An object map of query param names to values
 */
const parseQueryParams = (searchString) => {
    try {
        decodeURIComponent(searchString);
    }
    catch (err) {
        return {};
    }
    if (!searchString ||
        typeof searchString !== 'string' ||
        !searchString.length) {
        return {};
    }
    return searchString
        .substr(1) // remove leading '?'
        .split('&') // split on param separator
        .reduce((acc, pair) => {
        const [name, val] = pair.split('=');
        if (val) {
            acc[decodeURIComponent(name)] = decodeURIComponent(val);
        }
        return acc;
    }, {}); // aggregate into param map
};
module.exports = parseQueryParams;
//# sourceMappingURL=parseQueryParams.js.map

/***/ }),

/***/ 85613:
/***/ ((module) => {

/**
 * Strip query paremeters from base URI
 *
 * @param {string} uri - the uri to be appended to
 * @returns {string} - the new uri
 */
const stripParamsFromURI = (uri = '') => uri.replace(/\?(.*)/, '');
module.exports = stripParamsFromURI;
//# sourceMappingURL=stripParamsFromURI.js.map

/***/ }),

/***/ 77314:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { useEffect, useState } = __webpack_require__(96540);
const buildQueryString = (__webpack_require__(84077)/* ["default"] */ .A);
const transformRecircItem = (__webpack_require__(99659)["default"]);
const { cn_xid } = __webpack_require__(14307);
/**
 * Custom React hook to fetch and transform recommendation data from an API.
 *
 * @param {object} config - Configuration object for the hook.
 * @param {string} config.contentID - The ID of the content for which recommendations are fetched.
 * @param {string} config.brandSlug - The brand slug used in the API request.
 * @param {boolean} config.isSmallScreen - Indicates if the request is for a small screen.
 * @param {string} config.canonicalUrl - The canonical URL of the current page.
 * @param {string} config.language - The language code for the recommendations.
 * @param {string} config.recommendationsApiUrl - The base URL of the recommendations API.
 * @param {boolean} config.shouldUseTrailingSlash - Whether to use a trailing slash in URLs.
 * @param {object} config.photoConfig - Configuration for photo transformations.
 * @param {string} config.vulcanUrl - The base URL for Vulcan services.
 * @param {string} config.applicationID - The application ID for the API request.
 * @param {Array<string>} [config.excludeCategories] - Categories to exclude from recommendations.
 * @param {Array<string>} [config.categories] - Categories to include in recommendations.
 * @param {number} config.pageSize - The number of recommendations to fetch for larger screens.
 * @param {number} config.mobilePageSize - The number of recommendations to fetch for smaller screens.
 * @param {number} config.numberOfDays - The number of days to look back for recommendations.
 * @param {string} config.strategy - The strategy to use for fetching recommendations.
 * @param {boolean} config.isExtendedRecirc - Indicates if extended recirculation is enabled.
 * @param {object} config.extendedRecircItemsConfig - Configuration for extended recirculation items.
 *
 * @returns {object} - An object containing the fetched data, error, and loading state.
 * @returns {Array|null} return.data - The transformed recommendation data, or null if not available.
 * @returns {Error|null} return.error - The error object if an error occurred, or null otherwise.
 * @returns {boolean} return.loading - Indicates if the data is currently being fetched.
 */
const useClientRequest = (config) => {
    const [recircListClientData, setRecircListClientData] = useState([]);
    const [extendedRecircClientData, setExtendedRecircClientData] = useState([]);
    const [personalizedClientData, setPersonalizedClientData] = useState({
        items: [],
        varietyDesignItems: []
    });
    const [recircClientLoading, setRecircClientLoading] = useState(false);
    const [extendedRecircClientLoading, setExtendedRecircClientLoading] = useState(false);
    const { brandSlug, recommendationsApiUrl, shouldUseTrailingSlash, photoConfig, vulcanUrl, applicationID, isExtendedRecirc, extendedRecircItemsConfig, extendedRecircRightRailRenditions, isPersonalizedHomepage, varietyInvertedRenditions, varietyMainStoryRendition, carouselRenditions, layout } = config;
    const getQueryString = (params) => {
        return buildQueryString({
            ...params,
            isMobile: params.isSmallScreen,
            brandSlugs: [params.brandSlug],
            copilotId: params.contentID,
            url: params.canonicalUrl,
            xid: cn_xid
        });
    };
    const fetchData = async (queryString, isExtendedRecirc) => {
        const setLoading = isExtendedRecirc
            ? setExtendedRecircClientLoading
            : setRecircClientLoading;
        setLoading(true);
        try {
            const result = await fetch(`${recommendationsApiUrl}?${queryString}`, {
                method: 'GET'
            })
                .then((res) => res.json())
                .then((res) => res.data);
            return result;
        }
        catch (err) {
            throw new Error();
        }
        finally {
            setLoading(false);
        }
    };
    const generateRecircItemByLayout = (layout, index, baseConfig) => {
        switch (layout) {
            case 'variety-inverted':
                return transformRecircItem({
                    ...baseConfig,
                    photoConfig: index === 0 ? varietyMainStoryRendition : varietyInvertedRenditions
                });
            case 'carousel':
                return transformRecircItem({
                    ...baseConfig,
                    photoConfig: carouselRenditions
                });
            default:
                return transformRecircItem({
                    ...baseConfig,
                    photoConfig
                });
        }
    };
    useEffect(() => {
        if (!applicationID) {
            return;
        }
        const fetchRecircData = async () => {
            if (!recommendationsApiUrl) {
                throw new Error('Recommendations API URL is missing');
            }
            try {
                const clientData = await fetchData(getQueryString(config));
                const buildItem = (item, index) => {
                    const baseConfig = {
                        item,
                        shouldUseTrailingSlash,
                        vulcanUrl,
                        brandSlug
                    };
                    return generateRecircItemByLayout(layout, index, baseConfig);
                };
                if (isPersonalizedHomepage) {
                    const items = clientData.map(buildItem);
                    setPersonalizedClientData(items);
                    return;
                }
                const transformedData = clientData.map((item) => transformRecircItem({
                    item,
                    shouldUseTrailingSlash,
                    photoConfig,
                    vulcanUrl,
                    brandSlug
                }));
                setRecircListClientData(transformedData);
                if (isExtendedRecirc) {
                    const excludeCopilotIds = clientData
                        .slice(0, 4)
                        .map((item) => item.contentId);
                    const extendedConfig = {
                        ...config,
                        ...extendedRecircItemsConfig,
                        excludeCopilotIds,
                        ...(extendedRecircRightRailRenditions && {
                            extendedRecircRightRailRenditions
                        })
                    };
                    const extendedData = await fetchData(getQueryString(extendedConfig));
                    setExtendedRecircClientData(extendedData);
                }
            }
            catch (error) {
                console.error('Error fetching CSR recirc data:', error);
                throw new Error('Error fetching CSR recirc data');
            }
        };
        fetchRecircData();
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return {
        recircListClientData,
        recircClientLoading,
        extendedRecircClientData,
        extendedRecircClientLoading,
        personalizedClientData
    };
};
module.exports = useClientRequest;
//# sourceMappingURL=api-hook.js.map

/***/ }),

/***/ 99659:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const format_uri_1 = __webpack_require__(74644);
const transform_helpers_1 = __webpack_require__(55866);
const create_cloudinary_sources_1 = __importDefault(__webpack_require__(81478));
const create_vulcan_sources_1 = __importDefault(__webpack_require__(68073));
const map_sources_to_segmented_sources_1 = __webpack_require__(52009);
const format_markdown_data_1 = __webpack_require__(59175);
const modelMap = {
    clips: 'clip',
    photos: 'photo'
};
const transformRecircItem = ({ item, shouldUseTrailingSlash, photoConfig, vulcanUrl, brandSlug }) => {
    let sources = {};
    let contributors = {};
    const collection = item.image_url?.split?.('/')[3] || '';
    const imageID = item.image_url?.split?.('/')?.[4] || '';
    const { thumbnailImage } = item;
    const toutEdge = {
        altText: thumbnailImage?.altText || '',
        id: imageID,
        credit: thumbnailImage?.credit || '',
        caption: thumbnailImage?.caption || '',
        metaData: thumbnailImage?.metaData || '',
        modelName: modelMap[collection] || 'tout',
        contentType: modelMap[collection],
        ...(['cartoons', 'clips'].includes(collection) && { collection }),
        ...(collection === 'clips' && {
            renditions: [
                {
                    resolution: 'master',
                    width: 1280,
                    height: 720
                }
            ]
        })
    };
    if (item.contentType === 'CNEVIDEO') {
        const photoConfigCNE = (0, transform_helpers_1.convertToCNErenditions)(photoConfig, 800);
        sources = (0, create_cloudinary_sources_1.default)(photoConfigCNE, item.image_url);
    }
    else {
        sources = (0, create_vulcan_sources_1.default)(toutEdge, photoConfig, vulcanUrl);
    }
    const segmentedSources = (0, map_sources_to_segmented_sources_1.mapSourcesToSegmentedSources)(sources);
    const tout = {
        ...toutEdge,
        sources,
        segmentedSources
    };
    if (item.author || item.artist) {
        contributors = {
            author: {
                brandSlug,
                preamble: '',
                items: [{ name: item.author || item.artist }]
            }
        };
    }
    const setRubric = (genres) => {
        if (genres && genres.length) {
            return genres.map((genre) => {
                return { name: genre?.name, url: `/genre/${genre?.slug}` };
            });
        }
        return [{ name: item.channels?.[0]?.name ?? item.section }];
    };
    // Extracted relative paths, as external URLs (starting with http/https) were opening in a new tab, but the expected behavior was to open in the same tab.
    // const {pathname,hash}= new URL(item.url)
    let parsedUrl;
    if (item?.url.search(/^https?:\/\//) === 0) {
        const { pathname, hash } = new URL(item.url);
        parsedUrl = `${pathname}${hash}`;
    }
    else {
        parsedUrl = item?.url;
    }
    let dangerousHed = (0, format_markdown_data_1.formatMarkdownData)(item.title);
    dangerousHed = dangerousHed.replace(/\{[^}]*\}/g, '').replace(/\s+/g, ' ');
    return {
        contentId: item.id,
        contentType: item.contentType,
        dangerousHed,
        dangerousDek: item.dek || '',
        url: shouldUseTrailingSlash ? (0, format_uri_1.formatRecirculationUrl)(parsedUrl) : parsedUrl,
        rubric: setRubric(item.review?.genres),
        subHed: { name: item.review?.artistName },
        tout,
        image: {
            ...tout,
            isLazy: true
        },
        contributors
    };
};
exports["default"] = transformRecircItem;
//# sourceMappingURL=transform-recirc-item.js.map

/***/ }),

/***/ 33186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const get = __webpack_require__(58156);
const isEmpty = __webpack_require__(62193);
const TEASER_FLAG_MAP = {
    'recent-work-river': 'recentWorkTeaser',
    'tag-river': 'tagTeaser',
    'bundle-rubric': 'bundleTeaser'
};
const _internals = {};
/*
This function was previously defined on the server side. However now that certain recirculation
units are lazily loaded on the client side, I've moved the function to the client
side and am importing it into the server side (which Verso was more cooperative with)
For more context please see #3740
*/
// eslint-disable-next-line complexity
const getRubricRepresentation = ({ channelMap = {}, channels = [], contentType = '', featureFlags = {}, sections = [], primaryTag, rubric = '', useTrailingSlashRubric = false, locationRubric = {}, channelRubric = {} }) => {
    const teaserFlag = contentType
        ? TEASER_FLAG_MAP[contentType]
        : 'contentTeaser';
    const teaserStyle = primaryTag && primaryTag.tag === 'Sponsor Content'
        ? 'tag-only'
        : featureFlags[teaserFlag];
    const { rubricParentSlug, rubricPrimaryChannelSlug, usePrimaryCategoryAsRubric } = featureFlags;
    switch (teaserStyle) {
        case 'rubric-or-channel':
            return (_internals.getRubric(rubric) ||
                _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric));
        case 'rubric-or-channel-or-tag':
            if (!primaryTag) {
                return (_internals.getRubric(rubric) ||
                    _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric));
            }
            return {
                name: primaryTag.tag,
                url: primaryTag.url
            };
        case 'rubric-or-channel-or-section':
            return _internals.rubricOrChannelOrSection({
                rubric,
                channels,
                channelMap,
                rubricParentSlug,
                useTrailingSlashRubric,
                sections,
                hasUrl: true
            });
        case 'rubric-or-channel-or-section-no-url':
            return _internals.rubricOrChannelOrSection({
                rubric,
                channels,
                channelMap,
                rubricParentSlug,
                useTrailingSlashRubric,
                sections,
                hasUrl: false
            });
        case 'channel-only':
            return _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric, usePrimaryCategoryAsRubric);
        case 'channel-only-no-url':
            return _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric, false, false);
        case 'section-only':
            return _internals.getCategory(sections, {}, rubricParentSlug, useTrailingSlashRubric);
        case 'tag-or-channel':
            if (!primaryTag) {
                return _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric, usePrimaryCategoryAsRubric);
            }
            return {
                name: primaryTag.tag,
                url: primaryTag.url
            };
        case 'tag-only':
            if (!primaryTag) {
                return undefined;
            }
            return {
                name: primaryTag.tag,
                url: primaryTag.url
            };
        case 'location-or-channel-or-rubric':
            return _internals.locationOrChannelRubric(locationRubric, channelRubric, rubric, channels, channelMap, rubricParentSlug, useTrailingSlashRubric);
        case 'location-or-channel-or-rubric-no-url':
            return _internals.locationOrChannelRubric(locationRubric, channelRubric, rubric, channels, channelMap, rubricParentSlug, useTrailingSlashRubric, false);
        case 'rubric-or-channel-or-primaryChannelRelative':
            return _internals.rubricOrPrimaryChannelRelativeRubric({
                rubric,
                channels,
                channelMap,
                rubricPrimaryChannelSlug,
                useTrailingSlashRubric,
                hasUrl: true
            });
        case 'rubric-only':
        default:
            return rubric ? { name: rubric } : undefined;
    }
};
_internals.rubricOrPrimaryChannelRelativeRubric = ({ rubric, channels, channelMap, rubricPrimaryChannelSlug, useTrailingSlashRubric, hasUrl }) => {
    return _internals.checkForPrimaryChannelRelativeRubric(rubricPrimaryChannelSlug, channels)
        ? _internals.getPrimaryChannelRelativeRubric(channels, rubricPrimaryChannelSlug, useTrailingSlashRubric, hasUrl)
        : _internals.getRubric(rubric) ||
            _internals.getCategory(channels, channelMap, '', useTrailingSlashRubric);
};
_internals.rubricOrChannelOrSection = ({ rubric, channels, channelMap, rubricParentSlug, useTrailingSlashRubric, sections, hasUrl }) => _internals.getRubric(rubric) ||
    _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric, false, hasUrl) ||
    _internals.getCategory(sections, {}, rubricParentSlug, useTrailingSlashRubric, false, hasUrl);
/*
 * This needs to be refactored.  This is an effor to not increase the complexity lint rules for the giant swtich above
 */
_internals.locationOrChannelRubric = (locationRubric, channelRubric, rubric, channels, channelMap, rubricParentSlug, useTrailingSlashRubric, shouldReturnURL = true) => {
    if (!isEmpty(locationRubric) && get(locationRubric, 'name', '') !== '') {
        return locationRubric;
    }
    else if (!isEmpty(channelRubric) && get(channelRubric, 'name', '') !== '') {
        return channelRubric;
    }
    return (_internals.getRubric(rubric) ||
        _internals.getCategory(channels, channelMap, rubricParentSlug, useTrailingSlashRubric, false, shouldReturnURL));
};
/**
 * extract the correct category from the array of category data
 *
 * @param {Array} categories - array of category data
 * @param {object} channelMap - mapping of category to overwritten category name
 * @param {string} rubricParentSlug - optional tenant specified slug to use as parent. see #2377
 * @param {boolean} useTrailingSlashRubric - optional boolean value to add backslash at the end of the url
 * @param {boolean} usePrimaryCategoryAsRubric - optional boolean value to get primary category
 * @param {boolean} shouldReturnURL - opetional boolean value to return url
 * @returns {object} - an object with category's name and slug
 */
_internals.getCategory = (categories = [], channelMap = {}, rubricParentSlug = '', useTrailingSlashRubric = false, usePrimaryCategoryAsRubric = false, shouldReturnURL = true) => {
    if (categories.length === 0) {
        return undefined;
    }
    const category = usePrimaryCategoryAsRubric
        ? _internals.getPrimaryCategory(categories)
        : _internals.getDeepestCategory(categories);
    const name = _internals.getCategoryName(category);
    const expectedUrl = _internals.getUrl(channelMap, category, rubricParentSlug);
    const url = useTrailingSlashRubric && expectedUrl ? `${expectedUrl}/` : expectedUrl;
    return { name, url: shouldReturnURL ? url : undefined };
};
/**
 * extract the correct PrimaryChannelRelativeRubric from the array of channel data
 *
 * @param {Array} channels - array of channel data
 * @param {string} rubricPrimaryChannelSlug - optional tenant specified slug to use as primary channel slug.
 * @param {boolean} useTrailingSlashRubric - optional boolean value to add backslash at the end of the url
 * @param {boolean} usePrimaryCategoryAsRubric - optional boolean value to get primary category
 * @param {boolean} shouldReturnURL - opetional boolean value to return url
 * @returns {object} - an object with PrimaryChannelRelativeRubric's name and slug
 */
_internals.getPrimaryChannelRelativeRubric = (channels = [], rubricPrimaryChannelSlug = '', useTrailingSlashRubric = false, shouldReturnURL = true) => {
    const primaryChannel = _internals.getPrimaryCategory(channels);
    const primaryChannelHierarchy = _internals.getPrimaryCategory(primaryChannel.hierarchy);
    const expectedUrl = primaryChannelHierarchy.slug
        ? `/${rubricPrimaryChannelSlug}/${primaryChannelHierarchy.slug}`
        : '';
    const url = useTrailingSlashRubric && expectedUrl ? `${expectedUrl}/` : expectedUrl;
    const name = _internals.getCategoryName(primaryChannelHierarchy);
    return { name, url: shouldReturnURL ? url : undefined };
};
/**
 * @param {object} category - category object
 * @returns {string} - the category's name
 */
_internals.getCategoryName = (category = {}) => get(category, 'name') || get(category, 'fields.name') || '';
/**
 * @param {object} channelMap - a
 * @returns {string} - the category's slug
 */
_internals.getCategorySlug =
    (channelMap = {}) => (category = {}) => {
        const slug = get(category, 'slug', get(category, 'fields.slug'));
        return get(channelMap, slug, slug);
    };
/**
 * Returns the deepest category, or the first if none have parents
 *
 * @param {Array} categories - an array of the category data
 * @returns {object} - a category object
 */
_internals.getDeepestCategory = (categories = [{}]) => {
    return categories.reduce((previousCategory, currentCategory) => {
        return currentCategory.parent &&
            currentCategory.parent.slug === previousCategory.slug
            ? currentCategory
            : previousCategory;
    });
};
_internals.getPrimaryCategory = (categories = [{}]) => {
    return categories[0] || {};
};
/**
 * Checks for presence of rubric primary slug in channel hierarchy
 *
 * @param {Array} channels - an array of the channels data
 * @param {string} rubricPrimaryChannelSlug - primary channel slug
 * @returns {boolean} - a boolean value to determine presence of parent slug in channel hierarchy
 */
_internals.checkForPrimaryChannelRelativeRubric = (rubricPrimaryChannelSlug, channels = [{}]) => {
    const primaryChannel = _internals.getPrimaryCategory(channels);
    const primaryChannelHierarchy = primaryChannel.hierarchy
        ? primaryChannel.hierarchy
        : [];
    const primaryChannelParentIndex = primaryChannelHierarchy.length - 2;
    const primaryChannelParentSlug = primaryChannelParentIndex >= 0
        ? primaryChannelHierarchy[primaryChannelParentIndex].slug
        : '';
    return (primaryChannelParentIndex >= 0 &&
        primaryChannelParentSlug === rubricPrimaryChannelSlug);
};
/**
 * convert rubric to an object
 *
 * @param {string} name - rubric as a string
 * @returns {object|undefined} - object of name pointing to name or nothing
 */
_internals.getRubric = (name) => (name ? { name } : undefined);
/**
 * Return the expected url
 *
 * @param {object} channelMap - optional mapping of categories to overwritten channel name
 * @param {object} category - category object
 * @param {string} rubricParentSlug - optional tenant specified slug to use as parent. see #2377
 * @returns {string} - correct url from categories
 */
_internals.getUrl = (channelMap = {}, category = {}, rubricParentSlug = '') => {
    const getSlug = _internals.getCategorySlug(channelMap);
    let parentSlug = rubricParentSlug ||
        getSlug(get(category, 'parent') ||
            get(category, '_embedded.hierarchy.1.fields') ||
            get(category, 'hierarchy.1.fields') ||
            get(category, 'parentCategory') // <- using for GQL. TODO revise all keys while REST API removing
        ) ||
        get(category, 'hierarchy[1]');
    if (typeof parentSlug === 'object') {
        // if hierarchy[1] returns an object then get slug from it
        parentSlug = getSlug(parentSlug);
    }
    const categorySlug = getSlug(category);
    const hasParent = parentSlug &&
        parentSlug !== categorySlug &&
        parentSlug !== 'channels' &&
        parentSlug !== 'sections';
    if (!hasParent && !categorySlug) {
        return undefined;
    }
    return hasParent ? `/${parentSlug}/${categorySlug}` : `/${categorySlug}`;
};
module.exports = {
    getRubricRepresentation,
    _internals
};
//# sourceMappingURL=get-rubric-representation.js.map

/***/ }),

/***/ 55866:
/***/ ((module) => {

/**
 * convert a list of names to an array of Author
 *
 * @param {Array} names - author names
 * @param {string} contentType - is item content type
 * @param {string} brand - is brand name
 *
 * @returns {Array} - array with authors
 */
const namesToAuthors = (names, contentType, brand) => {
    let authors;
    if (names && names.length) {
        const nameByline = names.reduce((byline, name, index) => {
            return (byline +
                // if more than two names in list, join with a comma
                (names.length > 2 && index > 0 ? ', ' : '') +
                // if second name and only two names, join with a space
                (index === 1 && names.length === 2 ? ' ' : '') +
                // if at last name, join with an "and"
                (index === names.length - 1 && names.length > 1 ? 'and ' : '') +
                name);
        }, '');
        authors = [{ name: nameByline }];
    }
    else {
        authors =
            contentType && brand && contentType.includes('video')
                ? [{ name: brand }]
                : [];
    }
    return authors;
};
const convertToCNErenditions = (renditions, customWidth) => {
    const aspectRatioRegex = /(\d+):(\d+)/i;
    const CNErendition = {};
    if (!renditions) {
        return CNErendition;
    }
    const applyAspectRatio = (rendition, fixedDimension) => {
        const result = {};
        const aspectRatioParsed = rendition.aspectRatio.match(aspectRatioRegex);
        if (!aspectRatioParsed) {
            return result;
        }
        const widthAspect = parseInt(aspectRatioParsed[1], 10);
        const heightAspect = parseInt(aspectRatioParsed[2], 10);
        if (widthAspect && heightAspect) {
            result.h =
                fixedDimension === 'width'
                    ? Math.floor((rendition.width * heightAspect) / widthAspect)
                    : rendition.height;
            result.w =
                fixedDimension === 'height'
                    ? Math.floor((rendition.height * widthAspect) / heightAspect)
                    : rendition.width;
        }
        return result;
    };
    Object.keys(renditions).forEach((size) => {
        CNErendition[size] = {};
        if (renditions[size].height && renditions[size].width) {
            CNErendition[size].h = renditions[size].height;
            CNErendition[size].w = renditions[size].width;
        }
        else if (renditions[size].height && renditions[size].aspectRatio) {
            CNErendition[size] = applyAspectRatio(renditions[size], 'height');
        }
        else if (renditions[size].width && renditions[size].aspectRatio) {
            CNErendition[size] = applyAspectRatio(renditions[size], 'width');
        }
        else if (renditions[size].aspectRatio && customWidth) {
            CNErendition[size].w = renditions[size].customWidth;
            CNErendition[size] = applyAspectRatio({ ...renditions[size], width: customWidth }, 'width');
        }
    });
    return CNErendition;
};
/**
 * Rather than include a full Markdown parsing library that could contribute a
 * significant amount of unnecessary heft to our client-side code, we'll instead
 * just parse bold and italics manually and wrap in a `<p>` tag, emulating what
 * the copilot-markdown-shim does without the baggage that carries. The only
 * fields currently supported in CKEditor for this field are bold, italic and
 * strikethrough, but  super and subscript are also included here since they
 * occasionally appear in content data.
 *
 * @param {string} text - a string that potentially containing Markdown
 * @param {boolean} [wrapWithParagraph] - if true, the resulting string will be
 * wrapped in a <p> tag
 *
 * @returns {string} - the input string with italic and bold markdown converted
 * to HTML, optionally wrapped in a <p> tag
 */
const basicMarkdownToHtml = (text, wrapWithParagraph = true) => {
    if (!text) {
        return '';
    }
    const htmlText = text
        // handle escaped Markdown like \+ or \!
        .replace(/\\([+!]){1}/gim, '$1')
        // replaces backslash if starts with backslash
        .replace(/^\\/, '')
        // bold
        .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
        // handle both italic representations, *text* and _text_
        .replace(/_(.*)_/gim, '<em>$1</em>')
        .replace(/\*(.*)\*/gim, '<em>$1</em>')
        // strikethrough
        .replace(/~~(.*)~~/gim, '<del>$1</del>')
        // subscript (also uses ~ so do it after strikethrough)
        .replace(/~(.*)~/gim, '<sub>$1</sub>')
        // superscript
        .replace(/\^(.*)\^/gim, '<sup>$1</sup>')
        // and trim things
        .trim();
    return wrapWithParagraph ? `<p>${htmlText}</p>` : htmlText;
};
/**
 * Given a functionalTagCategory list in the form of ['/functional-tags/tag_name']
 * return an array [{ slug: tag_name }]
 *
 * @param {Array} functionalTagCategory - functional tag slug
 */
const categoryToFunctionalTags = (functionalTagCategory = []) => {
    return functionalTagCategory.map((category) => {
        const functionalTag = category.split('/')[2];
        return { slug: functionalTag };
    });
};
module.exports = {
    namesToAuthors,
    convertToCNErenditions,
    basicMarkdownToHtml,
    categoryToFunctionalTags
};
//# sourceMappingURL=transform-helpers.js.map

/***/ }),

/***/ 82407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const assign = __webpack_require__(86139);
const cloneDeep = __webpack_require__(88055);
const flow = __webpack_require__(49870);
const intersectionWith = __webpack_require__(80191);
const isEmpty = __webpack_require__(62193);
const isEqual = __webpack_require__(2404);
const merge = __webpack_require__(55364);
const pick = __webpack_require__(44383);
const snapshot = flow(pick, cloneDeep);
const registry = new Map();
/*
 * bindActorToStore
 *
 * Actors dynamically transform data within the store. They are objects
 * with a scope configuration and a perform function.
 *
 * The perform function is a state transformer. It is triggered
 * only when relevant state is updated within the store. It receives as
 * input the store state limited by a scope. It produces as output
 * transformed state limited by a scope. The perform function must be
 * synchronous and referentially transparent.
 *
 * Scope configuration defines 1) the watch scope - state that when it
 * changes triggers the actor, 2) the input scope - the state provided
 * to the perform function, 3) the output scope - the state produced by
 * the perform function that will update the store. Scopes can consist
 * of one or more data paths within the store
 *
 * For example, the following actor sums two values and updates a third.
 * When either input value changes, the output will be updated.
 *
 * const actor = {
 *   scopes: {
 *     watch: ['a', 'b'],
 *     input: ['a', 'b'],
 *     output: ['c']
 *   },
 *   perform: ({a, b}) => ({c: a + b})
 * };
 *
 *
 * Note: In order to help prevent state updates from cycling endlessly,
 * no two actors bound to a single store may have matching output scopes.
 */
const bindActorToStore = (actor, store) => {
    registry.set(store, registry.get(store) || {
        actors: [],
        watchedState: new Map()
    });
    const schedule = registry.get(store);
    const conflictingScope = (a, b) => a.match(b) || b.match(a);
    const conflictsWith = (actorInfo) => (other) => !!intersectionWith(actorInfo.scopes.output, other.scopes.output, conflictingScope).length;
    const detectChange = (state) => (actorInfo) => !isEqual(schedule.watchedState.get(actorInfo), pick(state, actorInfo.scopes.watch));
    const updateWatch = (state, actorInfo) => {
        const current = schedule.watchedState.get(actorInfo);
        const update = snapshot(state, actorInfo.scopes.watch);
        schedule.watchedState.set(actorInfo, assign({}, current, update));
    };
    const perform = (state) => (actorInfo) => {
        const watchState = pick(state, actorInfo.scopes.watch);
        updateWatch(watchState, actorInfo);
        const inputState = pick(state, actorInfo.scopes.input);
        const outputState = pick(state, actorInfo.scopes.output);
        const performance = cloneDeep(actorInfo.perform(cloneDeep(inputState)));
        const updatedState = pick(performance, actorInfo.scopes.output);
        if (isEqual(updatedState, outputState)) {
            return {};
        }
        updateWatch(updatedState, actorInfo);
        return updatedState;
    };
    const updateState = (updates) => store.dispatch({ type: 'BULK_UPDATE', state: merge({}, ...updates) });
    const act = () => {
        const state = store.getState();
        const stateUpdates = schedule.actors
            .filter(detectChange(state))
            .map(perform(state));
        if (!isEmpty(stateUpdates)) {
            updateState(stateUpdates);
        }
    };
    if (schedule.actors.find(conflictsWith(actor))) {
        throw new Error('Multiple actors bound to the store cannot update the same value');
    }
    const state = store.getState();
    schedule.watchedState.set(actor, snapshot(state, actor.scopes.watch));
    schedule.actors.push(actor);
    schedule.unbind = schedule.unbind || store.subscribe(act);
};
module.exports = bindActorToStore;
//# sourceMappingURL=bind-actor-to-store.js.map

/***/ }),

/***/ 27543:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isEqual = __webpack_require__(2404);
const capitalize = __webpack_require__(14792);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
/*
 * connectDomain
 *
 * This higher-order function wraps a component with another component. The
 * wrapping component delivers a single data domain from the store to the
 * wrapped component via a named property. When no store is available,
 * an empty store is provided.
 *
 * This function in an alternative to Redux `connect`. `connect` requires a
 * store. This can be problematic when, for example, a connected component
 * is nested within other components. If there already exists integration
 * tests of the parent component, each of these tests must be updated to
 * provide a store. Because the nested component is not a subject of the
 * existing tests, this unnecessary test complexity can be avoid by using
 * the default store provided by `connectDomain`.
 *
 * const connectPayment = connectDomain('payment');
 * const ConnectedPaymentGateway = connectPayment(PaymentGateway);
 *
 * <ConnectedPaymentGateway ... />
 */
const connectDomain = (domain) => (Component) => {
    const emptyStore = {
        getState: () => ({}),
        subscribe: () => { }
    };
    const componentName = Component.displayName || Component.name;
    class DomainConnector extends React.Component {
        constructor(_props, context) {
            super();
            this.context = context;
            this.state = this.domain || {};
            this.onStateChange = this.onStateChange.bind(this);
        }
        componentDidMount() {
            this.setState(() => this.domain);
            this.unsubscribe = this.store.subscribe(this.onStateChange);
            this.mounted = true;
        }
        componentWillUnmount() {
            if (typeof this.unsubscribe === 'function') {
                this.unsubscribe();
            }
            this.mounted = false;
        }
        onStateChange() {
            if (this.mounted && !isEqual(this.state, this.domain)) {
                this.setState(() => this.domain);
            }
        }
        get store() {
            return this.context.store || emptyStore;
        }
        get domain() {
            const storeState = this.store.getState();
            return storeState[domain];
        }
        render() {
            return React.createElement(Component, { ...{ [domain]: this.state }, ...this.props });
        }
    }
    DomainConnector.contextTypes = {
        store: PropTypes.object
    };
    DomainConnector.displayName = `with${capitalize(domain)}(${componentName})`;
    return DomainConnector;
};
module.exports = connectDomain;
//# sourceMappingURL=connect-domain.js.map

/***/ }),

/***/ 34967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { connect: connectToStore } = __webpack_require__(67851);
/**
 * Given an array of keys, returns only the properties associated with those keys.
 * Or, if provided a second argument, spreads the objects associated with those
 * keys into the returned properties.
 *
 * @param {Array} keysToPluck - the keys for the desired state properties to map directly
 * @param {Array} keysToSpread - the keys for the desired state properties to spread
 * @returns {Function} the state mapper
 */
function mapWithKeys(keysToPluck, keysToSpread) {
    /**
     * From state.
     *
     * @param {object} state - the state for the page
     * @returns {object} the mapped props
     */
    return function mapFromState(state) {
        let props = {};
        keysToSpread.forEach((key) => {
            props = {
                ...props,
                ...state[key]
            };
        });
        keysToPluck.forEach((key) => {
            props[key] = state[key];
        });
        return props;
    };
}
module.exports = function connector(Component, { keysToPluck = [], keysToSpread = [] }) {
    const mapStateToProps = mapWithKeys(keysToPluck, keysToSpread);
    const ConnectedComponent = connectToStore(mapStateToProps)(Component);
    ConnectedComponent.mapStateToProps = mapStateToProps;
    return ConnectedComponent;
};
//# sourceMappingURL=connector.js.map

/***/ }),

/***/ 26410:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const merge = __webpack_require__(55364);
const set = __webpack_require__(63560);
/**
 * Create a new root reducers for a Redux store that initializes with the passed state.
 *
 * @param {object} initialState - Initial values of the state object
 * @returns {Reducer} - Reducer that responds to update action.
 */
module.exports = function createRootReducer(initialState) {
    // eslint-disable-next-line default-param-last
    return function rootReducer(state = initialState, action) {
        if (action && action.type === 'UPDATE_KEY') {
            return { ...state, [action.key]: action.value };
        }
        if (action && action.type === 'MERGE_KEY') {
            return {
                ...state,
                [action.key]: merge({}, state[action.key], action.value)
            };
        }
        if (action && action.type === 'SET_KEY') {
            const newState = { ...state };
            set(newState, action.key, action.value);
            return newState;
        }
        if (action && action.type === 'BULK_UPDATE') {
            return merge({ ...state }, action.state);
        }
        return state;
    };
};
//# sourceMappingURL=create-root-reducer.js.map

/***/ }),

/***/ 79810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createStore: createReduxStore } = __webpack_require__(82960);
const createRootReducer = __webpack_require__(26410);
module.exports = function createStore(state) {
    return createReduxStore(createRootReducer(state));
};
//# sourceMappingURL=create-store.js.map

/***/ }),

/***/ 57744:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const bindActorToStore = __webpack_require__(82407);
const createRootReducer = __webpack_require__(26410);
const createStore = __webpack_require__(79810);
const connectDomain = __webpack_require__(27543);
const connector = __webpack_require__(34967);
module.exports = {
    bindActorToStore,
    createRootReducer,
    createStore,
    connectDomain,
    connector
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 26695:
/***/ ((module) => {

const buildThresholdArray = () => Array.from(Array(100).keys(), (i) => i / 100);
module.exports = {
    buildThresholdArray
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 55030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { useHover } = __webpack_require__(11967);
const { useScrollObserver } = __webpack_require__(59442);
const { useResizeObserver } = __webpack_require__(70251);
const { useViewportObserver } = __webpack_require__(7165);
const { useWindowEventObserver } = __webpack_require__(84279);
module.exports = {
    useHover,
    useScrollObserver,
    useResizeObserver,
    useViewportObserver,
    useWindowEventObserver
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 11967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
/**
 * useHover function for use in functional components like a hook.
 *
 * usage:
 * const [ref, isHovered] = useHover();
 * <div ref={ref}>Div to monitor hover behavior</div>
 * isHovered && // do stuff
 *
 * @returns {Array} - ref to pass as ref={ref} to jsx element to monitor, isHovered which is boolean representing hover status
 */
const useHover = () => {
    const ref = React.useRef();
    const [isHovered, setIsHovered] = React.useState(false);
    const enter = () => setIsHovered(true);
    const leave = () => setIsHovered(false);
    React.useEffect(() => {
        const currentRef = ref && ref.current;
        if (currentRef) {
            currentRef.addEventListener('mouseenter', enter);
            currentRef.addEventListener('mouseleave', leave);
            return () => {
                currentRef.removeEventListener('mouseenter', enter);
                currentRef.removeEventListener('mouseleave', leave);
            };
        }
        return () => { };
    }, [ref]);
    return [ref, isHovered];
};
module.exports = { useHover };
//# sourceMappingURL=useHover.js.map

/***/ }),

/***/ 70251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debounce = __webpack_require__(38221);
const { useWindowEventObserver } = __webpack_require__(84279);
/**
 * useEffect function for subscribe to resize event.
 *
 * @param {Function} callback - call each times if event triggered
 * @param {number} delay - time in millisecond for use in delayInvokeFunc function
 *
 * @returns {object} - state
 */
const useResizeObserver = (callback, delay = 300) => useWindowEventObserver('resize', callback, debounce, delay);
module.exports = { useResizeObserver };
//# sourceMappingURL=useResizeObserver.js.map

/***/ }),

/***/ 59442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const throttle = __webpack_require__(7350);
const { useWindowEventObserver } = __webpack_require__(84279);
/**
 * useEffect function for subscribe to scroll event.
 *
 * @param {Function} callback - call each times if event triggered
 * @param {number} delay - time in millisecond for use in delayInvokeFunc function
 *
 * @returns {object} - state
 */
const useScrollObserver = (callback, delay = 300) => useWindowEventObserver('scroll', callback, throttle, delay);
module.exports = { useScrollObserver };
//# sourceMappingURL=useScrollObserver.js.map

/***/ }),

/***/ 7165:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
/**
 * useEffect function use IntersectionObserver for checking element in screen visible.
 *
 * @param {string} selector - selector for find element in DOM and spy for element
 * @param {object} options - options for IntersectionObserver
 * @param {string} options.rootSelector - string selector for find
 * @param {string} options.rootMargin - margin
 * @param {number} options.threshold - number of threshold
 * @param {Array} [dependencies] - Array of dependencies for the observer
 *
 * @param {Function} callback - call if user can see observable element with argument true
 *
 * @returns {boolean} - state
 */
const useViewportObserver = (selector, options = {
    rootSelector: null,
    rootMargin: '0px',
    threshold: 0
}, callback = () => { }, dependencies = []) => {
    if (!selector) {
        throw new Error('selector is required param');
    }
    const [isIntersecting, setIsIntersecting] = React.useState(false);
    React.useEffect(() => {
        const element = document.querySelector(selector);
        if (!element) {
            return () => { };
        }
        let observer;
        const convertedOptions = {
            root: options.rootSelector
                ? document.querySelector(options.rootSelector)
                : null,
            rootMargin: options.rootMargin,
            threshold: options.threshold
        };
        const cleanup = () => {
            observer.unobserve(element);
        };
        observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                setIsIntersecting(entry.isIntersecting);
                callback(entry.isIntersecting, cleanup);
            });
        }, convertedOptions);
        observer.observe(element);
        return cleanup;
        // Explicitly specifying the dependencies for this hook caused a number of
        // seemingly unrelated tests to fail, often intermittently.
        // Disabling linter now, will be a tech debt task to investigate
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, dependencies);
    return isIntersecting;
};
module.exports = { useViewportObserver };
//# sourceMappingURL=useViewportObserver.js.map

/***/ }),

/***/ 84279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
/**
 * useEffect function for subscribe to event.
 *
 * @param {string} eventName - event name for listener on window
 * @param {Function} callback - call each times if event triggered
 * @param {Function} delayInvokeFunc - delay invoke function if you want use debounce or etc function
 * @param {number} delay - time in millisecond for use in delayInvokeFunc function
 *
 * @returns {object} - state
 */
const useWindowEventObserver = (eventName, callback, delayInvokeFunc = (cb) => cb, delay = 300) => {
    const handler = delayInvokeFunc(() => {
        callback();
    }, delay);
    React.useEffect(() => {
        window.addEventListener(eventName, handler);
        return function cleanup() {
            window.removeEventListener(eventName, handler);
        };
    });
};
module.exports = { useWindowEventObserver };
//# sourceMappingURL=useWindowEventObserver.js.map

/***/ }),

/***/ 759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const scrollToAnchor = __webpack_require__(67198);
module.exports = scrollToAnchor;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 67198:
/***/ ((module) => {

const scrollToAnchor = (hash, behavior = 'smooth', paddingOffset = -48) => {
    if (!hash) {
        return;
    }
    try {
        let destinationElement;
        try {
            destinationElement = document.querySelector(hash);
            // query selectors like "#22" will fail, instead get those by id
        }
        catch (e) {
            destinationElement = document.getElementById(hash.substr(1));
        }
        if (destinationElement) {
            const stickyHeader = document.querySelector('.site-navigation');
            const stickyHeaderOffset = stickyHeader ? stickyHeader.offsetHeight : 0;
            setTimeout(() => {
                window.scrollTo({
                    top: window.scrollY +
                        paddingOffset +
                        destinationElement.getBoundingClientRect().top -
                        stickyHeaderOffset,
                    behavior
                });
            }, 1);
            destinationElement.focus();
        }
    }
    catch (e) {
        // fail silently for now
    }
};
module.exports = { scrollToAnchor };
//# sourceMappingURL=scroll-to-anchor.js.map

/***/ }),

/***/ 27287:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAltTextForSeo = void 0;
const remove_html_tags_1 = __importDefault(__webpack_require__(66916));
/**
 * Decodes the html entites from given string
 * @param altText - altText of Image
 * @returns {string} - return decoded text
 */
function decodeHTMLEntities(altText) {
    let text = altText;
    text = text.replace(/&lt;/g, '<');
    text = text.replace(/&gt;/g, '>');
    text = text.replace(/&quot;/g, '"');
    text = text.replace(/&#39;/g, "'");
    text = text.replace(/&amp;/g, '&');
    text = text.replace(/#8212;/g, '-');
    return text;
}
/**
 * Remove the html tag present in string
 *
 * @param altText - altText of Image
 * @returns {string} - return altText value for the image
 */
const getAltTextForSeo = (altText) => {
    if (!altText)
        return null;
    const text = (0, remove_html_tags_1.default)(altText);
    const decodedHtmlEntitiesText = decodeHTMLEntities(text);
    return decodedHtmlEntitiesText;
};
exports.getAltTextForSeo = getAltTextForSeo;
//# sourceMappingURL=get-alt-text-for-seo.js.map

/***/ }),

/***/ 23695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { TrackComponentChannel } = __webpack_require__(78788);
const { SkeletonLoaderWrapper, SkeletonHeaderWrapper, SkeletonContentWrapper, SkeletonItemWrapper } = __webpack_require__(681);
const SkeletonScreen = (__webpack_require__(90340)["default"]);
/**
 * SkeletonLoader component
 *
 * @param {object} props - React props
 * @param {string} [props.itemsCount] - Optional provides the number of items skeleton to be displayed
 *
 * @returns {ReactElement} <div>
 */
const SkeletonLoader = ({ itemsCount = 4 }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SkeletonLoader'
        });
    }, []);
    return (React.createElement(SkeletonLoaderWrapper, { "data-testid": "skeleton-loader" },
        React.createElement(SkeletonHeaderWrapper, null,
            React.createElement(SkeletonScreen, null),
            React.createElement(SkeletonScreen, null)),
        React.createElement(SkeletonContentWrapper, null, Array(itemsCount)
            .fill()
            .map((_, i) => {
            return (React.createElement(SkeletonItemWrapper, { itemsCount: itemsCount, key: i },
                React.createElement(SkeletonScreen, null),
                React.createElement(SkeletonScreen, null),
                React.createElement(SkeletonScreen, null),
                React.createElement(SkeletonScreen, null),
                React.createElement(SkeletonScreen, null),
                React.createElement(SkeletonScreen, null)));
        }))));
};
SkeletonLoader.propTypes = {
    itemsCount: PropTypes.number
};
module.exports = SkeletonLoader;
//# sourceMappingURL=SkeletonLoader.js.map

/***/ }),

/***/ 87623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(23695);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 681:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { calculateSpacing, minScreen, maxScreen, getColorToken } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { SkeletonScreenWrapper } = __webpack_require__(65344);
const { maxThresholds } = __webpack_require__(99906);
const SkeletonLoaderWrapper = styled.div.withConfig({
    displayName: 'SkeletonLoaderWrapper'
}) `
  margin: auto;
  margin-bottom: ${calculateSpacing(3.2)};
  padding: 0 ${calculateSpacing(8)};
  max-width: ${BREAKPOINTS.xxl};

  ${maxScreen(`${maxThresholds.xl}px  `)} {
    padding: 0 ${calculateSpacing(6)};
  }

  ${maxScreen(`${maxThresholds.md}px  `)} {
    padding: 0 ${calculateSpacing(3)};
  }
`;
const SkeletonHeaderWrapper = styled.div.withConfig({
    displayName: 'SkeletonHeaderWrapper'
}) `
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: ${calculateSpacing(2)} 0 ${calculateSpacing(6)};
  width: 100%;
  gap: ${calculateSpacing(2)};

  ${maxScreen(`${maxThresholds.lg}px  `)} {
    padding: ${calculateSpacing(2)} 0 ${calculateSpacing(5)};
  }

  ${SkeletonScreenWrapper} {
    transform: none;
  }

  ${SkeletonScreenWrapper}:first-child {
    width: ${calculateSpacing(40.31)};
    height: ${calculateSpacing(4)};
  }
  ${SkeletonScreenWrapper}:last-child {
    width: ${calculateSpacing(18.54)};
    height: ${calculateSpacing(3.5)};
  }
`;
const SkeletonItemWrapper = styled.div.withConfig({
    displayName: 'SkeletonItemWrapper'
}) `
  ${({ itemsCount }) => itemsCount && `grid-column: span calc(12/${itemsCount})`};
  position: relative;

  ${maxScreen(`${maxThresholds.lg}px  `)} {
    display: flex;
    flex-direction: column;
    padding: ${calculateSpacing(2)} 0;
    gap: ${calculateSpacing(1)};

    ${SkeletonScreenWrapper} {
      transform: none;
    }

    ${SkeletonScreenWrapper}:first-child {
      position: absolute;
      right: 0;
      width: ${calculateSpacing(14)};
      height: ${calculateSpacing(18.62)};
    }

    ${SkeletonScreenWrapper}:nth-child(2) {
      width: ${calculateSpacing(53)};
      height: ${calculateSpacing(3.5)};
    }

    ${SkeletonScreenWrapper}:nth-child(3) {
      width: calc(100% - ${calculateSpacing(16)});
      height: ${calculateSpacing(3)};
    }

    ${SkeletonScreenWrapper}:nth-child(4) {
      width: ${calculateSpacing(38)};
      max-width: 100%;
      height: ${calculateSpacing(3)};
    }

    ${SkeletonScreenWrapper}:nth-child(5) {
      width: ${calculateSpacing(30)};
      height: ${calculateSpacing(3)};
    }

    ${SkeletonScreenWrapper}:nth-child(6) {
      width: ${calculateSpacing(15)};
      height: ${calculateSpacing(2.1)};
    }

    &::after {
      display: block;
      position: absolute;
      bottom: 0;
      background-color: ${getColorToken('colors.interactive.base.light')};
      width: 100%;
      height: 1px;
      content: '';
    }
  }

  ${maxScreen(`${maxThresholds.md}px  `)} {
    ${SkeletonScreenWrapper}:first-child {
      margin-top: ${calculateSpacing(5)};
      height: ${calculateSpacing(10.5)};
    }
  }

  ${maxScreen(calculateSpacing(58.75))} {
    ${SkeletonScreenWrapper}:nth-child(2) {
      width: 90%;
    }

    ${SkeletonScreenWrapper}:nth-child(3), ${SkeletonScreenWrapper}:nth-child(4), ${SkeletonScreenWrapper}:nth-child(5) {
      width: calc(100% - ${calculateSpacing(16)});
    }
  }

  ${minScreen(BREAKPOINTS.lg)} {
    display: flex;
    flex-direction: column;
    gap: ${calculateSpacing(1)};

    hr {
      display: none;
    }
    ${SkeletonScreenWrapper} {
      transform: none;
    }

    ${SkeletonScreenWrapper}:first-child {
      height: auto;
      aspect-ratio: 1/1;
    }

    ${SkeletonScreenWrapper}:nth-child(2) {
      width: ${calculateSpacing(18.5)};
      height: ${calculateSpacing(3.5)};
    }
    ${SkeletonScreenWrapper}:nth-child(3) {
      width: 100%;
      height: ${calculateSpacing(3)};
    }

    ${SkeletonScreenWrapper}:nth-child(4) {
      width: ${calculateSpacing(38)};
      max-width: 100%;
      height: ${calculateSpacing(3)};
    }

    ${SkeletonScreenWrapper}:nth-child(5) {
      width: ${calculateSpacing(30)};
      max-width: 100%;
      height: ${calculateSpacing(3)};
    }

    ${SkeletonScreenWrapper}:nth-child(6) {
      width: ${calculateSpacing(15)};
      height: ${calculateSpacing(2.1)};
    }
  }
`;
const SkeletonContentWrapper = styled.div.withConfig({
    displayName: 'SkeletonContentWrapper'
}) `
  ${minScreen(BREAKPOINTS.lg)} {
    display: grid;
    grid-template-columns: repeat(12, 1fr);
    gap: ${calculateSpacing(4)};
  }

  ${SkeletonItemWrapper}:last-child {
    &::after {
      height: 0;
    }

    ${maxScreen(`${maxThresholds.lg}px  `)} {
      padding: ${calculateSpacing(2)} 0 0 0;
    }
  }
`;
module.exports = {
    SkeletonLoaderWrapper,
    SkeletonHeaderWrapper,
    SkeletonContentWrapper,
    SkeletonItemWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 2820:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createContext } = __webpack_require__(96540);
const ThemingContext = createContext();
module.exports = ThemingContext;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 20223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const themedComponent = __webpack_require__(99630);
module.exports = themedComponent;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const ThemingContext = __webpack_require__(2820);
/**
 * HOC that wraps a component and passes it the
 * themes that are currently in context as a property
 *
 * `fullPageTheme` is used to set the theme for an entire page,
 * including body components. `theme` only affects header
 * components, eg an article with inverted navigation and content
 * header, but standard black body text on a white background
 *
 * in an ideal world `theme` would be called `headerTheme`, but
 * `theme` is currently used in the hierarchies of several
 * functional Copilot categories, which would need to be migrated
 *
 * @param {object} Component - Component to wrap
 * @returns {object} Wrapped React Component
 */
function asThemedComponent(Component) {
    const ThemedComponent = (props) => {
        return (React.createElement(ThemingContext.Consumer, null, ({ fullPageTheme, theme } = {}) => (React.createElement(Component, { ...props, fullPageTheme: fullPageTheme || 'standard', theme: theme || 'standard' }))));
    };
    ThemedComponent.displayName = Component.displayName;
    return ThemedComponent;
}
module.exports = { asThemedComponent };
//# sourceMappingURL=themed-component.js.map

/***/ }),

/***/ 99623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { trackNavigationEvent } = __webpack_require__(14307);
const POSITION_TOP = 0.33;
const POSITION_MIDDLE = 0.66;
/*
 * snowplow understands three values of positioning: top, middle, bottom
 * based on the componentId we calculate the position of top offset in relation to page height:
 * - top: 33% of the page
 * - middle 33% of the page
 * - bottom 66% of the page
 * */
const calculatePlacement = (componentId) => {
    if (!componentId || document === undefined)
        return null;
    const element = document.getElementById(componentId);
    const offsetTop = element ? element.offsetTop : 0;
    const scrollHeight = Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
    const positionPercentage = offsetTop / scrollHeight;
    if (positionPercentage <= POSITION_TOP) {
        return 'top';
    }
    else if (positionPercentage <= POSITION_MIDDLE) {
        return 'middle';
    }
    return 'bottom';
};
/*
 *
 * as we have a lot of helper functions for snowplow tracking around verso
 * maybe it's a good idea to start to collect and adjust them here?
 *
 * */
const trackNavigationClick = (url, text, subject = '', type = 'click', componentId = undefined, index = undefined) => {
    // snowplow tracking
    const placement = calculatePlacement(componentId);
    const snowplowData = {
        items: [
            {
                content_title: text,
                content_url: url
            }
        ],
        label: text,
        subject,
        type,
        index,
        placement
    };
    trackNavigationEvent(snowplowData);
};
module.exports = {
    trackNavigationClick,
    calculatePlacement
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 96445:
/***/ ((module) => {

const MAX_TIMEOUT = 9000;
const BOOKMARK_CLIENT_API = 'bookmark-client-util';
const CREATE_BOOKMARK_PROXY = '-createBookmarkProxy';
const GET_BOOKMARK = '-getBookmark';
const REMOVE_BOOKMARK_PROXY = '-removeBookmarkProxy';
const PERF_MARK_V2_SUFFIX = '-v2';
const PERF_MARK_V3_SUFFIX = '-v3';
const ACTION_START = 'start';
const ACTION_END = 'end';
const DEFAULT_BOOKMARK_RENDITIONS = {
    sm: {
        aspectRatio: '4:3',
        width: 720
    },
    md: {
        aspectRatio: '4:3',
        width: 720
    },
    lg: {
        aspectRatio: '4:3',
        width: 480
    },
    xl: {
        aspectRatio: '4:3',
        width: 480
    }
};
module.exports = {
    MAX_TIMEOUT,
    BOOKMARK_CLIENT_API,
    CREATE_BOOKMARK_PROXY,
    GET_BOOKMARK,
    REMOVE_BOOKMARK_PROXY,
    PERF_MARK_V2_SUFFIX,
    PERF_MARK_V3_SUFFIX,
    ACTION_START,
    ACTION_END,
    DEFAULT_BOOKMARK_RENDITIONS
};
//# sourceMappingURL=bookmark-constants.js.map

/***/ }),

/***/ 48373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const bookmarksV2 = __webpack_require__(78580);
const bookmarksV3 = __webpack_require__(16840);
const bookmarksCommon = __webpack_require__(62744);
const getBookmarkHelpers = (shouldUseBookmarkV3) => {
    const selectedBookmarksHelpers = shouldUseBookmarkV3
        ? bookmarksV3
        : bookmarksV2;
    return Object.assign(selectedBookmarksHelpers, bookmarksCommon);
};
module.exports = getBookmarkHelpers;
//# sourceMappingURL=bookmark.js.map

/***/ }),

/***/ 62744:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const vulcan = __webpack_require__(25888);
const get = __webpack_require__(58156);
const isEmpty = __webpack_require__(62193);
const URL = __webpack_require__(88835);
const { buildMarkName, buildMeasureName, perfMark, perfMeasure } = __webpack_require__(56822);
const rubricHelper = __webpack_require__(33186);
const { BOOKMARK_CLIENT_API, ACTION_START, ACTION_END, DEFAULT_BOOKMARK_RENDITIONS } = __webpack_require__(96445);
const getToutData = (tout) => {
    return tout?.edges?.length > 0 ? tout.edges[0]?.node : tout;
};
const transformBookmarkHelpers = {
    getSource: (bookmarkRendition, photoData, vulcanUrl) => {
        return Object.keys(bookmarkRendition).reduce((acc, breakpoint) => {
            acc[breakpoint] = {
                ...bookmarkRendition[breakpoint],
                url: encodeURI(`${vulcanUrl}${vulcan.buildUrl(photoData, bookmarkRendition[breakpoint])}`)
            };
            return acc;
        }, {});
    },
    getContributors: (contributorKeys, embedded) => {
        return contributorKeys.reduce((acc, embeddedKey) => {
            const contributorType = embeddedKey.slice(12).toLowerCase();
            const contributors = embedded[embeddedKey].reduce((account, person) => {
                const { name, canonicalUrl } = person.fields;
                const url = canonicalUrl ? URL.parse(canonicalUrl).pathname : '';
                account.push({ name, url });
                return account;
            }, []);
            acc[contributorType] = { items: contributors };
            return acc;
        }, {});
    },
    formatBookmark: (bookmark, shouldUseBookmarkV3) => {
        const { attributes, content, documentUrl, organizationID, id: userPlatformBookmarkID } = bookmark;
        if (!shouldUseBookmarkV3) {
            // eslint-disable-next-line no-shadow
            const { documentUrl, hydratedData, organizationID } = attributes;
            return {
                documentUrl,
                hydratedData,
                organizationID,
                userPlatformBookmarkID
            };
        }
        return {
            documentUrl,
            hydratedData: content,
            organizationID,
            userPlatformBookmarkID
        };
    },
    getPhotData: (tout, embedded) => {
        return getToutData(tout) || get(embedded, 'photosTout[0].fields') || {};
    },
    getRawData: (pubDate, embedded) => {
        return pubDate || get(embedded, 'publishHistory.pubDate') || '';
    },
    getChannels: (channels, embedded) => {
        return channels || get(embedded, '_categories.channels');
    },
    getDocumentUri: (documentUri, embedded, uri) => {
        return documentUri || get(embedded, 'publishHistory.uri') || uri;
    }
};
/**
 * A reusable abstraction for a set of calls to end user timing api performance measurements
 *
 * @param {string} perfMarkIdentifier - identifier to help perf tool to identify which API function was invoked
 * @param {object} serverResponse - server response status object
 * @returns {null} nothing
 */
exports.perfMeasureEnd = (perfMarkIdentifier, serverResponse) => {
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${perfMarkIdentifier}`, ACTION_END));
    perfMeasure(buildMeasureName(`${BOOKMARK_CLIENT_API}${perfMarkIdentifier}-${serverResponse.status}`, ACTION_START, ACTION_END), buildMarkName(`${BOOKMARK_CLIENT_API}${perfMarkIdentifier}`, ACTION_START), buildMarkName(`${BOOKMARK_CLIENT_API}${perfMarkIdentifier}`, ACTION_END));
};
/**
 * A reusable error response handler, returns the error with 500 status
 *
 * @param {object} error - an error caught from fetch call
 * @param {string} perfMarkIdentifier - identifier to help perf tool to identify which API function was invoked
 * @returns {object} a response object
 */
exports.handleError = (error, perfMarkIdentifier) => {
    exports.perfMeasureEnd(perfMarkIdentifier, { status: 500 });
    return Promise.reject(error);
};
/**
 * Returns contributors data from allContributors object
 *
 * @param {Array.<object>} allContributors - contributors data
 * @returns {Array.<object>} transformed contributors data
 */
exports.transformContributors = (allContributors) => {
    return (allContributors?.edges.map((data) => {
        return {
            // contributorType can be in type for allContributors object
            contributorType: data?.node.type || '',
            // url can be in uri for allContributors object
            url: data?.node.uri || '',
            name: data?.node.name || ''
        };
    }) || []);
};
/**
 * Transforms the data returned from GET bookmarks request via proxy route
 * into the appropriate shape for the Bookmark component.
 * This is mimicking the transformations happening on the server in
 * getBookmarksPlugin: https://github.com/CondeNast/verso/blob/8f12576f95ef5df5ed5d91ca0d28a9c7fda29472/src/router-user-service-plugins/bookmarks/getBookmarksPlugin.ts#L137
 * See the tests for this method to understand the desired shape.
 *
 * @param {string} baseBrandUrl - Used to construct full saved story url for analytics ex. https://www.newyorker.com/
 * @param {Array<object>} bookmarks - hydrated bookmark data from user platform
 * @param {object} bookmarkRenditions - from appConfig.tenant config for bookmark renditions
 * @param {object} channelMap - from appConfig.tenant config
 * @param {object} featureFlags - derived from tenant config
 * @param {string} vulcanUrl - vulcan media url
 *
 * @returns {Array<object>} - transformed data
 */
exports.transformBookmarkData = ({ baseBrandUrl, bookmarks, bookmarkRenditions, channelMap, featureFlags, vulcanUrl }) => {
    if (isEmpty(bookmarks)) {
        return [];
    }
    const { shouldUseBookmarkV3 } = featureFlags;
    const data = bookmarks.reduce((accum, bookmark) => {
        const { documentUrl, hydratedData, organizationID, userPlatformBookmarkID } = transformBookmarkHelpers.formatBookmark(bookmark, shouldUseBookmarkV3);
        if (isEmpty(hydratedData)) {
            return accum;
        }
        const { aggregateRating, // aggregate rating of a recipe
        allContributors, 
        // orgID+copilotID bookmark keys
        channels, contributors: orgBookmarkContributors = [], documentUri, pubDate, tout, 
        // documentUrl bookmark keys
        embedded: embeddedData, _embedded, 
        // shared keys
        hed, id: contentID, metadata, meta, name, promoHed, promoDek, rubric, socialTitle, uri } = hydratedData;
        const embedded = _embedded || embeddedData || {}; // embedded data could live in either of these keys in the API response
        let contributors = {};
        if (!orgBookmarkContributors.length) {
            // contributors data can be either in allContributors or contributors (which is deprecated)
            const contributorsData = exports.transformContributors(allContributors);
            orgBookmarkContributors.push(...contributorsData);
        }
        if (organizationID) {
            orgBookmarkContributors.forEach((person) => {
                const { url, name, contributorType } = person;
                const type = contributorType.toLowerCase().replace('_', '');
                if (!contributors[type]) {
                    contributors[type] = { items: [] };
                }
                contributors[type].items.push({ name, url: `/${url}` });
            });
        }
        else {
            const contributorKeys = Object.keys(embedded).filter((key) => key.indexOf('contributors') === 0 && !isEmpty(embedded[key]));
            contributors = transformBookmarkHelpers.getContributors(contributorKeys, embedded);
        }
        const photoData = transformBookmarkHelpers.getPhotData(tout, embedded);
        // TODO wire up to tenant config-defined bookmark renditions, before falling
        // back to the DEFAULT_BOOKMARK_RENDITIONS in this file.
        const bookmarkRendition = !isEmpty(bookmarkRenditions)
            ? bookmarkRenditions
            : DEFAULT_BOOKMARK_RENDITIONS;
        const sources = transformBookmarkHelpers.getSource(bookmarkRendition, photoData, vulcanUrl);
        // TODO wire up to brand config defaultDateFormat for other brand usage.
        const rawDate = transformBookmarkHelpers.getRawData(pubDate, embedded);
        const publishedDate = rawDate
            ? new Date(rawDate).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                timeZone: 'UTC'
            })
            : '';
        const finalRubric = rubricHelper.getRubricRepresentation({
            channelMap,
            channels: transformBookmarkHelpers.getChannels(channels, embedded),
            featureFlags,
            primaryTag: undefined,
            rubric
        });
        // full url of the saved story, used for GA
        const contentUrl = documentUrl || `${baseBrandUrl}${documentUri || uri}`;
        const metadataRubric = metadata?.contentType || meta?.modelName;
        const contentType = metadata?.contentType;
        const item = {
            contentID,
            contributors,
            contentType,
            contentUrl,
            documentUri: transformBookmarkHelpers.getDocumentUri(documentUri, embedded, uri),
            dek: promoDek || '',
            hed: promoHed || socialTitle || hed || name || '',
            id: userPlatformBookmarkID,
            photo: {
                altText: photoData.altText || '',
                sources
            },
            publishedDate,
            rating: aggregateRating,
            rubric: finalRubric || { name: metadataRubric },
            organizationID
        };
        accum.push(item);
        return accum;
    }, []);
    return data;
};
//# sourceMappingURL=bookmarks-common.js.map

/***/ }),

/***/ 78580:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const get = __webpack_require__(58156);
const { buildMarkName, perfMark } = __webpack_require__(56822);
const { fetchWithTimeout } = __webpack_require__(91250);
const { proxyApiRoutes } = __webpack_require__(15822);
const { perfMeasureEnd, handleError } = __webpack_require__(62744);
const { MAX_TIMEOUT, BOOKMARK_CLIENT_API, CREATE_BOOKMARK_PROXY, GET_BOOKMARK, REMOVE_BOOKMARK_PROXY, PERF_MARK_V2_SUFFIX, ACTION_START } = __webpack_require__(96445);
/**
 * Create a bookmark using the user platform proxy route.
 *
 * @param {object} opts - bookmark create options
 * @param {string} opts.amgUUID - the user's amgUUID
 * @param {string} opts.copilotID - ID of the Copilot entity
 * @param {object} [opts.meta] - a JSON serializable object that contains meta data about the bookmark
 * @param {string} opts.organizationID - ID of the brand associated with the Copilot entity
 * @param {string} opts.siteCode - the site code (ex. 'NYR')
 * @param {string} opts.source - where the bookmark is being created/the specific "form" or source of the request.
 * @param {string} opts.xClientID - the tenant's identifier coming from the tenant config (example Verso-Wired)
 * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 *
 * @returns {Promise<*|{error: *, status: *}>} - promise of a response with matching data from the user-platform-gateway
 */
exports.proxyCreateBookmark = async ({ amgUUID, copilotID, meta, organizationID, siteCode, source, userPlatformProxy, xClientID }) => {
    const proxyURL = `${userPlatformProxy}${proxyApiRoutes.userDetails}/${amgUUID}/bookmarks`;
    const payload = {
        copilotID,
        organizationID,
        meta,
        siteCode,
        source
    };
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${CREATE_BOOKMARK_PROXY}${PERF_MARK_V2_SUFFIX}`, ACTION_START));
    try {
        const serverResponse = await fetchWithTimeout(proxyURL, {
            body: JSON.stringify(payload),
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                'x-client': xClientID
            },
            method: 'POST'
        }, MAX_TIMEOUT);
        const processedResponse = await serverResponse.json();
        let response = processedResponse;
        if (serverResponse.status < 200 || serverResponse.status >= 300) {
            response = {
                statusCode: serverResponse.status,
                error: serverResponse.statusText
            };
            if (serverResponse.status === 409) {
                response.data = {
                    id: get(processedResponse, 'errors[0].meta.bookmarkID')
                };
            }
        }
        perfMeasureEnd(`${CREATE_BOOKMARK_PROXY}${PERF_MARK_V2_SUFFIX}`, serverResponse);
        return response;
    }
    catch (error) {
        return handleError(error, `${CREATE_BOOKMARK_PROXY}${PERF_MARK_V2_SUFFIX}`);
    }
};
/**
 * Retrieves a user's bookmarks using the gateway proxy route. For more on the
 * accepted route params, see https://stg-user-platform.conde.io/documentation
 *
 * @param {object} opts - request opts
 * @param {string} opts.amgUUID - user's amgUUID
 * @param {object} opts.params - params to query for bookmarks
 * @param {string} [opts.params.documentUrl] - optional bookmark url. Cannot be used at the same time as an organizationID
 * @param {string} [opts.params.format] - optional param to specify the format of the returned bookmarks (valid 'todayApp')
 * @param {boolean} [opts.params.hydrate] - optional param to hydrate bookmark data from Copilot (ex. 'true')
 * @param {number} [opts.params.page] - optional page number. Starts at page 1
 * @param {string} opts.params.siteCode - the site code (ex. NYR)
 * @param {number} [opts.params.size] - optional page size. Max 50.
 * @param {number} [opts.params.start] - optional "start" index when doing a GET of all bookmarks for a user
 * @param {string} [opts.params.sort] - optional sort field (default is ascending unless hyphen is placed before field name).
 * @param {boolean} [opts.parseJson] - optional bool to return response with parsed json, defaults to true
 * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 * @param {string} [opts.xClientID] - optional clientId goes in header (example Verso-Wired)
 *
 * @returns {Promise<*|{error: *, status: *}>} - promise of a response with matching data from the user-platform-gateway
 */
exports.proxyGetBookmarks = async ({ amgUUID, params = {}, parseJson = true, userPlatformProxy, xClientID }) => {
    let proxyURL = `${userPlatformProxy}${proxyApiRoutes.userDetails}/${amgUUID}/bookmarks`;
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${GET_BOOKMARK}${PERF_MARK_V2_SUFFIX}`, ACTION_START));
    if (!params.sort) {
        proxyURL += `?sort=-created_timestamp`;
    }
    for (const [key, value] of Object.entries(params)) {
        proxyURL +=
            proxyURL.indexOf('?') > 0 ? `&${key}=${value}` : `?${key}=${value}`;
    }
    try {
        const serverResponse = await fetchWithTimeout(proxyURL, {
            credentials: 'include',
            headers: { 'x-client': xClientID },
            method: 'GET'
        }, MAX_TIMEOUT);
        const { status } = serverResponse;
        const setPerfMeasureEnd = () => perfMeasureEnd(`${GET_BOOKMARK}${PERF_MARK_V2_SUFFIX}`, serverResponse);
        if (status < 200 || status >= 300) {
            setPerfMeasureEnd();
            return {
                status,
                error: serverResponse.statusText
            };
        }
        const body = parseJson && (await serverResponse.json());
        setPerfMeasureEnd();
        return parseJson ? body : serverResponse;
    }
    catch (error) {
        return handleError(error, `${GET_BOOKMARK}${PERF_MARK_V2_SUFFIX}`);
    }
};
/**
 * Removes a single bookmark by its ID.
 *
 * @param {object} opts - request options
 * @param {string} opts.amgUUID - the user's amgUUID. Must match cookie.
 * @param {string} opts.bookmarkId - the bookmark ID
 * @param {boolean} opts.isUrlBookmark - whether the bookmark was saved using the documentUrl or the organizationID/copilotID combo.
 * @param {string} [opts.source] - the source identifier for event tracking
 * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 * @param {string} opts.xClientID - the client identifier (ex. Verso-Wired)
 *
 * @returns {Promise<*|{error: *, status: *}>} - promise with response data
 */
exports.proxyRemoveBookmark = async ({ amgUUID, bookmarkId, isUrlBookmark = true, source, userPlatformProxy, xClientID }) => {
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${REMOVE_BOOKMARK_PROXY}${PERF_MARK_V2_SUFFIX}`, ACTION_START));
    const queryParams = source
        ? `source=${source}&isUrlBookmark=${isUrlBookmark}`
        : `isUrlBookmark=${isUrlBookmark}`;
    const proxyURL = `${userPlatformProxy}${proxyApiRoutes.userDetails}/${amgUUID}/bookmarks/${bookmarkId}?${queryParams}`;
    try {
        const serverResponse = await fetchWithTimeout(proxyURL, {
            credentials: 'include',
            headers: {
                'x-client': xClientID
            },
            method: 'DELETE'
        }, MAX_TIMEOUT);
        let response;
        if (serverResponse.status !== 204) {
            response = {
                id: bookmarkId,
                status: serverResponse.status,
                error: serverResponse.statusText
            };
        }
        perfMeasureEnd(`${REMOVE_BOOKMARK_PROXY}${PERF_MARK_V2_SUFFIX}`, serverResponse);
        return response;
    }
    catch (error) {
        return handleError(error, `${REMOVE_BOOKMARK_PROXY}${PERF_MARK_V2_SUFFIX}`);
    }
};
/**
 * Checks to see if a user has already bookmarked a given story. First looks for
 * the bookmark saved by documentUrl. If not found, looks for a bookmark saved
 * by the organizationID/copilotID combination.
 *
 * @param {object} opts - request opts
 * @param {string} opts.amgUUID - user's amgUUID
 * @param {string} opts.copilotID - optional ID associated with a Copilot entity. Must be passed in with an organizationID
 * @param {string} opts.documentUrl - optional bookmark url
 * @param {string} opts.siteCode - the site code (ex. NYR)
 * @param {string} opts.userPlatformProxy - user platform proxy base route from tenant config, ex. https://stag2.wired.com/api/up
 * @param {string} opts.xClientID - optional clientId goes in header (example Verso-Wired)
 * @param {string} opts.organizationID - optional organization ID associated with a Copilot entity. Cannot be used at the same time as a documentUrl
 * @returns {object} - { bookmarkId: String|null, isUrlBookmark: boolean|null }
 */
exports.getBookmarkStatus = async ({ amgUUID, documentUrl, siteCode, userPlatformProxy, xClientID, copilotID, organizationID }) => {
    try {
        const fetchByUrl = await exports.proxyGetBookmarks({
            amgUUID,
            params: { documentUrl, siteCode },
            userPlatformProxy,
            xClientID
        });
        if (fetchByUrl?.data?.length) {
            return {
                bookmarkId: fetchByUrl.data[0].id,
                isUrlBookmark: true
            };
        }
        const fetchByOrgId = await exports.proxyGetBookmarks({
            amgUUID,
            params: { copilotID, organizationID, siteCode },
            userPlatformProxy,
            xClientID
        });
        if (fetchByOrgId?.data?.length) {
            return {
                bookmarkId: fetchByOrgId.data[0].id,
                isUrlBookmark: false
            };
        }
    }
    catch (error) {
        // do nothing, return below
    }
    return {
        bookmarkId: null,
        isUrlBookmark: null
    };
};
//# sourceMappingURL=bookmarksV2.js.map

/***/ }),

/***/ 16840:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const isEmpty = __webpack_require__(62193);
const capitalize = __webpack_require__(14792);
const { federatedGraphqlService } = __webpack_require__(5736);
const { buildMarkName, perfMark } = __webpack_require__(56822);
const { perfMeasureEnd, handleError } = __webpack_require__(62744);
const { createBookmarkQuery, getBookmarks, removeBookmarkQuery, getBookmarkQuery, isPhotoBookmarkedQuery } = __webpack_require__(50643);
const { BOOKMARK_CLIENT_API, CREATE_BOOKMARK_PROXY, GET_BOOKMARK, REMOVE_BOOKMARK_PROXY, PERF_MARK_V3_SUFFIX, ACTION_START } = __webpack_require__(96445);
/**
 * Create a bookmark using the user federated graphql.
 *
 * @param {object} opts - bookmark create options
 * @param {string} opts.federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} opts.copilotID - ID of the Copilot entity
 * @param {string} opts.contentType - Type of content rendered
 * @param {string} opts.organizationID - ID of the brand associated with the Copilot entity
 * @param {object} opts.meta - Optional meta information in JSON format (Eg: slug, season, brand for Runway Gallery bookmarked photo)
 *
 * @returns {object} - { statusCode: Number, data: Object } object containing status code and created bookmark data from federated graphql.
 */
exports.proxyCreateBookmark = async ({ copilotID, contentType, federatedGraphqlUrl, organizationID, meta }) => {
    const documentType = contentType && capitalize(contentType);
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${CREATE_BOOKMARK_PROXY}${PERF_MARK_V3_SUFFIX}`, ACTION_START));
    const createBookmarkVariable = {
        organizationId: organizationID,
        bookmarkName: '',
        documentType,
        copilotId: copilotID,
        meta: !isEmpty(meta) ? JSON.stringify(meta) : null
    };
    try {
        const graphqlResponse = await federatedGraphqlService({
            federatedGraphqlUrl,
            query: createBookmarkQuery,
            variables: createBookmarkVariable,
            queryLabelForError: 'CreateBookmark'
        });
        const { status, data } = graphqlResponse;
        const response = {
            status,
            statusCode: 201,
            data: data?.createBookmark
        };
        perfMeasureEnd(`${CREATE_BOOKMARK_PROXY}${PERF_MARK_V3_SUFFIX}`, response);
        return response;
    }
    catch (error) {
        return handleError(error, `${CREATE_BOOKMARK_PROXY}${PERF_MARK_V3_SUFFIX}`);
    }
};
/**
 * Retrieves a user's bookmarks using the federated graphql.
 *
 * @param {object} opts - request opts
 * @param {string} opts.federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} opts.organizationID - ID of the brand associated with the Copilot entity
 * @param {object} opts.params - params to query for bookmarks
 * @param {number} [opts.params.size] - optional page size. Max 50.
 * @param {number} [opts.params.start] - optional "start" index when doing a GET of all bookmarks for a user
 * @param {string} [opts.params.sort] - optional sort field (default is ascending unless hyphen is placed before field name).
 * @param {boolean} [opts.parseJson] - optional bool to return response with parsed json, defaults to true
 * @param {Array} [opts.filterBookmarkTypes] - optional array containing bookmark types that should be fetched, defaults to [] implying to fetch all content types without any filtering
 *
 * @returns {object} - { status: Number, data: Array, meta:Object } object containing status code and array bookmarks from federated graphql.
 */
exports.proxyGetBookmarks = async ({ federatedGraphqlUrl, params = {}, parseJson = true, organizationID, filterBookmarkTypes = [] }) => {
    const getBookmarkVariable = {
        limit: 12,
        offset: 0,
        organizationId: organizationID,
        sortBy: 'createdAt',
        sortOrder: 'DESC'
    };
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${GET_BOOKMARK}${PERF_MARK_V3_SUFFIX}`, ACTION_START));
    for (const [key, value] of Object.entries(params)) {
        if (key === 'size') {
            getBookmarkVariable.limit = value;
        }
        if (key === 'start') {
            getBookmarkVariable.offset = value;
        }
        if (key === 'sort') {
            getBookmarkVariable.sortBy = value;
        }
    }
    getBookmarkVariable.limit ?? (getBookmarkVariable.limit = 10);
    try {
        const graphqlResponse = await federatedGraphqlService({
            federatedGraphqlUrl,
            query: getBookmarks(filterBookmarkTypes),
            variables: getBookmarkVariable,
            queryLabelForError: 'AllBookmarks'
        });
        const { data, status } = graphqlResponse;
        const bookmarkData = {
            status,
            data: data?.allBookmarks?.bookmarks,
            meta: { count: data?.allBookmarks?.allBookmarkCount }
        };
        if (!parseJson) {
            bookmarkData.json = () => ({
                ...bookmarkData
            });
        }
        const setPerfMeasureEnd = () => perfMeasureEnd(`${GET_BOOKMARK}${PERF_MARK_V3_SUFFIX}`, bookmarkData);
        setPerfMeasureEnd();
        return bookmarkData;
    }
    catch (error) {
        return handleError(error, `${GET_BOOKMARK}${PERF_MARK_V3_SUFFIX}`);
    }
};
/**
 * Removes a single bookmark by its ID.
 *
 * @param {object} opts - request options
 * @param {string} opts.bookmarkId - the bookmark ID
 * @param {string} opts.copilotId - the copilot ID
 * @param {string} opts.federatedGraphqlUrl - user platform federated graphql endpoint
 *
 * @returns {object} - { status: Number, data: Object } object containing status code and message from federated graphql.
 */
exports.proxyRemoveBookmark = async ({ bookmarkId, copilotId = null, federatedGraphqlUrl }) => {
    perfMark(buildMarkName(`${BOOKMARK_CLIENT_API}${REMOVE_BOOKMARK_PROXY}${PERF_MARK_V3_SUFFIX}`, ACTION_START));
    const removeBookmarkVariable = {
        bulkIds: bookmarkId ? [bookmarkId] : null,
        copilotId
    };
    try {
        const graphqlResponse = await federatedGraphqlService({
            federatedGraphqlUrl,
            query: removeBookmarkQuery,
            variables: removeBookmarkVariable,
            queryLabelForError: 'DeleteBookmark'
        });
        const { data } = graphqlResponse;
        const response = {
            status: 204,
            data: data?.deleteBookmark
        };
        perfMeasureEnd(`${REMOVE_BOOKMARK_PROXY}${PERF_MARK_V3_SUFFIX}`, response);
        return response;
    }
    catch (error) {
        return handleError(error, `${REMOVE_BOOKMARK_PROXY}${PERF_MARK_V3_SUFFIX}`);
    }
};
/**
 * Checks to see if a user has already bookmarked a given story. Looks for a bookmark saved
 * by the organizationID/copilotID combination.
 *
 * @param {object} opts - request opts
 * @param {string} opts.copilotID - optional ID associated with a Copilot entity. Must be passed in with an organizationID
 * @param {string} opts.federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} opts.organizationID - optional organization ID associated with a Copilot entity. Cannot be used at the same time as a documentUrl
 *
 * @returns {object} - { bookmarkId: String|null, isUrlBookmark: boolean|null }
 */
exports.getBookmarkStatus = async ({ copilotID, organizationID, federatedGraphqlUrl }) => {
    const getBookmarkVariable = {
        organizationId: organizationID,
        limit: 1,
        offset: 0,
        copilotIds: copilotID
    };
    try {
        const graphqlResponse = await federatedGraphqlService({
            federatedGraphqlUrl,
            query: getBookmarkQuery,
            variables: getBookmarkVariable,
            queryLabelForError: 'AllBookmarks'
        });
        const { data } = graphqlResponse;
        const bookmarks = data?.allBookmarks?.bookmarks;
        if (bookmarks && bookmarks.length)
            return {
                bookmarkId: bookmarks[0].id,
                isUrlBookmark: false
            };
    }
    catch (error) {
        // console error, return below
        console.info(error);
    }
    return {
        bookmarkId: null,
        isUrlBookmark: null
    };
};
/**
 * Checks to see if a user has already bookmarked a given photo. Looks for if the photo is bookmarked
 * by the organizationID/copilotID combination.
 *
 * @param {object} opts - request opts
 * @param {string} opts.copilotID - ID associated with a Copilot entity.
 * @param {string} opts.federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} opts.organizationID - organization ID associated with a Copilot entity.
 *
 * @returns {bool} - { true, if already bookmarked, else returns false }
 */
exports.isPhotoBookmarked = async ({ copilotID, organizationID, federatedGraphqlUrl }) => {
    const getBookmarkVariable = {
        organizationId: organizationID,
        copilotID
    };
    try {
        const graphqlResponse = await federatedGraphqlService({
            federatedGraphqlUrl,
            query: isPhotoBookmarkedQuery,
            variables: getBookmarkVariable,
            queryLabelForError: 'isPhotoBookmarked'
        });
        const { data = {} } = graphqlResponse || {};
        if (data.getPhoto) {
            return data.getPhoto.isBookmarked;
        }
        throw new Error(`GraphQL could not resolve isPhotoBookmarked for error: Invalid copilot ID`);
    }
    catch (error) {
        console.info(error);
    }
    return false;
};
//# sourceMappingURL=bookmarksV3.js.map

/***/ }),

/***/ 74139:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveBookmarkBetweenCollections = exports.createCollection = exports.getCollectionsWithoutBookmarks = exports.getCollectionCount = exports.addExistingBookmarksToACollection = exports.errorType = void 0;
const federated_graphql_service_1 = __webpack_require__(51895);
const { allCollectionsQuery, allCollectionCountQuery, createCollectionMutation, updateCollectionMutation, moveBookmarksMutation } = __webpack_require__(50643);
exports.errorType = {
    BOOKMARK_MOVE_FAILED: 'bookmark could not be moved',
    COLLECTION_COUNT_UNAVAILABLE: 'could not get collection count',
    COLLECTION_DATA_FETCHING_ISSUE: 'could not fetch collection data',
    COLLECTION_NOT_MADE: 'collection could not be made',
    DUPLICATE_NAME: 'collection name exists',
    MISSING_ACCESS_TOKEN: 'user not logged in',
    RECORD_ALREADY_EXISTS: 'Record already exists'
};
/**
 * Update a collection
 *
 * @param {Array} addBookmarkIds - Array list of bookmarkIds to add to the collection
 * @param {Array} addCopilotDetails - Array of objects containing copilot details to add to the collection - { bookmarkName, bookmarkOrder, copilotId, documentType, meta }
 * @param {string} collectionName - Name of the collection
 * @param {string} federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {object} meta - Object containing collection meta
 * @param {string} organizationId - Id of the brand associated with the Copilot entity
 * @param {Array} removeBookmarkIds - Array list of bookmarkIds to remove from the collection
 * @param {Array} removeCopilotIds - Array of copilotIds to remove from the collection
 * @param {string} updateCollectionId - Id of the collection to update
 *
 * @returns {object} - Object containing status code and collection data { status: Number, data: Object }
 */
const proxyUpdateCollection = async ({ addBookmarkIds, addCopilotDetails, collectionName, federatedGraphqlUrl, meta, organizationId, removeBookmarkIds, removeCopilotIds, updateCollectionId }) => {
    const updateCollectionVariables = {
        addBookmarkIds,
        addCopilotDetails,
        collectionName,
        meta,
        organizationId,
        removeBookmarkIds,
        removeCopilotIds,
        updateCollectionId
    };
    try {
        const graphqlResponse = await (0, federated_graphql_service_1.federatedGraphqlService)({
            federatedGraphqlUrl,
            query: updateCollectionMutation,
            variables: updateCollectionVariables,
            queryLabelForError: 'updateCollection'
        });
        return graphqlResponse;
    }
    catch (error) {
        console.error(error);
    }
    return null;
};
const proxyAllCollections = ({ federatedGraphqlUrl, organizationId, query = allCollectionsQuery, includeBookmarks = false }) => {
    return (0, federated_graphql_service_1.federatedGraphqlService)({
        federatedGraphqlUrl,
        query,
        variables: {
            organizationId,
            limit: 200,
            offset: 0,
            bookmarksLimit: 200,
            sortOrder: 'DESC',
            sortBy: 'createdAt',
            bookmarksOffset: 0,
            includeBookmarks
        },
        queryLabelForError: 'allCollections'
    });
};
/**
 * Add existing bookmarks to a collection
 *
 * @param {Array} copilotIds - Array of existing bookmark copilotIds to add to the collection
 * @param {string} federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} organizationId - Id of the brand associated with the Copilot entity
 * @param {string} updateCollectionId - Id of the collection to update
 *
 * @returns {Promise<object>} - object containing success status and data { success: boolean, data?: Object, error?: string }
 */
const addExistingBookmarksToACollection = async ({ copilotIds, federatedGraphqlUrl, organizationId, updateCollectionId }) => {
    const copilotIdObjs = copilotIds.map((copilotId) => ({ copilotId }));
    const result = await proxyUpdateCollection({
        addCopilotDetails: copilotIdObjs,
        updateCollectionId,
        federatedGraphqlUrl,
        organizationId
    });
    if (result === null) {
        return { success: false, error: 'Failed to add bookmark to collection' };
    }
    return { success: true, data: result };
};
exports.addExistingBookmarksToACollection = addExistingBookmarksToACollection;
/**
 * Get a count of the user's collections
 *
 * @param {string} federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} organizationId - Id of the brand associated with the Copilot entity
 *
 * @returns {Promise<number>} - number of collections
 */
const getCollectionCount = async ({ federatedGraphqlUrl, organizationId }) => {
    try {
        const { data: { allCollections: { allCollectionCount } } } = await proxyAllCollections({
            query: allCollectionCountQuery,
            federatedGraphqlUrl,
            organizationId
        });
        return allCollectionCount;
    }
    catch (error) {
        if (error.message.includes(exports.errorType.MISSING_ACCESS_TOKEN)) {
            return 0;
        }
        console.info(exports.errorType.COLLECTION_COUNT_UNAVAILABLE, error);
    }
    return 0;
};
exports.getCollectionCount = getCollectionCount;
/** Fetch collections data for drawer
 *
 * @param {string} federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} organizationId - Id of the brand associated with the Copilot entity
 *
 * @returns {Promise<object>} - collections data
 *
 * */
const getCollectionsWithoutBookmarks = async ({ federatedGraphqlUrl, organizationId }) => {
    const { data: { allCollections: { collections } } } = await proxyAllCollections({
        query: allCollectionsQuery,
        federatedGraphqlUrl,
        organizationId
    });
    return collections;
};
exports.getCollectionsWithoutBookmarks = getCollectionsWithoutBookmarks;
/**
 * create a new collection and add recently saved image to it
 *
 * @param {Array} copilotIds - Array of existing bookmark copilotIds to add to the collection
 * @param {string} collectionName - name of the collection to be created
 * @param {string} federatedGraphqlUrl - user platform federated graphql endpoint
 * @param {string} organizationId - Id of the brand associated with the Copilot entity
 *
 * @returns {object} - object containing newly created collection data { data: Object }
 */
const proxyCreateCollection = ({ federatedGraphqlUrl, createCollectionVariables }) => {
    return (0, federated_graphql_service_1.federatedGraphqlService)({
        federatedGraphqlUrl,
        query: createCollectionMutation,
        variables: createCollectionVariables,
        queryLabelForError: 'createCollection'
    });
};
const createCollection = async ({ copilotIds = [], collectionName, federatedGraphqlUrl, organizationId }) => {
    const copilotIdObjs = copilotIds.map((copilotId) => {
        return { copilotId };
    });
    const createCollectionVariables = {
        copilotDetails: copilotIdObjs,
        collectionName,
        organizationId
    };
    try {
        const { data: { createCollection } } = await proxyCreateCollection({
            createCollectionVariables,
            federatedGraphqlUrl
        });
        return createCollection;
    }
    catch (error) {
        if (error.message.includes(exports.errorType.RECORD_ALREADY_EXISTS)) {
            return { errorType: exports.errorType.DUPLICATE_NAME };
        }
        console.error(error);
        return { errorType: exports.errorType.COLLECTION_NOT_MADE };
    }
};
exports.createCollection = createCollection;
/**
 * Move bookmarks from one collection to another using GraphQL mutation
 *
 * @param {number} fromCollectionId - ID of the source collection to move bookmarks from
 * @param {number} toCollectionId - ID of the destination collection to move bookmarks to
 * @param {Array<string>} [copilotIds] - Optional array of specific copilot IDs to move
 * @param {Array<string>} [bookmarkIds] - Optional array of specific bookmark IDs to move
 * @param {boolean} [moveAll] - Optional flag to move all bookmarks from source collection
 * @param {string} federatedGraphqlUrl - User platform federated GraphQL endpoint
 *
 * @returns {Promise<object>} - Object containing the move operation result with message field indicating success/failure
 * @throws {Error} - Throws error with specific message for different failure scenarios
 */
const proxyMoveBookmarks = async ({ fromCollectionId, toCollectionId, copilotIds, bookmarkIds, moveAll, federatedGraphqlUrl }) => {
    const moveBookmarksVariables = {
        fromCollectionId,
        toCollectionId,
        copilotIds,
        bookmarkIds,
        moveAll
    };
    const graphqlResponse = await (0, federated_graphql_service_1.federatedGraphqlService)({
        federatedGraphqlUrl,
        query: moveBookmarksMutation,
        variables: moveBookmarksVariables,
        queryLabelForError: 'moveBookmarks'
    });
    return graphqlResponse;
};
/**
 * Move a bookmark from one collection to another
 *
 * @param {number} fromCollectionId - ID of the source collection to move the bookmark from
 * @param {number} toCollectionId - ID of the destination collection to move the bookmark to
 * @param {string} federatedGraphqlUrl - User platform federated GraphQL endpoint
 * @param {string} copilotId - ID of the specific copilot/bookmark to move
 *
 * @returns {Promise<object>} - Object containing success status and data { success: boolean, data?: Object, error?: string }
 */
const moveBookmarkBetweenCollections = async ({ fromCollectionId, toCollectionId, federatedGraphqlUrl, copilotId }) => {
    try {
        const result = await proxyMoveBookmarks({
            fromCollectionId,
            toCollectionId,
            federatedGraphqlUrl,
            copilotIds: [copilotId]
        });
        return { success: true, data: result };
    }
    catch (error) {
        console.error('Error moving bookmark between collections:', error);
        // Handle specific error types
        if (error.message.includes(exports.errorType.MISSING_ACCESS_TOKEN)) {
            return {
                success: false,
                error: 'Authentication required to move bookmark'
            };
        }
        return {
            success: false,
            error: error.message || exports.errorType.BOOKMARK_MOVE_FAILED
        };
    }
};
exports.moveBookmarkBetweenCollections = moveBookmarkBetweenCollections;
//# sourceMappingURL=collectionsUtils.js.map

/***/ }),

/***/ 16791:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFragmentOfContentTypes = exports.getAllContentTypesFragment = exports.bookmarksContentTypesFragmentName = exports.createVenuDocumentTypes = exports.venueSubtypes = void 0;
const queries_1 = __webpack_require__(2697);
exports.venueSubtypes = [
    'Bakery',
    'BedAndBreakfast',
    'BoutiqueHotel',
    'BoutiqueRetail',
    'Cafe',
    'Club',
    'CocktailBar',
    'CoffeeTeaBar',
    'CommonBar',
    'Culture',
    'DepartmentStore',
    'DestinationSpa',
    'DiveBar',
    'FoodHall',
    'HealthAndWellness',
    'Hotel',
    'HotelBar',
    'JuiceBar',
    'Mall',
    'Market',
    'OceanShip',
    'PerformanceVenue',
    'PrivateRental',
    'RooftopBar',
    'Resort',
    'Restaurant',
    'Shop',
    'Spa',
    'SpecialtyShop',
    'SportsAndOutdoors',
    'SportsBar',
    'StreetFood',
    'StudioWorkshop',
    'ThemePark',
    'WineryBreweryDistillery'
];
const createVenuDocumentTypes = (subtypes) => {
    const documentTypes = {};
    subtypes.forEach((subtype) => {
        documentTypes[subtype] = {
            fieldFragment: (0, queries_1.getVenueFragment)(subtype),
            fragmentName: `...${(0, queries_1.getVenueFragmentName)(subtype)}`
        };
    });
    return documentTypes;
};
exports.createVenuDocumentTypes = createVenuDocumentTypes;
// These are the document types stored in the bookmarking database
// which have bookmarking enabled across brands
const bookmarkDocumentTypes = {
    Article: {
        fieldFragment: queries_1.articleFieldFragment,
        fragmentName: `...${queries_1.articleFragmentName}`
    },
    Gallery: {
        fieldFragment: queries_1.galleryFieldFragment,
        fragmentName: `...${queries_1.galleryFragmentName}`
    },
    ProductReview: {
        fieldFragment: queries_1.productReviewFieldFragment,
        fragmentName: `...${queries_1.productReviewFragmentName}`
    },
    Recipe: {
        fieldFragment: queries_1.recipeFieldFragment,
        fragmentName: `...${queries_1.recipeFragmentName}`
    },
    Photo: {
        fieldFragment: (0, queries_1.getPhotoFieldFragment)(),
        fragmentName: `...${queries_1.photoFragmentName}`
    },
    Business: {
        fieldFragment: queries_1.businessFragment,
        fragmentName: `...${queries_1.businessFragmentName}`
    },
    ...(0, exports.createVenuDocumentTypes)(exports.venueSubtypes)
};
exports.bookmarksContentTypesFragmentName = 'bookmarkedContentForIncludedContentTypes';
const getAllContentTypesFragment = () => {
    let bookmarkContentTypesFragment = ``;
    let bookmarkContentTypesFields = ``;
    for (const contentType of Object.keys(bookmarkDocumentTypes)) {
        bookmarkContentTypesFragment += `${bookmarkDocumentTypes[contentType].fieldFragment}\n`;
        bookmarkContentTypesFields += `${bookmarkDocumentTypes[contentType].fragmentName}\n`;
    }
    return `
    ${bookmarkContentTypesFragment}
    fragment ${exports.bookmarksContentTypesFragmentName} on Content {
      ${bookmarkContentTypesFields}
    }
  `;
};
exports.getAllContentTypesFragment = getAllContentTypesFragment;
const getFragmentOfContentTypes = (filterContentTypes = []) => {
    let bookmarkContentTypesFragment = ``;
    let bookmarkContentTypesFields = ``;
    filterContentTypes.forEach((contentType) => {
        if (Object.hasOwn(bookmarkDocumentTypes, contentType)) {
            bookmarkContentTypesFragment += `${bookmarkDocumentTypes[contentType].fieldFragment}\n`;
            bookmarkContentTypesFields += `${bookmarkDocumentTypes[contentType].fragmentName}\n`;
        }
    });
    return `
    ${bookmarkContentTypesFragment}
    fragment ${exports.bookmarksContentTypesFragmentName} on Content {
      ${bookmarkContentTypesFields}
    }
  `;
};
exports.getFragmentOfContentTypes = getFragmentOfContentTypes;
//# sourceMappingURL=user-fragments-query.js.map

/***/ }),

/***/ 50643:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveBookmarksMutation = exports.createCollectionMutation = exports.updateCollectionMutation = exports.allCollectionCountQuery = exports.allCollectionsQuery = exports.addRecentlyViewedItem = exports.isPhotoBookmarkedQuery = exports.getBookmarkQuery = exports.removeBookmarkQuery = exports.getBookmarks = exports.createBookmarkQuery = void 0;
const user_fragments_query_1 = __webpack_require__(16791);
exports.createBookmarkQuery = `
mutation CreateBookmark($bookmarkName: String!, $organizationId: ID!, $copilotId: String!, $documentType: String!, $meta: String) {
  createBookmark(bookmarkName: $bookmarkName, organizationId: $organizationId, copilotId: $copilotId, documentType: $documentType, meta: $meta) {
      id
      copilotId
      siteCode
      bookmarkName
      documentType
    }
  }`;
const bookmarkFieldFragment = `
      fragment bookmarkField on Bookmark {
        id
        copilotId
        bookmarkName
        content {
          ...${user_fragments_query_1.bookmarksContentTypesFragmentName}
        }
        documentUrl
        documentType
        meta
        siteCode
        organizationId
}`;
const bookmarkQuery = `
  ${bookmarkFieldFragment}
  query AllBookmarks($limit: Int!, $offset: Int!, $organizationId: ID!, $copilotIds: [String], $sortOrder: SortOrder, $sortBy: BookmarkSortKeys) {
    allBookmarks(limit: $limit, offset: $offset, organizationId: $organizationId, copilotIds: $copilotIds, sortOrder: $sortOrder, sortBy: $sortBy) {
      bookmarks {
        ...bookmarkField
      }
      allBookmarkCount
    }
  }
`;
const getAllBookmarks = () => `
  ${(0, user_fragments_query_1.getAllContentTypesFragment)()}
  ${bookmarkQuery}
`;
const getBookmarksOfTypes = (filterContentTypes = []) => `
  ${(0, user_fragments_query_1.getFragmentOfContentTypes)(filterContentTypes)}
  ${bookmarkQuery}
`;
const getBookmarks = (filterContentTypes = []) => {
    if (filterContentTypes.length === 0) {
        return getAllBookmarks();
    }
    return getBookmarksOfTypes(filterContentTypes);
};
exports.getBookmarks = getBookmarks;
exports.removeBookmarkQuery = `
    mutation DeleteBookmark($bulkIds: [Int], $copilotId: String) {
    deleteBookmark(bulkIds: $bulkIds, copilotId: $copilotId) {
      message
    }
  }`;
exports.getBookmarkQuery = `
    query AllBookmarks($limit: Int!, $offset: Int!, $organizationId: ID!, $copilotIds: [String]) {
    allBookmarks(limit: $limit, offset: $offset, organizationId: $organizationId, copilotIds: $copilotIds) {
      bookmarks {
        id
        copilotId
        bookmarkName
      }
      allBookmarkCount
    }
  }`;
exports.isPhotoBookmarkedQuery = `
  query GetPhoto($organizationId: ID!, $copilotID: String!) {
    getPhoto(organizationId: $organizationId, id: $copilotID) {
      isBookmarked
    }
  }
`;
exports.addRecentlyViewedItem = `mutation AddRecentlyViewed($copilotId: String!, $organizationId: ID!) {
    addRecentlyViewed(copilotId: $copilotId, organizationId: $organizationId) {
      message
    }
  }`;
exports.allCollectionsQuery = `
    ${(0, user_fragments_query_1.getFragmentOfContentTypes)([
    'Photo',
    'Article',
    'Gallery',
    ...user_fragments_query_1.venueSubtypes
])}
    ${bookmarkFieldFragment}
    query allCollections(
      $limit: Int!
      $offset: Int!
      $organizationId: ID!
      $sortBy: CollectionSortKeys
      $sortOrder: SortOrder
      $bookmarksLimit: Int!
      $bookmarksOffset: Int!
      $bookmarksSortBy: BookmarkCollectionSortKeys
      $bookmarksSortOrder: SortOrder,
      $includeBookmarks: Boolean!
    ) {
      allCollections(
        limit: $limit
        offset: $offset
        organizationId: $organizationId
        sortBy: $sortBy
        sortOrder: $sortOrder
      ) {
        allCollectionCount
        collections {
          id
          collectionName
          totalBookmarkCount
          lastBookmark {
            ...bookmarkField
          }
          bookmarks(
            limit: $bookmarksLimit,
            offset: $bookmarksOffset,
            sortBy: $bookmarksSortBy,
            sortOrder: $bookmarksSortOrder
          ) @include(if: $includeBookmarks) {
            bookmark {
              ...bookmarkField
            }
          }
        }
      }
    }
`;
exports.allCollectionCountQuery = `
  query allCollections($limit: Int!, $offset: Int!, $organizationId: ID!) {
    allCollections(
      limit: $limit
      offset: $offset
      organizationId: $organizationId
    ) {
      allCollectionCount
    }
  }
`;
exports.updateCollectionMutation = `mutation UpdateCollection(
  $updateCollectionId: Int!, 
  $collectionName: String, 
  $organizationId: ID, 
  $addCopilotDetails: [CopilotDetail], 
  $removeCopilotIds: [String], 
  $addBookmarkIds: [Int], 
  $removeBookmarkIds: [Int], 
  $meta: String 
  ) {
    updateCollection(
      id: $updateCollectionId, 
      collectionName: $collectionName, 
      organizationId: $organizationId, 
      addCopilotDetails: $addCopilotDetails, 
      removeCopilotIds: $removeCopilotIds, 
      addBookmarkIds: $addBookmarkIds, 
      removeBookmarkIds: $removeBookmarkIds, 
      meta: $meta
      ) {
        id
        collectionName
        totalBookmarkCount
        }
    }
`;
exports.createCollectionMutation = ` 
  mutation CreateCollection($collectionName: String!, $organizationId: ID!, $copilotDetails: [CopilotDetail]) {
    createCollection(collectionName: $collectionName, organizationId: $organizationId,copilotDetails: $copilotDetails) {
    id
    collectionName
    lastBookmark {
      copilotId
    }
  }
}`;
exports.moveBookmarksMutation = `
mutation MoveBookmarks($fromCollectionId: Int!, $toCollectionId: Int!, $copilotIds: [String], $bookmarkIds: [Int], $moveAll: Boolean) {
  moveBookmarks(fromCollectionId: $fromCollectionId, toCollectionId: $toCollectionId, copilotIds: $copilotIds, bookmarkIds: $bookmarkIds, moveAll: $moveAll) {
    message
  }
}`;
//# sourceMappingURL=user-query.js.map

/***/ }),

/***/ 81372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const variationsHelpers = __webpack_require__(78448);
module.exports = variationsHelpers;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 78448:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { getDisplayName } = __webpack_require__(89738);
/**
 * HOC to wrap component as a variation
 *
 * @param {object} Component - Component to wrap
 * @param {string} variationName - Name to apply to this variation
 * @param {object} variationsProp - Set of values to apply to wrapped component
 * @param {object} [additionalProps] - Optional additional props to apply to component with the variation definition
 * @returns {object} Wrapped React Component
 */
function asVariation(Component, variationName, variationsProp, additionalProps = {}) {
    const displayName = getDisplayName(Component);
    const variationDisplayName = `${displayName}.${variationName}`;
    const variation = (props) => {
        const mergedClassName = classnames(props.className, additionalProps.className);
        return (
        /* eslint-disable react/forbid-component-props */
        React.createElement(Component, { ...props, ...additionalProps, className: mergedClassName, variationDisplayName: variationDisplayName, variationName: variationName, variations: variationsProp })
        /* eslint-enable react/forbid-component-props */
        );
    };
    variation.propTypes = {
        className: PropTypes.string
    };
    variation.displayName = variationDisplayName;
    variation.variationsProp = variationsProp;
    return variation;
}
/**
 * A helper for pulling Variation names out of a component-with-variations.
 *
 * @param {ReactComponent} component - component I want to find names inside
 * @returns {Array} variation names
 */
const getVariationNames = (component) => Object.keys(component).filter((key) => /^[A-Z]/.test(key));
module.exports = {
    asVariation,
    getVariationNames
};
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 91056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { withOnboarding } = __webpack_require__(46734);
module.exports = withOnboarding;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 73976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const getFeatures = () => {
    const features = __webpack_require__.g.window &&
        __webpack_require__.g.window.localStorage.getItem('usedOnboardingFeatures');
    return features ? JSON.parse(features) : [];
};
/**
 * Helper function that checks if the current user has already
 * completed the onboarding process for a given feature
 *
 * @param {string} feature - The feature to check
 * @returns {boolean} Whether the user has completed the onboarding process
 */
const isFeatureUsed = (feature) => getFeatures().includes(feature);
/**
 * Helper function that sets the current user onboarding
 * process as complete for the given feature
 *
 * @param {string} feature - The feature to set the onboarding process as complete
 * @returns {undefined}
 */
const setFeatureUsed = (feature) => {
    const features = getFeatures();
    if (!features.includes(feature)) {
        features.push(feature);
        __webpack_require__.g.window &&
            __webpack_require__.g.window.localStorage.setItem('usedOnboardingFeatures', JSON.stringify(features));
    }
};
module.exports = {
    isFeatureUsed,
    setFeatureUsed
};
//# sourceMappingURL=onboarding-helper.js.map

/***/ }),

/***/ 46734:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { connect: connectToStore } = __webpack_require__(67851);
const PropTypes = __webpack_require__(5556);
const get = __webpack_require__(58156);
const onboardingHelper = __webpack_require__(73976);
const mapStateToProps = (onboardingFeatureKey) => (state) => {
    const isOnboardingFeatureEnabled = get(state, `featureFlags.featureOnboarding.${onboardingFeatureKey}`) ||
        false;
    const { onboarding = { onboardingStep: '' } } = state;
    const isFeatureUsed = onboardingHelper.isFeatureUsed(onboardingFeatureKey);
    const shouldOnboard = !isFeatureUsed && isOnboardingFeatureEnabled;
    const onboardingStep = (shouldOnboard &&
        get(onboarding, `${onboardingFeatureKey}.onboardingStep`)) ||
        '';
    return {
        onboardingStep
    };
};
const mapDispatchToProps = (onboardingFeatureKey) => (dispatch) => {
    const dispatchAction = (nextStep) => {
        dispatch({
            type: 'MERGE_KEY',
            key: 'onboarding',
            value: { [onboardingFeatureKey]: { onboardingStep: nextStep } }
        });
    };
    return {
        updateOnboardingStep: (nextStep) => {
            dispatchAction(nextStep);
        },
        completeOnboarding: () => {
            dispatchAction('complete');
            onboardingHelper.setFeatureUsed(onboardingFeatureKey);
        }
    };
};
/**
 * withOnboarding Function - wraps a component and connects it to onboarded
 *
 * @param {Function} Component - the component that needs to be connected to onboarding state
 * @param {string} onboardingFeatureKey - the name of the feature that is being onboarded. when connecting the component, withOnboarding will grab the 'onboardingStep'
 *
 * @returns {Function} - returns the component connected to the onboarding redux status
 */
const withOnboarding = (Component, onboardingFeatureKey) => {
    const OnboardedComponent = (props) => {
        return React.createElement(Component, { ...props });
    };
    OnboardedComponent.displayName = Component.displayName;
    OnboardedComponent.propTypes = {
        isOnboardingFeatureEnabled: PropTypes.bool,
        updateOnboardingStep: PropTypes.func
    };
    return connectToStore(mapStateToProps(onboardingFeatureKey), mapDispatchToProps(onboardingFeatureKey))(OnboardedComponent);
};
module.exports = { withOnboarding };
//# sourceMappingURL=with-onboarding.js.map

/***/ }),

/***/ 28389:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { connect } = __webpack_require__(67851);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const classnames = __webpack_require__(32485);
const translations = (__webpack_require__(89844)["default"]);
const { asConfiguredComponent } = __webpack_require__(12892);
const queryParamsHelper = __webpack_require__(12311);
const { googleAnalytics } = __webpack_require__(90090);
const BookmarkActions = __webpack_require__(59953);
const { useCommentsCount } = (__webpack_require__(75978)/* ["default"] */ .A);
const { BookmarkNew, Comment } = __webpack_require__(91470);
const { Loader } = __webpack_require__(97504);
const { Print, Arrow } = __webpack_require__(24695);
const { trackNavigationEvent } = __webpack_require__(14307);
const { scrollToAnchor } = __webpack_require__(759);
const { usePhotoBookmarkingContext } = __webpack_require__(50624);
const { ActionBarWrapper, ActionBarButton, ActionBarButtonDivider, ActionBarButtonText, ActionBarButtonSubText, ActionBarButtonIcon, MessageBannerWrapper, ActionBarButtonLoader } = __webpack_require__(11586);
const DrawerMessageBanner = __webpack_require__(11501);
const { trackSignpostingEvent } = __webpack_require__(60325);
const COMMENTING_SECTION_CLASS = 'CommentingMainContent';
/**
 *
 * @param {object} props - ActionBar props
 * @param {string} props.alignBanner - Position on page to align banner. Default to bottom.
 * @param {Array} props.actionButtons - list of button that need to be render
 * @param {string} [props.buttonDirection] - Button direction - row or column
 * @param {string} [props.maxScreenThreshold] - Max Device size where the action bar is placed
 * @param {string} [props.minScreenThreshold] - Min Device size where the action bar is placed
 * @param {object} [props.variations] - Variation props for action bar component
 * @param {number} [props.bookmarkId] - ID of bookmark in user platform system
 * @param {string} [props.bookmarkRecipesSaveLocation] - Optional string which indicates bookmark save location through snowplow tracking
 * @param {string} [props.copilotID] - ID of the Copilot entity
 * @param {string} props.commentingUrl - url of Comment api
 * @param {string} [props.contentID] - ID of the contentID entity
 * @param {string} [props.className] - Class name to add in component
 * @param {string} [props.contentTitle] - title of parent for analytics.
 * @param {string} [props.contentType] - Content type which has been rendered
 * @param {string} [props.documentUrl] - current page canonical url
 * @param {Function} [props.displayBookmarkAlert] - Dispatch function to display bookmark alert
 * @param {Function} [props.doUpdateBookmarkedStatus] - Dispatch function to update global store
 * @param {Function} [props.doUpdateUnsavedBookmarks] - Dispatch function to update the redux state of an unsaved bookmarks
 * @param {boolean} [props.hasMessageBanner] - Enable messageBanner when bookmark is clicked
 * @param {boolean} [props.isUrlBookmark] - Whether the bookmark was saved using the document Url or the organizationID/copilotID
 * @param {boolean} [props.isBookmarkLoading] - Whether the bookmarks data is loading or not
 * @param {boolean} [props.isIcon] - Show Action bar as icon.
 * @param {boolean} [props.isInteractive] - Is ActionBar interactive
 * @param {object} [props.image] - image object for collection drawer
 * @param {string} [props.organizationID] - Brand ID associated copilot entity(copilotID)
 * @param {string} [props.signInHed] - Header on signin alert shown to user
 * @param {string} [props.signInHedSpanTag] - Hed span tag on signin alert shown to user
 * @param {string} [props.signInMessage] - Message on signin alert shown to user
 * @param {object} [props.user] - User information
 * @param {boolean} [props.user.isAuthenticated] - Represents if the user is currently authenticated
 * @param {boolean} [props.user.amguuid] - User's amguuid
 * @param {object} [props.userPlatform] - User platform details for fetching bookmark details
 * @param {string} [props.userPlatform.federatedGraphqlUrl] - User platform federated graphql endpoint
 * @param {string} [props.userPlatform.siteCode] -  Brand siteCode
 * @param {string} [props.userPlatform.userPlatformProxy] - Brand user platform proxy server url
 * @param {string} [props.userPlatform.xClientID] - xClientID from brand tenant config
 * @param {boolean} [props.shouldHideIllustration] - Boolean value to hide/show image in signin modal
 * @param {object} [props.signInModalConfig] - SignIn Modal information
 * @param {boolean} [props.signInModalConfig.isVisible] - SignIn Modal visibility
 * @param {string} [props.signInModalConfig.source] - Source information that triggered SignIn Modal action
 * @param {object} [props.actionBarConfig] - Define all button details like icons and labels
 * @param {boolean} [props.shouldUseBookmarkV3] - Feature flag to define whether to use bookmark v3
 * @param {string} [props.headerOffset] - Header offset to manage the section title height for Jump To Section action
 * @param {string} [props.sectionElement] - Section Element id or class to jump for
 * @param {string} [props.fallBackSectionElement] - Section Element id or class to jump for incase default one is not available
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - Feature flag to define whether enable bookmark drawers functionality
 * @param {boolean} [props.shouldEnableCommunityExperience] -  flag set if community experience is enabled
 * @param {Function} [props.setLastBookmarkedPhoto] - Dispatch function to set the id of the most recently bookmarked photo
 * @param {Function} [props.unsavedBookmarks] - Properties of an unsaved item in redux
 *
 * @returns {ReactElement} <ActionBar>
 */
const ActionBar = ({ actionBarConfig = {
    bookmark: {
        afterActionIcon: React.createElement(BookmarkNew, { fill: "#000" }),
        afterActionLabel: 'bookmarkSavedToLibrary',
        defaultIcon: React.createElement(BookmarkNew, null),
        defaultLabel: 'bookmarkSaveThisStory',
        loaderIcon: React.createElement(Loader, null)
    },
    comments: {
        defaultIcon: React.createElement(Comment, null),
        defaultLabel: 'comments'
    },
    print: {
        defaultIcon: React.createElement(Print, null)
    },
    jumpToSection: {
        defaultIcon: React.createElement(Arrow, { style: { transform: 'rotate(90deg)' } }),
        defaultLabel: 'Jump To Recipe'
    }
}, actionButtons, alignBanner = 'bottom', bookmarkId, bookmarkRecipesSaveLocation, buttonDirection = 'row', className, commentingUrl, contentID, contentTitle, contentType, displayBookmarkAlert, documentUrl, doUpdateBookmarkedStatus, doUpdateUnsavedBookmarks, hasMessageBanner, headerOffset, image, isBookmarkLoading, isUrlBookmark, maxScreenThreshold, minScreenThreshold, organizationID, sectionElement, fallBackSectionElement, shouldHideIllustration, shouldUseBookmarkV3 = false, signInHed, signInHedSpanTag, signInMessage, signInModalConfig, setLastBookmarkedPhoto, user, userPlatform, isIcon, isInteractive = true, shouldEnableBookmarkDrawers = false, shouldEnableCommunityExperience = false, unsavedBookmarks, variations = {} }) => {
    const { openCollectionsDrawer } = usePhotoBookmarkingContext();
    const bookmarkProps = {
        bookmarkId,
        contentID,
        contentTitle,
        contentType,
        documentUrl,
        displayBookmarkAlert,
        doUpdateBookmarkedStatus,
        doUpdateUnsavedBookmarks,
        image,
        isUrlBookmark,
        organizationID,
        shouldUseBookmarkV3,
        signInHed,
        signInHedSpanTag,
        signInMessage,
        setLastBookmarkedPhoto,
        user,
        userPlatform,
        shouldHideIllustration,
        shouldEnableBookmarkDrawers,
        openCollectionsDrawer
    };
    const MESSAGE_BANNER_DELAY = 15000;
    const [showMessageBanner, setShowMessageBanner] = React.useState(false);
    const [showDrawerMessageBanner, setShowDrawerMessageBanner] = React.useState(false);
    const [messageBannerProps, setMessageBannerProps] = React.useState({});
    const { formatMessage } = useIntl();
    const { hideSecondaryButtonText = false } = variations;
    const [buttonState, setButtonState] = React.useState({});
    const { toggleBookmark, createBookmark } = BookmarkActions(bookmarkProps);
    const { isVisible: signInModalIsVisible, source: signInModalSource } = signInModalConfig || {};
    const fireAnalytics = (eventName, buttonType, additonalData = {}) => {
        googleAnalytics.emitGoogleTrackingEvent(eventName, {
            actionbar_button_type: buttonType,
            actionbar_parent_id: contentID,
            actionbar_parent_title: contentTitle,
            ...additonalData
        });
    };
    React.useEffect(() => {
        const isUnsaved = typeof unsavedBookmarks !== 'undefined' &&
            unsavedBookmarks?.[contentID] &&
            unsavedBookmarks?.[contentID].isDeleted === true;
        setButtonState((prevStatus) => ({
            ...prevStatus,
            bookmark: {
                isActive: Boolean(Number(bookmarkId)) && !isUnsaved,
                inViewport: false
            }
        }));
    }, [bookmarkId, unsavedBookmarks, contentID]);
    React.useEffect(() => {
        !signInModalIsVisible &&
            signInModalSource === 'VERSO_BOOKMARKING' &&
            setButtonState((prevStatus) => ({
                ...prevStatus,
                bookmark: {
                    ...(prevStatus?.bookmark || {}),
                    isInProcess: false
                }
            }));
    }, [signInModalIsVisible, signInModalSource]);
    /** Triggering GTM for Bookmark */
    React.useEffect(() => {
        if ((isBookmarkLoading === false || !user.isAuthenticated) &&
            buttonState.bookmark?.inViewport) {
            setButtonState((prevState) => ({
                ...prevState,
                bookmark: {
                    ...prevState.bookmark,
                    inViewport: false
                }
            }));
            const actionbar_status = bookmarkId ? 'active' : 'default';
            fireAnalytics('actionbar-impression', 'bookmark', { actionbar_status });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [buttonState.bookmark?.inViewport, isBookmarkLoading]);
    /** End Triggering GTM for Bookmark */
    React.useEffect(() => {
        if (window.document && window.document.location) {
            const queryParams = queryParamsHelper.parseQueryParams(window.location.search);
            if (queryParams.action &&
                queryParams.action === 'addBookmark' &&
                user.isAuthenticated) {
                toggleBookmark();
                window.history.replaceState({}, document.title, document.location.pathname);
            }
        }
    }, [toggleBookmark, user.isAuthenticated]);
    const shouldFetchComments = actionButtons.includes('comments') && shouldEnableCommunityExperience;
    const { count, isLoading } = useCommentsCount(contentID, commentingUrl, shouldFetchComments);
    const isBrowser = "object" !== 'undefined';
    const isDesktop = isBrowser && window.innerWidth > 1023;
    const placement = isDesktop ? 'left' : 'top';
    const shouldShowLabel = (buttonId) => {
        if (buttonId !== 'comments')
            return true;
        if (isLoading)
            return '';
        if (isDesktop) {
            return count === 0 ? formatMessage(translations.comments) : `${count}`;
        }
        return count === 0 ? null : `${count}`;
    };
    const getButtonLabel = (buttonId) => {
        const { defaultLabel, afterActionLabel } = actionBarConfig[buttonId];
        if (buttonId === 'comments') {
            return shouldShowLabel(buttonId);
        }
        if (buttonId === 'jumpToSection') {
            return defaultLabel;
        }
        else if (afterActionLabel || defaultLabel) {
            return buttonState[buttonId]?.isActive
                ? formatMessage(translations[afterActionLabel])
                : formatMessage(translations[defaultLabel]);
        }
        return '';
    };
    const undoSaveAction = (event, buttonLabel, bookmarkRecipesSaveLocation) => {
        createBookmark(event, buttonLabel, bookmarkRecipesSaveLocation);
        setButtonState((prevStatus) => ({
            ...prevStatus,
            bookmark: {
                isActive: Boolean(Number(bookmarkId))
            }
        }));
        setShowDrawerMessageBanner(false);
    };
    const messageBannerHandler = (event, buttonLabel, bookmarkRecipesSaveLocation) => {
        const bannerProps = {
            unsave: {
                message: 'Save Removed',
                buttonLabel: 'Undo',
                shouldHideBannerOnButtonClick: true,
                action: () => {
                    undoSaveAction(event, buttonLabel, bookmarkRecipesSaveLocation);
                    setShowMessageBanner(false);
                }
            },
            save: {
                message: 'Saved',
                buttonLabel: 'View All',
                shouldHideBannerOnButtonClick: false,
                buttonHref: '/account/saved'
            }
        };
        if (bookmarkId) {
            setMessageBannerProps(bannerProps.unsave);
        }
        else {
            setMessageBannerProps(bannerProps.save);
        }
        setShowMessageBanner(true);
        setTimeout(() => {
            setShowMessageBanner(false);
        }, MESSAGE_BANNER_DELAY);
    };
    const handleEvents = async (buttonId, event, buttonLabel) => {
        let eventData;
        switch (buttonId) {
            case 'bookmark': {
                fireAnalytics('actionbar-interaction', 'bookmark', {
                    actionbar_status: bookmarkId ? 'active' : 'default',
                    actionbar_interaction_type: getButtonLabel(buttonId)
                });
                setButtonState((prevState) => ({
                    ...prevState,
                    bookmark: {
                        ...prevState.bookmark,
                        isInProcess: true
                    }
                }));
                await toggleBookmark(event, buttonLabel, bookmarkRecipesSaveLocation);
                if (user.isAuthenticated) {
                    messageBannerHandler(event, buttonLabel, bookmarkRecipesSaveLocation);
                    if (bookmarkId) {
                        setShowDrawerMessageBanner(true);
                    }
                    else {
                        setShowDrawerMessageBanner(false);
                    }
                }
                break;
            }
            case 'audio': {
                event.stopPropagation();
                setButtonState({
                    ...buttonState,
                    audio: {
                        isActive: buttonState.audio ? !buttonState.audio.isActive : true
                    }
                });
                break;
            }
            case 'print': {
                event.preventDefault();
                window.print();
                eventData = {
                    type: 'print',
                    subject: 'action_bar',
                    placement: 'top',
                    index: 2,
                    total_index: 3
                };
                trackNavigationEvent(eventData);
                break;
            }
            case 'jumpToSection': {
                const element = document.querySelector(sectionElement) ||
                    document.querySelector(fallBackSectionElement);
                const elementPosition = element.getBoundingClientRect().top;
                const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
                window.scrollTo({
                    top: offsetPosition,
                    behavior: 'smooth'
                });
                eventData = {
                    type: 'jump_to_recipe',
                    subject: 'action_bar',
                    placement: 'top',
                    label: buttonLabel,
                    index: 0,
                    total_index: 3
                };
                trackNavigationEvent(eventData);
                break;
            }
            case 'comments': {
                trackSignpostingEvent(placement);
                scrollToAnchor(`.${COMMENTING_SECTION_CLASS}`);
                break;
            }
            default:
                break;
        }
    };
    const buttonInViewport = () => {
        actionButtons.forEach((actionButton) => {
            if (actionButton === 'bookmark') {
                setButtonState((prevState) => ({
                    ...prevState,
                    bookmark: {
                        ...prevState.bookmark,
                        inViewport: true
                    }
                }));
            }
            // fire analytics for other buttons here
        });
    };
    const onIntersectionViewport = (isInViewport, unsubscribeCallback) => {
        if (isInViewport) {
            buttonInViewport();
            unsubscribeCallback();
        }
    };
    const getButtonIcon = (actionButton, buttonConfig, buttonState) => {
        if (buttonState[actionButton]?.isInProcess && buttonConfig?.loaderIcon) {
            return buttonConfig.loaderIcon;
        }
        if (buttonState[actionButton]?.isActive) {
            return buttonConfig.afterActionIcon;
        }
        return buttonConfig.defaultIcon;
    };
    return (React.createElement(ActionBarWrapper, { "data-test-id": "ActionBar", buttonDirection: buttonDirection, maxScreenThreshold: maxScreenThreshold, minScreenThreshold: minScreenThreshold, onIntersectionViewport: onIntersectionViewport, isIcon: isIcon }, actionButtons.map((actionButton, index) => {
        const buttonConfig = actionBarConfig[actionButton];
        const buttonSubText = ''; // this will come to picture when the button is interactive for audio
        const hideSecondaryButtonLabel = hideSecondaryButtonText && index === 1;
        if (actionButton === 'comments' && !shouldEnableCommunityExperience) {
            return null;
        }
        if (buttonConfig) {
            const buttonLabel = getButtonLabel(actionButton);
            const buttonIcon = getButtonIcon(actionButton, buttonConfig, buttonState);
            return (React.createElement(React.Fragment, { key: actionButton },
                React.createElement(ActionBarButton, { id: actionButton, "aria-label": buttonLabel + buttonSubText, buttonDirection: buttonDirection, ...(isInteractive && {
                        onClick: (e) => {
                            handleEvents(actionButton, e, buttonLabel);
                        }
                    }), className: classnames({
                        active: Boolean(buttonState[actionButton]?.isActive),
                        [actionButton]: actionButton,
                        [className]: className
                    }), maxScreenThreshold: maxScreenThreshold, isInteractive: isInteractive },
                    React.createElement(ActionBarButtonIcon, { className: `${actionButton}-button-icon`, count: count, ...(typeof buttonIcon === 'string' && {
                            dangerouslySetInnerHTML: { __html: buttonIcon }
                        }) }, typeof buttonIcon === 'string' ? null : buttonIcon),
                    !hideSecondaryButtonLabel && (React.createElement(React.Fragment, null, actionButton === 'comments' && isLoading ? (React.createElement(React.Fragment, null,
                        React.createElement(ActionBarButtonLoader, { className: "comments-loader", count: count },
                            React.createElement(Loader, null)))) : (buttonLabel !== null && (React.createElement(ActionBarButtonText, null,
                        buttonLabel,
                        buttonSubText && (React.createElement(ActionBarButtonSubText, null, buttonSubText)))))))),
                buttonDirection === 'row' &&
                    index < actionButtons.length - 1 && React.createElement(ActionBarButtonDivider, null),
                hasMessageBanner &&
                    showMessageBanner &&
                    !shouldEnableBookmarkDrawers && (React.createElement(MessageBannerWrapper, { alignBanner: alignBanner, contentAlign: "left", isFixed: true, position: "bottom-centre", shouldShowCloseButton: true, closeButtonCallback: () => setShowMessageBanner(false), isDisclaimer: true, buttonHref: messageBannerProps.buttonHref, buttonLabel: messageBannerProps.buttonLabel, shouldHideBannerOnButtonClick: messageBannerProps.shouldHideBannerOnButtonClick, delayDuration: MESSAGE_BANNER_DELAY, shouldAddButton: true, shouldOrderCloseButtonLast: true, buttonClickHandler: messageBannerProps.action, btnStyle: "text", hasBorderRadius: true }, messageBannerProps.message)),
                showDrawerMessageBanner && shouldEnableBookmarkDrawers && (React.createElement(DrawerMessageBanner, { action: undoSaveAction, bannerType: "saveRemoved" }))));
        }
        return null;
    })));
};
ActionBar.propTypes = {
    actionBarConfig: PropTypes.objectOf(PropTypes.shape({
        afterActionIcon: PropTypes.oneOfType([
            PropTypes.string,
            PropTypes.element
        ]),
        afterActionLabel: PropTypes.string,
        defaultIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),
        defaultLabel: PropTypes.string,
        loaderIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.element])
    })),
    actionButtons: PropTypes.arrayOf(PropTypes.oneOf(['audio', 'bookmark', 'print', 'jumpToSection', 'comments'])).isRequired,
    alignBanner: PropTypes.oneOf(['top', 'bottom']),
    bookmarkId: PropTypes.number,
    bookmarkRecipesSaveLocation: PropTypes.string,
    buttonDirection: PropTypes.oneOf(['row', 'column']),
    className: PropTypes.string,
    commentingUrl: PropTypes.string,
    contentID: PropTypes.string,
    contentTitle: PropTypes.string,
    contentType: PropTypes.string,
    displayBookmarkAlert: PropTypes.func,
    documentUrl: PropTypes.string,
    doUpdateBookmarkedStatus: PropTypes.func,
    doUpdateUnsavedBookmarks: PropTypes.func,
    fallBackSectionElement: PropTypes.string,
    hasMessageBanner: PropTypes.bool,
    headerOffset: PropTypes.number,
    image: PropTypes.object,
    isBookmarkLoading: PropTypes.bool,
    isIcon: PropTypes.bool,
    isInteractive: PropTypes.bool,
    isUrlBookmark: PropTypes.bool,
    maxScreenThreshold: PropTypes.string,
    minScreenThreshold: PropTypes.string,
    organizationID: PropTypes.string,
    sectionElement: PropTypes.string,
    setLastBookmarkedPhoto: PropTypes.func,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldEnableCommunityExperience: PropTypes.bool,
    shouldHideIllustration: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    signInHed: PropTypes.string,
    signInHedSpanTag: PropTypes.string,
    signInMessage: PropTypes.string,
    signInModalConfig: PropTypes.shape({
        isVisible: PropTypes.bool,
        source: PropTypes.string
    }),
    unsavedBookmarks: PropTypes.object,
    user: PropTypes.shape({
        amguuid: PropTypes.string,
        isAuthenticated: PropTypes.bool
    }),
    userPlatform: PropTypes.shape({
        federatedGraphqlUrl: PropTypes.string,
        siteCode: PropTypes.string,
        userPlatformProxy: PropTypes.string,
        xClientID: PropTypes.string
    }),
    variations: PropTypes.object
};
const mapStateToProps = (state, ownProps) => {
    const { coreDataLayer: { content: { contentType }, site: { orgId: organizationID } }, commentAttributes, communityExperience, 'head.contentID': contentID, 'head.canonicalUrl': documentUrl, 'head.title': contentTitle, featureFlags: { shouldUseBookmarkV3 }, config: { account }, pageState: { bookmarkStatus: { bookmarkId, isUrlBookmark, isBookmarkLoading } }, user, userPlatform, signInModalConfig, unsavedBookmarks = {} } = state;
    const enableBookmarkDrawers = account?.bookmark?.enableBookmarkDrawers || false;
    const { bookmarkDetails = {}, isPageScoped = true } = ownProps;
    const { commentingUrl } = commentAttributes || {};
    const { enableCommunityExperience } = communityExperience || {};
    if (!isPageScoped) {
        return {
            bookmarkId: bookmarkDetails.bookmarkId,
            commentingUrl,
            contentID: bookmarkDetails.contentId,
            contentType,
            contentTitle,
            documentUrl,
            isUrlBookmark: bookmarkDetails.isUrlBookmark,
            organizationID,
            user,
            userPlatform,
            shouldUseBookmarkV3,
            signInModalConfig,
            shouldEnableBookmarkDrawers: enableBookmarkDrawers,
            shouldEnableCommunityExperience: enableCommunityExperience,
            unsavedBookmarks
        };
    }
    return {
        bookmarkId,
        commentingUrl,
        contentID,
        contentType,
        contentTitle,
        documentUrl,
        isBookmarkLoading,
        isUrlBookmark,
        organizationID,
        user,
        userPlatform,
        shouldUseBookmarkV3,
        signInModalConfig,
        shouldEnableBookmarkDrawers: enableBookmarkDrawers,
        shouldEnableCommunityExperience: enableCommunityExperience,
        unsavedBookmarks
    };
};
const mapDispatchToProps = (dispatch) => ({
    displayBookmarkAlert: () => {
        dispatch({
            type: 'MERGE_KEY',
            key: 'bookmarkAlert',
            value: { isVisible: true }
        });
    },
    doUpdateBookmarkedStatus: (bookmarkStatus) => {
        dispatch({
            type: 'SET_KEY',
            key: 'pageState.bookmarkStatus',
            value: bookmarkStatus
        });
    },
    setLastBookmarkedPhoto: (copilotID, image, contentType, contentTitle) => {
        dispatch({
            type: 'SET_KEY',
            key: 'lastBookmarkedPhoto',
            value: { copilotID, image, contentType, contentTitle }
        });
    },
    doUpdateUnsavedBookmarks: ({ copilotID, isDeleted }) => {
        dispatch({
            type: 'MERGE_KEY',
            key: 'unsavedBookmarks',
            value: { [copilotID]: { isDeleted } }
        });
    }
});
module.exports = connect(mapStateToProps, mapDispatchToProps)(asConfiguredComponent(ActionBar, 'ActionBar'));
//# sourceMappingURL=ActionBar.js.map

/***/ }),

/***/ 59953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const signInModalActions = __webpack_require__(22509);
const { default: translations } = __webpack_require__(89844);
const userBookmarkHelper = __webpack_require__(48373);
const { errorType } = __webpack_require__(74139);
const { trackSaveEvent, buildSaveImageContext } = __webpack_require__(14307);
const BOOKMARK_UPDATE_SOURCE = 'verso-story-page';
/**
 *
 * @param {object} props - ActionBarBookmark props
 * @param {number} [props.bookmarkId] - ID of bookmark in user platform system
 * @param {string} [props.copilotID] - ID of the Copilot entity
 * @param {string} [props.contentID] - ID of the contentID entity
 * @param {string} props.contentTitle - Content type which has been rendered
 * @param {string} props.contentType - Content type which has been rendered
 * @param {Function} [props.displayBookmarkAlert] - Dispatch function to display bookmark alert
 * @param {Function} [props.doUpdateBookmarkedStatus] - Dispatch function to update global store
 * @param {Function} [props.doUpdateUnsavedBookmarks] - Dispatch function to reset the redux state of an unsaved bookmark item
 * @param {boolean} [props.isUrlBookmark] - Whether the bookmark was saved using the documentUrl or the organizationID/copilotID
 * @param {string} [props.organizationID] - Brand ID associated copilot entity(copilotID)
 * @param {boolean} [props.shouldHideIllustration] - Boolean value to hide/show image in signin modal
 * @param {string} [props.signInHed] - Header on signin alert shown to user
 * @param {string} [props.signInHedSpanTag] - Hed span tag on signin alert shown to user
 * @param {string} [props.signInMessage] - Message on signin alert shown to user
 * @param {object} props.user - User information
 * @param {boolean} [props.user.isAuthenticated] - Represents if the user is currently authenticated
 * @param {boolean} [props.user.amguuid] - User's amguuid
 * @param {object} props.userPlatform - User platform details for fetching bookmark details
 * @param {string} [props.userPlatform.federatedGraphqlUrl] - User platform federated graphql endpoint
 * @param {string} [props.userPlatform.siteCode] -  Brand siteCode
 * @param {string} [props.userPlatform.userPlatformProxy] - Brand user platform proxy server url
 * @param {string} [props.userPlatform.xClientID] - xClientID from brand tenant config
 * @param {boolean} [props.shouldUseBookmarkV3] - Define whether to use bookmark v3
 * @param {Function} [props.setLastBookmarkedPhoto] - Dispatch function to set the id of the most recently bookmarked photo
 * @param {object} [props.image] - image object for collection drawer
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - Feature flag to define whether enable bookmark drawers functionality
 * @param {Function} [props.openCollectionsDrawer] - Dispatch function to open the collection drawer
 *
 * @returns {{toggleBookmark: toggleBookmark, createBookmark: createBookmark, displaySignInModal: displaySignInModal}} - Returns functions
 */
const BookmarkActions = ({ bookmarkId, contentID: copilotID, contentTitle, contentType, displayBookmarkAlert, doUpdateBookmarkedStatus, doUpdateUnsavedBookmarks, image, isUrlBookmark, organizationID, setLastBookmarkedPhoto, shouldEnableBookmarkDrawers, shouldHideIllustration = false, shouldUseBookmarkV3 = false, signInHed, signInHedSpanTag, signInMessage, user, userPlatform, openCollectionsDrawer }) => {
    const { formatMessage } = useIntl();
    const { amguuid: amgUUID = '', isAuthenticated = false } = user;
    const { federatedGraphqlUrl, siteCode, userPlatformProxy, xClientID } = userPlatform;
    const bookmarkHelper = userBookmarkHelper(shouldUseBookmarkV3);
    let saveContext = buildSaveImageContext({
        subject: 'account_saved_stories'
    });
    const displaySignInModal = async (event) => {
        if (event) {
            event.preventDefault();
        }
        const { pathname, search } = window.location;
        const bookmarkQS = 'action=addBookmark';
        const documentURLWithActionQueryString = search
            ? `${pathname}${search}&${bookmarkQS}`
            : `${pathname}?${bookmarkQS}`;
        signInModalActions.doDisplayModal({
            authSource: 'sign-in-modal',
            source: 'VERSO_BOOKMARKING',
            dangerousHed: signInHed || '',
            dangerousHedSpanTag: signInHedSpanTag || '',
            dangerousDek: signInMessage || formatMessage(translations.bookmarkSignInMessage),
            redirectURL: documentURLWithActionQueryString,
            type: 'default',
            analyticsType: 'saved stories',
            shouldHideIllustration
        });
    };
    /**
     * Create book mark on basis or url for user
     *
     * @param bookmarkSaveLocation - Optional string which indicates bookmark save location through snowplow tracking
     * @param event - Button event reference
     * @param buttonLabel - Button label
     * @param bookmarkSaveLocation - Optional to pass bookmark save location
     *
     * @returns {Promise<void>} ie. undefined
     */
    const createBookmark = async (event, buttonLabel, bookmarkSaveLocation) => {
        if (event) {
            event.preventDefault();
        }
        if (bookmarkSaveLocation) {
            saveContext = buildSaveImageContext({
                subject: bookmarkSaveLocation
            });
        }
        try {
            const { statusCode, data: { id } = {} } = await bookmarkHelper.proxyCreateBookmark({
                amgUUID,
                copilotID,
                contentType,
                federatedGraphqlUrl,
                organizationID,
                siteCode,
                source: BOOKMARK_UPDATE_SOURCE,
                userPlatformProxy,
                xClientID
            });
            if ((statusCode === 201 && id) || statusCode === 409) {
                if (window && window.dataLayer) {
                    const dataLayer = window.dataLayer.length > 0 && window.dataLayer[0];
                    const eventData = {
                        type: 'save',
                        label: buttonLabel,
                        subject: 'action_bar',
                        items: [
                            {
                                content_title: dataLayer?.content.contentTitle,
                                content_id: copilotID,
                                content_type: contentType,
                                content_url: dataLayer?.page.canonical
                            }
                        ]
                    };
                    trackSaveEvent(eventData, saveContext);
                    setLastBookmarkedPhoto(copilotID, image, contentType, contentTitle);
                }
                const bookmarkDetails = { bookmarkId: id, isUrlBookmark: false };
                doUpdateUnsavedBookmarks({ copilotID, isDeleted: false });
                doUpdateBookmarkedStatus(bookmarkDetails);
                if (shouldEnableBookmarkDrawers && id) {
                    openCollectionsDrawer?.();
                }
            }
        }
        catch (error) {
            if (error.message.includes(errorType.MISSING_ACCESS_TOKEN)) {
                displaySignInModal(event, copilotID);
                return;
            }
            console.error(error);
        }
        finally {
            // Success or fail, we want to remove ?action= from URL to prevent sharing of this URL
            window.history.replaceState({}, document.title, document.location.pathname);
        }
        if (window.localStorage &&
            !window.localStorage.getItem('userHasUsedBookmarkFeature')) {
            displayBookmarkAlert();
            window.localStorage.setItem('userHasUsedBookmarkFeature', 'true');
        }
    };
    /**
     * Delete bookmark for the user
     *
     * @param event - Button event reference
     * @param buttonLabel - Button label
     * @param bookmarkSaveLocation - Optional to pass bookmark save location
     *
     * @returns {Promise<void>} ie. undefined
     */
    const removeBookmark = async (event, buttonLabel, bookmarkSaveLocation) => {
        event.preventDefault();
        let bookmarkUnsaveLabel = buttonLabel;
        try {
            const response = await bookmarkHelper.proxyRemoveBookmark({
                amgUUID,
                bookmarkId,
                federatedGraphqlUrl,
                isUrlBookmark,
                source: BOOKMARK_UPDATE_SOURCE,
                userPlatformProxy,
                xClientID
            });
            if (response && response.status !== 204) {
                return;
            }
            if (bookmarkSaveLocation) {
                saveContext = buildSaveImageContext({
                    subject: bookmarkSaveLocation
                });
                bookmarkUnsaveLabel = 'Recipe Unsaved';
            }
            if (window && window.dataLayer) {
                const dataLayer = window.dataLayer.length > 0 && window.dataLayer[0];
                const eventData = {
                    type: 'unsave',
                    label: bookmarkUnsaveLabel,
                    subject: 'action_bar',
                    items: [
                        {
                            content_title: dataLayer.content.contentTitle,
                            content_id: dataLayer.content.copilotId,
                            content_type: dataLayer.content.contentType,
                            content_url: dataLayer.page.canonical
                        }
                    ]
                };
                trackSaveEvent(eventData, saveContext);
                setLastBookmarkedPhoto();
            }
            const bookmarkDetails = { bookmarkId: null, isUrlBookmark: null };
            doUpdateBookmarkedStatus(bookmarkDetails);
        }
        catch (error) {
            console.error(error);
        }
    };
    const checkIsAlreadyBookmarked = async () => {
        let isBookmarked = false;
        try {
            const bookmarkStatus = await bookmarkHelper.getBookmarkStatus({
                copilotID,
                organizationID,
                federatedGraphqlUrl
            });
            doUpdateBookmarkedStatus(bookmarkStatus);
            if (bookmarkStatus?.bookmarkId) {
                isBookmarked = true;
            }
        }
        catch (error) {
            console.info(error);
        }
        return isBookmarked;
    };
    const toggleBookmark = async (event, buttonLabel, bookmarkSaveLocation = null) => {
        if (!isAuthenticated) {
            return displaySignInModal(event);
        }
        const isBookAlredyBookmarked = await checkIsAlreadyBookmarked();
        // The following line can be deleted when all brands migrate to BookmarkV3
        const verifyBookmarkStatus = shouldUseBookmarkV3
            ? isBookAlredyBookmarked
            : bookmarkId;
        return verifyBookmarkStatus
            ? removeBookmark(event, buttonLabel, bookmarkSaveLocation)
            : createBookmark(event, buttonLabel, bookmarkSaveLocation);
    };
    return { toggleBookmark, createBookmark, displaySignInModal };
};
BookmarkActions.propTypes = {
    bookmarkId: PropTypes.number,
    contentID: PropTypes.string,
    contentType: PropTypes.string.isRequired,
    displayBookmarkAlert: PropTypes.func,
    documentUrl: PropTypes.string,
    doUpdateBookmarkedStatus: PropTypes.func,
    doUpdateUnsavedBookmarks: PropTypes.func,
    image: PropTypes.object,
    isUrlBookmark: PropTypes.bool,
    openCollectionsDrawer: PropTypes.func,
    organizationID: PropTypes.string,
    setLastBookmarkedPhoto: PropTypes.func,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldHideIllustration: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    signInHed: PropTypes.string,
    signInHedSpanTag: PropTypes.string,
    signInMessage: PropTypes.string,
    user: PropTypes.shape({
        amguuid: PropTypes.string,
        isAuthenticated: PropTypes.bool
    }).isRequired,
    userPlatform: PropTypes.shape({
        federatedGraphqlUrl: PropTypes.string,
        siteCode: PropTypes.string,
        userPlatformProxy: PropTypes.string,
        xClientID: PropTypes.string
    }).isRequired
};
module.exports = BookmarkActions;
//# sourceMappingURL=BookmarkActions.js.map

/***/ }),

/***/ 75978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_1 = __webpack_require__(96540);
const utils_1 = __webpack_require__(60711);
/**
 * Custom hook to fetch and manage comments count
 *
 * @param {string} contentID - ID of the content to fetch comments for
 * @param {string} commentingUrl - URL endpoint for commenting API
 * @param {boolean} shouldFetch - Flag to determine if comments should be fetched
 * @returns {object} Object containing count and loading state
 */
const useCommentsCount = (contentID, commentingUrl, shouldFetch) => {
    const [count, setCount] = (0, react_1.useState)(0);
    const [isLoading, setIsLoading] = (0, react_1.useState)(true);
    (0, react_1.useEffect)(() => {
        if (!shouldFetch || !commentingUrl) {
            setIsLoading(false);
            return;
        }
        (async () => {
            try {
                setIsLoading(true);
                const fetchedCount = await (0, utils_1.getStoryCommentsCount)(contentID, commentingUrl, console);
                setCount(fetchedCount !== null ? fetchedCount : 0);
            }
            catch (error) {
                console.error('Error fetching comments count:', error);
                setCount(0);
            }
            finally {
                setIsLoading(false);
            }
        })();
    }, [contentID, commentingUrl, shouldFetch]);
    return { count, isLoading };
};
exports.A = {
    useCommentsCount
};
//# sourceMappingURL=hooks.js.map

/***/ }),

/***/ 72014:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ActionBar = __webpack_require__(29110);
module.exports = ActionBar;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 11586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(76955);
const ViewportMonitor = __webpack_require__(3990);
const { calculateSpacing, getColorStyles, getColorToken, getTypographyStyles, maxScreen, minScreen, minMaxScreen } = __webpack_require__(26865);
const { minThresholds, maxThresholds } = __webpack_require__(55058);
const MessageBanner = __webpack_require__(13447);
const { MessageBannerContent, MessageBannerCloseButton, MessageBannerCTA } = __webpack_require__(8070);
const ActionBarButtonIcon = styled.span.withConfig({
    displayName: 'ActionBarSecondaryButtonPrimaryIcon'
}) `
  display: flex;
  margin-right: ${calculateSpacing(1)};

  &.comments-button-icon {
    @media (max-width: 1023px) {
      margin-right: ${({ count }) => count === 0 ? '0' : `${calculateSpacing(1)}`};
    }
  }
`;
const ActionBarButtonText = styled(BaseText).withConfig({
    displayName: 'ActionBarButtonText'
}) `
  white-space: nowrap;
`;
ActionBarButtonText.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.black',
    typeIdentity: 'typography.definitions.utility.button-utility'
};
const ActionBarButtonSubText = styled(BaseText).withConfig({
    displayName: 'ActionBarButtonSubText'
}) `
  padding-left: ${calculateSpacing(0.5)};
`;
ActionBarButtonSubText.defaultProps = {
    as: 'span',
    colorToken: 'colors.interactive.base.dark',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const ActionBarButtonDivider = styled.span.withConfig({
    displayName: 'ActionBarButtonDivider'
}) `
  align-self: center;
  border-left: 1px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.border')};
  height: ${calculateSpacing(3)};
`;
const ActionBarButton = styled.button.withConfig({
    displayName: 'ActionBarButton'
}) `
  display: flex;
  position: relative;
  align-items: center;
  border-bottom: ${({ buttonDirection }) => buttonDirection === 'column' && `1px solid;`};
  border-radius: ${({ buttonDirection }) => buttonDirection === 'column' ? calculateSpacing(1) : calculateSpacing(6)};
  padding: 0 ${calculateSpacing(2)};
  height: ${calculateSpacing(6)};
  overflow: hidden;

  ${({ buttonDirection }) => {
    if (buttonDirection === 'column') {
        return `
        &:last-of-type:not(:first-of-type) {
          border-top-left-radius: 0;
          border-top-right-radius: 0;
        }
        &:not(:last-of-type) {
          border-bottom-left-radius: 0;
          border-bottom-right-radius: 0;
        }
      `;
    }
    if (buttonDirection === 'row') {
        return `
        &:last-of-type:not(:first-of-type) {
          border-top-left-radius: 0;
          border-bottom-left-radius: 0;
        }
        &:not(:last-of-type) {
          border-top-right-radius: 0;
          border-bottom-right-radius: 0;
        }
      `;
    }
    return '';
}};

  ${({ theme }) => {
    return `
      ${getColorStyles(theme, 'border-color', 'colors.interactive.base.border')};
      ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
    `;
}};

  ${({ buttonDirection }) => buttonDirection === 'column' &&
    `
      min-width: ${calculateSpacing(7)};
      height: ${calculateSpacing(7)};
      &:last-of-type {
        border-bottom: 0;
      }
    `}

  ${({ isInteractive }) => isInteractive &&
    css `
      &:hover {
        text-decoration: none;
        ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.highlight')};

        ${({ maxScreenThreshold }) => maxScreenThreshold &&
        css `
            ${maxScreen(`${maxThresholds[maxScreenThreshold]}px`)} {
              background-color: transparent;
            }
          `};
      }
    `}

  &:focus-visible {
    outline-style: auto;
  }

  &:focus {
    text-decoration: none;
  }

  ${ActionBarButtonIcon} .icon-bookmark-fill {
    ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
  }

  ${ActionBarButtonIcon} .icon-bookmark-stroke {
    ${({ theme }) => getColorStyles(theme, 'stroke', 'colors.interactive.base.black')};
  }

  ${ActionBarButtonIcon} .icon-loader {
    .icon-loader-track {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.light')};
    }

    .icon-loader-progress {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};
    }
  }

  &.active {
    ${ActionBarButtonIcon} {
      .icon-bookmark--activated-outline {
        ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};
      }

      .icon-bookmark--activated-checkmark {
        ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
      }

      .icon-bookmark--activated-fill {
        ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};
      }
    }

    ${ActionBarButtonText} {
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.brand-primary')};
    }
  }
`;
const ActionBarWrapper = styled(ViewportMonitor).withConfig({
    displayName: 'ActionBarWrapper'
}) `
  display: none;
  flex-direction: ${({ buttonDirection }) => `${buttonDirection};`};
  justify-content: center;
  border: 1px solid;
  border-radius: ${calculateSpacing(6)};

  ${({ buttonDirection }) => buttonDirection === 'column' &&
    `
    border-radius: ${calculateSpacing(1)};
    max-width: ${calculateSpacing(7.25)};
    transition: max-width 300ms ease-in-out;

    ${ActionBarButtonText} {
      display: none;
    }

    ${ActionBarButtonIcon} {
      margin-right: 0;
    }

    &:hover {
      max-width: ${calculateSpacing(24)};
      ${ActionBarButtonIcon} {
        margin-right: ${calculateSpacing(1)};
      }
      ${ActionBarButtonText} {
        display: unset;
      }
    }
  `}

  ${({ theme }) => {
    return `
      ${getColorStyles(theme, 'border-color', 'colors.interactive.base.border')};
      ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
    `;
}};

  ${({ maxScreenThreshold, minScreenThreshold }) => {
    const minScreenValue = minScreenThreshold
        ? minThresholds[minScreenThreshold]
        : 0;
    if (maxScreenThreshold) {
        const maxScreenValue = maxThresholds[maxScreenThreshold];
        return css `
        ${minMaxScreen(`${minScreenValue}px`, `${maxScreenValue}px`)} {
          display: inline-flex;
        }
      `;
    }
    return css `
      ${minScreen(`${minScreenValue}px`)} {
        display: inline-flex;
      }
    `;
}};

  ${({ isIcon, theme }) => isIcon &&
    `
      &::before {
        content: '';
        position: absolute;
        border-radius: ${calculateSpacing(0.5, 'px')};
        width: ${calculateSpacing(3, 'px')};
        height: ${calculateSpacing(3, 'px')};
        opacity: .9;
        ${getColorStyles(theme, 'background-color', 'colors.discovery.body.white.background')};
      }

      background: none;
      border: none;
      border-radius: ${calculateSpacing(0.5, 'px')};
      width: ${calculateSpacing(3, 'px')};
      height: ${calculateSpacing(3, 'px')};
      
      ${ActionBarButton} {
        background: none;
        height: auto;
        padding: 0;
        justify-content: center;

        svg {
          width: ${calculateSpacing(1.75, 'px')};
          height: ${calculateSpacing(1.75, 'px')};
        }
      }

      ${ActionBarButtonIcon} {
        margin-right: 0;
      }

      ${ActionBarButtonText} {
        display: none;
      }
    `}
`;
const bottomAlignment = css `
  @media (max-width: 767px) {
    top: auto;
    bottom: ${calculateSpacing(5)};
    min-width: calc(100vw - 48px);
  }

  @media (min-width: 768px) {
    top: auto;
    right: auto;
    bottom: ${calculateSpacing(6)};
    left: ${calculateSpacing(6)};
  }
`;
const topAlignment = css `
  @media (max-width: 767px) {
    top: ${calculateSpacing(8)};
    bottom: auto;
    min-width: calc(100vw - 48px);
  }

  @media (min-width: 768px) {
    top: ${calculateSpacing(10)};
    right: ${calculateSpacing(6)};
    left: auto;
    margin: 0;
  }
`;
const MessageBannerWrapper = styled(MessageBanner).withConfig({
    displayName: 'MessageBannerWrapper'
}) `
  ${({ alignBanner }) => {
    switch (alignBanner) {
        case 'bottom':
            return bottomAlignment;
        case 'top':
            return topAlignment;
        default:
            return bottomAlignment;
    }
}}

  display: flex;
  align-items: center;
  border: none;
  ${({ theme }) => getColorStyles(theme, 'background', 'colors.consumption.lead.inverted.background')};
  max-width: ${calculateSpacing(48)};
  min-height: 0;

  ${MessageBannerContent} {
    ${getTypographyStyles('typography.definitions.utility.description')};
    margin-top: ${calculateSpacing(1.5)};
    margin-bottom: ${calculateSpacing(1.5)};
    margin-left: ${calculateSpacing(2)};
    padding: 0;
    min-width: ${calculateSpacing(20)};
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')};
  }

  ${MessageBannerCloseButton} {
    svg path {
      fill: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
      stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
    }
    margin: ${calculateSpacing(1)};
  }

  ${MessageBannerCTA} {
    ${getTypographyStyles('typography.definitions.utility.button-utility')};
    border: none;
    background: none;
    padding: 0;
    min-width: ${calculateSpacing(10)};
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')};
  }
`;
const ActionBarButtonLoader = styled.div.withConfig({
    displayName: 'ActionBarButtonLoader'
}) `
  display: none;
  align-items: center;
  justify-content: center;

  /* Only show on small screens (1023px and below) */
  @media (max-width: 1023px) {
    display: flex;
    margin-left: ${({ count }) => count === 0 ? `${calculateSpacing(1)}` : '0'};
  }

  .icon-loader {
    width: 16px;
    height: 16px;
  }

  ${({ theme }) => `
    .icon-loader-track {
      ${getColorStyles(theme, 'fill', 'colors.interactive.base.light')};
    }
    
    .icon-loader-progress {
      ${getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};
    }
  `}
`;
module.exports = {
    ActionBarWrapper,
    ActionBarButton,
    ActionBarButtonDivider,
    ActionBarButtonText,
    ActionBarButtonSubText,
    ActionBarButtonIcon,
    MessageBannerWrapper,
    ActionBarButtonLoader
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 60325:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trackSignpostingEvent = void 0;
const snowplow_tracking_1 = __webpack_require__(14307);
const trackSignpostingEvent = (placement) => {
    const entityData = {
        type: 'jump_to_community_comments',
        subject: 'action_bar',
        placement
    };
    (0, snowplow_tracking_1.trackNavigationEvent)(entityData);
};
exports.trackSignpostingEvent = trackSignpostingEvent;
//# sourceMappingURL=tracking.js.map

/***/ }),

/***/ 89844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_intl_1 = __webpack_require__(46984);
exports["default"] = (0, react_intl_1.defineMessages)({
    audioPrimaryLabel: {
        id: 'AudioPrimaryLabel.Listen',
        defaultMessage: 'Listen',
        description: 'Listen'
    },
    audioSecondaryLabel: {
        id: 'AudioSecondaryLabel.NowPlaying',
        defaultMessage: 'Now playing',
        description: 'Now playing'
    },
    bookmarkSaveThisStory: {
        id: 'BookmarkPrimaryLabel.SaveThisStory',
        defaultMessage: 'Save this story',
        description: 'Save this story'
    },
    bookmarkSavedToLibrary: {
        id: 'BookmarkPrimaryLabel.SavedToLibrary',
        defaultMessage: 'Saved to library',
        description: 'Saved to library'
    },
    bookmarkSave: {
        id: 'BookmarkPrimaryLabel.Save',
        defaultMessage: 'Save',
        description: 'Save'
    },
    bookmarkSaved: {
        id: 'BookmarkPrimaryLabel.Saved',
        defaultMessage: 'Saved',
        description: 'Saved'
    },
    bookmarkSignInMessage: {
        id: 'Bookmark.SignInMessage',
        defaultMessage: 'After signing in, you can save stories and easily revisit them on any deviceeven off-line.',
        description: 'Bookmark sign in message'
    },
    bookmarkSaveRecipe: {
        id: 'BookmarkPrimaryLabel.SaveRecipe',
        defaultMessage: 'Save Recipe',
        description: 'Save Recipe'
    },
    bookmarkRecipeSaved: {
        id: 'BookmarkPrimaryLabel.RecipeSaved',
        defaultMessage: 'Recipe Saved',
        description: 'Recipe Saved'
    },
    comments: {
        id: 'CommunityLabel.CommentsCount',
        defaultMessage: 'Comments',
        description: 'Comments Count'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 29110:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const ActionBar = __webpack_require__(28389);
// TNY uses this variation for small screens
ActionBar.SecondaryButtonWithNoText = asVariation(ActionBar, 'SecondaryButtonWithNoText', {
    hideSecondaryButtonText: true
});
// TNY uses this variation for large screens
ActionBar.Stacked = asVariation(ActionBar, 'Stacked', {}, {
    buttonDirection: 'column'
});
ActionBar.IconWithoutInteraction = asVariation(ActionBar, 'IconWithoutInteraction', {}, {
    isIcon: true,
    isInteractive: false
});
module.exports = ActionBar;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 80060:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const innertext = __webpack_require__(23778);
const { googleAnalytics } = __webpack_require__(90090);
const { asConfiguredComponent } = __webpack_require__(12892);
const Button = __webpack_require__(73730);
const CloseIcon = __webpack_require__(76399);
const BookmarkActivatedIcon = __webpack_require__(52585);
const { TrackComponentChannel } = __webpack_require__(78788);
const { AlertWrapper, AlertArrow, AlertMessage, AlertIconWrapper, AlertDangerousBookmarkMessage } = __webpack_require__(3318);
/**
 * Alert component
 *
 * @param {object} props - React props
 * @param {Function} [props.AlertIcon] - optional icon to display in alert
 * @param {string} [props.alertPosition] - Determine how the Alert component should be placed relative to anchor component. Default - under
 * @param {string} [props.ariaRole] - optional aria role, defaults to 'tooltip'
 * @param {number} [props.arrowPosition] - A number between 0 and 100 representing a percentage of how far along the x or y axis you'd like to place the arrow. Defaults to zero
 * @param {string} [props.bookmarkIconAlertDesktopLeft] - optional string representing the css left property for the bookmark onboarding tooltip (defaults to 120%)
 * @param {string} [props.bookmarkIconAlertDesktopTop] - optional string representing the css top property for the bookmark onboarding tooltip (defaults to 70%)
 * @param {object} [props.children] - JSX element for alert message
 * @param {object} [props.dangerousBookmarkMessage] - JSX element for custom alert message
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dataTestId] - Optional html attr value for data-testid (used for cypress testing)
 * @param {string} [props.gaIdentifier] - optional prop to pass along to the data layer for google analytics. if this prop isn't present no analytics event will emit
 * @param {string} [props.iconName] - Optional
 * @param {string} [props.iconPosition] - Optional icon position in relation to text: ['before', 'after']. Defaults to 'before'
 * @param {string} [props.iconSize] - Optional
 * @param {boolean} [props.isVisible] - True to show, false to hide alert
 * @param {boolean} [props.isBookmarkAlert] - prop indicating the alert is the tooltip that appears (near nav on desktop, bottom of screen mobile) after a user has used the bookmark feature for the first time
 * @param {boolean} [props.isBookmarkIconAlert] - prop indicating the alert is the onboarding tooltip associated with the bookmark icon that appears on hover
 * @param {boolean} [props.isTooltip] - prop to control if alert is a tooltip or not                          |
 * @param {Function} [props.onClose] - if this callback is passed, the Alert Component will be rendered with a close button that calls this when pressed
 * @param {boolean} [props.shouldUseArrow] - Indicate whether or not you'd like to render the arrow. Default false
 *
 * @returns {ReactElement} <div>
 */
const Alert = ({ AlertIcon, alertPosition = 'under', ariaRole = 'tooltip', arrowPosition = 0, bookmarkIconAlertDesktopLeft = '120%', bookmarkIconAlertDesktopTop = '70%', children, className = '', dataTestId, dangerousBookmarkMessage, gaIdentifier, iconName, iconPosition = 'before', iconSize = 'thinner', isBookmarkAlert = false, isBookmarkIconAlert = false, isTooltip = false, isVisible = false, onClose, shouldUseArrow = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Alert'
        });
    }, []);
    const [isEscaped, setIsEscaped] = React.useState(!isVisible);
    React.useEffect(() => {
        setIsEscaped(!isVisible);
    }, [isVisible]);
    const escapeListener = (event) => {
        if (event.key === 'Escape') {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            escape();
        }
    };
    const escape = () => {
        onClose && onClose();
        setIsEscaped(true);
        window && window.removeEventListener('keydown', escapeListener);
    };
    React.useEffect(() => {
        window && window.addEventListener('keydown', escapeListener);
        return () => {
            window && window.removeEventListener('keydown', escapeListener);
        };
    });
    const ConnectedAlertIcon = iconName === 'BookmarkActivated' && iconSize === 'thin'
        ? BookmarkActivatedIcon
        : AlertIcon;
    React.useEffect(() => {
        if (isVisible && gaIdentifier && window.dataLayer) {
            /* This may seem redundant, however the same alert may have to be implemented with
              in different places with the same identifier in order to attach to elements only present
              in either desktop / mobile, and we dont want to trigger the same impression twice
            */
            const shouldPushEvent = !window.dataLayer.find(({ alertName }) => {
                return alertName === gaIdentifier;
            });
            shouldPushEvent &&
                googleAnalytics.emitUniqueGoogleTrackingEvent('alert-impression', {
                    alertName: gaIdentifier,
                    alertText: innertext(children)
                });
        }
    }, [children, gaIdentifier, isVisible]);
    return children ? (React.createElement(AlertWrapper, { alertPosition: alertPosition, bookmarkIconAlertDesktopLeft: bookmarkIconAlertDesktopLeft, bookmarkIconAlertDesktopTop: bookmarkIconAlertDesktopTop, className: className, "data-testid": dataTestId, isBookmarkAlert: isBookmarkAlert, isBookmarkIconAlert: isBookmarkIconAlert, isTooltip: isTooltip, isVisible: isVisible, isEscaped: isEscaped, role: ariaRole },
        shouldUseArrow && (React.createElement(AlertArrow, { isBookmarkAlert: isBookmarkAlert, alertPosition: alertPosition, arrowPosition: arrowPosition, "aria-hidden": true, role: "presentation", className: "alert-arrow" })),
        AlertIcon && iconPosition === 'before' && (React.createElement(AlertIconWrapper, { iconSize: iconSize, "aria-hidden": true, role: "presentation", isBookmarkAlert: isBookmarkAlert, isBookmarkIconAlert: isBookmarkIconAlert },
            React.createElement(ConnectedAlertIcon, null))),
        React.createElement(AlertMessage, { isBookmarkAlert: isBookmarkAlert, isBookmarkIconAlert: isBookmarkIconAlert, className: "alert-message" }, dangerousBookmarkMessage ? (React.createElement(AlertDangerousBookmarkMessage, { dangerouslySetInnerHTML: { __html: dangerousBookmarkMessage } })) : (children)),
        AlertIcon && iconPosition === 'after' && (React.createElement(AlertIconWrapper, { iconSize: iconSize, "aria-hidden": true, role: "presentation", isBookmarkAlert: isBookmarkAlert, isBookmarkIconAlert: isBookmarkIconAlert },
            React.createElement(ConnectedAlertIcon, null))),
        onClose && (React.createElement(Button.Utility, { ButtonIcon: CloseIcon, isIconButton: true, className: "close-alert-button", label: "Close Alert", onClickHandler: onClose, role: "button", tabIndex: !isEscaped || isVisible ? 0 : undefined })))) : null;
};
Alert.propTypes = {
    AlertIcon: PropTypes.func,
    alertPosition: PropTypes.oneOf(['over', 'right', 'under', 'left']),
    ariaRole: PropTypes.string,
    arrowPosition: PropTypes.number,
    bookmarkIconAlertDesktopLeft: PropTypes.string,
    bookmarkIconAlertDesktopTop: PropTypes.string,
    children: PropTypes.any,
    className: PropTypes.string,
    dangerousBookmarkMessage: PropTypes.string,
    dataTestId: PropTypes.string,
    gaIdentifier: PropTypes.string,
    iconName: PropTypes.string,
    iconPosition: PropTypes.oneOf(['before', 'after']),
    iconSize: PropTypes.oneOf(['thinner', 'thin', 'standard']),
    isBookmarkAlert: PropTypes.bool,
    isBookmarkIconAlert: PropTypes.bool,
    isTooltip: PropTypes.bool,
    isVisible: PropTypes.bool,
    onClose: PropTypes.func,
    shouldUseArrow: PropTypes.bool
};
module.exports = asConfiguredComponent(Alert, 'Alert');
//# sourceMappingURL=Alert.js.map

/***/ }),

/***/ 76235:
/***/ ((module) => {

const getAlertPositionForArrow = function (alertPosition) {
    switch (alertPosition) {
        case 'over':
            return `
        top: 100%;
        border-width: 8px 8px 0 8px;
        border-right-color: transparent;
        border-left-color: transparent;
      `;
        case 'right':
            return `
        right: 100%;
        border-width: 8px 8px 8px 0;
        border-top-color: transparent;
        border-bottom-color: transparent;
      `;
        case 'under':
            return `
        bottom: 100%;
        border-width: 0 8px 8px 8px;
        border-right-color: transparent;
        border-left-color: transparent;
      `;
        case 'left':
            return `
        left: 100%;
        border-width: 8px 0 8px 8px;
        border-top-color: transparent;
        border-bottom-color: transparent;
      `;
        default:
            return ``;
    }
};
const getAlertWrapperPosition = function (alertPosition) {
    switch (alertPosition) {
        case 'over':
            return `
        bottom: 100%;
      `;
        case 'right':
            return `
        left: 100%;
      `;
        case 'under':
            return `
        top: 32px;
        left: -200px;
      `;
        case 'left':
            return `
        right: 100%;
      `;
        default:
            return ``;
    }
};
module.exports = { getAlertPositionForArrow, getAlertWrapperPosition };
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 54330:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(47602);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(76955);
const Breakpoints = __webpack_require__(99906);
const { getColorStyles, getTypographyStyles, calculateSpacing, getZIndex } = __webpack_require__(26865);
const { getAlertPositionForArrow, getAlertWrapperPosition } = __webpack_require__(76235);
const { BREAKPOINTS } = __webpack_require__(96472);
const AlertArrow = styled.div.withConfig({ displayName: 'AlertArrow' }) `
  position: absolute;
  border-style: solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.brand-primary')};
  width: 0;
  height: 0;

  ${({ alertPosition, arrowPosition }) => {
    const marginDirection = alertPosition === 'over' || alertPosition === 'under' ? 'left' : 'top';
    if ( true &&
        window.innerWidth < Breakpoints.minThresholds.lg) {
        return `
        ${[marginDirection]}: calc(${arrowPosition}% - 1% - 8px);
        ${getAlertPositionForArrow(alertPosition)}
      `;
    }
    return `
      ${[marginDirection]}: calc(${arrowPosition}% - 8px);
      ${getAlertPositionForArrow(alertPosition)}
    `;
}}

  ${({ isBookmarkAlert }) => isBookmarkAlert
    ? `
    @media (max-width: ${BREAKPOINTS.lg}) and (min-width: 0) {
      display: none;
    }
  `
    : ``}
`;
const AlertIconWrapper = styled.div.withConfig({
    displayName: 'AlertIconWrapper'
}) `
  margin: 19px ${calculateSpacing(2)} 27px;

  .icon {
    transform: scale(1.72);
    ${({ theme }) => getColorStyles(theme, 'stroke', 'colors.consumption.lead.inverted.heading')};
    ${({ theme }) => getColorStyles(theme, 'fill', 'colors.consumption.lead.inverted.heading')};
  }

  ${({ isBookmarkAlert, iconSize }) => isBookmarkAlert
    ? css `
          position: relative;
          top: 0;

          .icon {
            transform: none;
            stroke: none;
            fill: none;
          }

          .icon-bookmark-fill,
          .icon-bookmark-stroke {
            ${({ theme }) => getColorStyles(theme, 'fill', 'colors.consumption.lead.inverted.heading')};
          }

          ${iconSize === 'thin'
        ? `
                display: flex;
                align-items: center;
                justify-content: center;
                margin: ${calculateSpacing(2)} ${calculateSpacing(2)};
                margin-top: ${calculateSpacing(1)}
              `
        : ``}
        `
    : ``}
`;
const AlertDangerousBookmarkMessage = styled.span.withConfig({
    displayName: 'AlertDangerousBookmarkMessage'
}) ``;
const AlertMessage = styled(BaseText).withConfig({
    displayName: 'AlertMessage'
}) `
  margin: auto;
  margin-right: ${calculateSpacing(4)};
  min-width: ${calculateSpacing(29)};
  font-synthesis: none;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.input-core')}

  @media (max-width: ${BREAKPOINTS.lg}) and (min-width: 0) {
    margin-right: ${calculateSpacing(3)};
    min-width: auto;
    max-width: ${calculateSpacing(30)};
  }

  a {
    text-decoration: none;
    color: inherit;
    font-weight: bold;

    &:hover {
      text-decoration: underline;
    }
  }

  ${({ theme, isBookmarkAlert }) => isBookmarkAlert
    ? getTypographyStyles(theme, 'typography.definitions.utility.label')
    : ``}

  ${({ theme, isBookmarkIconAlert }) => isBookmarkIconAlert
    ? `
    ${getTypographyStyles(theme, 'typography.definitions.utility.label')}
    margin: 17px 24px;
    min-width: initial;
    white-space: nowrap;
  `
    : ``}
`;
AlertMessage.defaultProps = {
    as: 'div',
    colorToken: 'colors.consumption.lead.inverted.heading',
    textAlign: 'left'
};
const AlertWrapper = styled.div.withConfig({
    displayName: 'AlertWrapper'
}) `
  display: flex;
  position: absolute;
  flex-direction: row;
  transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
  z-index: ${getZIndex('tooltip')};
  min-height: ${calculateSpacing(1)};

  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.brand-primary')};

  .close-alert-button {
    position: absolute;
    top: 1px;
    right: 2px;
    border: none;
    background-color: transparent;
    padding: 0;
    width: 30px;
    height: 30px;

    > .button__icon-container {
      height: 100%;
    }

    .icon-close {
      padding: 8px;

      g {
        ${({ theme }) => getColorStyles(theme, 'stroke', 'colors.consumption.lead.inverted.heading')};
      }
    }

    svg {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.consumption.lead.inverted.heading')};
      transform: scale(0.62);
    }

    &:focus {
      border: 0;

      > .button__icon-container {
        outline-width: 1px;
        outline-style: auto;
        ${({ theme }) => getColorStyles(theme, 'outline-color', 'colors.consumption.lead.inverted.heading')};
      }
    }

    &:active,
    &:hover {
      border: 0;
      background-color: initial;
    }
  }

  ${({ isEscaped, isVisible }) => !isVisible || isEscaped
    ? `
    visibility: hidden;
    opacity: 0;
  `
    : ''}

  ${({ alertPosition }) => getAlertWrapperPosition(alertPosition)}

  ${({ isTooltip }) => isTooltip
    ? `
    left: 0;
    height: min-content;
  `
    : ''}

  ${({ theme, isBookmarkAlert }) => isBookmarkAlert
    ? `
    ${getTypographyStyles(theme, 'typography.definitions.utility.label')}

    @media (max-width: ${BREAKPOINTS.lg}) and (min-width: 0) {
      position: fixed;
      top: 70px;
      right: 0;
      bottom: auto;
      left: 0;
      margin: 0 auto;
      width: 310px;
    }

    @media (max-width: ${BREAKPOINTS.lg - 1}) and (min-width: 0) {
      top: 235%;
      right: -67.5%;
    }
  `
    : ''}

  /* top/left positioning of the alert is based on the socialIcons component root */
  ${({ theme, isBookmarkIconAlert, bookmarkIconAlertDesktopLeft, bookmarkIconAlertDesktopTop }) => isBookmarkIconAlert &&
    `
      ${getTypographyStyles(theme, 'typography.definitions.utility.label')}
      display: none;

      @media (min-width: ${BREAKPOINTS.lg}) {
        display: block;
        top: ${bookmarkIconAlertDesktopTop};
        left: ${bookmarkIconAlertDesktopLeft};
        height: auto;
      }
  `}
`;
module.exports = {
    AlertArrow,
    AlertDangerousBookmarkMessage,
    AlertMessage,
    AlertIconWrapper,
    AlertWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 47602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const BookmarkActivatedIcon = __webpack_require__(64736);
const Alert = __webpack_require__(80060);
Alert.Bookmark = asVariation(Alert, 'Bookmark', {}, {
    AlertIcon: BookmarkActivatedIcon,
    arrowPosition: 78.5,
    isBookmarkAlert: true,
    gaIdentifier: 'bookmark-alert',
    shouldUseArrow: true
});
Alert.BookmarkIcon = asVariation(Alert, 'BookmarkIcon', {}, {
    alertPosition: 'right',
    arrowPosition: 50,
    isBookmarkIconAlert: true,
    shouldUseArrow: true
});
module.exports = Alert;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 58874:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Badge = __webpack_require__(71501);
const { AwardsWrapper } = __webpack_require__(96894);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Awards component
 *
 * @param {object} props - React props
 * @param {Array} props.awards - array of awards
 * @param {string} [props.className] - Optional top-level class to add
 * @param {boolean} [props.hasStaticPositionedAward] - Optional - adjusts heights of 'awards' class to work with static positioned badges
 * @returns {ReactElement} <div>
 */
const Awards = ({ awards, className, hasStaticPositionedAward = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Awards'
        });
    }, []);
    if (!Array.isArray(awards) || awards.length === 0)
        return null;
    const badges = awards.map((award) => award && (React.createElement(Badge, { hasStaticPositionedAward: hasStaticPositionedAward, award: award, key: `${award.name}${award.date}` })));
    return (React.createElement(AwardsWrapper, { hasStaticPositionedAward: hasStaticPositionedAward, className: className, "data-testid": "AwardsWrapper" }, badges));
};
Awards.propTypes = {
    awards: PropTypes.array.isRequired,
    className: PropTypes.string,
    hasStaticPositionedAward: PropTypes.bool
};
Awards.displayName = 'Awards';
module.exports = Awards;
//# sourceMappingURL=Awards.js.map

/***/ }),

/***/ 866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const Awards = __webpack_require__(58874);
module.exports = asConfiguredComponent(Awards, 'Awards');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 96894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BadgeWrapper } = __webpack_require__(34447);
const { calculateSpacing } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const AwardsWrapper = styled.div.withConfig({
    displayName: 'AwardsWrapper'
}) `
  width: 100%;
  height: 100%;

  ${BadgeWrapper} {
    display: inline-block;
    padding-left: ${calculateSpacing(1)};
    height: 100%;

    &:first-child {
      padding-left: 0;
    }
  }

  ${({ hasStaticPositionedAward }) => hasStaticPositionedAward
    ? `
    display: flex;
    flex-wrap: wrap;
    justify-content: space-evenly;
    margin: ${calculateSpacing(4)} 0 ${calculateSpacing(4)};
    height: auto;

    @media (min-width: ${BREAKPOINTS.md}) {
      flex-wrap: wrap;
      justify-content: center;
    }

    ${BadgeWrapper} {
      padding: 0 0 0 ${calculateSpacing(1)};

      &:nth-child(3),
      &:nth-child(4) {
        padding-bottom: 0;
      }

      @media (min-width: ${BREAKPOINTS.md}) {
        padding: 0 0 0 ${calculateSpacing(2)};

        &:first-child {
          padding-left: 0;
        }
      }
    }
  `
    : ``}
`;
module.exports = {
    AwardsWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 38248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const Byline = __webpack_require__(77813);
const translations = (__webpack_require__(46698)/* ["default"] */ .A);
const { BylinesWrapper } = __webpack_require__(15384);
const { TrackComponentChannel } = __webpack_require__(78788);
const { getVariationNames } = __webpack_require__(81372);
const CONTRIBUTOR_ORDER = [
    'author',
    'cover shoot',
    'writer',
    'as told to',
    'director',
    'photographer',
    'producer',
    'illustrator',
    'artist',
    'reporter',
    'stylist',
    'hair',
    'makeup',
    'nails',
    'editor',
    'reviewer',
    'animator',
    'artwork',
    'developer',
    'introducer',
    'with',
    'podcast host',
    'toldby',
    'medical reviewer',
    'film by',
    'video by',
    'text by',
    'introduction',
    'in conversation',
    'additional reporting',
    'adaptation by',
    'video director'
];
const PREAMBLES = {
    'cover shoot': translations.coverShootPreamble,
    'adaptation by': translations.adaptationEditorPreamble,
    'additional reporting': translations.additionalReportingPreamble,
    'as told to': translations.astoldtoPreamble,
    animator: translations.animatorPreamble,
    artwork: translations.artworkPreamble,
    author: translations.authorPreamble,
    developer: translations.developerPreamble,
    director: translations.directorPreamble,
    editor: translations.editorPreamble,
    'film by': translations.filmByPreamble,
    hair: translations.hairPreamble,
    illustrator: translations.illustratorPreamble,
    artist: translations.artistPreamble,
    introducer: translations.introducerPreamble,
    makeup: translations.makeupPreamble,
    'medical reviewer': translations.medicalReviewerPreamble,
    nails: translations.nailsPreamble,
    photographer: translations.photographerPreamble,
    'podcast host': translations.podcasthostPreamble,
    producer: translations.producerPreamble,
    reporter: translations.reporterPreamble,
    reviewer: translations.reviewerPreamble,
    stylist: translations.stylistPreamble,
    toldby: translations.toldbyPreamble,
    'video by': translations.videoByPreamble,
    with: translations.withPreamble,
    writer: translations.writer,
    'text by': translations.textByPreamble,
    introduction: translations.introductionPreamble,
    'in conversation': translations.inconversationPreamble,
    'video director': translations.videoDirectorPreamble
};
/**
 * @param {object} sortedContributorList - Sorted contributor data
 *
 * Function returns the total count of contributors
 */
const contributorItemsLength = (sortedContributorList) => {
    let itemsLength = 0;
    sortedContributorList.forEach((contributor) => {
        itemsLength += contributor?.items ? contributor.items.length : 0;
    });
    return itemsLength;
};
/**
 * normalizeContributors normalizes contributor information into an iterable array
 *
 * @param {object} contributors - Contributor data
 * @param {boolean} [hideAdaptationByline] - Optional parameter to hide adaptation by author's by line.
 * @param {number} [maxContributors] - Maximum number of contributor types to show
 * @param {number} [maxContributorsNames] - Maximum number of contributor names to show
 *
 * @returns {Array} an array of normalized contributors
 */
function normalizeContributors(contributors, maxContributors, maxContributorsNames, hideAdaptationByline) {
    if (!contributors || typeof contributors !== 'object') {
        return [];
    }
    // sort each valid contributor to the same order as CONTRIBUTOR_ORDER
    const sortedContributorList = [];
    CONTRIBUTOR_ORDER.forEach((type) => {
        if (!contributors[type]) {
            return;
        }
        if (hideAdaptationByline && type === 'adaptation by') {
            return;
        }
        sortedContributorList.push({
            type,
            ...contributors[type]
        });
    });
    if (maxContributorsNames &&
        contributorItemsLength(sortedContributorList) > maxContributorsNames) {
        const itemlist = [];
        const combinedList = [];
        sortedContributorList.forEach((contributor) => {
            itemlist.push(...contributor.items);
        });
        combinedList.push({
            items: itemlist
        });
        return combinedList;
    }
    return sortedContributorList.slice(0, maxContributors);
}
/**
 * Bylines component
 *
 * @param {object}     props - React props
 * @param {string}    [props.bylineVariation] - Variation of byline
 * @param {string}    [props.className] - Optional top-level class to add
 * @param {Function}  [props.clickHandler] - called when user clicks on link
 * @param {string}    [props.contentAlign] - Optional alignment of content
 * @param {object}    [props.contributors] - Contributors (authors, photographers, etc.)
 * @param {boolean}   [props.hideAdaptationByline] - Optional parameter to hide adaptation by author's by line.
 * @param {boolean}   [props.isCompact] - Remove spacing between contributors
 * @param {number}    [props.maxContributors] - Maximum number of contributor types to show
 * @param {number}    [props.maxContributorsNames] - Optional maximum number of contributors names to be displayed
 * @param {object}    [props.preambles] - optional contributors preambles
 * @param {boolean}   [props.shouldLink] - Tells whether to link contributor names and handles. Defaults to true.
 * @param {boolean} [props.shouldUseCustomPreambles] - Optional to use custom preambles
 * @param {boolean}   [props.showCommaAsideContributorName] - optional flag to override exisitng comma(,) with custom logic to fix visual bug with long author name. see #8939 for details - defaults to false
 *
 * @returns {ReactElement} <div>
 */
const Bylines = ({ bylineVariation = 'Item', className, clickHandler, contentAlign = 'center', contributors, hideAdaptationByline = false, isCompact = true, maxContributors = Infinity, maxContributorsNames, preambles, shouldUseCustomPreambles = false, shouldLink = true, showCommaAsideContributorName = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Bylines'
        });
    }, []);
    const intl = useIntl();
    const hasBylineBackground = bylineVariation === 'Card';
    const hasBylineBackgroundClass = hasBylineBackground
        ? 'bylines--inlined-with-bg'
        : false;
    const BylineConfigured = Byline[bylineVariation];
    const contributorsToRender = normalizeContributors(contributors, maxContributors, maxContributorsNames, hideAdaptationByline);
    return (React.createElement(BylinesWrapper, { "data-testid": "BylinesWrapper", className: classnames('bylines', hasBylineBackgroundClass, className), contentAlign: contentAlign }, contributorsToRender.map((contributor, index) => {
        const { type } = contributor;
        let { preamble } = contributor;
        if (shouldUseCustomPreambles && preambles)
            preamble = preambles[type];
        if (!preamble) {
            const preambleTypeKey = PREAMBLES[type];
            preamble = preambleTypeKey && intl.formatMessage(preambleTypeKey);
        }
        return (React.createElement(BylineConfigured, { ...contributor, className: "bylines__byline", clickHandler: clickHandler, contentAlign: contentAlign, isCompact: isCompact, key: `${index}_${type}`, maxContributorsNames: maxContributorsNames, preamble: preamble, shouldLink: shouldLink, showCommaAsideContributorName: showCommaAsideContributorName }));
    })));
};
Bylines.propTypes = {
    bylineVariation: PropTypes.oneOf(getVariationNames(Byline)),
    className: PropTypes.string,
    clickHandler: PropTypes.func,
    contentAlign: PropTypes.oneOf(['left', 'right', 'center']),
    contributors: PropTypes.shape({
        author: PropTypes.shape(Byline.propTypes),
        illustrator: PropTypes.shape(Byline.propTypes),
        photographer: PropTypes.shape(Byline.propTypes)
    }).isRequired,
    hideAdaptationByline: PropTypes.bool,
    isCompact: PropTypes.bool,
    maxContributors: PropTypes.number,
    maxContributorsNames: PropTypes.number,
    preambles: PropTypes.string,
    shouldLink: PropTypes.bool,
    shouldUseCustomPreambles: PropTypes.bool,
    showCommaAsideContributorName: PropTypes.bool
};
module.exports = Bylines;
//# sourceMappingURL=Bylines.js.map

/***/ }),

/***/ 52540:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(38248);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 15384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { calculateSpacing } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const BylinesWrapper = styled.div.withConfig({
    displayName: 'BylinesWrapper'
}) `
  @media (max-width: ${BREAKPOINTS.md}) {
    text-align: ${({ contentAlign }) => contentAlign};
    line-height: ${calculateSpacing(1)};
  }
`;
module.exports = {
    BylinesWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 46698:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    artistPreamble: {
        id: 'Bylines.ArtistPreamble',
        defaultMessage: 'Art by',
        description: 'Bylines component artist preamble'
    },
    additionalReportingPreamble: {
        id: 'Bylines.additionalReportingPreamble',
        defaultMessage: 'Additional Reporting by',
        description: 'Bylines component additional reporting preamble'
    },
    authorPreamble: {
        id: 'Bylines.AuthorPreamble',
        defaultMessage: 'By',
        description: 'Bylines component author preamble'
    },
    animatorPreamble: {
        id: 'Bylines.AnimatorPreamble',
        defaultMessage: 'Animation by',
        description: 'Bylines component animator preamble'
    },
    artworkPreamble: {
        id: 'Bylines.ArtworkPreamble',
        defaultMessage: 'Artwork by',
        description: 'Bylines component artwork preamble'
    },
    astoldtoPreamble: {
        id: 'Bylines.AstoldtoPreamble',
        defaultMessage: 'As told to',
        description: 'Bylines component astoldto preamble'
    },
    developerPreamble: {
        id: 'Bylines.DeveloperPreamble',
        defaultMessage: 'Development by',
        description: 'Bylines component developer preamble'
    },
    directorPreamble: {
        id: 'Bylines.DirectorPreamble',
        defaultMessage: 'Directed by',
        description: 'Bylines component director preamble'
    },
    editorPreamble: {
        id: 'Bylines.EditorPreamble',
        defaultMessage: 'Edited by',
        description: 'Bylines component editor preamble'
    },
    filmByPreamble: {
        id: 'Bylines.FilmByPreamble',
        defaultMessage: 'Film by',
        description: 'Bylines component film by preamble'
    },
    hairPreamble: {
        id: 'Bylines.HairPreamble',
        defaultMessage: 'Hair by',
        description: 'Bylines component hair preamble'
    },
    illustratorPreamble: {
        id: 'Bylines.IllustratorPreamble',
        defaultMessage: 'Illustration by',
        description: 'Bylines component illustrator preamble'
    },
    introductionPreamble: {
        id: 'Bylines.introductionPreamble',
        defaultMessage: 'Introduction by',
        description: 'Bylines component introduction preamble'
    },
    inconversationPreamble: {
        id: 'Bylines.inconversationPreamble',
        defaultMessage: 'In Conversation with',
        description: 'Bylines component in conversation preamble'
    },
    introducerPreamble: {
        id: 'Bylines.IntroducerPreamble',
        defaultMessage: 'Introduced by',
        description: 'Bylines component introducer preamble'
    },
    makeupPreamble: {
        id: 'Bylines.MakeupPreamble',
        defaultMessage: 'Makeup by',
        description: 'Bylines component makeup preamble'
    },
    medicalReviewerPreamble: {
        id: 'Bylines.MedicalReviewerPreamble',
        defaultMessage: 'Medically reviewed by',
        description: 'Bylines component medical reviewer preamble'
    },
    nailsPreamble: {
        id: 'Bylines.NailsPreamble',
        defaultMessage: 'Nails by',
        description: 'Bylines component nails preamble'
    },
    photographerPreamble: {
        id: 'Bylines.PhotographerPreamble',
        defaultMessage: 'Photography by',
        description: 'Bylines component photographer preamble'
    },
    podcasthostPreamble: {
        id: 'Bylines.PodcasthostPreamble',
        defaultMessage: 'With',
        description: 'Bylines component podcasthost preamble'
    },
    producerPreamble: {
        id: 'Bylines.ProducerPreamble',
        defaultMessage: 'Produced by',
        description: 'Bylines component producer preamble'
    },
    reporterPreamble: {
        id: 'Bylines.ReporterPreamble',
        defaultMessage: 'Reporting by',
        description: 'Bylines component reporter preamble'
    },
    reviewerPreamble: {
        id: 'Bylines.ReviewerPreamble',
        defaultMessage: 'Reviewed by',
        description: 'Bylines component reviewer preamble'
    },
    stylistPreamble: {
        id: 'Bylines.StylistPreamble',
        defaultMessage: 'Styled by',
        description: 'Bylines component stylist preamble'
    },
    textByPreamble: {
        id: 'Bylines.TextByPreamble',
        defaultMessage: 'Text by',
        description: 'Bylines component text by preamble'
    },
    toldbyPreamble: {
        id: 'Bylines.ToldbyPreamble',
        defaultMessage: 'As told by',
        description: 'Bylines component toldby preamble'
    },
    videoByPreamble: {
        id: 'Bylines.VideoByPreamble',
        defaultMessage: 'Video by',
        description: 'Bylines component video by preamble'
    },
    withPreamble: {
        id: 'Bylines.WithPreamble',
        defaultMessage: 'With',
        description: 'Bylines component with preamble'
    },
    writer: {
        id: 'Bylines.Writer',
        defaultMessage: 'Written by',
        description: 'Bylines component writer preamble'
    },
    adaptationEditorPreamble: {
        id: 'Bylines.AdaptationEditorPreamble',
        defaultMessage: 'Translated and Adapted by',
        description: 'Bylines component adaptation preamble'
    },
    coverShootPreamble: {
        id: 'Bylines.CoverShootPreamble',
        defaultMessage: 'Cover Shoot by',
        description: 'Bylines component cover shoot preamble'
    },
    videoDirectorPreamble: {
        id: 'Bylines.VideoDirectorPreamble',
        defaultMessage: 'Video Directed  by',
        description: 'Bylines component video director preamble'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 48318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const get = __webpack_require__(58156);
const throttle = __webpack_require__(7350);
const { useInView } = __webpack_require__(26855);
const debounce = __webpack_require__(38221);
const findLastIndex = __webpack_require__(94469);
const { buildThresholdArray } = __webpack_require__(26695);
const { componentTracking } = __webpack_require__(90090);
const { isScrollAtEnd, isScrollAtStart } = __webpack_require__(30271);
const { CarouselWrapper, CarouselList, CarouselListAnimations, CurrentSlideIndicatorWrapper, CurrentSlideIndicator, CarouselSectionTitle, CarouselCaption, CarouselHeaderDivider, CarouselListSwipe } = __webpack_require__(44802);
const CarouselHeader = __webpack_require__(22892);
const CarouselBody = __webpack_require__(99726);
const CarouselFooter = __webpack_require__(87797);
const CarouselItem = __webpack_require__(52641);
const { TrackComponentChannel } = __webpack_require__(78788);
const { interactionResponse } = __webpack_require__(56187);
const { productImpressionTracking } = __webpack_require__(60162);
const { trackNavigationEvent } = __webpack_require__(14307);
const SummaryDek = __webpack_require__(49989);
const SectionTitle = __webpack_require__(35864);
const { storageFactory } = __webpack_require__(60663);
const localStore = storageFactory(() => window.localStorage);
const sessionStore = storageFactory(() => window.sessionStorage);
// eslint-disable-next-line complexity
const Carousel = ({ carouselControlTheme = '', controlButtonIcon = 'ChevronIcon', children, className, dangerousHed, hasCarouselSectionTitle = false, hasControls = true, hasCustomSlider = false, hasCustomTypeToken = false, hasDecreasedSectionTitleMargin = false, hasDividerAboveCarouselSectionTitle = true, hasDividerBelowCarouselSectionTitle = true, hasDividerBelowHeader = false, hasFullBleedChevrons = false, hasImageCenteredButton = true, snowplowNavEventSubject, hasIncreasedMargin = false, hasExactlyOneImageInViewAtOnce = false, hasMobileControls = true, contentAlign = 'left', hasFlexibleControlPosition = true, hasCarouselDekMarginBottom, hasHeaderBorderTop = false, hasIncreasedFooterMargin = false, hasImpressionTracking = false, hasIncreasedPadding = false, hasModerateSpacing = false, hasModerateSpacingOnCarousel = false, hasNavigationButtonVariation, hasNoHorizontalScrollCarousel = false, hasPadding, hasPagination = false, hasThinBorder = false, hasHeaderBorder, hideDesktopPagination = false, hideStrapline = false, hideHeaderBorder, pos, strapline, scrollBehavior = 'smooth', title, controlPlacement = 'right', controlPosition = 'top', onBackClick, onScroll, onForwardClick, paginationStyle = 'bullet', isDotClickable = false, shouldAlignCenterIfContentIsLess = false, shouldEnableBundleComponentAnalytics, shouldEnableRecircTracking = false, shouldEnableScrollToStart = true, shouldHideCarouselFooter = false, shouldHideControlsOnDisable = false, shouldHideMarginOnCarousel = false, showPhotoCredit = false, shouldShowCarouselItemsViewed = false, trackingNamespace, isPlpCurated, isUpcEnabled = false, isSeriesNavigation, hasSwipeCarouseList, hasCircularScrolling = false, gtmTrackOnClick, hasUPCMultipleImages = false, videoDotIndexes = [], upcId, sectionTitleVariation = 'TextCenter' }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Carousel'
        });
    }, []);
    const [isScrollStart, setIsScrollStart] = React.useState(true);
    const [isScrollEnd, setIsScrollEnd] = React.useState(true);
    const [overriddenPlacement, setPlacement] = React.useState(controlPlacement);
    const [overriddenPosition, setPosition] = React.useState(controlPosition);
    const [listWidth, setListWidth] = React.useState(0);
    const [scrollWidth, setScrollWidth] = React.useState(0);
    const [listScrollLeft, setListScrollLeft] = React.useState(1);
    const [isBrowserScrollbarPresent, setIsBrowserScrollbarPresent] = React.useState(false);
    const [photoCredit, setPhotoCredit] = React.useState('');
    const [slideIndicatorWidth, setSlideIndicatorWidth] = React.useState(0);
    const [slideIndicatorPosition, setSlideIndicatorPosition] = React.useState(0);
    const [sliderMargins, setSliderMargins] = React.useState(0);
    // Scroll state handling
    const listRef = React.useRef(null);
    const childRefs = [];
    const [dotCount, updateDotCount] = React.useState(0);
    const [totalForwardCount, setForwardTotalCount] = React.useState(0);
    const [totalBackCount, setBackTotalCount] = React.useState(0);
    const [touchStartX, setTouchStartX] = React.useState(null);
    const [touchEndX, setTouchEndX] = React.useState(null);
    const [touchStartY, setTouchStartY] = React.useState(null);
    const [touchEndY, setTouchEndY] = React.useState(null);
    const [isScrolling, setIsScrolling] = React.useState(false);
    const isBubblesLayout = className?.includes('visualStoryLayout');
    const createCarouselName = () => dangerousHed?.replace(/[^a-zA-Z]+/gi, '-').toLowerCase() || '';
    const carouselName = createCarouselName();
    const totalChildren = React.Children.count(children);
    let isSwiped = false;
    const updateScrollState = () => {
        const listEl = listRef?.current;
        const listScrollLeft = listEl?.scrollLeft;
        const onScroll = () => {
            if (hasPagination &&
                paginationStyle === 'slider' &&
                hasCustomSlider &&
                listEl) {
                const scrollBarWidth = listEl.scrollWidth - listEl.offsetWidth;
                const sliderElScrollWidth = listEl.clientWidth - sliderMargins;
                const scrollBarThumbWidth = sliderElScrollWidth / listEl.children.length;
                let scrollBarPosition = Math.max((sliderElScrollWidth * listScrollLeft) / scrollBarWidth -
                    scrollBarThumbWidth, 0);
                if (hasExactlyOneImageInViewAtOnce) {
                    scrollBarPosition = Math.max(listScrollLeft / listEl.children.length, 0);
                }
                setSlideIndicatorWidth(scrollBarThumbWidth);
                setSlideIndicatorPosition(scrollBarPosition);
            }
        };
        if (listEl) {
            setIsScrollStart(isScrollAtStart(listEl, hasCircularScrolling));
            setIsScrollEnd(isScrollAtEnd(listEl, hasCircularScrolling));
            setListScrollLeft(listScrollLeft);
            onScroll();
        }
        setTimeout(() => {
            hasImpressionTracking &&
                productImpressionTracking('ContentCarousel', document.getElementsByClassName(`impressionTracking ${carouselName}`), carouselName);
        }, 1000);
    };
    React.useEffect(updateScrollState, [
        listRef,
        hasPagination,
        paginationStyle,
        hasCustomSlider,
        sliderMargins,
        hasExactlyOneImageInViewAtOnce,
        hasImpressionTracking,
        children,
        carouselName,
        hasCircularScrolling
    ]);
    // ADA zoom requirements
    const updateZoomOverwrites = () => {
        if (!hasControls || !hasFlexibleControlPosition) {
            return undefined;
        }
        const onResize = () => {
            const zoom = (window.outerWidth / window.innerWidth) * 100;
            setPlacement(zoom >= 300 ? 'space-between' : controlPlacement);
            setPosition(zoom >= 300 ? 'center' : controlPosition);
        };
        const debouncedResize = debounce(onResize, 300);
        window.addEventListener('resize', debouncedResize);
        onResize();
        return () => {
            window.removeEventListener('resize', debouncedResize);
        };
    };
    React.useEffect(updateZoomOverwrites, [
        hasFlexibleControlPosition,
        hasControls,
        controlPlacement,
        controlPosition
    ]);
    const ScrollRound = (scrollvalue) => {
        if (scrollvalue % 1 < 0.5) {
            return Math.trunc(scrollvalue);
        }
        return Math.ceil(scrollvalue);
    };
    // Dot counting
    const dotLength = React.useMemo(() => {
        const listEl = listRef?.current;
        if (hasPagination && paginationStyle === 'bullet' && listEl) {
            if (listWidth === scrollWidth)
                return 0;
            return ScrollRound(scrollWidth / listWidth);
        }
        return 0;
    }, [listWidth, paginationStyle, hasPagination, scrollWidth]);
    const selectedDotIndex = React.useMemo(() => {
        const listEl = listRef?.current;
        if (hasPagination && listEl) {
            if (hasCircularScrolling) {
                return dotCount;
            }
            if (isScrollEnd) {
                return dotLength - 1;
            }
            return ScrollRound(listScrollLeft / listWidth);
        }
        return 0;
    }, [
        hasPagination,
        isScrollEnd,
        listRef,
        dotLength,
        listWidth,
        listScrollLeft,
        dotCount,
        hasCircularScrolling
    ]);
    // set credit for photo on scroll state
    React.useEffect(() => {
        const hasCredit = get(children[selectedDotIndex], 'props.children.props.credit', '');
        if (hasCredit)
            setPhotoCredit(children[selectedDotIndex].props.children.props.credit);
    }, [selectedDotIndex, children]);
    // Move scroll bar to the start
    React.useEffect(() => {
        const listEl = listRef?.current;
        if (listEl && listEl?.scrollTo && shouldEnableScrollToStart) {
            listEl.scrollTo(0, 0);
        }
    }, [children, shouldEnableScrollToStart]);
    const [hasBeenSeen, setHasBeenSeen] = React.useState(false);
    const [recircHasBeenSeen, setRecircHasBeenSeen] = React.useState(false);
    const [plcHasBeenSeen, setPlcHasBeenSeen] = React.useState(false);
    const [setNode, , entry] = useInView({
        threshold: buildThresholdArray(),
        triggerOnce: true
    });
    const getHedValues = (listEl) => {
        const hedArr = localStore.getItem('hedArr')
            ? localStore.getItem('hedArr').split(',')
            : [];
        if (hedArr.length === 0) {
            for (let i = 0; i <= (listEl?.children?.length ?? 0) - 1; i++)
                hedArr.push(listEl?.children[i].querySelector('.summary-item__hed')?.innerText);
        }
        return hedArr;
    };
    const isSliderVisible = hasPagination && paginationStyle === 'slider';
    const clonedChildren = React.Children.map(children, (child, index) => {
        const ref = React.createRef();
        childRefs[index] = ref;
        return React.cloneElement(child, {
            ref,
            hasSlider: isPlpCurated ? false : isSliderVisible,
            isFirstItem: index === 0,
            isLastItem: index === totalChildren - 1,
            key: `carousel-item-${index}`,
            totalItems: totalChildren,
            carouselTitle: dangerousHed,
            isBubblesLayout
        });
    });
    const carouselItemsList = React.useMemo(() => {
        const carouselItemNames = [];
        clonedChildren?.map((item) => {
            return carouselItemNames.push(item.props.carouselItemName);
        });
        return carouselItemNames;
    }, [clonedChildren]);
    React.useEffect(() => {
        const computeProfilesSeenOnScroll = (title, dangerousHed, strapline, pos) => {
            const impressionObj = {
                event: 'carousel-impression',
                'carousel-name': title || dangerousHed || strapline,
                'carousel-position': pos
            };
            if (shouldShowCarouselItemsViewed) {
                const listEl = listRef?.current;
                const hedArr = getHedValues(listEl);
                const itemWidth = get(listEl?.children[0], 'clientWidth', 0);
                const maxItemsPerView = Math.floor(listWidth / itemWidth);
                let position = pos - 1;
                let carouselItemsArr = [];
                for (let i = 1; i <= maxItemsPerView && position <= listEl.children.length; i++) {
                    carouselItemsArr.push(`${hedArr[position]}`);
                    position++;
                }
                carouselItemsArr = carouselItemsArr.join('|');
                if (carouselItemsArr) {
                    impressionObj['carousel-items'] = carouselItemsArr;
                }
            }
            return impressionObj;
        };
        if (entry && entry.intersectionRatio) {
            if (shouldEnableRecircTracking &&
                !recircHasBeenSeen &&
                entry.isIntersecting) {
                setRecircHasBeenSeen(true);
                if ( true && window.dataLayer) {
                    window.dataLayer.push({
                        event: 'recirc',
                        eventCategory: 'recirc',
                        eventAction: 'recirc-see-related-recipes-impression',
                        eventLabel: ``
                    });
                }
            }
            if (!hasBeenSeen && entry.intersectionRatio > 0.95) {
                setHasBeenSeen(true);
                if ( true && window.dataLayer && pos) {
                    window.dataLayer.push(computeProfilesSeenOnScroll(title, dangerousHed, strapline, pos));
                }
            }
            if (hasImpressionTracking &&
                !plcHasBeenSeen &&
                entry.intersectionRatio > 0.5) {
                setPlcHasBeenSeen(true);
                if ( true && window.dataLayer) {
                    setTimeout(() => {
                        productImpressionTracking('ContentCarousel', document.getElementsByClassName(`impressionTracking ${carouselName}`), carouselName);
                    }, 1000);
                }
            }
        }
    }, [
        listWidth,
        entry,
        hasBeenSeen,
        dangerousHed,
        recircHasBeenSeen,
        title,
        shouldEnableRecircTracking,
        strapline,
        totalChildren,
        snowplowNavEventSubject,
        pos,
        plcHasBeenSeen,
        hasImpressionTracking,
        carouselName,
        shouldShowCarouselItemsViewed,
        carouselItemsList
    ]);
    React.useEffect(() => {
        const listEl = listRef?.current;
        const onResize = (e) => {
            e && listEl.offsetWidth === 0 && e.stopPropogation();
            if (listEl) {
                setListWidth(listEl.offsetWidth);
                setScrollWidth(listEl.scrollWidth);
                if (listEl.scrollWidth > listEl.clientWidth) {
                    setIsBrowserScrollbarPresent(true);
                    const isCustomSliderVisible = hasPagination && paginationStyle === 'slider' && hasCustomSlider;
                    if (isCustomSliderVisible) {
                        const sliderEl = listEl.nextElementSibling;
                        let customSliderMargins = 0;
                        if (sliderEl &&
                            sliderEl.classList?.contains('carousel_slider-wrapper')) {
                            const sliderMarginLeft = parseFloat(getComputedStyle(sliderEl)?.marginLeft) || 0;
                            const sliderMarginRight = parseFloat(getComputedStyle(sliderEl)?.marginRight) || 0;
                            customSliderMargins = sliderMarginLeft + sliderMarginRight;
                            sliderMargins !== customSliderMargins &&
                                setSliderMargins(customSliderMargins);
                        }
                    }
                }
                else {
                    setIsBrowserScrollbarPresent(false);
                    setIsScrollEnd(true);
                }
            }
        };
        const onDebounceResize = debounce(onResize, 200);
        if (hasPagination) {
            onResize();
            window.addEventListener('resize', onDebounceResize);
        }
        return () => {
            if (hasPagination)
                window.removeEventListener('resize', onDebounceResize);
        };
    }, [
        hasPagination,
        paginationStyle,
        hasCustomSlider,
        isBrowserScrollbarPresent,
        sliderMargins,
        listRef,
        totalChildren
    ]);
    /* if bubbles carousel set sessionStorage value with current URL when user click on a bubble */
    React.useEffect(() => {
        if (isBubblesLayout) {
            const listEl = listRef?.current;
            const elements = listEl.querySelectorAll('a');
            elements.forEach((link) => {
                link.addEventListener('click', () => {
                    const currentUrl = window.location.href;
                    sessionStore.setItem('visual_story_origin', currentUrl);
                });
            });
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    const isControlTop = hasControls && overriddenPosition === 'top';
    const isControlCenter = isBubblesLayout && !isBrowserScrollbarPresent
        ? false
        : hasControls && overriddenPosition === 'center';
    const isControlBottom = hasControls && overriddenPosition === 'bottom';
    const handleBackScroll = () => {
        return new Promise((resolve) => {
            const listEl = listRef?.current;
            if (!listEl) {
                resolve();
                return;
            }
            const itemWidth = listEl.firstElementChild?.getBoundingClientRect().width ||
                listEl.offsetWidth;
            const newScrollLeft = Math.floor(listEl.scrollLeft - itemWidth);
            if (dotCount === 0) {
                const lastItem = listEl.lastElementChild;
                if (lastItem) {
                    lastItem.classList.remove('carousel-last-item-post-animation', 'carousel-last-item-pre-animation');
                    if (window.navigator.userAgent.includes('Chrome')) {
                        lastItem.classList.add('carousel-last-item-pre-animation');
                    }
                    listEl.scrollTo({
                        left: listEl.scrollWidth - listEl.offsetWidth,
                        behavior: 'auto'
                    });
                    requestAnimationFrame(() => {
                        lastItem.classList.remove('carousel-last-item-pre-animation');
                        lastItem.classList.add('carousel-last-item-post-animation');
                        let onTransitionEnd;
                        const transitionTimeout = setTimeout(() => {
                            lastItem.removeEventListener('transitionend', onTransitionEnd);
                            resolve();
                        }, 500);
                        onTransitionEnd = () => {
                            clearTimeout(transitionTimeout);
                            lastItem.classList.remove('carousel-last-item-post-animation');
                            lastItem.removeEventListener('transitionend', onTransitionEnd);
                            resolve();
                        };
                        lastItem.addEventListener('transitionend', onTransitionEnd);
                    });
                }
                else {
                    resolve();
                }
            }
            else {
                requestAnimationFrame(() => {
                    listEl.scrollTo({
                        left: newScrollLeft,
                        behavior: 'smooth'
                    });
                    const onScrollEnd = () => {
                        clearTimeout(listEl._scrollTimeout);
                        listEl._scrollTimeout = setTimeout(() => {
                            resolve();
                            listEl.removeEventListener('scroll', onScrollEnd);
                        }, 100);
                    };
                    listEl.addEventListener('scroll', onScrollEnd);
                });
            }
        });
    };
    const onBackHandler = async (event) => {
        if (isScrolling)
            return;
        setIsScrolling(true);
        const image_index = dotCount < 1 ? dotLength - 1 : dotCount - 1;
        const listEl = listRef?.current;
        if (!listEl || isScrollStart)
            return;
        if (hasCircularScrolling) {
            await handleBackScroll();
            updateDotCount((prevDotCount) => prevDotCount > 0 ? prevDotCount - 1 : dotLength - 1);
            setIsScrolling(false);
        }
        else {
            const newScrollLeft = listEl.scrollLeft - listEl.offsetWidth;
            if (listEl.scrollLeft <= 0) {
                const lastItem = listEl.lastElementChild;
                if (lastItem) {
                    lastItem.classList.remove('carousel-last-item-post-animation', 'carousel-last-item-pre-animation');
                    if (window.navigator.userAgent.indexOf('Chrome') !== -1) {
                        lastItem.classList.add('carousel-last-item-pre-animation');
                    }
                    listEl.scrollTo({
                        left: listEl.scrollWidth - listEl.offsetWidth,
                        behavior: 'auto'
                    });
                    requestAnimationFrame(() => {
                        lastItem.classList.remove('carousel-last-item-pre-animation');
                        lastItem.classList.add('carousel-last-item-post-animation');
                        const onTransitionEnd = () => {
                            lastItem.classList.remove('carousel-last-item-post-animation');
                            lastItem.removeEventListener('transitionend', onTransitionEnd);
                        };
                        lastItem.addEventListener('transitionend', onTransitionEnd);
                    });
                }
            }
            else {
                listEl.scrollTo({ left: newScrollLeft, behavior: scrollBehavior });
            }
            const onScrollEnd = () => {
                clearTimeout(listEl._scrollTimeout);
                listEl._scrollTimeout = setTimeout(() => {
                    setIsScrolling(false);
                    listEl.removeEventListener('scroll', onScrollEnd);
                }, 100);
            };
            // Cross-browser scroll-end detection (scrollend || scroll + timeout)
            if ('onscrollend' in document.documentElement) {
                listEl.addEventListener('scrollend', () => setIsScrolling(false), {
                    once: true
                });
            }
            else {
                listEl.addEventListener('scroll', onScrollEnd);
            }
        }
        if (!event?.isCNEVideoEvent) {
            await interactionResponse();
            gtmTrackOnClick(event, null, image_index, 'back');
        }
    };
    const handleForwardScroll = () => {
        return new Promise((resolve) => {
            const listEl = listRef?.current;
            if (!listEl) {
                resolve();
                return;
            }
            const itemWidth = listEl.firstElementChild?.getBoundingClientRect().width ||
                listEl.offsetWidth;
            const newScrollLeft = Math.ceil(listEl.scrollLeft + itemWidth);
            if (dotCount === dotLength - 1) {
                const firstItem = listEl.firstElementChild;
                if (firstItem) {
                    firstItem.classList.remove('carousel-first-item-post-animation', 'carousel-first-item-pre-animation');
                    if (window.navigator.userAgent.includes('Chrome')) {
                        firstItem.classList.add('carousel-first-item-pre-animation');
                    }
                    listEl.scrollTo({ left: 0, behavior: 'auto' });
                    requestAnimationFrame(() => {
                        firstItem.classList.remove('carousel-first-item-pre-animation');
                        firstItem.classList.add('carousel-first-item-post-animation');
                        let onTransitionEnd;
                        const transitionTimeout = setTimeout(() => {
                            firstItem.removeEventListener('transitionend', onTransitionEnd);
                            resolve();
                        }, 500);
                        onTransitionEnd = () => {
                            clearTimeout(transitionTimeout);
                            firstItem.classList.remove('carousel-first-item-post-animation');
                            firstItem.removeEventListener('transitionend', onTransitionEnd);
                            resolve();
                        };
                        firstItem.addEventListener('transitionend', onTransitionEnd);
                        firstItem.addEventListener('transitionend', onTransitionEnd);
                    });
                }
                else {
                    resolve();
                }
            }
            else {
                requestAnimationFrame(() => {
                    listEl.scrollTo({
                        left: newScrollLeft,
                        behavior: 'smooth'
                    });
                    const onScrollEnd = () => {
                        clearTimeout(listEl._scrollTimeout);
                        listEl._scrollTimeout = setTimeout(() => {
                            resolve();
                            listEl.removeEventListener('scroll', onScrollEnd);
                        }, 100);
                    };
                    listEl.addEventListener('scroll', onScrollEnd);
                });
            }
        });
    };
    const onForwardHandler = async (event) => {
        if (isScrolling)
            return;
        setIsScrolling(true);
        const image_index = dotCount > dotLength - 2 ? 0 : dotCount + 1;
        const listEl = listRef?.current;
        if (!listEl || isScrollEnd)
            return;
        if (hasCircularScrolling) {
            await handleForwardScroll();
            updateDotCount((prevDotCount) => (prevDotCount + 1) % dotLength);
            setIsScrolling(false);
        }
        else {
            const newScrollLeft = listEl.scrollLeft + listEl.offsetWidth;
            listEl.scrollTo({
                left: newScrollLeft,
                behavior: scrollBehavior
            });
            const offsetDiff = listEl.scrollWidth - listEl.offsetWidth;
            if (listEl.scrollLeft <= offsetDiff + 1 &&
                listEl.scrollLeft >= offsetDiff - 1) {
                const firstItem = listEl.firstElementChild;
                if (firstItem) {
                    firstItem.classList.remove('carousel-first-item-post-animation', 'carousel-first-item-pre-animation');
                    if (window.navigator.userAgent.indexOf('Chrome') !== -1) {
                        firstItem.classList.add('carousel-first-item-pre-animation');
                    }
                    listEl.scrollTo({ left: 0, behavior: 'auto' });
                    requestAnimationFrame(() => {
                        firstItem.classList.remove('carousel-first-item-pre-animation');
                        firstItem.classList.add('carousel-first-item-post-animation');
                        const onTransitionEnd = () => {
                            firstItem.classList.remove('carousel-first-item-post-animation');
                            firstItem.removeEventListener('transitionend', onTransitionEnd);
                        };
                        firstItem.addEventListener('transitionend', onTransitionEnd);
                    });
                }
            }
            const onScrollEnd = () => {
                clearTimeout(listEl._scrollTimeout);
                listEl._scrollTimeout = setTimeout(() => {
                    setIsScrolling(false);
                    listEl.removeEventListener('scroll', onScrollEnd);
                }, 100);
            };
            // Cross-browser scroll-end detection (scrollend || scroll + timeout)
            if ('onscrollend' in document.documentElement) {
                listEl.addEventListener('scrollend', () => setIsScrolling(false), {
                    once: true
                });
            }
            else {
                listEl.addEventListener('scroll', onScrollEnd);
            }
        }
        if (!event?.isCNEVideoEvent) {
            await interactionResponse();
            gtmTrackOnClick(event, null, image_index, 'forward');
        }
    };
    const onSwipe = (event, type) => {
        if (isSwiped === false) {
            type === 'forward' ? onForwardHandler(event) : onBackHandler(event);
            isSwiped = true;
        }
        setTimeout(() => {
            isSwiped = false;
        }, 500);
    };
    const onTouchStart = (e) => {
        setTouchStartX(e.clientX || e.targetTouches[0].clientX);
        setTouchStartY(e.clientY || e.targetTouches[0].clientY);
    };
    const onTouchMove = (e) => {
        setTouchEndX(e.clientX || e.targetTouches[0].clientX);
        setTouchEndY(e.clientY || e.targetTouches[0].clientY);
    };
    const onTouchEnd = (e) => {
        const distanceX = touchStartX - touchEndX;
        const distanceY = touchStartY - touchEndY;
        let isLeftSwipe = distanceX > 0;
        if (e.isCNEVideoEvent) {
            if (e.data && Math.abs(e.data.dy) > 20) {
                return;
            }
            isLeftSwipe = e.data.dx < 0;
            isLeftSwipe ? onSwipe(e, 'forward') : onSwipe(e);
            return;
        }
        if (Math.abs(distanceX) > Math.abs(distanceY)) {
            isLeftSwipe ? onSwipe(e, 'forward') : onSwipe(e);
        }
        // add your conditional logic here
    };
    React.useEffect(() => {
        // Handling touch events from iframe for cnevideo contenttype
        window.touchStartPos = { x: 0, y: 0 };
        const handleMessage = (event) => {
            if (event.origin !== window.location.origin)
                return;
            if (event.data.name === 'cnevideoevent' && event.data.upcId === upcId) {
                setTouchStartY(0);
                setTouchEndY(0);
                event.isCNEVideoEvent = true;
                const { type, x, y, distance, duration } = event.data;
                event.clientX = x;
                event.clientY = y;
                if (type === 'touchstart') {
                    // No need to track touchStartPos here anymore, it's done inside the iframe
                }
                else if (type === 'touchmove') {
                    onTouchMove(event);
                }
                else if (type === 'touchend') {
                    if (distance >= 5 && duration > 0) {
                        onTouchEnd(event);
                    }
                }
            }
        };
        window.addEventListener('message', handleMessage);
        return () => {
            window.removeEventListener('message', handleMessage);
        };
    });
    if (totalChildren === 0) {
        return null;
    }
    const backClickHandler = async (event) => {
        const eventData = {
            type: 'back',
            label: dangerousHed || title,
            subject: snowplowNavEventSubject || 'carousel',
            items: [],
            placement: 'mid-content',
            total_index: carouselItemsList.length
        };
        let onBackClickEventProps = null;
        const listEl = listRef?.current;
        await onBackHandler(event);
        if (listScrollLeft > 1) {
            setListScrollLeft(listScrollLeft - 1);
        }
        await interactionResponse();
        if (shouldShowCarouselItemsViewed) {
            const hedArr = getHedValues(listEl);
            const itemWidth = get(listEl?.children[0], 'clientWidth', 0);
            const maxItemsPerView = Math.floor(listWidth / itemWidth) ||
                localStore.getItem('maxItemsPerView');
            const lastClickIndex = findLastIndex(window.dataLayer, (o) => {
                return (o.event === 'carousel-right-arrow-click' ||
                    o.event === 'carousel-left-arrow-click');
            });
            if (window.dataLayer[lastClickIndex] &&
                window.dataLayer[lastClickIndex]['carousel-items']) {
                const viewedProfiles = window.dataLayer[lastClickIndex]['carousel-items'];
                const startIndexArr = viewedProfiles.split('|');
                let startIndex;
                if (window.dataLayer[lastClickIndex].event.includes('right') ||
                    window.dataLayer[lastClickIndex].event.includes('left'))
                    startIndex = hedArr.findIndex((hed) => hed === startIndexArr[0]);
                const carouselItemsArr = [];
                startIndex -= 1;
                for (let i = 1; i <= maxItemsPerView && startIndex >= 0; i++) {
                    carouselItemsArr.unshift(`${hedArr[startIndex]}`);
                    startIndex--;
                }
                const carouselItems = carouselItemsArr.join('|');
                if (carouselItems) {
                    onBackClickEventProps = { 'carousel-items': carouselItems };
                }
            }
        }
        if (onBackClick && onBackClickEventProps) {
            onBackClick(event, onBackClickEventProps);
        }
        if (onBackClick && !onBackClickEventProps) {
            onBackClick(event);
        }
        await interactionResponse();
        trackNavigationEvent(eventData);
    };
    const forwardClickHandler = async (event) => {
        await onForwardHandler(event);
        if (listScrollLeft < listWidth) {
            setListScrollLeft(listScrollLeft + 1);
        }
        await interactionResponse();
        const eventData = {
            type: 'forward',
            label: dangerousHed || title,
            subject: snowplowNavEventSubject || 'carousel',
            items: [],
            placement: 'mid-content',
            total_index: carouselItemsList.length
        };
        let onForwardClickEventProps = null;
        const listEl = listRef?.current;
        if (shouldShowCarouselItemsViewed) {
            const hedArr = getHedValues(listEl);
            const itemWidth = get(listEl?.children[0], 'clientWidth', 0);
            let startIndex;
            const maxItemsPerView = Math.floor(listWidth / itemWidth) ||
                localStore.getItem('maxItemsPerView');
            const lastClickIndex = findLastIndex(window.dataLayer, (o) => {
                return (o.event === 'carousel-right-arrow-click' ||
                    o.event === 'carousel-left-arrow-click');
            });
            if (window.dataLayer[lastClickIndex] &&
                window.dataLayer[lastClickIndex]['carousel-items']) {
                const viewedProfiles = window.dataLayer[lastClickIndex]['carousel-items'];
                const startIndexArr = viewedProfiles.split('|');
                if (window.dataLayer[lastClickIndex].event.includes('right') ||
                    window.dataLayer[lastClickIndex].event.includes('left'))
                    startIndex = hedArr.findIndex((hed) => hed === startIndexArr[startIndexArr.length - 1]);
                startIndex++;
            }
            else
                startIndex = maxItemsPerView;
            const carouselItemsArr = [];
            for (let i = 1; i <= maxItemsPerView && startIndex < hedArr.length; i++) {
                carouselItemsArr.push(`${hedArr[startIndex]}`);
                startIndex++;
            }
            const carouselItems = carouselItemsArr.join('|');
            if (carouselItems) {
                onForwardClickEventProps = { 'carousel-items': carouselItems };
            }
        }
        if (onForwardClick && onForwardClickEventProps) {
            onForwardClick(event, onForwardClickEventProps);
        }
        if (onForwardClick && !onForwardClickEventProps) {
            onForwardClick(event);
        }
        await interactionResponse();
        trackNavigationEvent(eventData);
    };
    const dotClickHandler = (event, dotID, selectedIndex) => {
        gtmTrackOnClick(event, null, dotID, 'click');
        const index = (totalForwardCount - totalBackCount) % dotLength;
        if (isDotClickable) {
            const listEl = listRef?.current;
            if (hasCircularScrolling && index !== 0) {
                if (index > 0) {
                    for (let i = 1; i <= Math.abs(index); i++) {
                        listEl.prepend(listEl.lastElementChild);
                    }
                }
                else if (index < 0) {
                    for (let i = 1; i <= Math.abs(index); i++) {
                        listEl.append(listEl.firstElementChild);
                    }
                }
            }
            if (listEl) {
                listEl.scrollTo({
                    left: listEl.scrollLeft + (dotID - selectedIndex) * listEl.offsetWidth,
                    behavior: scrollBehavior
                });
            }
            if (hasCircularScrolling) {
                updateDotCount(dotID);
                setBackTotalCount(0);
                setForwardTotalCount(0);
            }
        }
    };
    const onScrollThrottle = throttle(updateScrollState, 300);
    const scrollHandler = () => {
        let propsData = null;
        if (shouldShowCarouselItemsViewed) {
            const listEl = listRef?.current;
            const hedArr = getHedValues(listEl);
            const childLen = hedArr.length;
            let startIndex = Math.ceil((listEl?.scrollLeft ?? 0) / (listEl?.offsetWidth ?? 1)) ||
                localStore.getItem('startIndex');
            const itemWidth = get(listEl?.children[0], 'clientWidth', 0);
            const maxItemsPerView = Math.floor(listWidth / itemWidth) ||
                localStore.getItem('maxItemsPerView');
            const carouselItemsArr = [];
            for (let i = 1; i <= maxItemsPerView && startIndex < childLen; i++) {
                carouselItemsArr.push(`${hedArr[startIndex]}`);
                startIndex++;
            }
            const carouselItems = carouselItemsArr.join('|');
            if (carouselItems) {
                propsData = { 'carousel-items': carouselItems };
            }
        }
        if (onScroll && propsData) {
            onScroll(propsData);
        }
        if (onScroll && !propsData) {
            onScroll();
        }
        if (!hasCircularScrolling) {
            onScrollThrottle();
        }
    };
    let analyticsDataAttribute = {};
    if (shouldEnableBundleComponentAnalytics) {
        analyticsDataAttribute = componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, trackingNamespace?.carouselList);
    }
    const renderCarouselList = () => {
        return (React.createElement(React.Fragment, null,
            React.createElement(CarouselListAnimations, null),
            React.createElement(CarouselList, { ref: listRef, onScroll: scrollHandler, hasCircularScrolling: hasCircularScrolling, hasUPCMultipleImages: hasUPCMultipleImages, hasNoHorizontalScroll: hasNoHorizontalScrollCarousel || hasCustomSlider, hasModerateSpacingOnCarousel: hasModerateSpacingOnCarousel, isSliderVisible: isSliderVisible && !hasCustomSlider, isScrollEnd: isScrollEnd, isScrollStart: isScrollStart, shouldAlignCenter: shouldAlignCenterIfContentIsLess && !isBrowserScrollbarPresent, ...analyticsDataAttribute }, clonedChildren)));
    };
    return (React.createElement(CarouselWrapper, { className: className, hasImageCenteredButton: hasImageCenteredButton, hasIncreasedMargin: hasIncreasedMargin, hasIncreasedPadding: hasIncreasedPadding, ref: setNode, shouldHideMarginOnCarousel: shouldHideMarginOnCarousel, hasFullBleedChevrons: hasFullBleedChevrons, isUpcEnabled: isUpcEnabled },
        hasCarouselSectionTitle && (React.createElement(CarouselSectionTitle, { as: SectionTitle[sectionTitleVariation], dangerousHed: dangerousHed, hasDecreasedSectionTitleMargin: hasDecreasedSectionTitleMargin, hasDividerAbove: hasDividerAboveCarouselSectionTitle, hasDividerBelow: hasDividerBelowCarouselSectionTitle, sectionTitleVariation: sectionTitleVariation })),
        React.createElement(CarouselHeader, { controlPlacement: overriddenPlacement, hasControls: isControlTop, hasHeaderBorderTop: hasHeaderBorderTop, hasThinBorder: hasThinBorder, hideHeaderBorder: hideHeaderBorder, isScrollStart: isScrollStart, isScrollEnd: isScrollEnd, hasHeaderBorder: hasHeaderBorder, onBackClick: backClickHandler, onForwardClick: forwardClickHandler, title: title, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable }),
        hasDividerBelowHeader && title && (React.createElement(CarouselHeaderDivider, { shouldUseCustomColorToken: true, hasDek: strapline })),
        React.createElement(SummaryDek, { dangerousDek: strapline, shouldDisplayDangerousDek: !hideStrapline, hasCustomTypeToken: hasCustomTypeToken, hasMarginBottom: hasCarouselDekMarginBottom, contentAlign: contentAlign }),
        React.createElement(CarouselBody, { controlPlacement: overriddenPlacement, hasControls: isControlCenter, hasMobileControls: hasMobileControls, hasNavigationButtonVariation: hasNavigationButtonVariation, hasPadding: hasPadding, isScrollStart: isScrollStart, isScrollEnd: isScrollEnd, onBackClick: backClickHandler, onForwardClick: forwardClickHandler, hasIncreasedPadding: hasIncreasedPadding, hasImageCenteredButton: hasImageCenteredButton, hasFullBleedChevrons: hasFullBleedChevrons, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable, carouselControlTheme: carouselControlTheme, isSeriesNavigation: isSeriesNavigation },
            hasSwipeCarouseList ? (React.createElement(CarouselListSwipe, { onTouchStart: onTouchStart, onTouchMove: onTouchMove, onTouchEnd: onTouchEnd }, renderCarouselList())) : (renderCarouselList()),
            !isSeriesNavigation &&
                isSliderVisible &&
                hasCustomSlider &&
                isBrowserScrollbarPresent && (React.createElement(CurrentSlideIndicatorWrapper, { className: "carousel_slider-wrapper", hasPadding: hasPadding },
                React.createElement(CurrentSlideIndicator, { slideIndicatorWidth: slideIndicatorWidth, style: { marginLeft: `${slideIndicatorPosition}px` } }))),
            showPhotoCredit && React.createElement(CarouselCaption, { dangerousCredit: photoCredit })),
        !shouldHideCarouselFooter && (React.createElement(CarouselFooter, { controlPlacement: overriddenPlacement, hasModerateSpacing: hasModerateSpacing, hasIncreasedFooterMargin: hasIncreasedFooterMargin, hasControls: isControlBottom, hideDesktopPagination: hideDesktopPagination, isScrollStart: isScrollStart, isScrollEnd: isScrollEnd, onBackClick: backClickHandler, onForwardClick: forwardClickHandler, dotLength: dotLength, selectedDotIndex: selectedDotIndex, onDotClick: dotClickHandler, isDotClickable: isDotClickable, controlButtonIcon: controlButtonIcon, shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable: shouldHideControlsOnDisable, trackingNamespace: trackingNamespace, isUpcEnabled: isUpcEnabled, hasUPCMultipleImages: hasUPCMultipleImages, videoDotIndexes: videoDotIndexes }))));
};
Carousel.propTypes = {
    carouselControlTheme: PropTypes.string,
    children: PropTypes.node.isRequired,
    className: PropTypes.string,
    contentAlign: PropTypes.oneOf(['left', 'center']),
    controlButtonIcon: PropTypes.oneOf(['ChevronIcon', 'ArrowIcon']),
    controlPlacement: PropTypes.oneOf(['right', 'space-between']),
    controlPosition: PropTypes.oneOf(['top', 'bottom', 'center']),
    dangerousHed: PropTypes.string,
    gtmTrackOnClick: PropTypes.func,
    hasCarouselDekMarginBottom: PropTypes.bool,
    hasCarouselSectionTitle: PropTypes.bool,
    hasCircularScrolling: PropTypes.bool,
    hasControls: PropTypes.bool,
    hasCustomSlider: PropTypes.bool,
    hasCustomTypeToken: PropTypes.bool,
    hasDecreasedSectionTitleMargin: PropTypes.bool,
    hasDividerAboveCarouselSectionTitle: PropTypes.bool,
    hasDividerBelowCarouselSectionTitle: PropTypes.bool,
    hasDividerBelowHeader: PropTypes.bool,
    hasExactlyOneImageInViewAtOnce: PropTypes.bool,
    hasFlexibleControlPosition: PropTypes.bool,
    hasFullBleedChevrons: PropTypes.bool,
    hasHeaderBorder: PropTypes.bool,
    hasHeaderBorderTop: PropTypes.bool,
    hasImageCenteredButton: PropTypes.bool,
    hasImpressionTracking: PropTypes.bool,
    hasIncreasedFooterMargin: PropTypes.bool,
    hasIncreasedMargin: PropTypes.bool,
    hasIncreasedPadding: PropTypes.bool,
    hasMobileControls: PropTypes.bool,
    hasModerateSpacing: PropTypes.bool,
    hasModerateSpacingOnCarousel: PropTypes.bool,
    hasNavigationButtonVariation: PropTypes.bool,
    hasNoHorizontalScrollCarousel: PropTypes.bool,
    hasNormalCaseStrapline: PropTypes.bool,
    hasPadding: PropTypes.bool,
    hasPagination: PropTypes.bool,
    hasSwipeCarouseList: PropTypes.bool,
    hasThinBorder: PropTypes.bool,
    hasUPCMultipleImages: PropTypes.bool,
    hideDesktopPagination: PropTypes.bool,
    hideHeaderBorder: PropTypes.bool,
    hideStrapline: PropTypes.bool,
    isDotClickable: PropTypes.bool,
    isPlpCurated: PropTypes.bool,
    isSeriesNavigation: PropTypes.bool,
    isUpcEnabled: PropTypes.bool,
    onBackClick: PropTypes.func,
    onForwardClick: PropTypes.func,
    onScroll: PropTypes.func,
    paginationStyle: PropTypes.oneOf(['bullet', 'slider']),
    pos: PropTypes.number,
    scrollBehavior: PropTypes.oneOf(['auto', 'instant', 'smooth']),
    sectionTitleVariation: PropTypes.string,
    shouldAlignCenterIfContentIsLess: PropTypes.bool,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldEnableRecircTracking: PropTypes.bool,
    shouldEnableScrollToStart: PropTypes.bool,
    shouldHideCarouselFooter: PropTypes.bool,
    shouldHideControlsOnDisable: PropTypes.bool,
    shouldHideMarginOnCarousel: PropTypes.bool,
    shouldShowCarouselItemsViewed: PropTypes.bool,
    showPhotoCredit: PropTypes.bool,
    snowplowNavEventSubject: PropTypes.string,
    strapline: PropTypes.string,
    title: PropTypes.string,
    trackingNamespace: PropTypes.object,
    upcId: PropTypes.string,
    videoDotIndexes: PropTypes.array
};
Carousel.CarouselItem = CarouselItem;
module.exports = Carousel;
//# sourceMappingURL=Carousel.js.map

/***/ }),

/***/ 99726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { ControlBack, ControlForward } = __webpack_require__(82164);
const { CarouselListButton, CarouselListWrapper } = __webpack_require__(44802);
const CarouselBody = ({ carouselControlTheme = '', children, controlPlacement = 'right', hasControls = false, hasFullBleedChevrons = false, hasIncreasedPadding = false, hasImageCenteredButton, hasMobileControls = true, hasNavigationButtonVariation, hasPadding, isScrollEnd = false, isScrollStart = false, onBackClick, onForwardClick, controlButtonIcon = 'ChevronIcon', shouldHideControlsOnDisable, isSeriesNavigation }) => {
    if (!children)
        return null;
    const isControlsRight = controlPlacement === 'right';
    const isControlsSpaceBetween = controlPlacement === 'space-between';
    return (React.createElement(CarouselListWrapper, { hasPadding: hasPadding, hasIncreasedPadding: hasIncreasedPadding, isSeriesNavigation: isSeriesNavigation },
        children,
        hasControls && isControlsSpaceBetween && (React.createElement(CarouselListButton, { isLeftSide: true, hasImageCenteredButton: hasImageCenteredButton, hasIncreasedPadding: hasIncreasedPadding, hasNavigationButtonVariation: hasNavigationButtonVariation, hasMobileControls: hasMobileControls, hasFullBleedChevrons: hasFullBleedChevrons },
            React.createElement(ControlBack, { onClick: onBackClick, isDisabled: isScrollStart, hasNavigationButtonVariation: hasNavigationButtonVariation, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable, fullPageTheme: carouselControlTheme }))),
        hasControls && (isControlsRight || isControlsSpaceBetween) && (React.createElement(CarouselListButton, { isRightSide: true, hasImageCenteredButton: hasImageCenteredButton, hasIncreasedPadding: hasIncreasedPadding, hasNavigationButtonVariation: hasNavigationButtonVariation, hasMobileControls: hasMobileControls, hasFullBleedChevrons: hasFullBleedChevrons },
            !isControlsSpaceBetween && (React.createElement(ControlBack, { onClick: onBackClick, isDisabled: isScrollStart, hasNavigationButtonVariation: hasNavigationButtonVariation, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable, fullPageTheme: carouselControlTheme })),
            React.createElement(ControlForward, { onClick: onForwardClick, isDisabled: isScrollEnd, hasNavigationButtonVariation: hasNavigationButtonVariation, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable, fullPageTheme: carouselControlTheme })))));
};
CarouselBody.propTypes = {
    carouselControlTheme: PropTypes.string,
    children: PropTypes.node.isRequired,
    controlButtonIcon: PropTypes.oneOf(['ChevronIcon', 'ArrowIcon']),
    controlPlacement: PropTypes.oneOf(['right', 'space-between']),
    hasControls: PropTypes.bool,
    hasFullBleedChevrons: PropTypes.bool,
    hasImageCenteredButton: PropTypes.bool,
    hasIncreasedPadding: PropTypes.bool,
    hasMobileControls: PropTypes.bool,
    hasNavigationButtonVariation: PropTypes.bool,
    hasPadding: PropTypes.bool,
    isScrollEnd: PropTypes.bool,
    isScrollStart: PropTypes.bool,
    isSeriesNavigation: PropTypes.bool,
    onBackClick: PropTypes.func,
    onForwardClick: PropTypes.func,
    shouldHideControlsOnDisable: PropTypes.bool
};
module.exports = CarouselBody;
//# sourceMappingURL=CarouselBody.js.map

/***/ }),

/***/ 82164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const ChevronIcon = __webpack_require__(39733);
const ArrowIcon = __webpack_require__(69571);
const translations = (__webpack_require__(86228)/* ["default"] */ .A);
const { CarouselControlButton, CarouselDot, CarouselVideoDot } = __webpack_require__(44802);
const getControlButtonIcon = (controlButtonIcon) => controlButtonIcon === 'ArrowIcon' ? ArrowIcon : ChevronIcon;
const ControlBack = ({ controlButtonIcon, fullPageTheme, isDisabled, hasNavigationButtonVariation, onClick, shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable, trackingNamespace = '' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement(CarouselControlButton, { isLeft: true, className: classnames('carousel-control-button--back'), ariaLabel: formatMessage(translations.backAriaLabel), fullPageTheme: hasNavigationButtonVariation ? 'inverted' : fullPageTheme, hasNavigationButtonVariation: hasNavigationButtonVariation, onClickHandler: onClick, label: "", isIconButton: true, inputKind: "button", isDisabled: isDisabled, shouldHideControlsOnDisable: shouldHideControlsOnDisable, ButtonIcon: getControlButtonIcon(controlButtonIcon), controlButtonIcon: controlButtonIcon, shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, trackingNamespace: `${trackingNamespace} Control Backward` }));
};
ControlBack.propTypes = {
    controlButtonIcon: PropTypes.string,
    fullPageTheme: PropTypes.string,
    hasNavigationButtonVariation: PropTypes.bool,
    isDisabled: PropTypes.bool,
    onClick: PropTypes.func,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldHideControlsOnDisable: PropTypes.bool,
    trackingNamespace: PropTypes.string
};
const ControlDots = ({ length = 0, selectedIndex = 0, onClick, isDotClickable = false, fullPageTheme, isUpcEnabled, hasUPCMultipleImages, videoDotIndexes }) => {
    if (!length)
        return null;
    const handleClick = (e, index, selectedIndex) => {
        onClick(e, index, selectedIndex);
    };
    const carouselDots = [];
    for (let i = 0; i < length; i += 1) {
        carouselDots.push(React.createElement(CarouselDot, { key: `dot-${i}`, isselected: `${i === selectedIndex}`, onClick: (e) => handleClick(e, i, selectedIndex), dotclickable: isDotClickable ? 1 : 0, fullpagetheme: fullPageTheme, "$isReducedSize": length >= 14, "$isUpcEnabled": isUpcEnabled, "$hasUPCMultipleImages": hasUPCMultipleImages }));
    }
    videoDotIndexes?.forEach((index) => {
        carouselDots[index] = (React.createElement(CarouselVideoDot, { key: `playdot-${index}`, isselected: `${index === selectedIndex}`, onClick: (e) => handleClick(e, index, selectedIndex), dotclickable: isDotClickable ? 1 : 0, fullpagetheme: fullPageTheme, "$isUpcEnabled": isUpcEnabled, "$hasUPCMultipleImages": hasUPCMultipleImages }));
    });
    return carouselDots;
};
ControlDots.propTypes = {
    fullPageTheme: PropTypes.string,
    hasUPCMultipleImages: PropTypes.bool,
    isDotClickable: PropTypes.bool,
    isUpcEnabled: PropTypes.bool,
    length: PropTypes.number,
    onClick: PropTypes.func,
    selectedIndex: PropTypes.number,
    videoDotIndexes: PropTypes.array
};
const ControlForward = ({ controlButtonIcon, fullPageTheme, isDisabled, hasNavigationButtonVariation, onClick, shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable, trackingNamespace = '' }) => {
    const { formatMessage } = useIntl();
    return (React.createElement(CarouselControlButton, { ariaLabel: formatMessage(translations.forwardAriaLabel), className: classnames('carousel-control-button--forward'), fullPageTheme: hasNavigationButtonVariation ? 'inverted' : fullPageTheme, hasNavigationButtonVariation: hasNavigationButtonVariation, onClickHandler: onClick, label: "", inputKind: "button", isIconButton: true, isDisabled: isDisabled, ButtonIcon: getControlButtonIcon(controlButtonIcon), shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable: shouldHideControlsOnDisable, trackingNamespace: `${trackingNamespace} Control Forward` }));
};
ControlForward.propTypes = {
    controlButtonIcon: PropTypes.oneOf(['ChevronIcon', 'ArrowIcon']),
    fullPageTheme: PropTypes.string,
    hasNavigationButtonVariation: PropTypes.bool,
    isDisabled: PropTypes.bool,
    onClick: PropTypes.func,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldHideControlsOnDisable: PropTypes.bool,
    trackingNamespace: PropTypes.string
};
module.exports = {
    ControlBack,
    ControlForward,
    ControlDots,
    CarouselDot
};
//# sourceMappingURL=CarouselControls.js.map

/***/ }),

/***/ 87797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { ControlBack, ControlForward, ControlDots } = __webpack_require__(82164);
const { CarouselFooter: CarouselFoot, CarouselFooterItemButton, CarouselFooterItemDots } = __webpack_require__(44802);
const { asThemedComponent } = __webpack_require__(20223);
const CarouselFooter = ({ className, controlPlacement = 'right', dotLength = 0, hasControls = false, hasIncreasedFooterMargin = false, hasModerateSpacing = false, hideDesktopPagination = false, isDotClickable = false, isScrollEnd = false, isScrollStart = false, onBackClick, onForwardClick, selectedDotIndex = 0, onDotClick, controlButtonIcon = 'ChevronIcon', shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable, trackingNamespace = {}, fullPageTheme, isUpcEnabled, hasUPCMultipleImages, videoDotIndexes }) => {
    if (!hasControls && dotLength === 0)
        return null;
    const isControlsRight = controlPlacement === 'right';
    const isControlsSpaceBetween = controlPlacement === 'space-between';
    return (React.createElement(CarouselFoot, { className: className, hasModerateSpacing: hasModerateSpacing, hasIncreasedFooterMargin: hasIncreasedFooterMargin },
        hasControls && isControlsSpaceBetween && (React.createElement(CarouselFooterItemButton, { isLeftSide: true },
            React.createElement(ControlBack, { fullPageTheme: fullPageTheme, onClick: onBackClick, isDisabled: isScrollStart, controlButtonIcon: controlButtonIcon, shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable: shouldHideControlsOnDisable, trackingNamespace: trackingNamespace?.backwardButton }))),
        React.createElement(CarouselFooterItemDots, { hideDesktopPagination: hideDesktopPagination },
            React.createElement(ControlDots, { selectedIndex: selectedDotIndex, length: dotLength, onClick: onDotClick, isDotClickable: isDotClickable, fullPageTheme: fullPageTheme, isUpcEnabled: isUpcEnabled, hasUPCMultipleImages: hasUPCMultipleImages, videoDotIndexes: videoDotIndexes })),
        hasControls && (isControlsRight || isControlsSpaceBetween) && (React.createElement(CarouselFooterItemButton, { isRightSide: true },
            !isControlsSpaceBetween && (React.createElement(ControlBack, { fullPageTheme: fullPageTheme, onClick: onBackClick, isDisabled: isScrollStart, controlButtonIcon: controlButtonIcon, shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable: shouldHideControlsOnDisable, trackingNamespace: trackingNamespace?.backwardButton })),
            React.createElement(ControlForward, { fullPageTheme: fullPageTheme, onClick: onForwardClick, isDisabled: isScrollEnd, controlButtonIcon: controlButtonIcon, shouldEnableBundleComponentAnalytics: shouldEnableBundleComponentAnalytics, shouldHideControlsOnDisable: shouldHideControlsOnDisable, trackingNamespace: trackingNamespace?.forwardButton })))));
};
CarouselFooter.propTypes = {
    className: PropTypes.string,
    controlButtonIcon: PropTypes.oneOf(['ChevronIcon', 'ArrowIcon']),
    controlPlacement: PropTypes.oneOf(['right', 'space-between']),
    dotLength: PropTypes.number,
    fullPageTheme: PropTypes.oneOf(['standard', 'inverted']),
    hasControls: PropTypes.bool,
    hasIncreasedFooterMargin: PropTypes.bool,
    hasModerateSpacing: PropTypes.bool,
    hasUPCMultipleImages: PropTypes.bool,
    hideDesktopPagination: PropTypes.bool,
    isDotClickable: PropTypes.bool,
    isScrollEnd: PropTypes.bool,
    isScrollStart: PropTypes.bool,
    isUpcEnabled: PropTypes.bool,
    onBackClick: PropTypes.func,
    onDotClick: PropTypes.func,
    onForwardClick: PropTypes.func,
    selectedDotIndex: PropTypes.number,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldHideControlsOnDisable: PropTypes.bool,
    trackingNamespace: PropTypes.object,
    videoDotIndexes: PropTypes.array
};
module.exports = asThemedComponent(CarouselFooter);
//# sourceMappingURL=CarouselFooter.js.map

/***/ }),

/***/ 22892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { ControlBack, ControlForward } = __webpack_require__(82164);
const { CarouselHeader: CarouselHead, CarouselHeaderItemTitle, CarouselHeaderItemButton, CarouselTitle } = __webpack_require__(44802);
const CarouselHeader = ({ controlPlacement = 'right', hasControls = false, hasHeaderBorderTop = false, hasThinBorder = false, hasHeaderBorder, hideHeaderBorder = false, isScrollEnd = false, isScrollStart = false, onBackClick, onForwardClick, title, controlButtonIcon = 'ChevronIcon', shouldHideControlsOnDisable }) => {
    if (!hasControls && !title)
        return null;
    const isControlsRight = controlPlacement === 'right';
    const isControlsSpaceBetween = controlPlacement === 'space-between';
    return (React.createElement(CarouselHead, { hasTitle: !!title, hideHeaderBorder: hideHeaderBorder, hasHeaderBorderTop: hasHeaderBorderTop, hasThinBorder: hasThinBorder, hasHeaderBorder: hasHeaderBorder },
        hasControls && isControlsSpaceBetween && (React.createElement(CarouselHeaderItemButton, { isLeftSide: true },
            React.createElement(ControlBack, { onClick: onBackClick, isDisabled: isScrollStart, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable }))),
        React.createElement(CarouselHeaderItemTitle, { hasHeaderBorder: hasHeaderBorder }, title && React.createElement(CarouselTitle, { dangerouslySetInnerHTML: { __html: title } })),
        hasControls && (isControlsRight || isControlsSpaceBetween) && (React.createElement(CarouselHeaderItemButton, { isRightSide: true },
            !isControlsSpaceBetween && (React.createElement(ControlBack, { onClick: onBackClick, isDisabled: isScrollStart, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable })),
            React.createElement(ControlForward, { onClick: onForwardClick, isDisabled: isScrollEnd, controlButtonIcon: controlButtonIcon, shouldHideControlsOnDisable: shouldHideControlsOnDisable })))));
};
CarouselHeader.propTypes = {
    controlButtonIcon: PropTypes.oneOf(['ChevronIcon', 'ArrowIcon']),
    controlPlacement: PropTypes.oneOf(['right', 'space-between']),
    hasControls: PropTypes.bool,
    hasHeaderBorder: PropTypes.bool,
    hasHeaderBorderTop: PropTypes.bool,
    hasThinBorder: PropTypes.bool,
    hideHeaderBorder: PropTypes.bool,
    isScrollEnd: PropTypes.bool,
    isScrollStart: PropTypes.bool,
    onBackClick: PropTypes.func,
    onForwardClick: PropTypes.func,
    shouldHideControlsOnDisable: PropTypes.bool,
    title: PropTypes.string
};
module.exports = CarouselHeader;
//# sourceMappingURL=CarouselHeader.js.map

/***/ }),

/***/ 52641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const { useInView } = __webpack_require__(26855);
const React = __webpack_require__(96540);
const { CarouselListItem } = __webpack_require__(44802);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const CarouselItem = React.forwardRef(({ children, className, id, totalItems, spacing, width, carouselTitle, carouselItemIndex, carouselItemName, pos, isUpcEnabled, isSeriesNavigation, hasSlider = false, isFirstItem = false, isLastItem = false, isSpecial = false, isTextExternalLink = false, isBubblesLayout = false, hasUPCMultipleImages = false, snowplowNavEventSubject, isMobile = false }, ref) => {
    const childId = children?.props?.id;
    const childUrl = children?.props?.url;
    const contentType = children?.props?.contentType;
    const removeHtmlTags = (inputString) => {
        return inputString.replace(/<\/?[^>]+(>|$)/g, '');
    };
    const handleInView = (inView) => {
        if (inView && childId && childUrl) {
            const eventData = {
                type: 'impression',
                label: isBubblesLayout
                    ? 'Visual Story'
                    : removeHtmlTags(carouselTitle),
                subject: snowplowNavEventSubject || 'carousel',
                items: [
                    {
                        content_title: removeHtmlTags(carouselItemName),
                        content_type: contentType,
                        content_id: childId,
                        content_url: new URL(childUrl, window.location.origin)
                    }
                ],
                ...(extractStrategyFromURL(childUrl) && {
                    strategy: extractStrategyFromURL(childUrl)
                }),
                index: carouselItemIndex,
                total_index: totalItems,
                placement: snowplowNavEventSubject === 'recirc-unit'
                    ? 'bottom_recirc'
                    : 'mid-content',
                subject_version: isMobile ? 'mobile_dense' : 'default'
            };
            if (isBubblesLayout) {
                delete eventData.strategy;
            }
            trackNavigationEvent(eventData);
        }
    };
    const { ref: inViewRef } = useInView({
        threshold: 0.5,
        delay: 100,
        triggerOnce: true,
        onChange: handleInView
    });
    // Combine the forwarded ref and the ref from useInView
    const combinedRef = (node) => {
        if (ref)
            ref.current = node;
        if (typeof inViewRef === 'function') {
            inViewRef(node);
        }
    };
    const onItemClickHandler = (title, itemIndex, itemName, position) => {
        if (children && children.props) {
            const { id, contentType, url, dangerousHed: hed } = children.props;
            trackNavigationEvent({
                type: 'click',
                label: title,
                subject: 'carousel',
                items: [
                    {
                        content_title: hed.replace(/<[^>]*>/g, ''),
                        content_type: contentType,
                        content_id: id,
                        content_url: window && window.location.origin + url
                    }
                ],
                placement: 'mid-content',
                index: itemIndex - 1,
                total_index: totalItems,
                subject_version: isMobile ? 'mobile_dense' : 'default'
            });
        }
        if ( true &&
            window.dataLayer &&
            carouselItemName) {
            window.dataLayer.push({
                event: 'carousel-click',
                'carousel-name': title,
                'carousel-position': position,
                'carousel-click-position': itemIndex,
                'carousel-click-text': itemName
            });
        }
    };
    if (React.Children.count(children) === 0)
        return null;
    return (React.createElement(CarouselListItem, { id: id, className: className, hasSlider: hasSlider, isFirstItem: isFirstItem, isLastItem: isLastItem, itemSpacing: spacing, itemWidth: width, isTextExternalLink: isTextExternalLink, hasUPCMultipleImages: hasUPCMultipleImages, ref: combinedRef, onClick: () => onItemClickHandler(carouselTitle, carouselItemIndex + 1, carouselItemName, pos), isSpecial: isSpecial, isUpcEnabled: isUpcEnabled, isSeriesNavigation: isSeriesNavigation }, children));
});
CarouselItem.displayName = 'CarouselItem';
CarouselItem.propTypes = {
    carouselItemIndex: PropTypes.number,
    carouselItemName: PropTypes.string,
    carouselTitle: PropTypes.string,
    children: PropTypes.node.isRequired,
    className: PropTypes.string,
    hasSlider: PropTypes.bool,
    hasUPCMultipleImages: PropTypes.bool,
    id: PropTypes.string,
    isBubblesLayout: PropTypes.bool,
    isFirstItem: PropTypes.bool,
    isLastItem: PropTypes.bool,
    isMobile: PropTypes.bool,
    isSeriesNavigation: PropTypes.bool,
    isSpecial: PropTypes.bool,
    isTextExternalLink: PropTypes.bool,
    isUpcEnabled: PropTypes.bool,
    pos: PropTypes.number,
    snowplowNavEventSubject: PropTypes.string,
    spacing: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.shape({
            sm: PropTypes.string,
            md: PropTypes.string,
            lg: PropTypes.string,
            xl: PropTypes.string,
            xxl: PropTypes.string
        })
    ]),
    totalItems: PropTypes.number,
    width: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.shape({
            sm: PropTypes.string,
            md: PropTypes.string,
            lg: PropTypes.string,
            xl: PropTypes.string,
            xxl: PropTypes.string
        })
    ])
};
module.exports = CarouselItem;
//# sourceMappingURL=CarouselItem.js.map

/***/ }),

/***/ 30830:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const withAnalytics = __webpack_require__(80526);
const Carousel = __webpack_require__(48318);
module.exports = withAnalytics(Carousel);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44802:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css, createGlobalStyle } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorToken, getColorStyles, minMaxScreen, minScreen } = __webpack_require__(26865);
const { ButtonIcon, ButtonIconWrapper } = __webpack_require__(18974);
const Button = __webpack_require__(73730);
const Caption = __webpack_require__(14760);
const DotIcon = __webpack_require__(60261);
const playIcon = __webpack_require__(11118);
const { getItemSpacing, getItemWidth } = __webpack_require__(30271);
const { BREAKPOINTS } = __webpack_require__(96472);
const { isInverted } = __webpack_require__(70698);
const CarouselWrapper = styled.section.withConfig({
    displayName: 'CarouselWrapper'
}) `
  position: relative;
  ${({ shouldHideMarginOnCarousel }) => !shouldHideMarginOnCarousel && `margin: ${calculateSpacing(4)} 0;`}

  ${({ hasIncreasedMargin }) => hasIncreasedMargin &&
    `margin: ${calculateSpacing(3)} 0 ${calculateSpacing(4)} 0;`}
  ${({ hasIncreasedPadding }) => hasIncreasedPadding &&
    `
padding-left:0px ! important;
padding-right:0px ! important;
`}
  ${({ isUpcEnabled }) => isUpcEnabled &&
    `
    padding-left: ${calculateSpacing(1.25)};
  `}
  @media print {
    display: none;
  }
`;
const CarouselHeader = styled.header.withConfig({
    displayName: 'CarouselHeader'
}) `
  display: flex;
  align-items: center;
  justify-content: flex-end;
  margin-bottom: ${calculateSpacing(1.5)};

  ${({ hasTitle, theme, hideHeaderBorder, hasThinBorder }) => hasTitle && !hideHeaderBorder
    ? `
      border-width: ${hasThinBorder ? '0 0 1px' : '0 0 2px'};
      border-style: solid;
      ${getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.divider')};
      padding-bottom: ${calculateSpacing(1.5)};`
    : ''}

  ${({ hasHeaderBorderTop, theme }) => hasHeaderBorderTop &&
    `
    border-width: 1px 0 1px 0;
    text-align: center;
    ${getColorStyles(theme, 'border-color', 'colors.discovery.body.white.divider')};
    margin-bottom: ${calculateSpacing(2)};
    padding-bottom: ${calculateSpacing(2)};
    padding-top: ${calculateSpacing(2)};
  `}
  
  ${({ hasThinBorder, theme }) => hasThinBorder &&
    `
      border-width: 0 0 1px;
      ${getColorStyles(theme, 'border-color', 'colors.consumption.lead.standard.divider')};
    `}
    ${({ hasHeaderBorder }) => hasHeaderBorder && `padding-bottom: ${calculateSpacing(4)};`}
`;
const CarouselHeaderDivider = styled.div.withConfig({
    displayName: 'CarouselHeaderDivider'
}) `
  grid-column: 1 / -1;
  margin: auto;
  margin-top: ${calculateSpacing(2)};
  border-bottom-width: ${calculateSpacing(0.25, 'px')};
  border-bottom-style: solid;
  ${({ shouldUseCustomColorToken, theme }) => shouldUseCustomColorToken
    ? `border-bottom-color: ${getColorToken(theme, 'colors.discovery.body.white.context-signature')};`
    : `border-bottom-color: ${getColorToken(theme, 'colors.consumption.lead.standard.accent')};`};
  width: ${calculateSpacing(12.5, 'px')};
  ${({ hasDek }) => !hasDek && ` margin-bottom: 40px;`};
`;
const CarouselHeaderItemTitle = styled.div.withConfig({
    displayName: 'CarouselHeaderItemTitle'
}) `
  flex: 1;
  ${({ hasHeaderBorder, theme }) => hasHeaderBorder &&
    `
  border-width:1px 0 1px 0;
  border-style: solid;
  ${getColorStyles(theme, 'border-color', 'colors.discovery.body.white.divider')};
  padding: ${calculateSpacing(2)} 0;
  `}
`;
const CarouselHeaderItemButton = styled.div.withConfig({
    displayName: 'CarouselHeaderItemButton'
}) `
  height: 32px;
  font-size: 0;

  ${({ isLeftSide }) => isLeftSide && `padding-right: ${calculateSpacing(3)};`}
  ${({ isRightSide }) => isRightSide && `padding-left: ${calculateSpacing(3)};`}
`;
const CarouselFooter = styled.footer.withConfig({
    displayName: 'CarouselFooter'
}) `
  display: flex;
  align-items: center;
  justify-content: flex-end;
  margin-top: ${calculateSpacing(1.5)};

  ${({ hasIncreasedFooterMargin }) => hasIncreasedFooterMargin &&
    `
      margin-top: ${calculateSpacing(2)};
    `}

  ${({ hasModerateSpacing }) => hasModerateSpacing &&
    `
    margin-top: ${calculateSpacing(2.5)};
    @media (min-width: ${BREAKPOINTS.xl}) {
      margin-top: ${calculateSpacing(3.5)};
    }
  `}
`;
const CarouselFooterItemDots = styled.div.withConfig({
    displayName: 'CarouselFooterItemDots'
}) `
  display: flex;
  flex: 1;
  align-items: center;
  justify-content: center;
  ${({ hideDesktopPagination }) => hideDesktopPagination &&
    `
  ${minScreen(BREAKPOINTS.md)} {
    display: none;
  }
  `}
`;
const CarouselFooterItemButton = styled.div.withConfig({
    displayName: 'CarouselFooterItemButton'
}) `
  height: 32px;
  font-size: 0;

  ${({ isLeftSide }) => isLeftSide && `padding-right: ${calculateSpacing(3)};`}
  ${({ isRightSide }) => isRightSide && `padding-left: ${calculateSpacing(3)};`}
`;
const CarouselTitle = styled(BaseText).withConfig({
    displayName: 'CarouselTitle'
}) `
  a {
    text-decoration: none;

    &:hover {
      text-decoration: underline;
    }
  }
`;
CarouselTitle.defaultProps = {
    as: 'h2',
    colorToken: 'colors.consumption.body.standard.subhed',
    typeIdentity: 'typography.definitions.consumptionEditorial.subhed-aux-primary'
};
const CarouselControlButton = styled(Button.Utility).withConfig({
    displayName: 'CarouselControlButton'
}) `
  && {
    ${({ theme, fullPageTheme }) => {
    if (fullPageTheme === 'inverted') {
        return css `
          ${getColorStyles(theme, 'background-color', 'colors.interactive.base.black')}
        `;
    }
    return css `
        ${getColorStyles(theme, 'background-color', 'colors.interactive.base.white')}
      `;
}};

    ${({ hasNavigationButtonVariation }) => hasNavigationButtonVariation &&
    `border-radius: 50%;
      opacity: 0.8;`}
    display: inline-block;
    border: 0;
    width: 40px;
    min-width: auto;
    height: 40px;

    ${({ isLeft, controlButtonIcon }) => {
    let transformValue = '';
    if (isLeft && controlButtonIcon === 'ArrowIcon') {
        transformValue = 'rotate(180deg) scale(0.7)';
    }
    else if (isLeft) {
        transformValue = 'rotate(180deg)';
    }
    else if (controlButtonIcon === 'ArrowIcon') {
        transformValue = 'scale(0.7)';
    }
    return `transform: ${transformValue};`;
}}

    svg {
      ${({ theme, fullPageTheme }) => {
    if (fullPageTheme === 'inverted') {
        return css `
            ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
          `;
    }
    return css `
          ${getColorStyles(theme, 'fill', 'colors.interactive.base.black')}
        `;
}};
    }

    ${ButtonIcon} {
      ${({ hasNavigationButtonVariation }) => hasNavigationButtonVariation
    ? `
          width: 28px;
          height: 28px;`
    : `
          width: 40px;
          height: 40px;`}
    }

    ${ButtonIconWrapper} {
      ${({ hasNavigationButtonVariation }) => hasNavigationButtonVariation &&
    `display: flex;
        align-items: center;
        justify-content: center;`}
      position: absolute;
      top: 0;
      left: 0;
      width: 40px;
      height: 40px;
    }

    &:disabled {
      ${({ shouldHideControlsOnDisable }) => shouldHideControlsOnDisable
    ? `
        visibility: hidden;
        margin-left: 0;
        padding: 0;
         width: 0;
        `
    : ''}

      ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
      border: none;

      svg {
        ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.light')};
      }
    }

    &:hover,
    &:focus {
      ${({ hasNavigationButtonVariation, hasFullBleedChevrons }) => {
    if (!hasNavigationButtonVariation && hasFullBleedChevrons) {
        return css `
            ${({ theme, fullPageTheme }) => {
            if (fullPageTheme === 'inverted') {
                return css `
                  ${getColorStyles(theme, 'background', 'colors.interactive.base.white')};
                `;
            }
            return css `
                ${getColorStyles(theme, 'background', 'colors.interactive.base.black')};
              `;
        }}
            border: none;

            svg {
              ${({ theme, fullPageTheme }) => {
            if (fullPageTheme === 'inverted') {
                return css `
                    ${getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
                  `;
            }
            return css `
                  ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')}
                `;
        }};
            }
          `;
    }
    return css ``;
}}
    }
  }

  & + & {
    /* Fix for two buttons next to each other adding margin-top */
    margin-top: 0;
    margin-left: ${calculateSpacing(1)};
  }
`;
const CarouselListWrapper = styled.div.withConfig({
    displayName: 'CarouselListWrapper'
}) `
  position: relative;
  width: 100%;

  .summary-item__dek--isCneVideo {
    display: none;
  }

  ${({ isSeriesNavigation }) => isSeriesNavigation &&
    `
      display: flex;
      justify-content: center;
  `}

  ${({ hasIncreasedPadding }) => hasIncreasedPadding &&
    ` @media (min-width: ${BREAKPOINTS.lg}) {
      padding-left:4%;
      padding-right:4%;
    }
`}
`;
const CarouselListButton = styled.div.withConfig({
    displayName: 'CarouselListButton'
}) `
  position: absolute;
  ${({ hasImageCenteredButton }) => !hasImageCenteredButton
    ? `
    top: 25%;
  `
    : `
    top: 50%;
  `}
  transform: translateY(-50%);

  ${({ isLeftSide, hasImageCenteredButton, hasNavigationButtonVariation, hasFullBleedChevrons }) => {
    if (hasImageCenteredButton && !hasFullBleedChevrons) {
        return hasNavigationButtonVariation
            ? isLeftSide && `left: ${calculateSpacing(2)}`
            : isLeftSide && `left: 0;`;
    }
    if (hasFullBleedChevrons && hasImageCenteredButton) {
        return hasNavigationButtonVariation
            ? isLeftSide && `left: ${calculateSpacing(2)}`
            : isLeftSide &&
                `left: -51px; top: 38%; @media (max-width: ${BREAKPOINTS.lg}) {top: 21%;}`;
    }
    return isLeftSide && `left: 8px;`;
}}

  ${({ isRightSide, hasImageCenteredButton, hasNavigationButtonVariation, hasFullBleedChevrons }) => {
    if (hasImageCenteredButton && !hasFullBleedChevrons) {
        return hasNavigationButtonVariation
            ? isRightSide && `right: ${calculateSpacing(2)}`
            : isRightSide && `right: 0;`;
    }
    if (hasImageCenteredButton && hasFullBleedChevrons) {
        return hasNavigationButtonVariation
            ? isRightSide && `right: ${calculateSpacing(2)}`
            : isRightSide &&
                `right: -51px; top: 38%; @media (max-width: ${BREAKPOINTS.lg}) {top: 21%;}`;
    }
    return isRightSide && `right: 8px;`;
}}
  z-index: 1;
  ${({ hasMobileControls }) => !hasMobileControls &&
    `@media (max-width: 760px) {
    display: none;
  }
`}

  ${({ hasIncreasedPadding }) => hasIncreasedPadding &&
    ` @media (max-width: ${BREAKPOINTS.lg}) {
    top: 100%;
  }
`}
`;
const CurrentSlideIndicatorWrapper = styled.div.withConfig({
    displayName: 'CurrentSlideIndicatorWrapper'
}) `
  display: flex;
  position: absolute;
  top: 100%;
  align-items: center;
  width: fill-available;
  height: 1px;

  ${({ hasPadding }) => hasPadding &&
    `${minMaxScreen(0, BREAKPOINTS.md)}
     {  
      margin: ${calculateSpacing(4)} ${calculateSpacing(3)}
       0 ${calculateSpacing(3)};
     }
      margin:${calculateSpacing(4)} ${calculateSpacing(8)} 0 
      ${calculateSpacing(8)};
    `}
  ${({ theme }) => getColorStyles(theme, 'background', `colors.interactive.base.${isInverted(theme) ? 'dark' : 'light'}`)};
`;
const CurrentSlideIndicator = styled.div.withConfig({
    displayName: 'CurrentSlideIndicator'
}) `
  ${({ theme }) => getColorStyles(theme, 'background', `colors.interactive.base.${isInverted(theme) ? 'white' : 'dark'}`)};

  margin-left: 0;
  height: 2px;

  ${({ slideIndicatorWidth }) => slideIndicatorWidth && `width: ${slideIndicatorWidth}px;`}
`;
const CarouselListAnimations = createGlobalStyle `
  /* Classes for animating the last item (used in onBackHandler) */
  .carousel-last-item-pre-animation {
    transform: translateX(-100%);
    transition: none;
  }

  .carousel-last-item-post-animation {
    transform: translateX(0);
    transition: transform 0.3s ease-out;
  }

  /* Classes for animating the first item (used in onForwardHandler) */
  .carousel-first-item-pre-animation {
    transform: translateX(100%);
    transition: none;
  }

  .carousel-first-item-post-animation {
    transform: translateX(0);
    transition: transform 0.3s ease-out;
  }
`;
const CarouselList = styled.ul.withConfig({ displayName: 'CarouselList' }) `
  display: flex;
  ${({ hasModerateSpacingOnCarousel }) => {
    const defaultSpacing = calculateSpacing(3);
    const top = hasModerateSpacingOnCarousel
        ? calculateSpacing(2)
        : defaultSpacing;
    return `margin: ${top} 0 0 0;`;
}}
  padding: 0;
  list-style: none;
  ${({ hasCircularScrolling }) => hasCircularScrolling
    ? ` overflow: hidden;`
    : `
    -webkit-overflow-scrolling: touch;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x mandatory;
    scroll-behavior: smooth;
    scrollbar-width: none;
    & > * {
      scroll-snap-align: start;
      flex-shrink: 0;
    }
    `}

  ${({ hasUPCMultipleImages }) => hasUPCMultipleImages &&
    `
     &&&{
          margin: 0;
          height: 100%;
          }
   `}

  ${({ hasNoHorizontalScroll }) => hasNoHorizontalScroll &&
    `
    &::-webkit-scrollbar {
      display: none;
    }
    -ms-overflow-style: none; /* IE and Edge */
    scrollbar-width: none; /* Firefox */
  `}
  ${({ isSliderVisible }) => isSliderVisible &&
    css `
      ::-webkit-scrollbar {
        height: 1px;
      }

      ::-webkit-scrollbar-track {
        ${({ theme }) => getColorStyles(theme, 'background', `colors.interactive.base.${isInverted(theme) ? 'dark' : 'light'}`)};
      }

      ::-webkit-scrollbar-thumb {
        ${({ theme }) => getColorStyles(theme, 'background', `colors.interactive.base.${isInverted(theme) ? 'light' : 'dark'}`)};
      }
      /* not yet supported by getColorStyles */
      scrollbar-color: ${({ theme }) => `
    ${getColorToken(theme, `colors.interactive.base.${isInverted(theme) ? 'light' : 'dark'}`)} ${getColorToken(theme, `colors.interactive.base.${isInverted(theme) ? 'dark' : 'light'}`)}`};
      scrollbar-width: auto;
    `}
    @media (min-width: ${BREAKPOINTS.md}) {
    ${({ shouldAlignCenter }) => shouldAlignCenter && `justify-content: center`}
  }
`;
const CarouselListItem = styled.li.withConfig({
    displayName: 'CarouselListItem'
}) `
  flex-shrink: 0;
  align-self: stretch;
  ${getItemSpacing}
  ${getItemWidth}
  scroll-snap-align: start;
  ${({ hasSlider }) => hasSlider && `padding-bottom: ${calculateSpacing()};`}

  ${({ theme, isSpecial }) => {
    if (isSpecial) {
        return `
        border-style: solid;
        border-width: 4px;
        ${getColorStyles(theme, 'border-color', 'colors.interactive.base.black')};
        ${getColorStyles(theme, 'background-color', 'colors.consumption.body.standard.bg-card')};
      `;
    }
    return ``;
}}

  ${({ isTextExternalLink }) => isTextExternalLink &&
    `
     display: flex;              
    justify-content: center;       
    align-items: center;     
    `}
  ${({ isUpcEnabled }) => isUpcEnabled &&
    `
      ${minMaxScreen(0, BREAKPOINTS.md)} {
        ${getItemSpacing({ itemSpacing: calculateSpacing(0.5) })}
      }

      ${minScreen(BREAKPOINTS.md)} {
        ${getItemSpacing({
        itemSpacing: calculateSpacing(1)
    })}
      }
    `}

    ${({ hasUPCMultipleImages }) => hasUPCMultipleImages &&
    `
     &&& {
      margin: 0;
      width: 100%;
      height: 100%;
      :first-child {
        padding: 0;
      }
      :last-child {
        padding: 0;
      }
    }
    `}

 ${({ isSeriesNavigation, isFirstItem }) => isSeriesNavigation &&
    ` 
      ${minMaxScreen(0, BREAKPOINTS.md)} {
        ${getItemSpacing({ itemSpacing: calculateSpacing(1) })}
        width: 176px;
      }

      ${minScreen(BREAKPOINTS.md)} {
        ${getItemSpacing({
        itemSpacing: calculateSpacing(1),
        isFirstItem
    })}
        width: 176px;
      }
    `}
`;
CarouselListItem.defaultProps = {
    itemSpacing: '0px',
    itemWidth: '100%'
};
const getDotFill = ({ isselected, theme, fullpagetheme }) => {
    const hasInvertedTheme = theme.palette === 'inverted' || fullpagetheme === 'inverted';
    if (isselected === 'true') {
        return hasInvertedTheme
            ? getColorStyles(theme, 'fill', 'colors.interactive.base.white')
            : getColorStyles(theme, 'fill', 'colors.interactive.base.black');
    }
    return hasInvertedTheme
        ? getColorStyles(theme, 'fill', 'colors.interactive.base.dark')
        : getColorStyles(theme, 'fill', 'colors.interactive.base.light');
};
const getCursorStyle = ({ dotclickable }) => {
    return dotclickable && 'cursor: pointer;';
};
// reduces dot size when limit is reached preventing overflow
const getDotSize = ({ $isReducedSize }) => {
    return ($isReducedSize &&
        `
    width: ${calculateSpacing(2.2)};
    height: ${calculateSpacing(2.2)};
  `);
};
const getDotOpacity = ({ isselected, $isUpcEnabled, $hasUPCMultipleImages }) => {
    return (isselected === 'false' &&
        $isUpcEnabled &&
        $hasUPCMultipleImages &&
        `
    fill-opacity: 0;
  `);
};
const CarouselDot = styled(DotIcon).withConfig({ displayName: 'CarouselDot' }) `
  ${getDotOpacity}
  ${getDotSize}
  ${getCursorStyle}
  ${getDotFill}
`;
const CarouselVideoDot = styled(playIcon).withConfig({
    displayName: 'CarouselVideoDot'
}) `
  ${getDotOpacity}
  path {
    transform: scale(0.6);
    transform-origin: center;
    stroke-width: 1.5px;
  }
  ${getCursorStyle}
  ${getDotFill}
`;
const CarouselSectionTitle = styled.div.withConfig({
    displayName: 'CarouselSectionTitle'
}) `
  margin: 0 auto ${calculateSpacing(4)};
  ${({ hasDecreasedSectionTitleMargin }) => hasDecreasedSectionTitleMargin &&
    `
    margin: 0 auto ${calculateSpacing(3)};
  `}

  ${({ sectionTitleVariation }) => sectionTitleVariation === 'TextLeftLineAboveWithHedBackground' &&
    `
    && {
      padding-left: 0px;
    }
  `}
  padding-right: ${calculateSpacing(3)};
  padding-left: ${calculateSpacing(3)};
  max-width: ${BREAKPOINTS.lg};

  @media (min-width: ${BREAKPOINTS.lg}) {
    padding-right: ${calculateSpacing(6)};
    padding-left: ${calculateSpacing(6)};
    max-width: ${BREAKPOINTS.xl};
  }

  @media (min-width: ${BREAKPOINTS.xl}) {
    padding-right: ${calculateSpacing(8)};
    padding-left: ${calculateSpacing(8)};
    max-width: ${BREAKPOINTS.xxl};
  }
`;
const CarouselCaption = styled(Caption).withConfig({
    displayName: 'CarouselCaption'
}) `
  margin: ${calculateSpacing(1)} 0 0 ${calculateSpacing(3)};

  @media (min-width: ${BREAKPOINTS.lg}) {
    margin: ${calculateSpacing(2)} 0 0 ${calculateSpacing(4)};
  }
`;
const CarouselListSwipe = styled.div.withConfig({
    displayName: 'CarouselListSwipe'
}) ``;
module.exports = {
    CarouselWrapper,
    CarouselHeader,
    CarouselHeaderDivider,
    CarouselHeaderItemTitle,
    CarouselHeaderItemButton,
    CarouselFooter,
    CarouselFooterItemButton,
    CarouselFooterItemDots,
    CarouselTitle,
    CarouselControlButton,
    CarouselList,
    CarouselDot,
    CarouselListButton,
    CarouselListItem,
    CarouselListWrapper,
    CurrentSlideIndicatorWrapper,
    CurrentSlideIndicator,
    CarouselSectionTitle,
    CarouselCaption,
    CarouselListSwipe,
    CarouselListAnimations,
    CarouselVideoDot
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 86228:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    forwardAriaLabel: {
        id: 'CarouselControls.ForwardAriaLabel',
        defaultMessage: 'Carousel forward',
        description: 'Aria label text for carousel forward'
    },
    backAriaLabel: {
        id: 'CarouselControls.BackAriaLabel',
        defaultMessage: 'Carousel back',
        description: 'Aria label text for carousel back'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 30271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { BREAKPOINTS_RANGE } = __webpack_require__(96472);
const mapBreakpoints = (breakpointObj, callback) => {
    return Object.keys(breakpointObj)
        .filter((key) => {
        return Object.hasOwnProperty.call(BREAKPOINTS_RANGE, key);
    })
        .map((key, index) => {
        const cssValue = callback(key, breakpointObj[key], index);
        return `
      @media (min-width: ${BREAKPOINTS_RANGE[key][0]}) {
        ${cssValue}
      }
     `;
    });
};
const getItemSpacing = ({ isFirstItem, isLastItem, itemSpacing }) => {
    if (typeof itemSpacing === 'string') {
        if (isFirstItem) {
            return `margin: 0 ${itemSpacing} 0 0;`;
        }
        else if (isLastItem) {
            return `margin: 0 0 0 ${itemSpacing};`;
        }
        return `margin: 0 ${itemSpacing};`;
    }
    return mapBreakpoints(itemSpacing, (_, value) => {
        return getItemSpacing({ isFirstItem, isLastItem, itemSpacing: value });
    }).join('\n');
};
const getItemWidth = ({ itemWidth }) => {
    if (typeof itemWidth === 'string')
        return `width: ${itemWidth};`;
    return mapBreakpoints(itemWidth, (_, value) => {
        return getItemWidth({ itemWidth: value });
    }).join('\n');
};
const isScrollAtEnd = (el, hasCircularScrolling) => {
    /*
    Precision errors when used inside a grid.
    Computed width can be a fractional unit.
    Scroll operates with whole numbers.
    Rounding causes scroll left to be 1 more/less
    */
    return (!hasCircularScrolling &&
        el.scrollLeft <= el.scrollWidth - el.offsetWidth + 1 &&
        el.scrollLeft >= el.scrollWidth - el.offsetWidth - 1);
};
const isScrollAtStart = (el, hasCircularScrolling) => {
    return !hasCircularScrolling && el.scrollLeft === 0;
};
module.exports = {
    getItemSpacing,
    getItemWidth,
    isScrollAtEnd,
    isScrollAtStart,
    mapBreakpoints
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 80526:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const debounce = __webpack_require__(38221);
const hoistNonReactStatic = __webpack_require__(4146);
const { interactionResponse } = __webpack_require__(56187);
const { isDesktopBrowser } = __webpack_require__(72362);
const withAnalytics = (Component) => {
    const ComponentWithAnalytics = (props) => {
        const hasDataLayer =  true && window.dataLayer;
        const onBackClick = (event, additionalProps = null) => {
            if (props.onBackClick) {
                props.onBackClick(event);
            }
            if (hasDataLayer && additionalProps) {
                window.dataLayer.push({
                    event: 'carousel-left-arrow-click',
                    ...additionalProps
                });
            }
            if (hasDataLayer && !additionalProps) {
                window.dataLayer.push({ event: 'carousel-left-arrow-click' });
            }
        };
        const onForwardClick = async (event, additionalProps = null) => {
            if (props.onForwardClick) {
                props.onForwardClick(event);
            }
            if (hasDataLayer) {
                await interactionResponse();
                window.dataLayer.push({
                    event: 'carousel-right-arrow-click',
                    ...(additionalProps || {})
                });
            }
        };
        const onScrollDebounce = debounce((additionalProps) => {
            if (hasDataLayer && !isDesktopBrowser()) {
                window.dataLayer.push({
                    event: 'carousel-swipe',
                    ...(additionalProps || {})
                });
            }
        }, 300);
        const onScroll = (additionalProps = null) => {
            if (props.onScroll) {
                props.onScroll();
            }
            onScrollDebounce(additionalProps);
        };
        const gtmTrackOnClick = async (event, actionId, image_index, type) => {
            if (props.gtmTrackOnClick) {
                await interactionResponse();
                props.gtmTrackOnClick(event, actionId, image_index, type);
            }
        };
        return (React.createElement(Component, { ...props, onBackClick: onBackClick, onForwardClick: onForwardClick, onScroll: onScroll, gtmTrackOnClick: gtmTrackOnClick }));
    };
    ComponentWithAnalytics.propTypes = {
        gtmTrackOnClick: PropTypes.func,
        onBackClick: PropTypes.func,
        onForwardClick: PropTypes.func,
        onScroll: PropTypes.func
    };
    hoistNonReactStatic(ComponentWithAnalytics, Component);
    return ComponentWithAnalytics;
};
module.exports = withAnalytics;
//# sourceMappingURL=withAnalytics.js.map

/***/ }),

/***/ 59098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { injectIntl } = __webpack_require__(46984);
const { connect: connectToStore } = __webpack_require__(67851);
const { useContext, useEffect } = React;
const { TeaserVariationWrapper, TEASER_VARIATIONS } = __webpack_require__(21221);
const { StickyVariationWrapper, VARIATIONS } = __webpack_require__(64911);
const { TrackComponentChannel } = __webpack_require__(78788);
const useLazyLoadComponent = __webpack_require__(70920);
const { STICKY_PLAYER_EVENTS, STICKY_VARIATION_POSITIONS } = __webpack_require__(8379);
const Caption = __webpack_require__(14760);
const { appendQueryToURI, parseQueryParams } = __webpack_require__(12311);
const { initWindowCne, PlayerProxy } = __webpack_require__(34446);
const { CneVideoEmbedFigure } = __webpack_require__(86078);
const { ConsentContext } = __webpack_require__(85438);
const VIDEO_EMBED_POSITIONS = __webpack_require__(62327);
const { BREAKPOINTS } = __webpack_require__(96472);
let counter = 0;
function usePrevious(value) {
    const ref = React.useRef();
    useEffect(() => {
        ref.current = value;
    }, [value]);
    return ref.current;
}
function generateCallbackName(prefix) {
    return `${prefix}${Date.now()}${counter++}`;
}
/**
 * Validate and return an onReady callback name, ensuring that it exists on _cne.window
 *
 * a system is in place on the player to handle multiple onReady callbacks that can be set
 * in different locations for different purposes, thus the need for this check, rather than
 * simply generating a new callback name
 *
 * @param {string} onReady - an onReady prop that needs to be validated
 *
 * @returns {string} - either the validated onReady or a randomly generated one
 */
function getOnReadyCallbackName(onReady) {
    const windowCne = initWindowCne();
    if (onReady && typeof windowCne[onReady] === 'function') {
        return onReady;
    }
    return generateCallbackName('onReady');
}
/**
 * CNEVideoEmbedConsentProvider component
 *
 * @description This React component is used to track consent information using ConsentContext hook
 *              and pass the updated information to parent component.
 *              The purpose of this component is to provide access to updated consent from hook to
 *              a class component.
 *
 * @param {Function} [onConsentChange] - Function used to pass updated consent to parent component
 */
function CNEVideoEmbedConsentProvider({ onConsentChange }) {
    const consentContext = useContext(ConsentContext);
    useEffect(() => {
        onConsentChange(consentContext);
    }, [onConsentChange, consentContext]);
    return React.createElement(React.Fragment, null);
}
CNEVideoEmbedConsentProvider.displayName = 'CNEVideoEmbedConsentProvider';
CNEVideoEmbedConsentProvider.propTypes = {
    onConsentChange: PropTypes.func
};
/**
 * CNEVideoEmbed component
 *
 * @param {object} props - React props
 * @param {boolean} [props.shouldByPassLazyLoading] - Optional flag to trun on/off the lazy loading.
 * @param {string} [props.className] - Optional top-level class to add.
 * @param {string} [props.dangerousCaption] - Optional caption to place under video.
 * @param {boolean} [props.hasNoBottomMarginForCneVideo] - Optional flag to remove bottom margin for cnevideo
 * @param {boolean} [props.isBundle] - indicates if video is an item that is part of a bundle page
 * @param {boolean} [props.isTitleLeftAligned] - indicates if header and video title should be left aligned
 * @param {Function} [props.onVideoChange] - Optional function that gets called with video when video loads or changes.
 * @param {string} props.scriptUrl - protocol-relative URI for a script which instantiates the player iframe and loads a video
 * @param {boolean} [props.shouldAutoplay] - Optional flag to autoplay video. Defaults to true.
 * @param {string} [props.shouldDisableAds] - Optional shouldDisableAds to disable ads of video.
 * @param {boolean} [props.shouldEnableExternalControl] - Optional flag to control play/pause through parent component.
 * @param {boolean} [shouldLoopVideo] - Optional flag to loop play videos after a video ends. Defaults to false.
 * @param {boolean} [props.shouldMute] - Optional flag to mute video on playback. Defaults to true.
 * @param {boolean} [props.shouldPause] - Optional flag to pause video. Defaults to false.
 * @param {boolean} [props.shouldPlayContinuously] - Optional flag to continuously play videos after a video ends. Defaults to true.
 * @param {boolean} [props.shouldSkipAdPrefetch_variation] - Optional flag to disable vast video ad prefetch. Defaults to false.
 * @param {boolean} [props.shouldSkipAdPrebid_variation] - Optional flag to disable prebid ad request. Defaults to false.
 * @param {Function} [props.registerTracker] - Function used to pass tracking function to parent component
 * @param {object} [props.user] - Object containing user authentication information `{ isAuthenticated: true }`
 * @param {string} [props.videoIdToLoad] - Allows you to load a different video into the player. This component must be loaded by a script first.
 * @param {string} [props.videoEmbedPosition] - indicates the position/type of the video player on the page
 * @param {string} [props.tags] - Page tags
 *
 * @returns {ReactElement} <CneVideoEmbedFigure>
 */
const CNEVideoEmbed = ({ scriptUrl, videoIdToLoad, onVideoChange = () => { }, onVideoLoad = () => { }, shouldGoFullScreenOnPlay, onVideoEnded = () => { }, shouldHaveTeaser = false, isStickyType, stickyTags, tags, animationClip, categories, functionalTags, isBundle = false, isLive, isRightRail = false, positionInstance = 0, shouldAutoplay = true, shouldDisableAds, shouldLoopVideo, shouldMute = true, shouldPlayContinuously = true, shouldSkipAdPrebid_variation = false, shouldSkipAdPrefetch_variation = false, title, videoEmbedPosition = '', additionalEmbedParams = {}, variations, variationName, registerTracker = () => { }, dangerousCaption, className, hasMargins = true, hasNoBottomMarginForCneVideo, isTitleLeftAligned = false, stickyImage, style, shouldPause = false, shouldEnableExternalControl = false, shouldByPassLazyLoading = false, hasCNEVideoInProductCard = false, upcId }) => {
    const videoEmbedRef = React.useRef(null);
    const containerRef = React.useRef(null);
    const player = React.useRef(new PlayerProxy());
    const getQueryParams = (scriptUrl) => {
        // scriptUrl is a required prop, but it seems like it can be missing sometimes
        if (!scriptUrl)
            return {};
        const [, queryString] = scriptUrl.split('?');
        return queryString ? parseQueryParams(`?${queryString}`) : {};
    };
    const params = getQueryParams(scriptUrl);
    const fullBleedTeaserQueryParam = params.fullBleedTeaser === '1' ? 'FullBleedTeaser' : undefined;
    const [live, setLive] = React.useState(false);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [videoTitle, setVideoTitle] = React.useState('');
    const [userCancel, setUserCancel] = React.useState(false);
    const [isCurrentlySticky, setIsCurrentlySticky] = React.useState(false);
    const [isPausedByModal, setIsPausedByModal] = React.useState(false);
    const [isPlaylist, setIsPlaylist] = React.useState(false);
    const [showTeaser, setShowTeaser] = React.useState(false);
    const [aspectRatio, setAspectRatio] = React.useState();
    const [aspectRatioString, setAspectRatioString] = React.useState();
    const [teaser, setTeaser] = React.useState({});
    const [lazyLoadElementRef, shouldLoadComponent] = useLazyLoadComponent(!shouldByPassLazyLoading);
    const prevVideoIdToLoad = usePrevious(videoIdToLoad);
    /* We've added 'istanbul ignore next' here because another team added the next useEffect.
    We'd like to ask them to extract the logic inside useEffect() to an external file, and create a test file for it, since we're not sure how to test it. */
    /* istanbul ignore next */
    useEffect(() => {
        if (!hasCNEVideoInProductCard)
            return;
        const figureElement = videoEmbedRef?.current;
        if (!figureElement)
            return;
        const iframe = figureElement.querySelector('iframe');
        if (!iframe)
            return;
        const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
        if (hasCNEVideoInProductCard) {
            const appendScriptToIframe = () => {
                if (!iframeDocument.body) {
                    // Wait for the iframe body to load
                    const observer = new MutationObserver(() => {
                        if (iframeDocument.body) {
                            observer.disconnect();
                            appendScriptToIframe(); // Retry appending the script
                        }
                    });
                    observer.observe(iframeDocument, { childList: true, subtree: true });
                    return;
                }
                // Check if the script is already appended
                if (iframeDocument.getElementById('cne-video-events-script'))
                    return;
                const script = document.createElement('script');
                script.id = 'cne-video-events-script'; // Unique ID to prevent duplicates
                script.textContent = `
            window.touchStartPos = { x: 0, y: 0 };
            window.touchStartTime = null;
            window.eventId = 0;
            window.isTouchMoveScheduled = false;
            window.touchMoveTimeout = null;
      
            window.addEventListener("touchstart", (e) => {
              const x = e.targetTouches[0]?.clientX || 0;
              const y = e.targetTouches[0]?.clientY || 0;
              window.touchStartPos = { x, y };
              window.touchStartTime = Date.now();
              window.eventId = Math.random().toString(36).substr(2, 9);
      
              window.parent.postMessage(
                { name: "cnevideoevent", type: "touchstart", x, y, eventId: window.eventId, upcId: "${upcId}" },
                "*"
              );
            });
      
            window.addEventListener("touchmove", (e) => {
              e.preventDefault();
              if (window.isTouchMoveScheduled) return;
      
              window.isTouchMoveScheduled = true;
              requestAnimationFrame(() => {
                const x = e.targetTouches[0]?.clientX || 0;
                const y = e.targetTouches[0]?.clientY || 0;
      
                window.parent.postMessage(
                  { name: "cnevideoevent", type: "touchmove", x, y, eventId: window.eventId, upcId: "${upcId}" },
                  "*"
                );
      
                window.isTouchMoveScheduled = false;
      
                clearTimeout(window.touchMoveTimeout);
                window.touchMoveTimeout = setTimeout(() => {
                  const lastX = e.targetTouches[0]?.clientX || 0;
                  const lastY = e.targetTouches[0]?.clientY || 0;
                  const dx = lastX - window.touchStartPos.x;
                  const dy = lastY - window.touchStartPos.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  const duration = Date.now() - (window.touchStartTime || Date.now());
      
                  window.parent.postMessage(
                    {
                      name: "cnevideoevent",
                      type: "touchend",
                      x: lastX,
                      y: lastY,
                      dx,
                      dy,
                      distance,
                      duration,
                      eventId: window.eventId,
                      upcId: "${upcId}"
                    },
                    "*"
                  );
      
                  window.touchStartPos = { x: 0, y: 0 };
                  window.touchStartTime = null;
                  window.eventId = 0;
                }, 100);
              });
            }, { passive: false });
      
            window.addEventListener("touchend", (e) => {
              if (window.touchStartTime === null) return;
      
              const x = e.changedTouches[0]?.clientX || 0;
              const y = e.changedTouches[0]?.clientY || 0;
              const dx = x - window.touchStartPos.x;
              const dy = y - window.touchStartPos.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const duration = Date.now() - window.touchStartTime;
              const TIME_THRESHOLD = 10;
      
              if (duration > TIME_THRESHOLD) {
                window.parent.postMessage(
                  { name: "cnevideoevent", type: "touchend", x, y, dx, dy, distance, duration, eventId: window.eventId, upcId: "${upcId}" },
                  "*"
                );
              }
      
              window.touchStartPos = { x: 0, y: 0 };
              window.touchStartTime = null;
              window.eventId = 0;
            });
          `;
                iframeDocument.body.appendChild(script);
            };
            // Check if the iframe is already loaded
            if (iframeDocument.readyState === 'complete' || iframeDocument.body) {
                appendScriptToIframe();
            }
            else {
                // Wait for iframe to fully load
                iframeDocument.addEventListener('DOMContentLoaded', appendScriptToIframe);
            }
        }
        const videoJsElement = iframeDocument.querySelector('.video-js');
        if (videoJsElement)
            videoJsElement.style.paddingTop = '0px';
    });
    /**
     * Helper function to set the infos required for the
     * sticky variation or teaser variation
     *
     * @param {object} currentVideo - the current video object
     *
     * @returns {void} undefined
     */
    const setTeaserInfo = (currentVideo) => {
        const { title, categories, live_metadata, animated_clip_url_mp4, animated_clip_url_high_mp4, animated_clip_url_webm, animated_clip_url_high_webm, animated_clip_still } = currentVideo;
        // set title and teaser coming from video component
        setVideoTitle(title);
        setLive(!!live_metadata?.is_currently_broadcasting);
        setTeaser({
            title,
            category: categories?.[0] || null,
            animated_clip_url_mp4,
            animated_clip_url_high_mp4,
            animated_clip_url_webm,
            animated_clip_url_high_webm,
            isLive: !!live_metadata?.is_currently_broadcasting,
            animated_clip_still
        });
        // to have the teaser enabled we need to have the animated clips.
        // if, for some reason, they are not available, we'll disable the teaser
        if (!animated_clip_url_high_mp4 && !animated_clip_url_high_webm) {
            setShowTeaser(false);
        }
    };
    /**
     * Fires on "cne:video:current", updates the component with
     *   the current video details and calls any passed in `onVideoChange`
     *   hooks.
     *
     * @param {object} video - the current video object
     * @returns {void} undefined
     */
    const handleVideoChange = (video) => {
        setTeaserInfo(video);
        setAspectRatioString(video.aspect_ratio);
        onVideoChange(video);
    };
    /**
     * Proxy for the CN player object's private `_trackCNESparrow` method
     *   which serves to track information in CN's sparrow account using
     *   the CN player's tracking system
     *
     * @param {string} type - the "type" for tracking (maps to _t in sparrow)
     * @param {string} category - the "category" for tracking (maps to _c in sparrow)
     * @param {object} [meta] - Optional additional information to be included in the tracking url
     * @returns {undefined} undefined
     */
    const track = (type, category, meta = {}) => {
        player.current._trackCNESparrow(type, category, meta);
    };
    /**
     * Fires when:
     * 1. user click on the button in the teaser variation
     * 2. after 5 seconds timeout, in the teaser variation
     *
     * @param  {bool} userClicked - check if user clicked on button
     * @returns {undefined} undefined
     */
    const onHideTeaser = (userClicked = false) => {
        if (userClicked) {
            player.current.volume(0.5);
        }
        setShowTeaser(false);
    };
    /**
     * Proxy for the CN player object's private `_markCurrentlySticky` method
     *   which serves to:
     *   - toggle a state value to include in any tracking calls
     *   - hide certain player UI elements
     *
     * @param {boolean} value - should the player be marked sticky? (player sticks in fixed position)
     * @returns {undefined} undefined
     */
    const markCurrentlySticky = (value) => player.current._markCurrentlySticky(value);
    /**
     * Fires when the sticky variation has a sticky change event
     *
     * @param  {string} event - event as defined in STICKY_PLAYER_EVENTS
     * @returns {undefined} undefined
     */
    const onStickyEvent = (event) => {
        if (event === STICKY_PLAYER_EVENTS.START ||
            event === STICKY_PLAYER_EVENTS.STOP) {
            const currentlySticky = event === STICKY_PLAYER_EVENTS.START;
            // don't track start/stop unless it has changed (to avoid initial calls)
            if (currentlySticky !== isCurrentlySticky) {
                markCurrentlySticky(currentlySticky);
                track(event, 'Sticky Player Event');
                setIsCurrentlySticky(currentlySticky);
            }
        }
        else {
            track(event, 'Sticky Player Event');
        }
    };
    /**
     * Proxy for the CN player object's private `_onConsentUpdated` method
     *   which serves to:
     *   - enable/disable tracking based on provided consent
     *
     * @param value - {
     *       functional: bool,
     *       performance: bool,
     *       socialMedia: bool,
     *       strictlyNecessary: bool,
     *       targeting: bool
     * }
     */
    const onConsentUpdated = (value) => player.current._onConsentUpdated(value);
    /**
     * Fires on "iframeReady", and calls the onVideoLoad hook with
     * the container node as the parameter
     *
     * @returns {undefined} undefined
     */
    const handleIframeReady = () => {
        const videoContainerEl = videoEmbedRef?.current;
        onVideoLoad(videoContainerEl);
    };
    /**
     * Convenience method to clear the effect of user cancel when an
     *   overriding event fires
     *
     * @returns {undefined} undefined
     */
    const clearCancel = () => setUserCancel(false);
    /**
     * Open the passed in element (video) in fullscreen.
     * Note that we must include prefixes for different browsers, as they don't support the requestFullscreen property yet
     *
     * @param {object} element - the element to set to full screen
     * @returns {void} undefined
     */
    const openFullscreen = (element) => {
        if (element.requestFullscreen) {
            element.requestFullscreen();
        }
        else if (element.webkitRequestFullscreen) {
            /* Safari */
            element.webkitRequestFullscreen();
        }
        else if (element.msRequestFullscreen) {
            /* Safari */
            element.msRequestFullscreen();
        }
    };
    /**
     * Fires on "cne:is-playing", and updates the state accordingly.
     *   - player must be playing to become persistent
     *   - clears the result of any previous cancellation
     *   - calls openFullscreen with the video player element if video is playing and `shouldGoFullScreenOnPlay` is `true`
     *
     * @param {boolean} isPlaying - is the player playing?
     * @returns {undefined} undefined
     */
    const handleIsPlaying = (isPlaying) => {
        if (isPlaying && isPausedByModal) {
            player.current.pause();
            return;
        }
        setIsPlaying(isPlaying);
        isPlaying &&
            shouldGoFullScreenOnPlay &&
            openFullscreen(videoEmbedRef.current);
        clearCancel();
    };
    /**
     * Removes player from "persistence" when the "_coordinator:cancel-persist"
     *   event is fired on the player object
     *
     * @returns {undefined} undefined
     */
    const handleExternalPersistentCancel = () => setUserCancel(true);
    /**
     * listenForModalEvents - this function subscribes to the journey bus to
     * listen for Journey units that are rendered with modals. When a modal
     * is rendered the player is paused. When a modal is removed, playing is
     * resumed.
     */
    const listenForModalEvents = () => {
        if (!window.jBus)
            return;
        window.jBus.whenAnEventOccurs({
            id: 'journey.unit.render.begin',
            payload: { data: { isModalPresent: true } },
            callback: () => {
                setIsPausedByModal(true);
                player.current.pause();
            }
        });
        window.jBus.whenAnEventOccurs({
            id: 'journey.unit.empty.begin',
            payload: { data: { isModalPresent: true } },
            callback: () => {
                setIsPausedByModal(false);
                player.current.play();
            }
        });
    };
    /**
     * Retrieves and sets player object from onReady callback and sets up
     *   player event listeners.
     *
     * Event name mapping: https://github.com/cnerepo/player-frontend/blob/3dace7836bae80cfb8bac4818161bd7c37c06f8c/src/js/sinks/cneEvent/streams.js#L21-L31
     *
     * @param  {object} playerInstance - The player object returned from player callback
     * @returns {undefined} undefined
     */
    const setupPlayerEvents = (playerInstance) => {
        if (player.current && player.current.flush) {
            player.current.flush(playerInstance);
        }
        player.current = playerInstance;
        // for live video, we can have a very slow cne:video:current event or no event at all
        // so we need to check for the existence of an animatedClip and disable the teaser variable
        const currentVideo = playerInstance?.currentVideo();
        if (currentVideo) {
            setTeaserInfo(currentVideo);
            setAspectRatioString(currentVideo.aspect_ratio);
        }
        // 'cne:video:current': fired as soon as the current video is "known" by
        //    the CN player. This happens at the beginning of the player cycle
        //    and every time the video changes.
        player.current.on('cne:video:current', handleVideoChange);
        // 'cne:is-playing': fired whenever the playing state changes in the CN player
        player.current.on('cne:is-playing', handleIsPlaying);
        // '_coordinator:cancel-persistent': private event fired by the player coordinator
        //    singleton whenever a second video on the page starts playing.
        player.current.on('_coordinator:cancel-persistent', handleExternalPersistentCancel);
        player.current.on('cne:video:end', onVideoEnded);
        listenForModalEvents();
    };
    /**
     * Helper function to return the name of the teaser variation,
     * if set on copilot page
     *
     * @returns {string} the name of the teaser variation
     */
    const getTeaserVariation = () => {
        const availableTeaserVariations = Object.keys(TEASER_VARIATIONS);
        const functionalTagsArray = functionalTags?.split('|') || [];
        if (fullBleedTeaserQueryParam)
            functionalTagsArray.push(fullBleedTeaserQueryParam);
        return functionalTagsArray.find((tag) => {
            return availableTeaserVariations.includes(tag);
        });
    };
    /**
     * Helper function to return the name of the teaser variation,
     * if available as variation and found in copilot page as functionalTag
     *
     * @returns {boolean} true if this video is requested with a teaser
     */
    const shouldActivateTeaser = () => {
        const hasTeaserTag = (shouldHaveTeaser || fullBleedTeaserQueryParam) && !!getTeaserVariation();
        return hasTeaserTag;
    };
    /**
     * Helper function to return idOverride, set in copilot as functional tag,
     * to use it for stream on mobile
     *
     * @param functionalTags - the values read from copilot
     * @returns {string} the id of the video
     */
    const getCNEVerticalVideoIdOverride = (functionalTags) => {
        const functionalTagsArray = functionalTags?.split('|') || [];
        const textToSearch = 'CNEVerticalVideoIdOverride-';
        let idOverride = null;
        functionalTagsArray.forEach((item) => {
            if (item.startsWith(textToSearch))
                idOverride = item.replace(textToSearch, '');
        });
        return idOverride;
    };
    const isFullBleedVideo = (functionalTags, videoEmbedPosition, isBundle) => {
        const functionalTagsArray = functionalTags?.split('|') || [];
        const tagsToSearch = ['FullBleedTeaser', 'FullBleedNoTeaser'];
        const isEligible = videoEmbedPosition === VIDEO_EMBED_POSITIONS.storyVideoPosition ||
            isBundle;
        return (functionalTagsArray.some((tag) => tagsToSearch.includes(tag)) &&
            isEligible);
    };
    /**
     * Helper function to determine if we can use the animationClip and if we can activate
     * as soon as possibile the teaser, without waiting for the player-frontend callback
     *
     * @param {*} animationClip - the animationClip used for the teaser
     * @param {Array} categories - categories of the video
     * @param {boolean} isLive - true if the video is a live one
     * @param {*} queryParams - the params object to append to the CNE player frontend
     * @param {string} title - title of the video
     */
    const checkAnimationClipAndTeaser = ({ animationClip = null, categories = [], isLive = false, title = '', queryParams = {} }) => {
        // we don't have animationClips but we need the teaser
        // in this case, all info about the teaser will come from the CNE player frontend call
        if ((!animationClip ||
            animationClip?.lowResUrl === '' ||
            animationClip?.highResUrl === '') &&
            getTeaserVariation() &&
            shouldActivateTeaser()) {
            setShowTeaser(true);
            queryParams.hasTeaser = true;
        }
        else if (animationClip &&
            getTeaserVariation() &&
            shouldActivateTeaser()) {
            // we have the animationClips and we want to activate the fullbleedteaser
            // in this case, we use the animatonClips while calling the CNE player frontend to obtain the real video
            setShowTeaser(true);
            setTeaser({
                animated_clip_still: null,
                animated_clip_url_mp4: animationClip.lowResUrl,
                animated_clip_url_high_mp4: animationClip.highResUrl,
                animated_clip_url_webm: null,
                animated_clip_url_high_webm: null,
                category: categories?.[0] || null,
                isLive,
                title
            });
            queryParams.hasTeaser = true;
        }
    };
    /**
     * Proxy for the CN player object's public `pause` method
     *   which serves to pause the player
     *
     * @returns {undefined} undefined
     */
    const pause = () => player.current.pause();
    /**
     * Proxy for the CN player object's public `play` method
     *   which serves to play the player
     *
     * @returns {undefined} undefined
     */
    const play = () => player.current.play();
    /**
     * Helper function to return if the player should have sticky functionality
     *
     * @returns {boolean} true if this video embed has the ability to be sticky
     */
    const shouldBeSticky = () => {
        const queryParams = getQueryParams(scriptUrl);
        if (!scriptUrl || scriptUrl.indexOf('/playlist/') >= 0) {
            return false;
        }
        const hasStickyQueryParam = queryParams.isStickyType && queryParams.isStickyType !== 'false';
        const hasStickyTag = stickyTags?.length && tags?.length
            ? tags.some((tag) => stickyTags.includes(tag))
            : false;
        return (isStickyType || // if parent provides isStickyType prop
            hasStickyQueryParam || // if has "?isSticky=true" query param
            hasStickyTag // if page tags has sticky tag specified in brand config
        );
    };
    React.useEffect(() => {
        // scriptUrl is a required prop, but it seems like it can be missing sometimes
        if (!scriptUrl)
            return;
        const params = getQueryParams(scriptUrl);
        let baseUrl = scriptUrl.split('?')[0];
        const idOverride = getCNEVerticalVideoIdOverride(functionalTags);
        const onReady = getOnReadyCallbackName(params.onReady);
        const onIframeReady = generateCallbackName('onIframeReady');
        if (baseUrl.includes('playlist')) {
            setIsPlaylist(true);
        }
        window[onReady] = setupPlayerEvents;
        window[onIframeReady] = handleIframeReady;
        const queryParams = {
            autoplay: shouldAutoplay ? 1 : 0,
            muted: shouldMute,
            continuousPlay: shouldPlayContinuously ? 1 : 0,
            ...params,
            onReady,
            isFullBleed: isFullBleedVideo(functionalTags, videoEmbedPosition, isBundle),
            isRightRail,
            onIframeReady,
            ...additionalEmbedParams
        };
        if (shouldBeSticky()) {
            const stickyPosition = variations?.stickyVariation || variationName?.stickyVariation;
            queryParams.isStickyType = true;
            queryParams.stickyPosition = STICKY_VARIATION_POSITIONS[stickyPosition];
        }
        checkAnimationClipAndTeaser({
            animationClip,
            categories,
            queryParams,
            isLive,
            title
        });
        if (Object.values(VIDEO_EMBED_POSITIONS).includes(videoEmbedPosition)) {
            queryParams.videoEmbedPosition = videoEmbedPosition;
        }
        if (shouldSkipAdPrefetch_variation) {
            queryParams.disableVastPrefetch = true;
        }
        if (shouldSkipAdPrebid_variation) {
            queryParams.disableVideoPrebid = true;
        }
        if (positionInstance > 0) {
            queryParams.positionInstance = positionInstance;
        }
        if (shouldLoopVideo !== null && shouldLoopVideo !== undefined) {
            queryParams.loopVideo = shouldLoopVideo;
        }
        if (shouldDisableAds !== null && shouldDisableAds !== undefined) {
            queryParams.adsDisabled = shouldDisableAds;
        }
        if (idOverride &&
            !baseUrl.includes('playlist') &&
            queryParams.hasTeaser &&
            window.matchMedia(`(max-width: ${BREAKPOINTS.md})`).matches) {
            const regex = /\/\/(.*)\/video\/(.*).js/gm;
            const m = regex.exec(baseUrl);
            if (m && m.length === 3) {
                baseUrl = `//${m[1]}/video/${idOverride}.js`;
            }
        }
        if (shouldLoadComponent) {
            const src = appendQueryToURI(baseUrl, queryParams);
            const script = document.createElement('script');
            script.src = src;
            script.async = true;
            // Make sure script comes before caption
            containerRef.current.insertBefore(script, containerRef.current.firstChild);
            registerTracker(track);
        }
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'CNEVideoEmbed'
        });
        // eslint-disable-next-line consistent-return
        return () => {
            window[onReady] && delete window[onReady];
            window[onIframeReady] && delete window[onIframeReady];
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [shouldLoadComponent]);
    React.useEffect(() => {
        // Only load a new video if this prop was previously set
        // This ensures backwards compat for existing clients of this component
        // Note that this will not work if the player is not initially loaded by a script
        if (player &&
            player.current.load &&
            prevVideoIdToLoad &&
            videoIdToLoad &&
            prevVideoIdToLoad !== videoIdToLoad) {
            player.current.load(videoIdToLoad, true);
            // second param `true` indicates to player that adsManager needs to be reinitialized
        }
        if (player && isPlaying && shouldPause) {
            player.current.pause();
        }
        if (shouldEnableExternalControl) {
            if (player && player.current.currentVideo) {
                if (!isPlaying && !shouldPause) {
                    player.current.play();
                }
                if (shouldMute) {
                    player.current.volume(0);
                }
                else {
                    player.current.volume(0.5);
                }
            }
        }
    }, [
        videoIdToLoad,
        shouldPause,
        shouldEnableExternalControl,
        shouldMute,
        isPlaying,
        prevVideoIdToLoad,
        player
    ]);
    React.useEffect(() => {
        const aspectRatioParam = params?.aspectRatio || aspectRatioString;
        if (!/^[1-9](\d?)+x[1-9](\d?)+$/.test(aspectRatioParam)) {
            setAspectRatio(1.7777777777777777);
        }
        else {
            const [w, h] = aspectRatioParam.split('x');
            setAspectRatio(w / h);
        }
    }, [aspectRatioString, params]);
    /* istanbul ignore next */
    const handleViewportVisibility = React.useCallback((entries) => {
        if (!hasCNEVideoInProductCard ||
            !videoEmbedRef?.current ||
            !player?.current)
            return;
        // Destructure player.current for readability
        const { current: playerCurrent } = player;
        // If player.current is not available, exit early
        if (!playerCurrent)
            return;
        entries.forEach((entry) => {
            const { intersectionRatio } = entry;
            const isVideoPlaying = playerCurrent.isPlaying() ?? false;
            const isMostlyOutOfViewport = intersectionRatio < 0.3;
            if (isMostlyOutOfViewport && isVideoPlaying) {
                playerCurrent.pause();
                playerCurrent.volume(0);
            }
            else if (!isMostlyOutOfViewport && !isVideoPlaying) {
                playerCurrent.play();
                playerCurrent.volume(0);
            }
        });
    }, [hasCNEVideoInProductCard] // Only re-run when this value changes
    );
    useEffect(() => {
        const videoElement = videoEmbedRef?.current;
        // Create an Intersection Observer to track the visibility of the video
        const observer = new IntersectionObserver(handleViewportVisibility, {
            threshold: [0, 0.3, 0.5, 0.75, 1],
            rootMargin: '0px 0px -20% 0px' // Optional: Adjust margins if needed
        });
        if (videoElement) {
            observer.observe(videoElement); // Start observing the video element
        }
        // Clean up observers when the component is unmounted or handleViewportVisibility changes
        return () => {
            if (videoElement) {
                observer.unobserve(videoElement);
            }
            observer.disconnect(); // Disconnect the observer completely to avoid memory leaks
        };
    }, [handleViewportVisibility]); // Re-run effect when `handleViewportVisibility` changes
    return (React.createElement("div", { ref: lazyLoadElementRef, "data-testid": "cnevideoembed" },
        React.createElement(TeaserVariationWrapper, { "data-testid": "teaser-wrapper", variation: getTeaserVariation(), config: {
                onHideTeaser,
                aspectRatio,
                fullBleedTeaserQueryParam,
                isCurrentlySticky,
                isTeaserPlaying: showTeaser,
                shouldActivateTeaser: shouldActivateTeaser(),
                teaser
            } },
            React.createElement(CneVideoEmbedFigure, { ref: videoEmbedRef, className: classnames('cne-video-embed', className), style: style, aspectRatio: aspectRatio, isTeaserPlaying: showTeaser, hasMargins: hasMargins && !isRightRail, hasNoBottomMarginForCneVideo: hasNoBottomMarginForCneVideo, isRightRail: isRightRail, isTitleLeftAligned: isTitleLeftAligned, isPlaylist: isPlaylist, shouldActivateTeaser: shouldActivateTeaser(), "data-testid": "video-embed-figure", "data-has-margins": isRightRail ? false : hasMargins, "data-is-right-rail": isRightRail, "data-is-sticky-type": shouldBeSticky(), "data-is-teaser-playing": showTeaser, "data-is-playing": isPlaying, "data-is-live": live, "data-is-playlist": isPlaylist, "data-video-title": videoTitle },
                React.createElement(StickyVariationWrapper, { "data-testid": "sticky-wrapper", shouldBeSticky: shouldBeSticky(), stickyConfig: {
                        onPause: pause,
                        onPlay: play,
                        onStickyEvent,
                        video: {
                            title: videoTitle
                        },
                        aspectRatio,
                        isUserCanceled: userCancel,
                        isPlaying,
                        isLive: live,
                        stickyImage,
                        stickyTags
                    }, variation: variations?.stickyVariation || variationName?.stickyVariation }, shouldLoadComponent && (React.createElement("div", { ref: containerRef, id: "video-container", "data-testid": "script-container" }))),
                dangerousCaption && (React.createElement(Caption, { dangerousCaptionText: dangerousCaption, className: "cne-video-embed__caption" })),
                React.createElement(CNEVideoEmbedConsentProvider, { onConsentChange: onConsentUpdated })))));
};
CNEVideoEmbed.propTypes = {
    // Available params: https://github.com/cnerepo/player-frontend/blob/master/src/embed/util/parseEmbedParams.js#L27-L80
    additionalEmbedParams: PropTypes.shape({
        cntPlatform: PropTypes.string,
        pageType: PropTypes.string
    }),
    animationClip: PropTypes.shape({
        highResUrl: PropTypes.string,
        lowResUrl: PropTypes.string
    }),
    categories: PropTypes.arrayOf(PropTypes.string),
    className: PropTypes.string,
    dangerousCaption: PropTypes.string,
    functionalTags: PropTypes.string,
    hasCNEVideoInProductCard: PropTypes.bool,
    hasMargins: PropTypes.bool,
    hasNoBottomMarginForCneVideo: PropTypes.bool,
    isBundle: PropTypes.bool,
    isLive: PropTypes.bool,
    isRightRail: PropTypes.bool,
    isStickyType: PropTypes.bool,
    isTitleLeftAligned: PropTypes.bool,
    onVideoChange: PropTypes.func,
    onVideoEnded: PropTypes.func,
    onVideoLoad: PropTypes.func,
    positionInstance: PropTypes.number,
    registerTracker: PropTypes.func,
    scriptUrl: PropTypes.string.isRequired,
    shouldAutoplay: PropTypes.bool,
    shouldByPassLazyLoading: PropTypes.bool,
    shouldDisableAds: PropTypes.bool,
    shouldEnableExternalControl: PropTypes.bool,
    shouldGoFullScreenOnPlay: PropTypes.bool,
    shouldHaveTeaser: PropTypes.bool,
    shouldLoopVideo: PropTypes.bool,
    shouldMute: PropTypes.bool,
    shouldPause: PropTypes.bool,
    shouldPlayContinuously: PropTypes.bool,
    shouldSkipAdPrebid_variation: PropTypes.bool,
    shouldSkipAdPrefetch_variation: PropTypes.bool,
    stickyImage: PropTypes.string,
    stickyTags: PropTypes.arrayOf(PropTypes.string),
    style: PropTypes.object,
    tags: PropTypes.arrayOf(PropTypes.string),
    title: PropTypes.arrayOf(PropTypes.string),
    upcId: PropTypes.string,
    variationName: PropTypes.shape({
        stickyVariation: PropTypes.oneOf(Object.keys(VARIATIONS))
    }),
    variations: PropTypes.shape({
        stickyVariation: PropTypes.oneOf(Object.keys(VARIATIONS)),
        teaserVariation: PropTypes.oneOf(Object.keys(TEASER_VARIATIONS))
    }),
    videoEmbedPosition: PropTypes.oneOf(Array.from([...Object.values(VIDEO_EMBED_POSITIONS), ''])),
    videoIdToLoad: PropTypes.string
};
CNEVideoEmbed.displayName = 'CNEVideoEmbed';
module.exports = connectToStore((store) => {
    const { user } = store || {};
    let pageType = store['head.pageType'];
    if (pageType === 'homepage') {
        // page type is homepage, we reference it as bundle
        pageType = 'bundle';
    }
    let tags = store[pageType]?.tags;
    if (!tags && store[pageType]?.tagCloud) {
        // gallery tags
        tags = store[pageType].tagCloud.tags.map((tagItem) => tagItem.slug ?? tagItem.tag);
    }
    else if (tags && typeof tags[0] !== 'string') {
        // recipe and review tags
        tags = tags.map((tagItem) => tagItem.tag ?? tagItem.slug);
    }
    const { functionalTags } = store.coreDataLayer?.content || {};
    return {
        user,
        tags,
        functionalTags
    };
})(injectIntl(CNEVideoEmbed));
//# sourceMappingURL=CNEVideoEmbed.js.map

/***/ }),

/***/ 13843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classNames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const { STICKY_PLAYER_EVENTS } = __webpack_require__(8379);
const translations = (__webpack_require__(43256)/* ["default"] */ .A);
const ViewportMonitor = __webpack_require__(11246);
const { CloseButton, StickyVariationHeader, StickyTitle, StickyHeaderShadow, WatchNowLabel } = __webpack_require__(48518);
function StickyVariationHeaderComponent({ children, video = {}, onPause, onPlay, isLive, isPlaying, isUserCanceled, onStickyEvent, stickyImage }) {
    const intl = useIntl();
    const [isClosed, setIsClosed] = React.useState(false);
    const [isCurrentlySticky, setIsCurrentlySticky] = React.useState(false);
    const [headerHeight, setHeaderHeight] = React.useState(0);
    const [userClosed, setUserClosed] = React.useState(false);
    const { title } = video;
    const onStickyToggle = React.useCallback((isStickyAccordingToViewportMonitor, { headerHeight }) => {
        if (userClosed || isUserCanceled || (!isCurrentlySticky && !isPlaying)) {
            return;
        }
        setIsCurrentlySticky(isStickyAccordingToViewportMonitor);
        // eslint-disable-next-line no-shadow
        setIsClosed((isClosed) => isStickyAccordingToViewportMonitor ? isClosed : false);
        setHeaderHeight(headerHeight);
        onStickyEvent &&
            onStickyEvent(isStickyAccordingToViewportMonitor
                ? STICKY_PLAYER_EVENTS.START
                : STICKY_PLAYER_EVENTS.STOP);
    }, [userClosed, isUserCanceled, isPlaying, isCurrentlySticky, onStickyEvent]);
    React.useEffect(() => {
        if (isUserCanceled || userClosed) {
            setIsCurrentlySticky(false);
            setIsClosed(false);
            onStickyEvent && onStickyEvent(STICKY_PLAYER_EVENTS.CLOSE);
        }
    }, [isUserCanceled, onStickyEvent, userClosed]);
    const onClose = React.useCallback(() => {
        if (isClosed) {
            return;
        }
        setUserClosed(true);
        // setIsClosed(true);
        onPause();
        // onStickyEvent && onStickyEvent(STICKY_PLAYER_EVENTS.MINIMIZE);
    }, [isClosed, onPause]);
    const onActivate = React.useCallback(() => {
        if (!isClosed) {
            return;
        }
        setIsClosed(false);
        onPlay();
        onStickyEvent && onStickyEvent(STICKY_PLAYER_EVENTS.EXPAND);
    }, [isClosed, onPlay, onStickyEvent]);
    return (React.createElement(ViewportMonitor, { onSticky: onStickyToggle },
        React.createElement(StickyVariationHeader, { className: classNames({ isCurrentlySticky, isClosed }), onClick: onActivate, topOffset: headerHeight, "data-testid": "sticky-variation-header" },
            React.createElement("div", { className: "root" },
                isCurrentlySticky && (React.createElement(StickyHeaderShadow, { "data-testid": "sticky-header-shadow" })),
                React.createElement("div", { className: classNames({
                        grid: isCurrentlySticky,
                        'grid-margins': isCurrentlySticky
                    }), "data-testid": "sticky-content-grid" },
                    isCurrentlySticky && (React.createElement(CloseButton, { className: "close-icon", "aria-label": intl.formatMessage(translations.persistantCloseTitle), onClick: onClose, type: "button", "data-testid": "sticky-close-button" },
                        React.createElement("svg", { width: "32", height: "32", viewBox: "0 0 32 32" },
                            React.createElement("title", null, intl.formatMessage(translations.persistantCloseTitle)),
                            React.createElement("path", { d: "M14.94 16 2.453 28.486l1.094 1.028L16 17.06l12.453 12.453 1.094-1.028L17.061 16 29.547 3.514l-1.094-1.028L16 14.94 3.547 2.486 2.453 3.514 14.94 16Z" })))),
                    React.createElement("div", { className: "video", "data-testid": "sticky-video-container" }, children),
                    React.createElement("div", { className: "content", "data-testid": "sticky-content" },
                        stickyImage && (React.createElement("div", { className: "sticky-image", "data-testid": "sticky-image-container" },
                            React.createElement("img", { src: stickyImage, alt: "Video Logo", "data-testid": "sticky-image" }))),
                        React.createElement(StickyTitle, { className: "sticky-title", "data-testid": "sticky-title" }, title),
                        isLive && (React.createElement(WatchNowLabel, { className: "watch-now", "data-testid": "watch-now-label" }, intl.formatMessage(translations.watchNowTitle)))))))));
}
StickyVariationHeaderComponent.propTypes = {
    children: PropTypes.node,
    isLive: PropTypes.bool,
    isPlaying: PropTypes.bool,
    isUserCanceled: PropTypes.bool,
    onPause: PropTypes.func.isRequired,
    onPlay: PropTypes.func.isRequired,
    onStickyEvent: PropTypes.func,
    stickyImage: PropTypes.string,
    video: PropTypes.shape({
        title: PropTypes.string
    })
};
module.exports = StickyVariationHeaderComponent;
//# sourceMappingURL=StickyVariationHeader.js.map

/***/ }),

/***/ 80011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classNames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const { STICKY_PLAYER_EVENTS } = __webpack_require__(8379);
const translations = (__webpack_require__(43256)/* ["default"] */ .A);
const ViewportMonitor = __webpack_require__(11246);
const { CloseButtonStories, StickyVariationLiveStories, StickyTitleStories, StickyHeaderShadow, WatchNowLabelStories } = __webpack_require__(48518);
function StickyVariationLiveStoriesComponent({ aspectRatio, children, initialOffsetTop = 10, video = {}, onPause, onPlay, isLive, isPlaying, isUserCanceled, onStickyEvent }) {
    const intl = useIntl();
    const [isClosed, setIsClosed] = React.useState(false);
    const [isCurrentlySticky, setIsCurrentlySticky] = React.useState(false);
    const [headerHeight, setHeaderHeight] = React.useState(0);
    const [animationEnabled, setAnimationEnabled] = React.useState(false);
    const [offsetTop, setOffsetTop] = React.useState(initialOffsetTop);
    const [userClosed, setUserClosed] = React.useState(false);
    const { title } = video;
    React.useEffect(() => {
        if (isUserCanceled) {
            setIsCurrentlySticky(false);
            setIsClosed(false);
            onStickyEvent && onStickyEvent(STICKY_PLAYER_EVENTS.CLOSE);
        }
    }, [isUserCanceled, onStickyEvent]);
    const onClose = React.useCallback(() => {
        if (isClosed) {
            return;
        }
        setUserClosed(true);
        // setIsClosed(true);
        onPause();
        // onStickyEvent && onStickyEvent(STICKY_PLAYER_EVENTS.MINIMIZE);
    }, [isClosed, onPause]);
    const onActivate = React.useCallback(() => {
        if (isCurrentlySticky)
            setAnimationEnabled(true);
        if (!isClosed) {
            return;
        }
        setIsClosed(false);
        onPlay();
        onStickyEvent && onStickyEvent(STICKY_PLAYER_EVENTS.EXPAND);
    }, [isClosed, onPlay, onStickyEvent, setAnimationEnabled, isCurrentlySticky]);
    const onViewportChangeToggle = React.useCallback((param) => {
        const isStickyAccordingToViewportMonitor = !param.inView && offsetTop <= 0;
        if (isCurrentlySticky)
            setAnimationEnabled(true);
        else
            setAnimationEnabled(false);
        if (isUserCanceled || (!isCurrentlySticky && !isPlaying)) {
            return;
        }
        setIsCurrentlySticky(isStickyAccordingToViewportMonitor);
        // eslint-disable-next-line no-shadow
        setIsClosed((isClosed) => isStickyAccordingToViewportMonitor ? isClosed : false);
        onStickyEvent &&
            onStickyEvent(isStickyAccordingToViewportMonitor
                ? STICKY_PLAYER_EVENTS.START
                : STICKY_PLAYER_EVENTS.STOP);
    }, [isUserCanceled, isPlaying, isCurrentlySticky, onStickyEvent, offsetTop]);
    const onPositionChangeToggle = React.useCallback(
    // eslint-disable-next-line no-shadow
    ({ topOffset, headerHeight }) => {
        setOffsetTop(topOffset);
        setHeaderHeight(headerHeight);
    }, []);
    const onStickyToggle = React.useCallback(
    // eslint-disable-next-line no-shadow
    (isStickyAccordingToViewportMonitor, { headerHeight }) => {
        setHeaderHeight(headerHeight);
        if (isStickyAccordingToViewportMonitor) {
            // empty
        }
    }, []);
    return (React.createElement(ViewportMonitor, { observerThreshold: 0.25, onSticky: onStickyToggle, onViewportChange: onViewportChangeToggle, onPositionChange: onPositionChangeToggle },
        React.createElement(StickyVariationLiveStories, { className: classNames({
                isCurrentlySticky: isCurrentlySticky && !userClosed,
                isClosed,
                animationEnabled
            }), onClick: onActivate, topOffset: headerHeight, aspectRatio: aspectRatio, "data-testid": "sticky-variation-live-stories" },
            React.createElement("div", { className: "root" },
                isCurrentlySticky && false && (0),
                React.createElement("div", { className: "stickyVideoWrapper", "data-testid": "sticky-video-wrapper" },
                    React.createElement("div", { className: classNames({
                            grid: isCurrentlySticky,
                            'grid-margins': isCurrentlySticky
                        }), "data-testid": "sticky-content-grid" },
                        React.createElement("div", { className: "video", "data-testid": "sticky-video-container" }, children),
                        React.createElement("div", { className: "content", "data-testid": "sticky-content" },
                            isLive && (React.createElement(WatchNowLabelStories, { className: "watch-now", "data-testid": "watch-now-label" }, "\u2022 Live")),
                            React.createElement(StickyTitleStories, { className: "sticky-title", "data-testid": "sticky-title" }, title)),
                        isCurrentlySticky && (React.createElement(CloseButtonStories, { className: "close-icon", "aria-label": intl.formatMessage(translations.persistantCloseTitle), onClick: onClose, type: "button", "data-testid": "sticky-close-button" },
                            React.createElement("svg", { width: "32", height: "32", viewBox: "0 0 32 32" },
                                React.createElement("title", null, intl.formatMessage(translations.persistantCloseTitle)),
                                React.createElement("path", { d: "M14.94 16 2.453 28.486l1.094 1.028L16 17.06l12.453 12.453 1.094-1.028L17.061 16 29.547 3.514l-1.094-1.028L16 14.94 3.547 2.486 2.453 3.514 14.94 16Z" }))))))))));
}
StickyVariationLiveStoriesComponent.propTypes = {
    aspectRatio: PropTypes.number,
    children: PropTypes.node,
    initialOffsetTop: PropTypes.number,
    isLive: PropTypes.bool,
    isPlaying: PropTypes.bool,
    isUserCanceled: PropTypes.bool,
    onPause: PropTypes.func.isRequired,
    onPlay: PropTypes.func.isRequired,
    onStickyEvent: PropTypes.func,
    video: PropTypes.shape({
        title: PropTypes.string
    })
};
module.exports = StickyVariationLiveStoriesComponent;
//# sourceMappingURL=StickyVariationLiveStories.js.map

/***/ }),

/***/ 64911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const StickyVariationHeader = __webpack_require__(13843);
const StickyVariationLiveStories = __webpack_require__(80011);
const VARIATIONS = {
    StickyHeader: StickyVariationHeader,
    StickyLiveStories: StickyVariationLiveStories
};
function StickyVariationWrapper({ variation, children, shouldBeSticky, stickyConfig, ...otherProps }) {
    const WrapperComponent = variation && shouldBeSticky && VARIATIONS[variation];
    if (WrapperComponent) {
        return (React.createElement(WrapperComponent, { ...stickyConfig, ...otherProps }, children));
    }
    return React.createElement("div", { ...otherProps }, children);
}
StickyVariationWrapper.propTypes = {
    children: PropTypes.node,
    shouldBeSticky: PropTypes.bool,
    stickyConfig: PropTypes.shape({
        aspectRatio: PropTypes.number,
        isLive: PropTypes.bool,
        isPlaying: PropTypes.bool,
        onPause: PropTypes.func.isRequired,
        onPlay: PropTypes.func.isRequired,
        onStickyEvent: PropTypes.func,
        stickyImage: PropTypes.string,
        stickyTags: PropTypes.arrayOf(PropTypes.string),
        userCancel: PropTypes.bool,
        video: PropTypes.shape({
            title: PropTypes.string
        })
    }),
    variation: PropTypes.oneOf(Object.keys(VARIATIONS))
};
module.exports = {
    StickyVariationWrapper: React.memo(StickyVariationWrapper),
    VARIATIONS
};
//# sourceMappingURL=StickyVariationWrapper.js.map

/***/ }),

/***/ 48518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorToken, getTypographyStyles } = __webpack_require__(26865);
const { universalGridCore } = __webpack_require__(89085);
const { applyGridSpacing } = __webpack_require__(1123);
const StickyVariationHeader = styled.div.withConfig({
    displayName: 'StickyVariationHeader'
}) `
  width: 100%;

  .close-icon,
  .content {
    display: none;
  }

  .video {
    width: 100%;
  }

  &.isCurrentlySticky {
    margin-bottom: 50px;
    height: 210px;

    @media (max-width: ${BREAKPOINTS.md}) {
      margin-bottom: 130px;
      height: 235px;
    }

    .root {
      position: fixed;
      top: ${(props) => `${props.topOffset ? props.topOffset - 1 : 64}px`};
      left: 0;
      transition: top 0.07s;
      z-index: 399;
      border-bottom: 1px solid
        ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.divider')};
      background: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.background')};
      padding: 16px 0;
      width: 100%;
      height: 210px;

      @media (max-width: ${BREAKPOINTS.md}) {
        padding: 0;
        height: auto;
      }
    }

    .grid {
      display: flex;
      position: relative;

      @media (max-width: ${BREAKPOINTS.md}) {
        flex-direction: column-reverse;
        --grid-gap: 0;
      }
    }

    .video {
      margin-right: 40px;
      width: 322px;

      @media (max-width: ${BREAKPOINTS.md}) {
        margin-right: 0;
        padding-top: 12px;
        padding-bottom: 20px;
        width: auto;
      }
    }

    .content {
      display: flex;
      flex: 1;
      flex-direction: column;
      justify-content: center;

      .sticky-image {
        display: flex;
        margin-bottom: 14px;

        img {
          height: 16px;
        }
      }

      @media (max-width: ${BREAKPOINTS.md}) {
        padding-top: 14px;

        .sticky-image {
          margin-right: 20px;

          img {
            height: 12px;
          }
        }
      }
    }

    .close-icon {
      display: block;
    }
  }

  &.isClosed {
    height: 60px;

    @media (max-width: ${BREAKPOINTS.md}) {
      height: 50px;
    }

    .root {
      cursor: pointer;
      padding: 10px 0;
      height: 60px;

      @media (max-width: ${BREAKPOINTS.md}) {
        padding: 8px;
        height: 50px;
      }
    }

    .grid {
      --grid-gap: 0;
      justify-content: center;

      @media (max-width: ${BREAKPOINTS.md}) {
        flex-direction: row;
        justify-content: flex-start;
        padding-right: 16px;
        padding-left: 16px;
      }
    }

    .video {
      margin-right: 0;
      width: 70px;

      @media (max-width: ${BREAKPOINTS.md}) {
        margin-right: 10px;
        padding-top: 0;
        padding-bottom: 0;
        width: 59px;
      }
    }

    .content {
      flex: inherit;
      flex-direction: row;
      align-items: center;
      justify-content: start;
      margin-left: 1rem;

      .sticky-image {
        margin-right: 20px;
        margin-bottom: 0;

        @media (max-width: ${BREAKPOINTS.md}) {
          margin-right: 10px;
        }
      }

      @media (max-width: ${BREAKPOINTS.md}) {
        flex: 1;
        margin-left: auto;
        padding-top: 0;
        padding-right: 0;
        padding-bottom: 0;
        min-width: 100px;
      }
    }

    .sticky-title {
      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-tertiary')};

      padding-right: 30px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.accreditation')};

      && {
        font-size: 11px;
      }

      @media (max-width: ${BREAKPOINTS.md}) {
        color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.white.description')};
      }
    }

    .watch-now {
      display: none;
    }

    .close-icon {
      top: -10px;
      transform: rotate(180deg);

      @media (max-width: ${BREAKPOINTS.md}) {
        top: -8px;
        right: 0;
      }
    }
  }
`;
const StickyVariationLiveStories = styled.div.withConfig({
    displayName: 'StickyVariationLiveStories'
}) `
  width: 100%;

  .close-icon,
  .content {
    display: none;
  }

  .video {
    width: 100%;
  }

  &.isCurrentlySticky {
    ::before {
      display: block;
      padding-top: 56.25%;
      content: '';
    }

    .root {
      position: fixed;
      top: ${(props) => `${props.topOffset ? props.topOffset : 0}px`};
      left: 0;
      z-index: 400;
      border-top: 1px solid
        ${({ theme }) => getColorToken(theme, 'colors.foundation.menu.dividers')};
      box-shadow: rgb(0 0 0 / 10%) 0 2px 4px;
      background: rgba(
        ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.standard.background', {
    rgbOnly: true
})},
        0.95
      );
      padding: 0;
      width: 100%;
      height: 148px;
      @media (max-width: ${BREAKPOINTS.md}) {
        z-index: 400;
        background: rgba(
          ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.standard.background', {
    rgbOnly: true
})},
          1
        );
        padding: 0;
        height: 110px;
      }

      .stickyVideoWrapper {
        ${universalGridCore(false)}
        grid-column: main;
        width: 100%;

        @media (min-width: ${BREAKPOINTS.md}) {
          ${applyGridSpacing('padding')}
        }

        > * {
          grid-column: 1/-1;
        }
      }
    }

    .grid {
      display: flex;
      position: relative;

      &.grid-margins:first-child {
        margin-top: 0;
      }
    }

    .video {
      margin-right: 0;
      width: 196px;
      max-width: ${({ aspectRatio }) => {
    return aspectRatio ? `calc( 110px * ${aspectRatio} )` : null;
}};

      @media (min-width: ${BREAKPOINTS.md}) {
        width: 263px;
        max-width: ${({ aspectRatio }) => {
    return aspectRatio ? `calc( 148px * ${aspectRatio} )` : null;
}};
      }
    }

    .content {
      display: flex;
      flex: 1;
      flex-direction: column;
      justify-content: center;
      padding: 0 ${calculateSpacing(4)} 0 ${calculateSpacing(4)};

      @media (max-width: ${BREAKPOINTS.md}) {
        padding: 0 ${calculateSpacing(1.5)} 0 ${calculateSpacing(1.5)};
      }
    }

    .close-icon {
      display: block;
      bottom: 5px;
      transform: rotate(0);
      @media (max-width: ${BREAKPOINTS.md}) {
        top: unset;
        right: 14px;
        bottom: 3px;
      }
    }
  }

  &.isClosed {
    @media (min-width: ${BREAKPOINTS.md}) {
      .root {
        cursor: pointer;
        padding: 0 0;
        height: 56px;
      }

      .grid {
        --grid-gap: 0;
        justify-content: left;
      }

      .video {
        margin-right: 0;
        width: 100px;
        max-width: ${({ aspectRatio }) => {
    return aspectRatio ? `calc( 56px * ${aspectRatio} )` : null;
}};
      }

      .content {
        flex: inherit;
        flex-direction: row;
        align-items: center;
        justify-content: start;
        margin-left: 0;
        max-width: calc(100% - 100px);
      }

      .sticky-title {
        padding-right: 30px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
        color: ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.standard.heading')};

        @media (min-width: ${BREAKPOINTS.md}) {
          font-size: 18px;
        }
      }

      .watch-now {
        padding-right: ${calculateSpacing(1)};
        padding-bottom: 0;
        white-space: nowrap;
      }

      .close-icon {
        top: 0;
        transform: rotate(180deg);
      }
    }
  }

  &.isCurrentlySticky.animationEnabled {
    .root {
      transition: height 0.8s cubic-bezier(0.2, 0, 0.2, 1);
    }

    .video {
      transition: all 0.8s cubic-bezier(0.2, 0, 0.2, 1);
    }

    .close-icon {
      transition: all 0.8s cubic-bezier(0.2, 0, 0.2, 1);
    }
  }

  &.isCurrentlySticky.isClosed.animationEnabled {
    .root {
      transition: height 0.8s cubic-bezier(0.2, 0, 0.2, 1);
    }

    .video {
      transition: all 0.8s cubic-bezier(0.2, 0, 0.2, 1);
    }

    .close-icon {
      transition: all 0.8s cubic-bezier(0.2, 0, 0.2, 1);
    }
  }
`;
const StickyTitle = styled(BaseText).withConfig({
    displayName: 'StickyTitle'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-feature')};

  text-align: left;
  color: ${({ theme }) => getColorToken(theme, 'colors.discovery.body.light.heading')};

  && {
    line-height: 1.25em;
    font-size: 24px;
  }

  @media (max-width: ${BREAKPOINTS.md}) {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-secondary')};
    width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;

    && {
      font-size: 16px;
    }
    ${({ isMobileFooterVariation, theme }) => isMobileFooterVariation &&
    `
        ${getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.subhed-aux-secondary')};

        max-width:90%;
        text-transform: uppercase;
        color: ${getColorToken(theme, 'colors.consumption.lead.inverted.context-tertiary')};
    `}
  }
`;
const StickyTitleStories = styled(BaseText).withConfig({
    displayName: 'StickyTitleStories'
}) `
  text-align: left;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
  color: ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.standard.heading')};

  &.sticky-title-nowrap {
    white-space: unset;
  }

  @media (max-width: ${BREAKPOINTS.md}) {
    /* stylelint-disable-next-line value-no-vendor-prefix */
    display: -webkit-box;
    width: calc(
      100vw - 200px - ${calculateSpacing(1.5)} - ${calculateSpacing(1.5)}
    );
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: unset;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-primary')};
    color: ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.standard.heading')};
  }
`;
StickyTitle.defaultProps = {
    isMobileFooterVariation: false
};
const WatchNowLabel = styled(BaseText).withConfig({
    displayName: 'WatchNowLabel'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}

  padding-top: 12px;
  text-align: left;
  color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.dark')};

  @media (max-width: ${BREAKPOINTS.md}) {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-core')};
    font-size: 11px;
  }
`;
const WatchNowLabelStories = styled(BaseText).withConfig({
    displayName: 'WatchNowLabelStories'
}) `
  padding-top: 0;
  padding-bottom: ${calculateSpacing(1)};
  text-align: left;

  @media (max-width: ${BREAKPOINTS.md}) {
    padding-bottom: ${calculateSpacing(1)};
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};
  }
`;
WatchNowLabelStories.defaultProps = {
    colorToken: 'colors.discovery.body.white.context-signature',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
const CloseButton = styled.button.withConfig({ displayName: 'CloseButton' }) `
  display: none;
  position: absolute;
  top: 0;
  right: 45px;
  background-color: transparent;
  padding: 8px;
  line-height: 1;

  svg {
    width: 18px;
    height: 18px;

    @media (max-width: ${BREAKPOINTS.md}) {
      width: 18px;
      height: 18px;
    }
  }

  path {
    stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.dark')};
    fill: transparent;
    stroke-width: 1;
  }

  @media (max-width: ${BREAKPOINTS.md}) {
    display: inline-block;
    top: 5px;
    right: 10px;
    z-index: 1;
  }
`;
const CloseButtonStories = styled.button.withConfig({
    displayName: 'CloseButtonStories'
}) `
  display: none;
  position: absolute;
  right: -8px;
  bottom: 0;
  background-color: transparent;
  padding: 0;
  line-height: 1;

  svg {
    width: 18px;
    height: 18px;

    @media (max-width: ${BREAKPOINTS.md}) {
      width: 18px;
      height: 18px;
    }
  }

  path {
    stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.dark')};
    fill: transparent;
    stroke-width: 1;
  }

  @media (max-width: ${BREAKPOINTS.md}) {
    display: inline-block;
    top: 5px;
    right: 10px;
    z-index: 1;
  }
`;
const CloseButtonRound = styled.button.withConfig({
    displayName: 'CloseButtonRound'
}) `
  display: none;
  position: absolute;
  top: 0;
  right: 45px;
  background-color: transparent;
  padding: 8px;
  line-height: 1;

  svg {
    border-radius: 50%;
    background: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.black')};
    width: 32px;
    height: 32px;
    @media (max-width: ${BREAKPOINTS.md}) {
      width: 22px;
      height: 22px;
    }
  }

  path {
    stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
    fill: transparent;
    stroke-width: 1;
  }

  @media (max-width: ${BREAKPOINTS.md}) {
    display: inline-block;
    top: 5px;
    right: 10px;
    z-index: 1;

    svg {
      background: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.white')};
    }

    path {
      stroke: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.black')};
    }
  }
`;
const StickyHeaderShadow = styled.div.withConfig({
    displayName: 'StickyHeaderShadow'
}) `
  position: absolute;
  top: -4px;
  box-shadow: 0 4px 4px rgb(0 0 0 / 13%);
  width: 100%;
  height: 1px;
`;
module.exports = {
    CloseButton,
    CloseButtonStories,
    CloseButtonRound,
    StickyVariationHeader,
    StickyVariationLiveStories,
    StickyHeaderShadow,
    StickyTitle,
    StickyTitleStories,
    WatchNowLabel,
    WatchNowLabelStories
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 8379:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STICKY_VARIATION_POSITIONS = exports.STICKY_PLAYER_EVENTS = void 0;
exports.STICKY_PLAYER_EVENTS = {
    START: 'Start Sticky',
    STOP: 'Stop Sticky',
    CLOSE: 'Close',
    MINIMIZE: 'Minimize',
    EXPAND: 'Expand' // user expanded sticky player (if sticky player has minimize functionality)
};
exports.STICKY_VARIATION_POSITIONS = {
    // CNE Player is explicitly expecting either 'hero' or 'footer' for
    // stickyPosition query parameter to identify where player is sticky
    StickyHeader: 'hero',
    StickyLiveStories: 'hero'
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 15449:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { CneVideoEmbedContainer } = __webpack_require__(25423);
const FullBleedNoTeaser = ({ children, isCurrentlySticky, shouldActivateTeaser, aspectRatio
// teaser
 }) => {
    return (React.createElement(CneVideoEmbedContainer
    // background={teaser.animated_clip_still}
    , { 
        // background={teaser.animated_clip_still}
        shouldActivateTeaser: shouldActivateTeaser, isCurrentlySticky: isCurrentlySticky, aspectRatio: aspectRatio }, children));
};
FullBleedNoTeaser.propTypes = {
    aspectRatio: PropTypes.number,
    children: PropTypes.node,
    isCurrentlySticky: PropTypes.bool,
    shouldActivateTeaser: PropTypes.bool
    // teaser: PropTypes.shape({
    //   animated_clip_still: PropTypes.string
    // })
};
module.exports = FullBleedNoTeaser;
//# sourceMappingURL=FullBleedNoTeaser.js.map

/***/ }),

/***/ 64714:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Rubric = __webpack_require__(34187);
const LiveIndicator = __webpack_require__(77938);
const ViewportMonitor = __webpack_require__(11246);
const { BREAKPOINTS } = __webpack_require__(96472);
const { CneVideoEmbedContainer, CNETeaserWrapper, CNETeaser, CNETeaserHed, CNETeaserInfoWrapper, CNETeaserButtonWrapper, CNETeaserButton } = __webpack_require__(25423);
const sparrow =  true &&
    // eslint-disable-next-line global-require
    __webpack_require__(31170);
function FullBleedTeaser({ children, fullBleedTeaserQueryParam, isCurrentlySticky, isTeaserPlaying, onHideTeaser, shouldActivateTeaser, aspectRatio, teaser }) {
    const [startCountDown, setStartCountDown] = React.useState(false);
    const getTeaserRendition = (format) => {
        if (window.matchMedia(`(max-width: ${BREAKPOINTS.sm})`).matches) {
            return teaser[`animated_clip_url_${format}`];
        }
        return teaser[`animated_clip_url_high_${format}`];
    };
    const trackSparrow = (category, type, eventName) => {
        const payload = {
            _t: eventName
        };
        sparrow && sparrow.trackSparrowEvent(category, type, payload);
    };
    const onViewportChangeToggle = React.useCallback(({ inView }) => {
        if (startCountDown) {
            return;
        }
        if (inView && teaser.title) {
            setTimeout(() => {
                onHideTeaser();
            }, 5000);
            setStartCountDown(true);
        }
    }, [startCountDown, teaser, onHideTeaser]);
    const onClose = React.useCallback(() => {
        onHideTeaser(true);
        trackSparrow('cneVideoTeaser', 'click', 'Video Teaser Click');
    }, [onHideTeaser]);
    React.useEffect(() => {
        if (isTeaserPlaying) {
            trackSparrow('cneVideoTeaser', 'load', 'Video Teaser Start');
        }
    }, [isTeaserPlaying]);
    const container_ref = React.useRef(null);
    const [marginAdjustment, setMarginAdjustment] = React.useState(undefined);
    React.useEffect(() => {
        const handleResize = () => {
            const fullContainer = document.querySelector('.body__inner-container') ||
                document.querySelector('.body__container');
            setMarginAdjustment((window.innerWidth - fullContainer.offsetWidth) / 2);
        };
        if (fullBleedTeaserQueryParam) {
            handleResize();
            window.addEventListener('resize', handleResize);
        }
        return () => window.removeEventListener('resize', handleResize);
    });
    return (React.createElement(CneVideoEmbedContainer
    // background={teaser.animated_clip_still} //uncomment this line to show an image instead of a black background in the full bleed video
    , { 
        // background={teaser.animated_clip_still} //uncomment this line to show an image instead of a black background in the full bleed video
        isTeaserPlaying: isTeaserPlaying, shouldActivateTeaser: shouldActivateTeaser, isCurrentlySticky: isCurrentlySticky, ref: container_ref, aspectRatio: aspectRatio, marginAdjustment: marginAdjustment },
        isTeaserPlaying && (React.createElement(CNETeaserWrapper, null,
            React.createElement(CNETeaser, { "aria-label": teaser.title, autoPlay: true, className: "responsive-clip__video", loop: true, muted: true, playsInline: true, crossorigin: "anonymous" },
                (teaser.animated_clip_url_high_mp4 ||
                    teaser.animated_clip_url_mp4) && (React.createElement("source", { src: `${getTeaserRendition('mp4')}`, type: "video/mp4" })),
                (teaser.animated_clip_url_high_webm ||
                    teaser.animated_clip_url_webm) && (React.createElement("source", { src: `${getTeaserRendition('webm')}`, type: "video/webm" }))),
            React.createElement(CNETeaserInfoWrapper, null,
                !teaser.isLive && teaser.category && (React.createElement(Rubric.DiscoveryCard, { name: teaser.category })),
                teaser.isLive && (React.createElement(LiveIndicator, { hasBackground: true, isDiscovery: false, shouldEnableAnimation: true })),
                React.createElement(CNETeaserHed, null, teaser.title),
                React.createElement(ViewportMonitor, { observerThreshold: 0.25, onViewportChange: onViewportChangeToggle }, teaser.title && (React.createElement(CNETeaserButtonWrapper, { animation: startCountDown },
                    React.createElement(CNETeaserButton, { onClick: onClose, animation: startCountDown, role: "button" },
                        React.createElement("svg", { width: "15", height: "15", viewBox: "0 0 15 15", xmlns: "http://www.w3.org/2000/svg" },
                            React.createElement("path", { d: "M0 15V0L15 6.79907L0 15Z" })),
                        "Watch Now"))))))),
        children));
}
FullBleedTeaser.propTypes = {
    aspectRatio: PropTypes.number,
    children: PropTypes.node,
    fullBleedTeaserQueryParam: PropTypes.string,
    isCurrentlySticky: PropTypes.bool,
    isTeaserPlaying: PropTypes.bool,
    onHideTeaser: PropTypes.func,
    shouldActivateTeaser: PropTypes.bool,
    teaser: PropTypes.shape({
        title: PropTypes.string,
        category: PropTypes.string,
        animated_clip_url_mp4: PropTypes.string,
        animated_clip_url_high_mp4: PropTypes.string,
        animated_clip_url_webm: PropTypes.string,
        animated_clip_url_high_webm: PropTypes.string,
        isLive: PropTypes.bool,
        animated_clip_still: PropTypes.string
    })
};
module.exports = FullBleedTeaser;
//# sourceMappingURL=FullBleedTeaser.js.map

/***/ }),

/***/ 21221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const FullBleedTeaser = __webpack_require__(64714);
const FullBleedNoTeaser = __webpack_require__(15449);
const TEASER_VARIATIONS = {
    FullBleedTeaser,
    FullBleedNoTeaser
};
function TeaserVariationWrapper({ children, variation, config, ...otherProps }) {
    const WrapperComponent = config.shouldActivateTeaser && variation && TEASER_VARIATIONS[variation];
    if (WrapperComponent) {
        return (React.createElement(WrapperComponent, { ...config, ...otherProps }, children));
    }
    return React.createElement("div", { ...otherProps }, children);
}
TeaserVariationWrapper.propTypes = {
    children: PropTypes.node,
    config: PropTypes.shape({
        aspectRatio: PropTypes.number,
        fullBleedTeaserQueryParam: PropTypes.string,
        isCurrentlySticky: PropTypes.bool,
        isTeaserPlaying: PropTypes.bool,
        onHideTeaser: PropTypes.func,
        shouldActivateTeaser: PropTypes.bool,
        teaser: PropTypes.shape({
            title: PropTypes.string,
            category: PropTypes.string,
            animated_clip_url_mp4: PropTypes.string,
            animated_clip_url_high_mp4: PropTypes.string,
            animated_clip_url_webm: PropTypes.string,
            animated_clip_url_high_webm: PropTypes.string,
            isLive: PropTypes.bool,
            animated_clip_still: PropTypes.string
        })
    }),
    variation: PropTypes.oneOf(Object.keys(TEASER_VARIATIONS))
};
module.exports = {
    TeaserVariationWrapper: React.memo(TeaserVariationWrapper),
    TEASER_VARIATIONS
};
//# sourceMappingURL=TeaserVariationWrapper.js.map

/***/ }),

/***/ 25423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseWrap, BaseLink, BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorToken } = __webpack_require__(26865);
const { cssVariablesGrid } = __webpack_require__(1123);
const { BREAKPOINTS } = __webpack_require__(96472);
const STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT = calculateSpacing(8);
const LINK_BANNER_HEIGHT = 60;
const animationSetting = () => `
  animation-duration: 4s;
  animation-delay: 1s;
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
`;
const linearGradient = (grad) => `
  background: linear-gradient(
    ${grad}deg,
    rgba(0, 0, 0, 0) 0%,
    rgba(0, 0, 0, 0) 50%,
    rgba(0, 0, 0, 1) 100%
  );
`;
const CneVideoEmbedContainer = styled.div.withConfig({
    displayName: 'CneVideoEmbedContainer'
}) `
  ${cssVariablesGrid()}
  position:relative;
  border-bottom: 1px solid
    ${getColorToken('colors.consumption.lead.standard.divider')};
  background: ${({ aspectRatio }) => {
    return aspectRatio && aspectRatio > 1 ? 'black' : 'white';
}};
  width: 100vw;

  height: ${({ aspectRatio }) => {
    return aspectRatio && aspectRatio < 1
        ? `calc(( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px )); `
        : `calc(( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px ) * 80 / 100 ); `;
}};

  @media only screen and (orientation: landscape) {
    height: calc(
      100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} -
        ${LINK_BANNER_HEIGHT}px
    );
  }

  .verso-bundle-cne-embed--grid-with-margins & {
    margin-right: calc(-1 * var(--grid-margin));
    margin-left: calc(-1 * var(--grid-margin));
    @media (max-width: ${BREAKPOINTS.md}) {
      margin-bottom: 30px;
    }
  }

  .lead-asset & {
    @media (min-width: ${BREAKPOINTS.fullBleed}) {
      margin-right: calc(-1 * (100vw - 1600px) / 2);
      margin-left: calc(-1 * (100vw - 1600px) / 2);
    }
  }

  @media (max-width: ${BREAKPOINTS.lg}) {
    &::before {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: -50%;
      opacity: 0.25;
      ${({ background, aspectRatio }) => background &&
    aspectRatio &&
    aspectRatio > 1 &&
    `background-image: url(${background});`}
      background-size: cover;
      content: '';
    }
  }
  ${({ isTeaserPlaying }) => isTeaserPlaying && `&& .cne-video-embed { display: none; }`}

  ${({ marginAdjustment = undefined }) => marginAdjustment &&
    `
      margin-left: -${marginAdjustment}px;
      margin-right: -${marginAdjustment}px;
      .cne-video-embed{
        max-width: calc(
          (
              100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} -
                ${LINK_BANNER_HEIGHT}px
            ) * 16 / 9
        ) ;
      }
  `}

  ${({ shouldActivateTeaser, isCurrentlySticky }) => shouldActivateTeaser &&
    !isCurrentlySticky &&
    `
    && {
      .cne-video-embed{
        position: absolute;
        top: 50%;
        right: 50%;
        transform: translate(50%, -50%);
        width: 100%;
        height: auto;
        max-height: calc( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px);        
      }
    }
  `}

  ${({ aspectRatio }) => aspectRatio &&
    `
    && {
      .cne-video-embed{
        .verso-bundle-cne-embed &,
          .verso-bundle-cne-embed--grid-with-margins &,
          .lead-asset & {
            max-width: calc(
              (
                  100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} -
                    ${LINK_BANNER_HEIGHT}px
                ) * ${aspectRatio}
            ) ;
          }
        }
  `}
`;
const CNETeaserWrapper = styled(BaseWrap).withConfig({
    displayName: 'CNETeaserWrapper'
}) ``;
const CNETeaser = styled.video.withConfig({
    displayName: 'CNETeaser'
}) `
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  @media (min-width: ${BREAKPOINTS.md}) {
    max-height: calc(
      100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} -
        ${LINK_BANNER_HEIGHT}px
    );
  }
  @media (min-width: 1920px) {
    right: 0;
    left: 0;
    margin-right: auto;
    margin-left: auto;
    max-width: 1920px;
  }
`;
const CNETeaserInfoWrapper = styled.div.withConfig({
    displayName: 'CNETeaserInfoWrapper'
}) `
  display: flex;
  position: absolute;
  top: 0;
  bottom: 0;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;
  ${linearGradient(180)}
  padding: ${calculateSpacing(6)};
  width: 100%;
  height: 100%;
  @media (min-width: ${BREAKPOINTS.xl}) {
    padding: ${calculateSpacing(8)};
  }
  @media (min-width: 1920px) {
    right: 0;
    left: 0;
    margin-right: auto;
    margin-left: auto;
    width: 1920px;
  }

  .rubric {
    background: black;
    width: fit-content;

    .rubric__name {
      color: white;
    }
  }
`;
const CNETeaserButtonWrapper = styled(BaseWrap).withConfig({
    displayName: 'CNETeaserButtonWrapper'
}) `
  position: relative;
  z-index: 0;
  border: 1px solid black;
  border-radius: 3px;
  background: white;
  width: 150px;
  overflow: hidden;

  &::before {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    ${({ animation }) => animation &&
    `
        animation-name: animationBackground;
        ${animationSetting()}
  `}
    z-index: -1;
    border-radius: 0;
    background-color: black;
    width: 0;
    height: 100%;
    content: '';
    transition-timing-function: linear;
  }
  @keyframes animationBackground {
    0% {
      width: 0;
    }

    100% {
      width: 100%;
    }
  }
`;
const CNETeaserButton = styled(BaseLink).withConfig({
    displayName: 'CNETeaserButton'
}) `
  &&& {
    display: block;
    position: relative;
    z-index: 5;
    background: transparent;
    padding: 8px 20px;
    overflow: hidden;
    white-space: nowrap;
    color: white;
    mix-blend-mode: difference;

    svg {
      padding-top: 6px;
      padding-right: 8px;
      fill: white;
      mix-blend-mode: difference;
    }

    &:active,
    &:link,
    &:visited,
    &:hover {
      text-decoration: none;
      color: white;
    }
  }
`;
CNETeaserButton.defaultProps = {
    colorToken: 'colors.interactive.base.dark',
    typeIdentity: 'typography.definitions.utility.button-utility'
};
const CNETeaserHed = styled(BaseText).withConfig({
    displayName: 'CNETeaserHed'
}) `
  margin: ${calculateSpacing(1)} 0;
  text-align: center;
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-bottom: ${calculateSpacing(2)};
    max-width: 80%;
  }
  @media (min-width: ${BREAKPOINTS.lg}) {
    margin-bottom: ${calculateSpacing(3)};
  }
  @media (min-width: ${BREAKPOINTS.xl}) {
    margin-bottom: ${calculateSpacing(4)};
  }

  &&& {
    color: ${getColorToken('colors.interactive.base.white')};
  }
`;
CNETeaserHed.defaultProps = {
    as: 'h3',
    typeIdentity: 'typography.definitions.discovery.hed-feature'
};
module.exports = {
    CneVideoEmbedContainer,
    CNETeaserWrapper,
    CNETeaser,
    CNETeaserHed,
    CNETeaserInfoWrapper,
    CNETeaserButtonWrapper,
    CNETeaserButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 11246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const throttle = __webpack_require__(7350);
const { AspectRatioWrapper } = __webpack_require__(86078);
const buildThresholdList = (length) => {
    const thresholds = [];
    for (let i = 0; i < length; i++) {
        thresholds.push(i / length);
    }
    return thresholds;
};
const ON_SCROLL_THROTTLE = 80;
/**
 * ViewportMonitor component
 *
 * @param {object} props - React props
 * @param {ReactElement} [props.children] - The children of this element
 * @param {number} [props.observerThreshold] - Threshold to be used for the intersection observer
 * @param {func} [props.onViewportChange] - callback to run when viewport status changes
 * @param {func} [props.onSticky] - callback to run when children changes stickiness
 * @param {func} [props.onPositionChange] - callback to run when children changes position
 *
 * @returns {ReactElement} <div>
 */
function ViewportMonitor({ children, onViewportChange: onViewportChangeProp, observerThreshold = 0.25, onSticky, onPositionChange, shouldCheckPositionForOnViewportEnteredOnly = true }) {
    const anchorRef = React.useRef();
    const onScrollTimeoutRef = React.useRef();
    const [hasEnteredViewport, setHasEnteredViewport] = React.useState(false);
    const [isSticky, setIsSticky] = React.useState(false);
    const getHeaderHeight = React.useCallback(() => {
        const header = document.querySelector('header');
        if (header?.parentNode?.classList.contains('persistent-top') === false) {
            const headerClientRect = header?.getBoundingClientRect();
            const headerBottom = headerClientRect?.bottom;
            const height = headerBottom > 0 ? headerBottom : 0;
            return Math.max(height, 0);
        }
        const linkBannerWrapper = header?.parentNode?.querySelector('.persistent-top > [class^="LinkBannerWrapper"]');
        const height = (header?.offsetHeight ?? 0) +
            (header?.offsetTop ?? 0) +
            (linkBannerWrapper?.offsetHeight ?? 1) -
            1;
        return Math.max(height, 0);
    }, []);
    const onViewportChange = React.useCallback(([{ intersectionRatio }]) => {
        // README: firefox interprets `isIntersecting` a different from chrome,
        // so we need to manually compute it here in order for things to work...
        const inView = intersectionRatio >= observerThreshold;
        if (inView) {
            setHasEnteredViewport(inView);
        }
        // If you scroll really slowly on a larger player, you can get
        //   the player to play and immediately persist and then when you
        //   keep scrolling it "unpersists". The `hasEnteredViewport` flag
        //   keeps this from happening until an inView event has happened
        if (onViewportChangeProp) {
            onViewportChangeProp({
                inView,
                isSticky
            });
        }
    }, [onViewportChangeProp, isSticky, observerThreshold]);
    const handleScroll = React.useCallback(() => {
        if (!anchorRef.current ||
            (!hasEnteredViewport && shouldCheckPositionForOnViewportEnteredOnly)) {
            return;
        }
        let headerHeight = getHeaderHeight();
        const { top } = anchorRef.current.getBoundingClientRect();
        if (onPositionChange) {
            onPositionChange({ topOffset: top, headerHeight });
        }
        if (onSticky) {
            if (onScrollTimeoutRef.current) {
                window.clearTimeout(onScrollTimeoutRef.current);
            }
            const sticky = headerHeight > top;
            setIsSticky(sticky);
            onSticky(sticky, { headerHeight });
            /* This logic looks weird, but we need it because of different types of headers.
             * Header can be fully dynamic (disappears when the user scrolls the page) or partly
             * dynamic (only subheader disappears when user scrolls page).
             * When user scrolls the page, we calculate the header height, but afterwards, that header
             * can start a collapse animation and it's height will different than what we
             * calculated on previous tick. We recalculate the header height after an interval up to 700ms (subheader animation can take about 500ms)
             * because the height from the prev tick won't be equal to the height after the animation is done.
             */
            let headerHeightRecheckRunCount = 0;
            onScrollTimeoutRef.current = window.setInterval(() => {
                headerHeightRecheckRunCount++;
                const newHeaderHeight = getHeaderHeight();
                if (headerHeight !== newHeaderHeight) {
                    onSticky(sticky, { headerHeight: newHeaderHeight });
                }
                if (headerHeight === newHeaderHeight ||
                    headerHeightRecheckRunCount > 7) {
                    onScrollTimeoutRef.current &&
                        window.clearInterval(onScrollTimeoutRef.current);
                }
                headerHeight = newHeaderHeight;
            }, 100);
        }
    }, [
        hasEnteredViewport,
        onPositionChange,
        onSticky,
        getHeaderHeight,
        shouldCheckPositionForOnViewportEnteredOnly
    ]);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    const onScrollThrottle = React.useCallback(throttle(handleScroll, ON_SCROLL_THROTTLE), [handleScroll]);
    React.useEffect(() => {
        // set intersection observer
        const observerOptions = {
            root: null,
            threshold: buildThresholdList(20)
        };
        const observer = new IntersectionObserver(onViewportChange, observerOptions);
        if (anchorRef.current) {
            observer.observe(anchorRef.current);
        }
        return () => {
            if (observer) {
                observer.disconnect();
            }
        };
    }, [onViewportChange]);
    React.useEffect(() => {
        if (!onSticky && !onPositionChange) {
            return;
        }
        window.addEventListener('scroll', onScrollThrottle, { passive: true });
        // eslint-disable-next-line consistent-return
        return () => {
            onScrollThrottle?.cancel && onScrollThrottle.cancel();
            window.removeEventListener('scroll', onScrollThrottle);
        };
    }, [onSticky, onPositionChange, onScrollThrottle]);
    return (React.createElement(AspectRatioWrapper, { isActive: true, ref: anchorRef }, children));
}
ViewportMonitor.propTypes = {
    children: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    observerThreshold: PropTypes.number,
    /** Fires each onScroll event to apply custom logic to detect if wrapper is sticky or other. */
    onPositionChange: PropTypes.func,
    /** Fires when sticky toggles */
    onSticky: PropTypes.func,
    onViewportChange: PropTypes.func,
    shouldCheckPositionForOnViewportEnteredOnly: PropTypes.bool
};
module.exports = ViewportMonitor;
//# sourceMappingURL=ViewportMonitor.js.map

/***/ }),

/***/ 64930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const VariedCNEVideoEmbed = __webpack_require__(83482);
module.exports = asConfiguredComponent(VariedCNEVideoEmbed, 'CNEVideoEmbed');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86078:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { calculateSpacing } = __webpack_require__(26865);
const { cssVariablesGrid } = __webpack_require__(1123);
const { BREAKPOINTS } = __webpack_require__(96472);
const STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT = calculateSpacing(8);
const CNE_VIDEO_EMBED_BIG_PLAYER_HEIGHT_PADDING = calculateSpacing(2);
const LINK_BANNER_HEIGHT = 60;
const MIN_WIDTH_VIDEO_ITEM = 642; // min width for for watch page to fit well in the available space
const MIN_WIDTH_VIDEO_ITEM_XS = 375; // min width for watch page && for small devices to fit well in the available space
const AspectRatioWrapper = styled.div.withConfig({
    displayName: 'AspectRatioWrapper'
}) ``;
const CneVideoEmbedFigure = styled.figure.withConfig({
    displayName: 'CneVideoEmbedFigure'
}) `
  margin: ${({ hasMargins, isTitleLeftAligned, isRightRail, shouldActivateTeaser, hasNoBottomMarginForCneVideo }) => {
    if (shouldActivateTeaser) {
        return `0 auto;`;
    }
    if (hasMargins && !isTitleLeftAligned) {
        if (hasNoBottomMarginForCneVideo) {
            return `${calculateSpacing(5)} auto 0 auto`;
        }
        return `${calculateSpacing(5)} auto;`;
    }
    if (!isRightRail && isTitleLeftAligned) {
        if (hasNoBottomMarginForCneVideo) {
            return `${calculateSpacing(3)} 0 0 0`;
        }
        return `${calculateSpacing(3)} 0;`;
    }
    return `0 auto;`;
}};

  /* we need to set a generic max-width calc() for homepage / bundle page
   to let the video stay in viewport
   these lines override some generic style in stacked-navigation component
   making them available for all configurations */
  .verso-bundle-cne-embed &,
  .verso-bundle-cne-embed--grid-with-margins & {
    ${cssVariablesGrid()}
    max-width: ${({ aspectRatio }) => {
    return (aspectRatio &&
        `calc((100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px - ${CNE_VIDEO_EMBED_BIG_PLAYER_HEIGHT_PADDING} ) * ${aspectRatio} - var(--grid-margin) * 2 );`);
}};
  }
  /* LANDSCAPE VIDEOs */
  ${({ aspectRatio }) => aspectRatio &&
    aspectRatio > 1 &&
    `
    /* if the figure has a parent with lead-asset (so we're in the content-header)
    then we can calc() the max-width to let the video stay always into the viewport */
    .lead-asset & {
      max-width: calc(
        (
            100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} -
              ${LINK_BANNER_HEIGHT}px -
              ${CNE_VIDEO_EMBED_BIG_PLAYER_HEIGHT_PADDING}
          ) * ${aspectRatio}
      );
    }

    #video-container > div {
      padding-top: calc( 100% * ( 1 / ${aspectRatio} )) !important
    }

    .CneVideoWatchPageContainer & {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
      }
  `}

  /* VERTICAL or SQUARED VIDEOs */
  ${({ aspectRatio }) => aspectRatio &&
    (aspectRatio < 1 || aspectRatio === 1) &&
    `
     &&& {
        max-width: calc( ( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px ) * ${aspectRatio} );
     }
    
    &&& {
      /* with responsive asset (aka: gallery) we need to force the height of the container */
      .GallerySlideResponsiveAsset &{
        max-width: 100%;
        height: auto;
        padding-bottom: 0;
      }
    }
    
    #video-container > div {
      padding-top: calc( 100% * ( 1 / ${aspectRatio} )) !important
    }
    
    &&& {
        .CollageVideoItemWrapper & ,
        .CneVideoWatchPageContainer & {
          position: relative;
          top: unset;
          left: unset;
          right: unset;
          margin-top: -56.25%;
          width: 100%;
          height: 100%;
          max-width: calc( ( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px ) * ${aspectRatio} );
          @media (orientation: landscape) {
            min-width: calc(${MIN_WIDTH_VIDEO_ITEM_XS}px);
          }

          @media (min-width: ${BREAKPOINTS.md}) {
            max-width: calc( ( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px - ${calculateSpacing(24)} ) * ${aspectRatio} );
            min-width: calc( ${MIN_WIDTH_VIDEO_ITEM}px * ${aspectRatio} );
          }
          
          @media (min-width: ${BREAKPOINTS.lg}) {
            max-width: calc( ( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px  - ${calculateSpacing(48)} ) * ${aspectRatio} );
            min-width: calc( ${MIN_WIDTH_VIDEO_ITEM}px * ${aspectRatio} );
          }

          @media (min-width: ${BREAKPOINTS.xl}) {
            max-width: calc( ${MIN_WIDTH_VIDEO_ITEM}px * ${aspectRatio} );
            min-width: calc( ${MIN_WIDTH_VIDEO_ITEM}px * ${aspectRatio} );
          }
        }   
                      
       .CollageVideoItemWrapper & {
          margin-left: 50%;
          transform: translateX(-50%);
          margin-top: unset;
          padding-bottom: unset;
          max-width: calc( ( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} ) * ${aspectRatio} );
          min-width: calc( ${MIN_WIDTH_VIDEO_ITEM}px * ${aspectRatio} );
          
          
          @media (min-width: ${BREAKPOINTS.lg}) {
            max-width: calc( ( 100vh - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT} - ${LINK_BANNER_HEIGHT}px  - ${calculateSpacing(48)} ) * ${aspectRatio} );
          }
        
       }

        .MixedMediaCarouselItem & { max-width: inherit; }
    `}

    /* SQUARED VIDEOs */
    ${({ aspectRatio }) => aspectRatio &&
    aspectRatio === 1 &&
    `    
    &&& {
      .CneVideoWatchPageContainer & {
          min-width: ${MIN_WIDTH_VIDEO_ITEM_XS}px;

          @media (orientation: landscape) {
            min-width: calc(${MIN_WIDTH_VIDEO_ITEM_XS}px);
          }
          
          @media (min-width: ${BREAKPOINTS.md}) {
            min-width: ${MIN_WIDTH_VIDEO_ITEM}px;
          }

          @media (min-width: ${BREAKPOINTS.lg}) {
            min-width: calc(${MIN_WIDTH_VIDEO_ITEM}px - ${STACKED_NAVIGATION_FIXED_HEADER_TOP_HEIGHT});
          }

          @media (min-width: ${BREAKPOINTS.xl}) {
            min-width: ${MIN_WIDTH_VIDEO_ITEM}px;
          }
      } 
              
       .CollageVideoItemWrapper & {
          @media (orientation: landscape) {
            min-width: calc(${MIN_WIDTH_VIDEO_ITEM_XS}px + ${calculateSpacing(4)});
          }
          @media (min-width: ${BREAKPOINTS.md}) {
            max-width: calc( ${MIN_WIDTH_VIDEO_ITEM}px + ${calculateSpacing(6)} ) ;
          }
       }
    }
  `}

  ${({ isPlaylist }) => isPlaylist &&
    `
      &&& {
        @media (max-width: ${BREAKPOINTS.md}) { margin: 0 calc(-1 * var(--grid-margin)); }
      }

      /* force 16/9 aspect ratio */
      #video-container > div {
        padding-top: 56.25% !important;
      }
    `}

  ${({ isPlaylist, aspectRatio }) => isPlaylist &&
    aspectRatio &&
    (aspectRatio < 1 || aspectRatio === 1) &&
    `
      max-width: initial !important;
  `}

  // Visual Story needs a full width/height video
  .StoryContainer & {
    border-radius: 0;
    width: 100%;
    max-width: inherit; /* reset max-width in cnevideoembed component */
    height: 100%;
    overflow: hidden;
    object-fit: cover;
    @media (min-width: 480px) {
      border-radius: 16px;
    }
  }
`;
module.exports = {
    CneVideoEmbedFigure,
    AspectRatioWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 43256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    persistantCloseTitle: {
        id: 'CneVideoEmbed.PersistantCloseTitle',
        defaultMessage: 'Close Persisted Player',
        description: 'persistant close title for cne video embed'
    },
    watchNowTitle: {
        id: 'CneVideoEmbed.WatchNow',
        defaultMessage: 'Streaming Live Now',
        description: 'Watch Now label'
    },
    live: {
        id: 'CneVideoEmbed.Live',
        defaultMessage: ' Live',
        description: 'Live label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 62327:
/***/ ((module) => {

/**
 * positionUtils.js
 * Exports different types/positions of CNE video embeds
 * that can be interpreted and used by the CNEVideoEmbed
 * component and the CNE Player
 */
/*
  storyVideoPosition represents copilot's "Story Videos"
  rendered via LeadAsset.js. "heroVideo" is the label required
  by CNE Player for tracking purposes
*/
const storyVideoPosition = 'heroVideo';
const inlineInterludePosition = 'inlineInjected';
const inlineEmbedPosition = 'inlineEmbedded';
const watchPagePosition = 'watchPage';
module.exports = {
    storyVideoPosition,
    inlineInterludePosition,
    watchPagePosition,
    inlineEmbedPosition
};
//# sourceMappingURL=positionsUtils.js.map

/***/ }),

/***/ 83482:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const CNEVideoEmbed = __webpack_require__(59098);
CNEVideoEmbed.StickyHeader = asVariation(CNEVideoEmbed, 'StickyHeader', {
    stickyVariation: 'StickyHeader'
});
CNEVideoEmbed.FullBleedTeaser = asVariation(CNEVideoEmbed, 'FullBleedTeaser', {
    teaserVariation: 'FullBleedTeaser'
});
CNEVideoEmbed.StickyLiveStories = asVariation(CNEVideoEmbed, {}, {
    stickyVariation: 'StickyLiveStories'
});
CNEVideoEmbed.FullBleedNoTeaser = asVariation(CNEVideoEmbed, 'FullBleedNoTeaser', {
    teaserVariation: 'FullBleedNoTeaser'
});
module.exports = CNEVideoEmbed;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 45548:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
module.exports = React.createContext();
//# sourceMappingURL=FormErrorContext.js.map

/***/ }),

/***/ 14871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
module.exports = React.createContext(new Map());
//# sourceMappingURL=FormValidationContext.js.map

/***/ }),

/***/ 88974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const get = __webpack_require__(58156);
const PropTypes = __webpack_require__(5556);
const { injectIntl } = __webpack_require__(46984);
const React = __webpack_require__(96540);
const ValidityContext = __webpack_require__(14871);
const FormErrorContext = __webpack_require__(45548);
const UtilityValidationDescription = __webpack_require__(17249);
const translations = (__webpack_require__(98259)/* ["default"] */ .A);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Converts array of errors to Map
 *
 * @param {Array<{ elementId: string, id: string }>} errors - List of errors
 *
 * @returns {Map<key, key>} Map where key is invalid element id and the value is the description element's id
 */
function getInvalidElements(errors) {
    const invalidElements = new Map();
    errors.forEach((error) => {
        if (error.elementId) {
            invalidElements.set(error.elementId, error.id);
        }
    });
    return invalidElements;
}
/**
 * FormWithValidation component
 *
 * @param {object} props - React props
 * @param {ReactElement} [props.children] - Optional React children
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object} [props.customInvalidityMessages] - Optional custom invalidity messages, which must be nested under form element names.
 *   Ex: { email: { typeMismatch: 'Please enter a valid email' } }
 *   "Email" corresponds to the HTML element with attribute name=email
 *   For a list of all possible invalid properties, please refer to https://developer.mozilla.org/en-US/docs/Web/API/ValidityState.
 * @param {Array<object>} [props.errors] - Optional list of external errors of type `{ id: string, text: string, messages: string[], elementId: string }`.
 *   id must be a unique string that will be assigned to the validation description.
 *   for is optional and point to an invalid element's id
 * @param {string} props.name - Name of form
 * @param {Function} [props.onInvalidFormHandler] - Optional handler to fire when form has invalid elements
 * @param {Function} [props.onResetHandler] - Optional handler for resetting inputs
 * @param {Function} [props.onSubmitAttemptHandler] - Optional handler for any attempted (not necessarily completed) submit
 * @param {Function} [props.onSubmitHandler] - Optional submit handler
 * @param {boolean} [props.shouldHideValidationErrorText] - Optional hide validation error text just displaying the message
 * @param {string} [props.validationClassName] - Optional className for validation description
 *
 * @returns {ReactElement} <form>
 */
class FormWithValidation extends React.Component {
    constructor(props) {
        super(props);
        this.onFocusHandler = () => {
            this.props.onFocusHandler && this.props.onFocusHandler();
        };
        this.onBlurHandler = (e) => {
            this.props.onBlurHandler && this.props.onBlurHandler(e);
        };
        this.onResetHandler = (e) => {
            this.props.onResetHandler && this.props.onResetHandler(e);
        };
        /**
         * @param {Event} event - Submit event
         *
         * @returns {undefined} undefined
         */
        this.onSubmitHandler = (event) => {
            event.preventDefault();
            const { onInvalidFormHandler, onSubmitAttemptHandler, onSubmitHandler } = this.props;
            if (onSubmitAttemptHandler) {
                onSubmitAttemptHandler();
            }
            const formValidationErrors = this.validateForm();
            if (formValidationErrors.length) {
                if (onInvalidFormHandler) {
                    onInvalidFormHandler(formValidationErrors);
                }
                return;
            }
            if (onSubmitHandler) {
                onSubmitHandler(event);
            }
        };
        /**
         * @param {object} node - React node ref
         *
         * @returns {undefined} undefined
         */
        this.formRef = (node) => {
            this.form = node;
        };
        this.form = null;
        this.state = {
            invalidElements: new Map(),
            formValidationErrors: []
        };
    }
    componentDidMount() {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'FormWithValidation'
        });
    }
    /**
     * @returns {Map<key, key>} Map where key is invalid element id and the value is the description element's id
     */
    validateForm() {
        let hasFocused = false;
        const { customInvalidityMessages, intl } = this.props;
        const invalidElements = new Map();
        const formValidationErrors = [];
        for (let i = 0; i < this.form.elements.length; i++) {
            const element = this.form.elements[i];
            if (element.validity.valid) {
                continue;
            }
            if (!hasFocused) {
                element.focus();
                hasFocused = true;
            }
            const descriptionId = `${element.id}-validation-description`;
            invalidElements.set(element.id, descriptionId);
            const invalidityMessages = {
                badInput: intl.formatMessage(translations.badInput),
                customError: intl.formatMessage(translations.customError),
                patternMismatch: intl.formatMessage(translations.patternMismatch),
                rangeOverflow: intl.formatMessage(translations.rangeOverflow),
                rangeUnderflow: intl.formatMessage(translations.rangeUnderflow),
                stepMismatch: intl.formatMessage(translations.stepMismatch),
                tooLong: intl.formatMessage(translations.tooLong),
                tooShort: intl.formatMessage(translations.tooShort),
                typeMismatch: intl.formatMessage(translations.typeMismatch),
                valueMissing: intl.formatMessage(translations.valueMissing)
            };
            const elementErrors = Object.keys(invalidityMessages).reduce((acc, key) => {
                if (element.validity[key]) {
                    const errorMessage = get(customInvalidityMessages, `${element.name}.${key}`) ||
                        invalidityMessages[key];
                    acc.push(errorMessage);
                }
                return acc;
            }, []);
            if (elementErrors.length) {
                const descriptor = element.dataset && element.dataset.descriptor;
                formValidationErrors.push({
                    id: descriptionId,
                    elementId: element.id,
                    text: descriptor ||
                        intl.formatMessage(translations.invalidValueMessage, {
                            field: element.name
                        }),
                    messages: descriptor ? null : elementErrors
                });
            }
        }
        this.setState({
            formValidationErrors,
            invalidElements
        });
        return formValidationErrors;
    }
    render() {
        const { children, className, errors, name, validationClassName, shouldHideValidationErrorText } = this.props;
        const validationErrors = this.state.formValidationErrors.concat(errors);
        const invalidElements = getInvalidElements(errors);
        this.state.invalidElements.forEach((value, key) => {
            invalidElements.set(key, value);
        });
        return (React.createElement("form", { className: classnames('form-with-validation', className), "data-testid": "form-with-validation", id: name, name: name, "aria-label": name, noValidate: true, onFocus: this.onFocusHandler, onBlur: this.onBlurHandler, onReset: this.onResetHandler, onSubmit: this.onSubmitHandler, ref: this.formRef, method: "POST" },
            validationErrors.length > 0 && (React.createElement(UtilityValidationDescription, { shouldHideErrorText: shouldHideValidationErrorText, className: validationClassName, errors: validationErrors })),
            React.createElement(ValidityContext.Provider, { value: invalidElements },
                React.createElement(FormErrorContext.Provider, { value: validationErrors }, children))));
    }
}
FormWithValidation.propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,
    customInvalidityMessages: PropTypes.object,
    errors: PropTypes.arrayOf(PropTypes.shape({
        id: PropTypes.string,
        elementId: PropTypes.string,
        messages: PropTypes.arrayOf(PropTypes.string),
        text: PropTypes.string.isRequired
    })),
    intl: PropTypes.object,
    name: PropTypes.string,
    onBlurHandler: PropTypes.func,
    onFocusHandler: PropTypes.func,
    onInvalidFormHandler: PropTypes.func,
    onResetHandler: PropTypes.func,
    onSubmitAttemptHandler: PropTypes.func,
    onSubmitHandler: PropTypes.func,
    shouldHideValidationErrorText: PropTypes.bool,
    validationClassName: PropTypes.string
};
FormWithValidation.defaultProps = {
    customInvalidityMessages: {},
    errors: []
};
module.exports = injectIntl(FormWithValidation);
//# sourceMappingURL=FormWithValidation.js.map

/***/ }),

/***/ 72983:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(88974);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 98259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    badInput: {
        id: 'FormWithValidation.BadInput',
        defaultMessage: 'Bad input',
        description: 'form validation message on bad input'
    },
    customError: {
        id: 'FormWithValidation.CustomError',
        defaultMessage: 'Custom error',
        description: 'form validation message on Custom error'
    },
    patternMismatch: {
        id: 'FormWithValidation.PatternMismatch',
        defaultMessage: 'Pattern mismatch',
        description: 'form validation message on pattern mismatch'
    },
    rangeOverflow: {
        id: 'FormWithValidation.RangeOverflow',
        defaultMessage: 'Range overflow',
        description: 'form validation message on range overflow'
    },
    rangeUnderflow: {
        id: 'FormWithValidation.RangeUnderflow',
        defaultMessage: 'Range underflow',
        description: 'form validation message on range underflow'
    },
    stepMismatch: {
        id: 'FormWithValidation.StepMismatch',
        defaultMessage: 'Step mismatch',
        description: 'form validation message on step mismatch'
    },
    tooLong: {
        id: 'FormWithValidation.TooLong',
        defaultMessage: 'Too long',
        description: 'form validation message on too long'
    },
    tooShort: {
        id: 'FormWithValidation.TooShort',
        defaultMessage: 'Too short',
        description: 'form validation message on too short'
    },
    typeMismatch: {
        id: 'FormWithValidation.TypeMismatch',
        defaultMessage: 'Type mismatch',
        description: 'form validation message on type mismatch'
    },
    valueMissing: {
        id: 'FormWithValidation.ValueMissing',
        defaultMessage: 'This field cannot be empty',
        description: 'form validation message on value missing'
    },
    invalidValueMessage: {
        id: 'FormWithValidation.InvalidValueMessage',
        defaultMessage: '{field} is invalid.',
        description: 'Mesage indicating invalid value'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 63050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const ValidityContext = __webpack_require__(14871);
function withInvalidElementMapping(Component) {
    const displayName = Component.displayName || Component.name;
    const WithInvalidElements = (props) => (React.createElement(ValidityContext.Consumer, null, (invalidElements) => (React.createElement(Component, { ...props, invalidElements: invalidElements }))));
    WithInvalidElements.displayName = displayName
        ? `WithInvalidElements(${displayName})`
        : 'WithInvalidElements';
    WithInvalidElements.propTypes = Component.propTypes;
    return WithInvalidElements;
}
module.exports = withInvalidElementMapping;
//# sourceMappingURL=withInvalidElementMapping.js.map

/***/ }),

/***/ 2722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const CNEVideoEmbed = __webpack_require__(64930);
const ResponsiveAsset = __webpack_require__(73275);
const PlayIcon = __webpack_require__(11118);
const PlayCNEIcon = __webpack_require__(23150);
const { TrackComponentChannel } = __webpack_require__(78788);
const { InlineVideoItemWrapper, InlineVideoItemHed, InlineVideoItemImageLink, InlineVideoItemHeadingLink, InlineVideoItemPublishDate, InlineVideoItemIconButton, InlineVideoItemRubric } = __webpack_require__(41803);
/**
 * InlineVideoItem component
 *
 * @param {object} props - React Props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dangerousHed] - Optional Article Hed.
 * @param {string} props.image - Image to show when not playing video inline
 * @param {Bool} props.isDenseSummaryCollageThree - Flag to use alternate style for SummaryCollageThree
 * @param {Function} [props.onVideoChange] - Optional function that gets called with video when video loads or changes.
 * @param {string} [props.playIconStyle] - Optional choice of 'dark', 'white' or 'cne' for play icon
 * @param {string} [props.publishDate] - Optional Publish Date.
 * @param {object} props.rubric - rubric object
 * @param {string} props.scriptUrl - Url for script to load CNE Video.
 * @param {boolean} [props.shouldHideIcon] - Optional setting to hide play button icon (defaults to false)
 * @param {boolean} [props.shouldPlayInline] - Optional Switch to enable inline playback
 * @param {string} props.url -  URL to video page when not playing video inline. Required
 * @param {string} [props.contentAlign] - [`center`, `left`] Optional. Sets the text alignment of textual content block. Defaults to `left`
 * @param {boolean} [props.hasNoBottomMarginForCneVideo] - Optional flag to remove bottom margin for cnevideo
 * @param {string} [props.hedTag] - Option to override the default header html tag when nested whithin a higher level header
 * @param {string} [props.videoEmbedPosition] - video position in page
 *
 * @returns {ReactElement} <div>
 */
const InlineVideoItem = ({ className, contentAlign = 'left', dangerousHed, hasNoBottomMarginForCneVideo, hedTag = 'h2', rubric, image, isDenseSummaryCollageThree, onVideoChange = () => { }, playIconStyle, publishDate, scriptUrl, shouldHideIcon = false, shouldPlayInline = false, url, videoEmbedPosition = '' }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'InlineVideoItem'
        });
    }, []);
    const classes = classnames('inline-video-item', className);
    const RenderedPlayIcon = playIconStyle === 'cne' ? PlayCNEIcon : PlayIcon;
    const cneAsset = shouldPlayInline && scriptUrl ? (React.createElement(CNEVideoEmbed, { scriptUrl: scriptUrl, onVideoChange: onVideoChange, hasNoBottomMarginForCneVideo: hasNoBottomMarginForCneVideo, videoEmbedPosition: videoEmbedPosition })) : (React.createElement(InlineVideoItemImageLink, { "data-testid": "InlineVideoItemImageLink", href: url, "aria-hidden": "true", tabIndex: "-1", isDenseSummaryCollageThree: isDenseSummaryCollageThree },
        React.createElement(ResponsiveAsset, { ...image }),
        !shouldHideIcon && (React.createElement(InlineVideoItemIconButton, { iconStyle: playIconStyle, ButtonIcon: RenderedPlayIcon, inputKind: "text", isIconButton: true, label: "icon", isDenseSummaryCollageThree: isDenseSummaryCollageThree }))));
    const headingElement = (React.createElement(InlineVideoItemHed, { className: "inline-video-item__hed", dangerouslySetInnerHTML: { __html: dangerousHed }, as: hedTag }));
    const headingLink = shouldPlayInline ? (headingElement) : (React.createElement(InlineVideoItemHeadingLink, { href: url }, headingElement));
    return (React.createElement(InlineVideoItemWrapper, { className: classes, contentAlign: contentAlign, "data-testid": "InlineVideoItemWrapper", hasNoBottomMarginForCneVideo: hasNoBottomMarginForCneVideo, isDenseSummaryCollageThree: isDenseSummaryCollageThree },
        cneAsset,
        isDenseSummaryCollageThree && (React.createElement(InlineVideoItemRubric, { name: rubric.name })),
        dangerousHed && headingLink,
        publishDate && (React.createElement(InlineVideoItemPublishDate, null, publishDate))));
};
InlineVideoItem.propTypes = {
    className: PropTypes.string,
    contentAlign: PropTypes.oneOf(['center', 'left']).isRequired,
    dangerousHed: PropTypes.string,
    hasNoBottomMarginForCneVideo: PropTypes.bool,
    hedTag: PropTypes.string,
    image: PropTypes.shape(ResponsiveAsset.propTypes).isRequired,
    isDenseSummaryCollageThree: PropTypes.bool,
    onVideoChange: PropTypes.func,
    playIconStyle: PropTypes.oneOf(['dark', 'cne', 'white']),
    publishDate: PropTypes.string,
    rubric: PropTypes.object,
    scriptUrl: PropTypes.string.isRequired,
    shouldHideIcon: PropTypes.bool,
    shouldPlayInline: PropTypes.bool,
    url: PropTypes.string.isRequired,
    videoEmbedPosition: PropTypes.string
};
module.exports = InlineVideoItem;
//# sourceMappingURL=InlineVideoItem.js.map

/***/ }),

/***/ 29697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(2722);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 41803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseLink, BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorStyles, getTypographyStyles, getColorToken, minScreen, maxScreen } = __webpack_require__(26865);
const { BREAKPOINTS, INTERACTIVE } = __webpack_require__(96472);
const { CneVideoEmbedFigure } = __webpack_require__(86078);
const { ButtonIconWrapper, ButtonIcon } = __webpack_require__(18974);
const Button = __webpack_require__(73730);
const Rubric = __webpack_require__(34187);
const InlineVideoItemHed = styled(BaseText).withConfig({
    displayName: 'InlineVideoItemHed'
}) `
  ${getTypographyStyles('typography.definitions.discovery.hed-break-out')}
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-bottom: ${calculateSpacing(3)};
  }
`;
InlineVideoItemHed.defaultProps = {
    bottomSpacing: 2,
    topSpacing: 0
};
const InlineVideoItemRubric = styled(Rubric).withConfig({
    displayName: 'InlineVideoItemRubric'
}) `
  display: block;
  margin-bottom: ${calculateSpacing(1)};
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.context-signature')};
`;
const InlineVideoItemWrapper = styled.div.withConfig({
    displayName: 'InlineVideoItemWrapper'
}) `
  border-bottom: 1px solid;
  ${({ theme, isDenseSummaryCollageThree }) => isDenseSummaryCollageThree
    ? getColorStyles(theme, 'border-color', 'colors.discovery.body.white.border')
    : getColorStyles(theme, 'border-color', 'colors.discovery.body.white.divider')};
  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.discovery.body.white.background')};
  padding-bottom: ${calculateSpacing(5)};
  ${({ contentAlign }) => contentAlign && `text-align: ${contentAlign};`}
  ${CneVideoEmbedFigure} {
    margin-top: 0;
    margin-bottom: ${({ hasNoBottomMarginForCneVideo }) => !hasNoBottomMarginForCneVideo ? `${calculateSpacing(3)}` : '0'};
  }
  ${InlineVideoItemRubric} {
    @media (min-width: ${BREAKPOINTS.lg}) {
      display: none;
    }
  }
`;
const InlineVideoItemImageLink = styled(BaseLink).withConfig({
    displayName: 'InlineVideoItemImageLink'
}) `
  display: inline-block;
  position: relative;
  margin-bottom: ${({ isDenseSummaryCollageThree }) => !isDenseSummaryCollageThree
    ? `${calculateSpacing(3)}`
    : `${calculateSpacing(2)}`};

  .icon-playcne circle {
    transition: fill-opacity 300ms, stroke-opacity 300ms;
  }

  &:hover,
  &:active,
  &:focus {
    .icon-playcne {
      background: none;

      circle {
        fill-opacity: 0.8;
        stroke-opacity: 1;
      }
    }
  }
`;
const InlineVideoItemHeadingLink = styled(BaseLink).withConfig({
    displayName: 'InlineVideoItemHeadingLink'
}) ``;
InlineVideoItemHeadingLink.defaultProps = {
    colorStaticLinkToken: 'colors.discovery.body.white.heading',
    getLinkStyles: 'global'
};
const InlineVideoItemPublishDate = styled(BaseText).withConfig({
    displayName: 'InlineVideoItemPublishDate'
}) `
  display: block;
`;
InlineVideoItemPublishDate.defaultProps = {
    as: 'time',
    colorToken: 'colors.discovery.body.white.context-tertiary',
    typeIdentity: 'typography.definitions.globalEditorial.context-title'
};
const applyIconStyle = ({ iconStyle, theme }) => {
    switch (iconStyle) {
        case 'white':
            return `
          background: rgba(
            ${getColorToken(theme, 'colors.interactive.base.black', {
                rgbOnly: true
            })},
            0.8
          );
          ${getColorStyles(theme, 'border', 'colors.interactive.base.dark')};

          &:hover,
          &:active,
          &:focus {
            background: rgba(
              ${getColorToken(theme, 'colors.interactive.base.dark', {
                rgbOnly: true
            })},
              0.8
            );
            border: 0;
          }

          .icon {
            ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
          }
        `;
        case 'dark':
            return `
          && {
            background: rgba(
              ${getColorToken(theme, 'colors.interactive.base.black', {
                rgbOnly: true
            })},
              0.8
            );
            border: 1px solid;
            ${getColorStyles(theme, 'border-color', 'colors.interactive.base.dark')};
  
            &:hover,
            &:active,
            &:focus {
              background: rgba(
                ${getColorToken(theme, 'colors.interactive.base.light', {
                rgbOnly: true
            })},
                0.8
              );
              border: 0;
            }
  
            .icon {
              ${getColorStyles(theme, 'fill', 'colors.interactive.base.dark')};
            }
          }
        `;
        case 'cne':
            return `
          background: none;
          /* renders icon with 40px diameter  */
          height: 43px;
          width: 43px;

          &:hover,
          &:active,
          &:focus {
            background: none;
          }

          ${minScreen(BREAKPOINTS.md)} {
            /* renders icon with 44px diameter  */
            height: 47.5px;
            width: 47.5px;
          }
        `;
        default:
            return '';
    }
};
const InlineVideoItemIconButton = styled(Button.Utility).withConfig({
    displayName: 'InlineVideoItemIconButton'
}) `
  display: inline-flex;
  position: absolute;
  bottom: ${calculateSpacing(1)};
  align-items: center;
  justify-content: center;
  transition: background ${INTERACTIVE.timingLinkDefault} ease;
  border: 0;
  border-radius: 50%;
  background: rgba(
    ${getColorToken('colors.interactive.base.white', { rgbOnly: true })},
    0.85
  );
  padding: 0;
  width: 48px;
  height: 48px;

  ${({ position, isDenseSummaryCollageThree }) => {
    if (position === 'right' || isDenseSummaryCollageThree) {
        if (isDenseSummaryCollageThree) {
            return `${maxScreen(BREAKPOINTS.md)}{
          right: ${calculateSpacing(1)};
        }
        ${minScreen(BREAKPOINTS.lg)}{
          left: ${calculateSpacing(1)};
        }
        `;
        }
        return `right: ${calculateSpacing(1)};`;
    }
    return `left: ${calculateSpacing(1)};`;
}}
  ${ButtonIconWrapper} {
    display: flex;

    ${ButtonIcon} {
      margin-left: 2px;
      width: auto;
      height: auto;
    }
  }

  .icon {
    ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
  }

  &:hover,
  &:active,
  &:focus {
    border: 0;
    background: rgba(
      ${getColorToken('colors.interactive.base.white', { rgbOnly: true })},
      0.85
    );
  }

  ${applyIconStyle}
`;
module.exports = {
    InlineVideoItemWrapper,
    InlineVideoItemHed,
    InlineVideoItemImageLink,
    InlineVideoItemHeadingLink,
    InlineVideoItemPublishDate,
    InlineVideoItemIconButton,
    InlineVideoItemRubric
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 46997:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { LiveIndicatorContainer, LiveIndicatorIconContainer, LiveIndicatorAnimatedIcon, LiveIndicatorIcon, LiveIndicatorText } = __webpack_require__(750);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * LiveIndicator component
 *
 * @param {boolean}  [props.hasBackground] - Flag for background transparency
 * @param {boolean} [props.isDiscovery] - is discovery component
 * @param {boolean} [props.isStandard] - Optional to set color as per standard theme of brand.
 * @param {string} [props.liveIndicatorHeight] - height of live indicator
 * @param {boolean}  [props.shouldEnableAnimation] -  Optional to set animation true false for indicator.
 * @param {boolean} [props.shouldUseContextTertiaryTypeToken] - Optional to use globalEditorial.context-tertiary as type token for LiveIndicatorText
 * @param {boolean}  [props.shouldUseCutomColorLiveIndicator] - Optional to use custom background color.
 * @param {boolean} [props.shouldUseRubricColor] - Optional to use {discovery/consumption}.context-signature as background color token
 *
 * @returns {ReactElement} <div>
 */
const LiveIndicator = ({ className, hasBackground = true, isDiscovery = false, isStandard = false, shouldEnableAnimation = true, shouldUseContextTertiaryTypeToken = false, shouldUseCutomColorLiveIndicator = false, shouldUseRubricColor = false, liveIndicatorHeight }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'LiveIndicator'
        });
    }, []);
    return (React.createElement(LiveIndicatorContainer, { className: classnames('liveindicator', {
            'liveindicator--with-bg': hasBackground,
            'liveindicator--discovery': isDiscovery,
            'liveindicator--animated': shouldEnableAnimation
        }, className), hasBackground: hasBackground, isDiscovery: isDiscovery, isStandard: isStandard, shouldUseCutomColorLiveIndicator: shouldUseCutomColorLiveIndicator, shouldUseRubricColor: shouldUseRubricColor },
        React.createElement(LiveIndicatorIconContainer, { hasBackground: hasBackground, isDiscovery: isDiscovery, isStandard: isStandard },
            React.createElement(LiveIndicatorAnimatedIcon, { hasBackground: hasBackground, isDiscovery: isDiscovery, isStandard: isStandard, shouldEnableAnimation: shouldEnableAnimation }),
            React.createElement(LiveIndicatorIcon, { hasBackground: hasBackground, isDiscovery: isDiscovery, isStandard: isStandard })),
        React.createElement(LiveIndicatorText, { hasBackground: hasBackground, isDiscovery: isDiscovery, isStandard: isStandard, liveIndicatorHeight: liveIndicatorHeight, shouldUseContextTertiaryTypeToken: shouldUseContextTertiaryTypeToken }, "Live")));
};
LiveIndicator.propTypes = {
    className: PropTypes.string,
    hasBackground: PropTypes.bool,
    isDiscovery: PropTypes.bool,
    isStandard: PropTypes.bool,
    liveIndicatorHeight: PropTypes.string,
    shouldEnableAnimation: PropTypes.bool,
    shouldUseContextTertiaryTypeToken: PropTypes.bool,
    shouldUseCutomColorLiveIndicator: PropTypes.bool,
    shouldUseRubricColor: PropTypes.bool
};
module.exports = LiveIndicator;
//# sourceMappingURL=LiveIndicator.js.map

/***/ }),

/***/ 77938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const VariedLiveIndicator = __webpack_require__(91210);
module.exports = asConfiguredComponent(VariedLiveIndicator, 'LiveIndicator');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 750:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles, calculateSpacing } = __webpack_require__(26865);
const handleBackgroundColorForContainer = (hasBackground, isDiscovery, theme, shouldUseCutomColorLiveIndicator, shouldUseRubricColor) => {
    if (!hasBackground)
        return 'transparent';
    if (shouldUseRubricColor && isDiscovery)
        return getColorToken(theme, 'colors.discovery.body.white.context-signature');
    else if (shouldUseRubricColor)
        return getColorToken(theme, 'colors.consumption.lead.standard.context-signature');
    else if (shouldUseCutomColorLiveIndicator)
        return getColorToken(theme, 'colors.consumption.lead.standard.accent');
    else if (isDiscovery)
        return getColorToken(theme, 'colors.interactive.feedback.alert-secondary');
    return getColorToken(theme, 'colors.interactive.feedback.alert-secondary');
};
const handleFontColor = (hasBackground, isDiscovery, isStandard, theme) => {
    if (isStandard) {
        return getColorToken(theme, 'colors.interactive.base.brand-primary');
    }
    if (!isDiscovery)
        return getColorToken(theme, 'colors.consumption.lead.standard.context-texture');
    else if (hasBackground)
        return getColorToken(theme, 'colors.interactive.feedback.alert-primary');
    return getColorToken(theme, 'colors.interactive.feedback.alert-primary');
};
const LiveIndicatorContainer = styled.div.withConfig({
    displayName: 'LiveIndicatorContainer'
}) `
  display: inline-flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  margin-bottom: ${({ isStandard }) => isStandard ? calculateSpacing(2, 'px') : 0};
  background: ${({ hasBackground, isDiscovery, theme, shouldUseCutomColorLiveIndicator, shouldUseRubricColor }) => handleBackgroundColorForContainer(hasBackground, isDiscovery, theme, shouldUseCutomColorLiveIndicator, shouldUseRubricColor)};
  padding-right: ${({ hasBackground }) => hasBackground ? calculateSpacing(1.5, 'px') : calculateSpacing(0, 'px')};
  padding-left: ${({ hasBackground }) => hasBackground ? calculateSpacing(1.5, 'px') : calculateSpacing(0, 'px')};
  height: ${({ hasBackground }) => (hasBackground ? '32px' : '24px')};
`;
const handleLiveIndicatorTextStyle = (theme, shouldUseContextTertiaryTypeToken) => {
    if (shouldUseContextTertiaryTypeToken)
        return getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-tertiary');
    return getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary');
};
const LiveIndicatorText = styled.div.withConfig({
    displayName: 'LiveIndicatorText'
}) `
  align-items: center;
  height: ${({ liveIndicatorHeight }) => liveIndicatorHeight};
  color: ${({ hasBackground, isDiscovery, isStandard, theme }) => handleFontColor(hasBackground, isDiscovery, isStandard, theme)};
  ${({ theme, shouldUseContextTertiaryTypeToken }) => handleLiveIndicatorTextStyle(theme, shouldUseContextTertiaryTypeToken)};
`;
const LiveIndicatorIconContainer = styled.div.withConfig({
    displayName: 'LiveIndicatorIconContainer'
}) `
  position: relative;
  align-items: center;
  margin-right: ${calculateSpacing(1, 'px')};
  margin-left: ${({ hasBackground, isStandard }) => hasBackground || isStandard
    ? calculateSpacing(0, 'px')
    : calculateSpacing(1, 'px')};
`;
const LiveIndicatorIcon = styled.div.withConfig({
    displayName: 'LiveIndicatorIcon'
}) `
  border-radius: 50%;
  background-color: ${({ hasBackground, isDiscovery, isStandard, theme }) => handleFontColor(hasBackground, isDiscovery, isStandard, theme)};
  width: 8px;
  height: 8px;
`;
const LiveIndicatorAnimatedIcon = styled.div.withConfig({
    displayName: 'LiveIndicatorAnimatedIcon'
}) `
  position: absolute;
  animation: pulsate 2.5s ease-in-out;
  animation-iteration-count: ${({ shouldEnableAnimation }) => shouldEnableAnimation ? 'infinite' : 'unset'};
  opacity: 0;
  border: 3px solid;
  border-radius: 50%;
  border-color: ${({ hasBackground, isDiscovery, isStandard, theme }) => handleFontColor(hasBackground, isDiscovery, isStandard, theme)};
  background-color: ${({ hasBackground, isDiscovery, isStandard, theme }) => handleFontColor(hasBackground, isDiscovery, isStandard, theme)};

  width: 8px;
  height: 8px;

  @keyframes pulsate {
    0% {
      transform: scale(0.1, 0.1);
      opacity: 0;
    }

    35% {
      opacity: 1;
    }

    75% {
      transform: scale(3, 3);
      opacity: 0;
    }
  }
`;
module.exports = {
    LiveIndicatorContainer,
    LiveIndicatorIconContainer,
    LiveIndicatorAnimatedIcon,
    LiveIndicatorIcon,
    LiveIndicatorText
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 91210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const LiveIndicator = __webpack_require__(46997);
LiveIndicator.DiscoveryCard = asVariation(LiveIndicator, 'DiscoveryCard', {
    hasBackground: true,
    isDiscovery: true,
    shouldEnableAnimation: true
});
LiveIndicator.DiscoveryItem = asVariation(LiveIndicator, 'DiscoveryItem', {
    hasBackground: false,
    isDiscovery: true,
    shouldEnableAnimation: true
});
module.exports = LiveIndicator;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 10246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorStyles, getColorToken, getLinkStyles, getTypographyStyles, maxScreen, minScreen } = __webpack_require__(26865);
const { GridItem } = __webpack_require__(40653);
const Grid = __webpack_require__(86659);
const Navigation = __webpack_require__(54790);
const { NavigationListItemWrapper } = __webpack_require__(51418);
const { BaseLink } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const Button = __webpack_require__(73730);
const { resolveMenuKey } = __webpack_require__(70698);
const { SummaryCarouselRow } = __webpack_require__(34751);
const { CarouselWrapper, CarouselListItem } = __webpack_require__(44802);
const { isInverted } = __webpack_require__(70698);
const { maxThresholds } = __webpack_require__(99906);
const fixedSecondaryFooterAllLinkHeight = calculateSpacing(6);
const MarginTopSize = {
    LARGE: 'large'
};
const MegaMenuWrapper = styled.div.withConfig({
    displayName: 'MegaMenuWrapper'
}) `
  height: 100%;
`;
const commonNavigationStyles = `
  p {
    margin: 0;
  }

  .navigation__list-item {
    display: flex;
    position: relative;
    align-items: center;

    .navigation__link {
      display: block;
    }

    .drawer--align-center & {
      justify-content: center;
    }
  }

  .consumer-marketing-unit--nav-drawer {
    position: absolute;
  }
`;
const drawerSecondarySpacing = calculateSpacing(3);
const drawerPrimarySpacing = calculateSpacing(4);
const defaultMobileSpacing = calculateSpacing(2);
const MegaMenuGridWrapper = styled(Grid).withConfig({
    displayName: 'MegaMenuGridWrapper'
}) `
  ${({ theme }) => getColorStyles(theme, 'background-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.background'
    : 'colors.foundation.menu-bg.collapsed')};

  && {
    width: auto;
    max-width: inherit;

    ${minScreen(BREAKPOINTS.lg)} {
      padding: 0 ${calculateSpacing(6)};
    }

    ${minScreen(BREAKPOINTS.xl)} {
      padding: 0 ${calculateSpacing(8)};
    }

    ${minScreen(BREAKPOINTS.xxl)} {
      margin-left: 0;
    }
  }
  height: 100%;
  overflow-y: scroll;
  box-sizing: content-box;

  scrollbar-width: none;

  &::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  ${maxScreen(BREAKPOINTS.lg)} {
    ${({ hasSecondaryFooterAllLink }) => hasSecondaryFooterAllLink &&
    `
      height: calc(100% - ${fixedSecondaryFooterAllLinkHeight});
    `}
  }

  ${GridItem} {
    ${({ hasLinkBanner, isSlim, hasExtraTopMargin }) => {
    const calculateMarginTop = (num) => hasLinkBanner ? calculateSpacing(num + 7.5) : calculateSpacing(num);
    const calculateMarginSpace = () => {
        let marginTopValue;
        if (hasExtraTopMargin) {
            marginTopValue = calculateSpacing(8);
        }
        else if (isSlim) {
            marginTopValue = calculateMarginTop(11);
        }
        else {
            marginTopValue = calculateMarginTop(13);
        }
        return marginTopValue;
    };
    return `
        column-gap: ${calculateSpacing(14)};
        grid-column: 1 / -1;
        grid-template-rows: min-content;
        margin-top: ${calculateMarginTop(8)};
        
        ${minScreen(BREAKPOINTS.md)} {
          margin-top: ${!isSlim && calculateMarginTop(8)}
        }

        ${minScreen(BREAKPOINTS.lg)} {
          margin-top: ${calculateMarginSpace()}  
        }
      `;
}}
  }
`;
const MegaMenuContent = styled.div.withConfig({
    displayName: 'MegaMenuContent'
}) `
  ${({ isCentered }) => isCentered &&
    `
    max-width: ${BREAKPOINTS.xxl};
    margin: 0 auto;`}

  ${minScreen(BREAKPOINTS.lg)} {
    display: flex;
  }
`;
const MegaMenuNavigationPrimary = styled(Navigation.Vertical).withConfig({
    displayName: 'MegaMenuNavigationPrimary'
}) `
  ${({ showBlankHeading, marginTopSize }) => {
    const marginTop = showBlankHeading || marginTopSize === MarginTopSize.LARGE ? 4 : 2;
    return `margin: ${calculateSpacing(marginTop)} 0 ${calculateSpacing(4)} 0;`;
}};

  .navigation__heading {
    ${({ isHeadingALink }) => `
      margin: ${isHeadingALink
    ? `${calculateSpacing(5)} ${defaultMobileSpacing} 0  ${defaultMobileSpacing}`
    : `0  ${defaultMobileSpacing}`};
    `}

    ${minScreen(BREAKPOINTS.md)} {
      margin: 0 ${defaultMobileSpacing};
    }

    ${minScreen(BREAKPOINTS.lg)} {
      margin: 0;
    }

    &,
    a {
      text-decoration: none;
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};

      ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.title-primary')};
      ${({ theme, isHeadingALink }) => isHeadingALink &&
    `
          &:focus,
          &:hover {
            text-decoration: none;
            ${getColorStyles(theme, 'color', isInverted(theme)
        ? 'colors.consumption.lead.inverted.link-hover'
        : 'colors.foundation.collapsed-menu.nav-link.hover')};
          }
      `}
    }

    .content-divider {
      display: block;
      margin: ${calculateSpacing(2)} 0;
      border-bottom-width: 1px;
      border-bottom-style: solid;
      width: ${calculateSpacing(6)};
      ${({ theme }) => getColorStyles(theme, 'border-bottom-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.accent'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
    }
  }

  .navigation__list {
    display: grid;
    grid-column-gap: ${calculateSpacing(3)};
    grid-auto-columns: 1fr;
    grid-auto-flow: column;
    grid-template-rows: repeat(
      ${({ maxItemsPerColumn }) => {
    return maxItemsPerColumn;
}},
      ${({ hasExtraTopMargin }) => hasExtraTopMargin ? calculateSpacing(4.4) : calculateSpacing(5)}
    );
    margin-right: ${defaultMobileSpacing};
    justify-items: start;
    ${minScreen(BREAKPOINTS.lg)} {
      margin: 0;
    }

    ${maxScreen(BREAKPOINTS.lg)} {
      grid-column-gap: unset;
      grid-auto-flow: row;
      grid-template-rows: min-content;
      grid-row-gap: ${calculateSpacing(1)};
    }

    .navigation__list-item {
      margin: ${calculateSpacing(1)} 0 ${calculateSpacing(1)}
        ${defaultMobileSpacing};

      ${minScreen(BREAKPOINTS.md)} {
        margin: ${calculateSpacing(1)} 0 ${calculateSpacing(1)}
          ${defaultMobileSpacing};
      }

      ${minScreen(BREAKPOINTS.lg)} {
        margin: ${calculateSpacing(1)} ${calculateSpacing(3)}
          ${calculateSpacing(1)} 0;
      }

      .navigation__link {
        width: auto;
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};
        ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')};
        ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};

        &:visited,
        &:link {
          ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
        }

        &:focus,
        &:hover {
          ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
        }
      }

      .navigation__link_more {
        ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
      }
    }
  }

  .navigation__list.list__card {
    ${({ isCard }) => isCard &&
    `
      grid-auto-flow: row;
    `}

    ${minScreen(BREAKPOINTS.lg)} {
      grid-template-rows: revert;
      width: auto;
    }

    .summary-item__hed-link {
      &::after {
        content: none;
      }
    }

    .summary-item__hed {
      color: ${getColorToken('colors.foundation.collapsed-menu.nav-link.default')};
      ${getTypographyStyles('typography.definitions.foundation.link-secondary')};
    }
  }

  .navigation__list-item:last-of-type {
    ${({ theme, includesClickOut }) => includesClickOut &&
    `
        border-width: 1px 0;
        border-style: solid;
        ${getColorStyles(theme, 'border-color', isInverted(theme)
        ? 'colors.consumption.lead.inverted.divider'
        : 'colors.foundation.menu.dividers')};
        padding-top: ${calculateSpacing(2)};
        padding-bottom: ${calculateSpacing(2)};
        &&{
          justify-content: start;
        }
        width: 100%;
        margin: ${calculateSpacing(2)} 0;

        ${minScreen(BREAKPOINTS.lg)} {
          padding: ${calculateSpacing(3)} 0;
        }
      `}
    a {
      ${({ theme, includesClickOut }) => includesClickOut &&
    getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}
      ${({ theme, includesClickOut }) => includesClickOut &&
    `
          padding-left: ${calculateSpacing(3)};
          ${getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')}
          &:focus,
          &:hover {
            ${getColorStyles(theme, 'color', 'colors.foundation.expanded-utility.nav-link.hover')};
          }

          ${minScreen(BREAKPOINTS.md)} {
            padding-left: ${calculateSpacing(6)};
          }

          ${minScreen(BREAKPOINTS.lg)} {
            padding: 0;
          }
        `}
    }
  }

  &:last-of-type {
    .navigation__list.list__card {
      .navigation__list-item:last-of-type {
        ${({ hasClickOutWithCard }) => hasClickOutWithCard && `justify-content: flex-start;`}
      }
    }
  }

  ${minScreen(BREAKPOINTS.lg)} {
    &:last-of-type {
      .navigation__list {
        .navigation__list-item:last-of-type {
          ${({ theme, includesClickOut }) => includesClickOut &&
    `
              border-width: 1px 0 0 0;
              border-style: solid;
              margin: ${calculateSpacing(1)} 0 -${calculateSpacing(1)} 0;
              padding: ${calculateSpacing(2)} 0 0 0;
              ${getColorStyles(theme, 'border-color', isInverted(theme)
        ? 'colors.consumption.lead.inverted.divider'
        : 'colors.foundation.menu.dividers')};

              a {
                ${getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}
              }
            `}
        }
      }
    }
  }

  ${maxScreen(`${maxThresholds.lg}px`)} {
    margin: ${calculateSpacing(2)} 0;

    ${({ noHeadingGroupName, showDividerOnTop, isHeadingEmpty }) => {
    if (noHeadingGroupName) {
        return `margin-top: -${calculateSpacing(1)}}`;
    }
    else if (showDividerOnTop && isHeadingEmpty) {
        return `margin: ${calculateSpacing(4)} 0`;
    }
    return ``;
}}
  }

  ${commonNavigationStyles}
`;
const MegaMenuVerboseWrapper = styled('div').withConfig({
    displayName: 'MegaMenuVerboseWrapper'
}) `
  ${minScreen(BREAKPOINTS.lg)} {
    display: grid;
    grid-column-gap: ${calculateSpacing(4)};
    grid-auto-rows: min-content;
    grid-template-columns: repeat(12, auto);
  }

  ${minScreen(BREAKPOINTS.xl)} {
    grid-column-gap: ${calculateSpacing(8)};
  }

  ${MegaMenuNavigationPrimary} {
    ${minScreen(BREAKPOINTS.lg)} {
      &:nth-of-type(1) {
        grid-column: 4 / 6;
      }

      &:nth-of-type(2) {
        grid-column: 6 / 8;
      }

      &:nth-of-type(3) {
        grid-column: 8 / 10;
      }

      &:nth-of-type(4) {
        grid-column: 10 / 12;
      }

      > ul {
        min-width: ${calculateSpacing(15)};
      }
    }
  }

  .nav__card {
    ${minScreen(BREAKPOINTS.lg)} {
      width: 140px;
    }
    ${minScreen(BREAKPOINTS.xl)} {
      width: 180px;
    }
    ${minScreen(BREAKPOINTS.xxl)} {
      width: 240px;
    }
  }

  .navigation__divider {
    display: block;
    margin: 0 0 0 ${calculateSpacing(3)};
    border-bottom: 1px solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.divider'
    : 'colors.foundation.menu.dividers')};
    width: calc(100% - ${calculateSpacing(6)});

    ${minScreen(BREAKPOINTS.md)} {
      margin: 0 0 0 ${calculateSpacing(6)};
      width: calc(100% - ${calculateSpacing(12)});
    }

    ${minScreen(BREAKPOINTS.lg)} {
      display: none;
    }
  }

  .navigation__divider:last-of-type {
    display: none;
  }

  .nav__card {
    ${minScreen(BREAKPOINTS.xl)} {
      margin-right: -${calculateSpacing(4)};
    }
  }
`;
const MegaMenuCloseIcon = styled(Button.Utility).withConfig({
    displayName: 'MegaMenuCloseIconWrapper'
}) `
  position: relative;
  margin-left: auto;
  padding: 0;
  height: ${calculateSpacing(4)};

  &,
  &:active,
  &:hover,
  &:focus {
    border: 0;
    background-color: transparent;
  }

  .icon-close {
    padding: 8px;

    g {
      ${({ theme }) => getColorStyles(theme, 'stroke', isInverted(theme)
    ? 'colors.background.white'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
    }
  }

  ${({ hasExtraTopMargin, hasLinkBanner }) => hasExtraTopMargin &&
    !hasLinkBanner &&
    `margin-top: ${calculateSpacing(2)};`}
`;
const MegaMenuColumnFooterAllLinkWrapper = styled('div').withConfig({
    displayName: 'MegaMenuColumnFooterAllLinkWrapper'
}) `
  grid-column: 1;
  grid-row: -1;
  border-top: 1px solid;
  padding: ${calculateSpacing(1.5)} 0;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};

  ${maxScreen(`${maxThresholds.lg}px`)} {
    display: flex;
    position: fixed;
    align-items: center;
    justify-content: center;
    padding: 0;
    width: fill-available;
    height: ${fixedSecondaryFooterAllLinkHeight};

    ${({ theme }) => `
      border-top: 1px solid
      ${getColorStyles('border-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.divider'
    : 'colors.foundation.menu.dividers')};
      ${getColorStyles('background-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.background'
    : 'colors.foundation.menu-bg.collapsed')};
      ${getColorStyles('color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
    `}
  }
`;
const MegaMenuColumnWrapper = styled('div').withConfig({
    displayName: 'MegaMenuColumnWrapper'
}) `
  display: grid;
  grid-gap: 0 ${calculateSpacing(4)};
  --grid-columns-desktop: 5;
  grid-template-columns: repeat(var(--grid-columns-desktop), minmax(0, 1fr));
  grid-template-rows: min-content;
  flex-grow: 1;
  padding-bottom: ${calculateSpacing(2)};
`;
const MegaMenuDrawerNavLink = styled('li').withConfig({
    displayName: 'MegaMenuDrawerNavLink'
}) `
  list-style: none;

  a {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
    ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')};

    &:link,
    &:visited {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.body.inverted.body'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
    }

    &:focus,
    &:hover {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.body.inverted.body'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
    }
  }
`;
const MegaMenuDefaultWrapper = styled('div').withConfig({
    displayName: 'MegaMenuDefaultWrapper'
}) `
  ul {
    ${minScreen(BREAKPOINTS.lg)} {
      width: 500px;
    }
  }

  && {
    ${NavigationListItemWrapper} {
      justify-content: start;
    }
  }

  ${NavigationListItemWrapper} {
    width: 100%;

    ${minScreen(BREAKPOINTS.lg)} {
      padding-left: 0;
    }
  }
`;
const MegaMenuVerboseCategoryList = styled('ul').withConfig({
    displayName: 'MegaMenuVerboseCategoryList'
}) `
  padding: 0;
  ${minScreen(BREAKPOINTS.lg)} {
    grid-column: 1 / 4;
    min-width: ${calculateSpacing(30)};
  }

  ${minScreen(BREAKPOINTS.xl)} {
    min-width: ${calculateSpacing(35)};
  }

  li:first-of-type {
    border-top: 1px solid ${getColorToken('colors.foundation.menu.dividers')};
  }

  li {
    display: grid;
    position: relative;
    grid-template-columns: 1fr 10px;
    align-items: center;
    border-bottom: 1px solid;
    padding-left: ${defaultMobileSpacing};
    width: auto;
    min-height: ${calculateSpacing(6)};
    list-style: none;

    && {
      text-decoration: none;
    }

    &:focus,
    &:hover {
      ${({ theme, showBorderHighlight }) => showBorderHighlight &&
    `
        &::before {
          ${getColorStyles(theme, 'background-color', resolveMenuKey(theme, 'colors.foundation.collapsed-menu.nav-link.default'))};
          bottom: 0;
          content: '';
          height: 4px;
          position: absolute;
          width: 100%;
        }
      `}
      ${({ theme }) => `
        span {
          ${getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')}
        }

        svg { 
          ${getColorStyles(theme, 'fill', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')}} 
      `};
    }

    ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};

    ${minScreen(BREAKPOINTS.lg)} {
      grid-template-columns: unset;
      padding: ${calculateSpacing(2)} ${calculateSpacing(2)}
        ${calculateSpacing(2)} 0;
    }
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
    ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')};

    span {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};

      &:focus,
      &:hover {
        ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
      }
    }

    svg {
      ${({ theme }) => getColorStyles(theme, 'fill', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};

      justify-self: flex-end;
      margin-right: ${calculateSpacing(1)};

      ${minScreen(BREAKPOINTS.lg)} {
        margin-right: 0;
        width: ${calculateSpacing(2)};
        height: ${calculateSpacing(2)};
      }
    }

    &.active {
      grid-template-columns: ${calculateSpacing(4)} auto ${calculateSpacing(5)};
      margin-left: ${calculateSpacing(-1)};

      ${minScreen(BREAKPOINTS.lg)} {
        grid-template-columns: unset;
        margin-left: 0;
      }

      ${({ theme, showBorderHighlight }) => showBorderHighlight &&
    `
      &::before {
        ${getColorStyles(theme, 'background-color', resolveMenuKey(theme, 'colors.foundation.collapsed-menu.nav-link.hover'))};
        bottom: 0;
        content: '';
        height: 4px;
        position: absolute;
        width: 100%;
      }
    `};

      span {
        ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
        grid-area: 1 / 2;
        text-align: center;

        ${minScreen(BREAKPOINTS.lg)} {
          grid-area: unset;
          text-align: left;
        }
      }

      svg {
        justify-self: flex-start;
        ${({ theme }) => getColorStyles(theme, 'fill', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
        transform: rotate(180deg);
        ${minScreen(BREAKPOINTS.lg)} {
          justify-self: flex-end;
          transform: unset;
        }
      }
    }

    &:hover {
      text-decoration: none;

      ${({ showUnderlineOnHover }) => showUnderlineOnHover && `text-decoration: underline`}
    }
  }

  .li-with-chevron {
    grid-template-columns: none;
  }

  ${maxScreen(`calc(${BREAKPOINTS.lg} - 1px)`)} {
    margin: 0;
  }
`;
const MegaMenuVerboseCategoryLink = styled('a').withConfig({
    displayName: 'MegaMenuVerboseCategoryLink'
}) `
  display: grid;
  grid-template-columns: 1fr 10px;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
  ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')};

  &:hover {
    text-decoration: none;
    ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.expanded-utility.nav-link.default')};
  }

  &.active {
    ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.expanded-utility.nav-link.hover')};
  }
  transition: unset;

  span {
    ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
  }
`;
const MegaMenuNavLinkWithChevron = styled('a').withConfig({
    displayName: 'MegaMenuNavLinkWithChevron'
}) `
  display: grid;
  position: relative;
  grid-template-columns: 1fr 10px;
  align-items: center;
  width: auto;

  && {
    text-decoration: none;
  }

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
  ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')};

  &:focus,
  &:hover {
    ${({ theme }) => `
    span {
      ${getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')}
    }

    svg { 
      ${getColorStyles(theme, 'fill', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')}} 
  `};
  }

  &.active {
    grid-template-columns: ${calculateSpacing(4)} auto ${calculateSpacing(5)};
    margin-left: ${calculateSpacing(-1)};

    span {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
      grid-area: 1 / 2;
      text-align: center;
      white-space: nowrap;
    }

    svg {
      justify-self: flex-start;
      ${({ theme }) => getColorStyles(theme, 'fill', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
      transform: rotate(180deg);
    }
  }
`;
const MegaMenuBottom = styled.div.withConfig({
    displayName: 'MegaMenuBottom'
}) `
  padding: ${drawerPrimarySpacing} ${defaultMobileSpacing};

  &:empty {
    border: 0;
    padding: 0;
  }
`;
const MegaMenuAccount = styled.div.withConfig({
    displayName: 'MegaMenuAccount'
}) `
  line-height: 0.8em;

  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};

    ${({ theme }) => getLinkStyles(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default', null, 'navigation')};

    &:hover {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
    }
  }

  .navigation__list-item {
    display: flex;
    align-items: center;
    margin-bottom: ${drawerSecondarySpacing};

    .navigation__link {
      display: block;
    }
  }

  .account-links__sign-out {
    margin-bottom: ${drawerSecondarySpacing};
    padding: 0;
  }

  ${({ contentAlign }) => {
    if (contentAlign === 'center') {
        return `
        text-align: center;

        .navigation__list-item {
          justify-content: center;
        }
      `;
    }
    return '';
}}
`;
const MegaMenuSignInLink = styled(BaseLink).withConfig({
    displayName: 'MegaMenuSignInLink'
}) `
  ${({ theme }) => getLinkStyles(theme, isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default', null, 'navigation')};

  &:hover {
    ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
  }

  display: inline-block;
  margin-bottom: ${drawerSecondarySpacing};
`;
MegaMenuSignInLink.defaultProps = {
    colorStaticLinkToken: 'colors.foundation.collapsed-menu.nav-link.default',
    typeToken: 'typography.definitions.foundation.link-secondary'
};
const MegaMenuUtilityLinks = styled(Navigation.Vertical).withConfig({
    displayName: 'MegaMenuUtilityLinks'
}) `
  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};
    ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')};

    &:link,
    &:visited {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.collapsed-menu.nav-link.default')};
    }

    &:focus,
    &:hover {
      ${({ theme }) => getColorStyles(theme, 'color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link-hover'
    : 'colors.foundation.collapsed-menu.nav-link.hover')};
    }
  }

  .navigation__list-item {
    margin-bottom: ${drawerSecondarySpacing};
  }

  margin-bottom: ${drawerSecondarySpacing};

  ${({ utilityLinksOneItem }) => utilityLinksOneItem && `margin-bottom: 0;`}
`;
const MegaMenuMobileVerboseWrapper = styled(MegaMenuVerboseWrapper).withConfig({
    displayName: 'MegaMenuMobileVerboseWrapper'
}) `
  ${maxScreen(BREAKPOINTS.md)} {
    display: block;
  }

  .navigation__divider:last-of-type {
    display: block;
  }

  .navigation__divider:first-of-type {
    display: none;
  }

  ${MegaMenuNavigationPrimary} {
    width: auto;
  }

  ${SummaryCarouselRow} {
    ${({ theme }) => getColorStyles(theme, 'background-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.link'
    : 'colors.foundation.menu-bg.collapsed')};
    ${CarouselWrapper} {
      margin-top: ${calculateSpacing(1)};
      padding: 0 ${defaultMobileSpacing};
      ${CarouselListItem} {
        width: 50%;
        ${minScreen(BREAKPOINTS.md)} {
          width: 25%;
        }
      }

      .summary-item__icon-button {
        background-color: rgba(
          ${getColorToken('colors.interactive.base.white', {
    rgbOnly: true
})},
          0.9
        );

        svg path {
          fill: ${getColorToken('colors.interactive.base.black')};
        }

        &:hover,
        &:active,
        &:focus {
          background-color: rgba(
            ${getColorToken('colors.interactive.base.white', {
    rgbOnly: true
})},
            0.9
          );

          svg path {
            fill: ${getColorToken('colors.interactive.base.black')};
          }
        }
      }

      .summary-item__hed {
        color: ${getColorToken('colors.foundation.collapsed-menu.nav-link.default')};
        ${getTypographyStyles('typography.definitions.foundation.link-secondary')};
      }
    }
  }
`;
const MegaMenuMobileClickOutLink = styled('li').withConfig({
    displayName: 'MegaMenuMobileClickOutLink'
}) `
  ${({ theme }) => `
  border-width: 1px 0;
  border-style: solid;
  ${getColorStyles(theme, 'border-color', isInverted(theme)
    ? 'colors.consumption.lead.inverted.divider'
    : 'colors.foundation.menu.dividers')};
  padding-top: ${calculateSpacing(2)};
  padding-bottom: ${calculateSpacing(2)};
  &&{
    justify-content: start;
  }
  width: 95%;
  ${maxScreen(BREAKPOINTS.sm)} {
    width: 90%;
  }

  margin: ${calculateSpacing(2)} 0;

  ${minScreen(BREAKPOINTS.lg)} {
    padding: ${calculateSpacing(3)} 0;
  }
`}
  a {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}
    ${({ theme }) => `
    ${getLinkStyles(theme, 'colors.foundation.collapsed-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default', 'navigation')}
    &:focus,
    &:hover {
      ${getColorStyles(theme, 'color', 'colors.foundation.collapsed-menu.nav-link.hover')};
    }

    ${minScreen(BREAKPOINTS.md)} {
      padding-left: ${calculateSpacing(3)};
    }

    ${minScreen(BREAKPOINTS.lg)} {
      padding: 0;
    }
  `}
  }
`;
module.exports = {
    MarginTopSize,
    MegaMenuGridWrapper,
    MegaMenuContent,
    MegaMenuColumnFooterAllLinkWrapper,
    MegaMenuColumnWrapper,
    MegaMenuCloseIcon,
    MegaMenuDefaultWrapper,
    MegaMenuDrawerNavLink,
    MegaMenuNavigationPrimary,
    MegaMenuVerboseCategoryList,
    MegaMenuVerboseCategoryLink,
    MegaMenuVerboseWrapper,
    MegaMenuWrapper,
    MegaMenuBottom,
    MegaMenuAccount,
    MegaMenuSignInLink,
    MegaMenuUtilityLinks,
    MegaMenuMobileVerboseWrapper,
    MegaMenuMobileClickOutLink,
    MegaMenuNavLinkWithChevron
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 93944:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const ConsumerMarketingUnit = __webpack_require__(71284);
/**
 * CMNavItem - Renders Nav CTA Consumer Marketing Units as navigation links depending on the navigation alignment.
 * If the navigation link is not a Nav CTA, it will render a CM Unit regardless the navigation alignment.
 *
 * @param {object} props - React Props
 * @param {string} props.alignment - navigation alignment: horizontal/vertical
 * @param {string} props.cmPosition - consumer-marketing position to create a slot for
 */
const CMNavItem = (props) => {
    const { alignment, cmPosition } = props;
    if (cmPosition !== 'nav-cta') {
        return React.createElement(ConsumerMarketingUnit, { position: cmPosition });
    }
    if (alignment === 'horizontal') {
        return (React.createElement(React.Fragment, null,
            React.createElement(ConsumerMarketingUnit, { position: "nav-cta" }),
            React.createElement(ConsumerMarketingUnit, { position: "nav-rollover" })));
    }
    if (alignment === 'vertical') {
        return React.createElement(ConsumerMarketingUnit, { position: "nav-drawer" });
    }
    return null;
};
CMNavItem.propTypes = {
    alignment: PropTypes.string.isRequired,
    cmPosition: PropTypes.string.isRequired
};
module.exports = {
    CMNavItem
};
//# sourceMappingURL=CMNavitem.js.map

/***/ }),

/***/ 78407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const isEmpty = __webpack_require__(62193);
const SummaryItem = __webpack_require__(74992);
const { PaymentGateway } = __webpack_require__(92807);
const { withPaymentGateway } = __webpack_require__(22315);
const googleAnalytics = __webpack_require__(37402);
const { getVariationNames } = __webpack_require__(81372);
const { ResponsiveLinkText } = __webpack_require__(31605);
const { CMNavItem } = __webpack_require__(93944);
const { trackNavigationEvent } = __webpack_require__(14307);
const { NavigationListItemWrapper, NavigationItemIcon, NavigationExternalLink, NavigationInternalLink, NavigationSummaryItem } = __webpack_require__(51418);
/**
 * Navigation links
 *
 * @param {object} props - React Props
 * @param {string} props.alignment - navigation alignment: horizontal/vertical
 * @param {string} [props.className] - Optional className to apply to the link element
 * @param {object} props.link - Link object
 * @param {string} [props.link.attributes] - Optional HTML attributes to apply to links
 * @param {string} [props.link.text] - Optional text to link
 * @param {string} [props.link.verboseText] - Optional additional text longer text for larger screens
 * @param {number} [props.link.cardPosition] - Optional content card position for use in click event tracking
 * @param {string} [props.link.className] - Optional className to apply to the link element
 * @param {string} [props.link.dangerousIcon] - Optional HTML icon to display
 * @param {string} [props.link.disableClickTracking] - Optional boolean to disable the click tracking
 * @param {boolean} [props.link.isActive] - Optional flag whether the link is active
 * @param {boolean} [props.link.isExternal] - Optional flag whether the link is external
 * @param {boolean} [props.link.isLinkForMore] - Optional flag whether the link is for more link (for styling purpose)
 * @param {boolean} [props.link.hasClickOut] - Optional flag to check if link are clickOut for navigation tracking
 * @param {boolean} [props.hasUnderlineActiveLink] - optional for adding the underline for links
 * @param {boolean} [props.link.showInTopNav] - Optional flag to show the link in top Nav
 * @param {object} [props.parentAttributes] - Optional HTML attributes to apply on wrapper
 * @param {boolean} [props.link.paymentGroup] - Optional payment group that is required for the link to be rendered
 * @param {string} [props.link.cmPosition] - Optional consumer marketing position to render a cm unit
 * @param {string} props.link.url - URL to link
 * @param {Function} [props.link.onClick] - Optional function to execute on click.
 * @param {string} [props.link.width] - Optional link width
 * @param {boolean} [props.shouldAllowNavItemHide] - Optionally hide nav items
 * @param {boolean} [props.shouldStyleListItems] - Optionally apply link styling to list items as well
 * @param {boolean} [props.summaryItemVariation] - Optional variation for SummaryItem
 * @param {boolean} [props.trackingText] - Navigation click event tracking string for links
 * @param {boolean} [props.trackingTextIndex] - Index of link for navigation event tracking
 * @param {boolean} [props.isNavigationClosed] - Optionally style components based on whether navigation is closed
 * @param {boolean} [props.navigationJustification] - Optionally style components based on justification
 * @param {boolean} [props.hasNavigationSection] - Optionally style components based on navigation section
 * @param {boolean} [props.isNavigationActiveState] - Optionally style components based on navigaation to enable the active state of links
 * @param {boolean} [props.isMegamenu] - Optional flag to disable snowplow tracking in header for mega menu
 * @param {string} [props.navHighlightColour] - colour code for highlighting navigation link
 *
 * @returns {ReactElement} - content for a navigation heading
 */
const ListItem = ({ alignment, className, isNavigationClosed, isNavigationActiveState, link, shouldAllowNavItemHide, shouldStyleListItems, summaryItemVariation = 'TextBelowImageLeftHedOnly', navigationJustification, hasNavigationSection, hasUnderlineActiveLink, trackingText, trackingTextIndex, isMegamenu, navHighlightColour }) => {
    if (shouldAllowNavItemHide && !link.showInTopNav) {
        return null;
    }
    const handleClickNavigation = (url) => {
        if (link?.disableClickTracking) {
            return;
        }
        if ( true && window.dataLayer) {
            let navType = '';
            navType = url.showInTopNav === true ? 'header' : 'footer';
            if (navType === 'header' && alignment === 'vertical')
                navType = 'menu';
            if (url.isActive === undefined)
                navType = 'menu';
            if (trackingText) {
                window.dataLayer.push({
                    event: 'navigation-click',
                    navigationType: 'header',
                    clickText: url?.hasClickOut
                        ? `${trackingText}Viewall`
                        : `${trackingText}${url.text}/C${trackingTextIndex + 1}`
                });
            }
            else {
                window.dataLayer.push({
                    event: 'navigation-click',
                    navigationType: navType,
                    clickText: url.text
                });
                if (navType === 'footer') {
                    const eventData = {
                        type: 'click',
                        label: link.text,
                        subject: 'footer_menu',
                        items: [
                            {
                                content_title: link.text,
                                content_url: link.url
                            }
                        ],
                        placement: 'footer'
                    };
                    trackNavigationEvent(eventData);
                }
            }
        }
    };
    const trackSnowplowEvent = () => {
        if (link?.disableClickTracking) {
            return;
        }
        const eventData = {
            type: 'click',
            label: link?.text,
            subject: 'header_menu',
            items: [
                {
                    content_title: link?.text,
                    content_url: link?.url
                }
            ],
            placement: 'header'
        };
        link.showInTopNav && trackNavigationEvent(eventData);
    };
    const handleCardClickNavigation = (url) => {
        if ( true && window.dataLayer) {
            window.dataLayer.push({
                event: 'navigation-click',
                navigationType: 'menu',
                clickText: `${trackingText.replace(/\|/g, '/')}${url?.cardPosition}`
            });
        }
    };
    const isActiveLink = !!link.isActive;
    const isLinkForMore = !!link.isLinkForMore;
    const listItemClassName = classnames(shouldStyleListItems && link.className, 'navigation__list-item');
    const linkClassName = classnames(className, link.className, 'navigation__link', { 'navigation__link--active': isActiveLink }, { navigation__link_more: isLinkForMore });
    const SummaryItemComponent = SummaryItem[summaryItemVariation];
    const isExternalLink = link.text && link.isExternal;
    const isInternalLink = link.text && !link.isExternal;
    const isCardExternal = !link.text && !isEmpty(link.cardData) && link.isExternal;
    const isCardInternal = !link.text && !isEmpty(link.cardData) && !link.isExternal;
    return (React.createElement(NavigationListItemWrapper, { as: "li", alignment: alignment, className: listItemClassName, isNavigationClosed: isNavigationClosed, hasNavigationSection: hasNavigationSection, linkData: link, navigationJustification: navigationJustification, "data-testid": "navigation__list-item", onClick: isMegamenu !== true ? trackSnowplowEvent : undefined, ...(link.parentAttributes || {}) },
        link.dangerousIcon && (React.createElement(NavigationItemIcon, { dangerouslySetInnerHTML: { __html: link.dangerousIcon }, "data-testid": "navigation__nav-item-icon" })),
        link.cmPosition && (React.createElement(PaymentGateway, { group: link.paymentGroup || 'consumer-marketing' },
            React.createElement(CMNavItem, { cmPosition: link.cmPosition, alignment: alignment }))),
        isExternalLink && (React.createElement(NavigationExternalLink, { attributes: link.attributes, className: linkClassName, hasColorAnimation: link.hasColorAnimation, hasUnderlineActiveLink: hasUnderlineActiveLink, href: link.url, rel: link.rel, hasNavigationSection: hasNavigationSection, onClick: () => {
                handleClickNavigation(link);
                link.analyticsEvent &&
                    googleAnalytics.emitGoogleTrackingEvent(link.analyticsEvent, {
                        'gtm.elementUrl': link.url
                    });
            }, "data-testid": "navigation__external-link", shouldHighlight: link.shouldHighlightLink, navHighlightColour: navHighlightColour },
            React.createElement(ResponsiveLinkText, { text: link.text, verboseText: link.verboseText }))),
        isInternalLink && (React.createElement(NavigationInternalLink, { role: "link", ...link.attributes, className: linkClassName, isActiveLink: isActiveLink, hasColorAnimation: link.hasColorAnimation, hasUnderlineActiveLink: hasUnderlineActiveLink, isNavigationActiveState: isNavigationActiveState, href: link.url, "data-testid": "navigation__internal-link", hasNavigationSection: hasNavigationSection, rel: link.rel, onClick: (event) => {
                handleClickNavigation(link);
                link.onClick && link.onClick(event);
                link.analyticsEvent &&
                    googleAnalytics.emitGoogleTrackingEvent(link.analyticsEvent, {
                        'gtm.elementUrl': link.url
                    });
            }, shouldHighlight: link.shouldHighlightLink, navHighlightColour: navHighlightColour },
            React.createElement(ResponsiveLinkText, { text: link.text, verboseText: link.verboseText }))),
        isCardExternal && (React.createElement(NavigationExternalLink, { "data-testid": "navigation__external-link", href: link.url, isActiveLink: isActiveLink, hasUnderlineActiveLink: hasUnderlineActiveLink, isNavigationActiveState: isNavigationActiveState, hasColorAnimation: link.hasColorAnimation },
            React.createElement(NavigationSummaryItem, { ...link.cardData, as: SummaryItemComponent, clickHandlerHed: () => handleCardClickNavigation(link), hasBorder: false }))),
        isCardInternal && (React.createElement(NavigationInternalLink, { "data-testid": "navigation__internal-link", href: link.url, hasColorAnimation: link.hasColorAnimation, hasUnderlineActiveLink: hasUnderlineActiveLink },
            React.createElement(NavigationSummaryItem, { ...link.cardData, as: SummaryItemComponent, clickHandlerHed: () => handleCardClickNavigation(link), hasBorder: false })))));
};
const SUMMARY_ITEM_VARIATIONS = getVariationNames(SummaryItem);
ListItem.propTypes = {
    alignment: PropTypes.oneOf(['horizontal', 'vertical']).isRequired,
    className: PropTypes.string,
    hasNavigationSection: PropTypes.bool,
    hasUnderlineActiveLink: PropTypes.bool,
    isMegamenu: PropTypes.bool,
    isNavigationActiveState: PropTypes.bool,
    isNavigationClosed: PropTypes.bool,
    link: PropTypes.shape({
        analyticsEvent: PropTypes.string,
        attributes: PropTypes.object,
        text: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
        verboseText: PropTypes.string,
        cardPosition: PropTypes.number,
        cardData: PropTypes.object,
        className: PropTypes.string,
        dangerousIcon: PropTypes.string,
        disableClickTracking: PropTypes.bool,
        hasColorAnimation: PropTypes.bool,
        isActive: PropTypes.bool,
        isExternal: PropTypes.bool,
        isLinkForMore: PropTypes.bool,
        hasClickOut: PropTypes.bool,
        rel: PropTypes.string,
        shouldHighlightLink: PropTypes.bool,
        showInTopNav: PropTypes.bool,
        parentAttributes: PropTypes.object,
        paymentGroup: PropTypes.string,
        cmPosition: PropTypes.string,
        url: PropTypes.string,
        onClick: PropTypes.func,
        width: PropTypes.number
    }).isRequired,
    navHighlightColour: PropTypes.string,
    navigationAlignment: PropTypes.string,
    navigationJustification: PropTypes.string,
    shouldAllowNavItemHide: PropTypes.bool,
    shouldStyleListItems: PropTypes.bool,
    summaryItemVariation: PropTypes.oneOf(SUMMARY_ITEM_VARIATIONS),
    trackingText: PropTypes.string,
    trackingTextIndex: PropTypes.number
};
const ListItemWithPaymentGateway = withPaymentGateway(ListItem);
module.exports = { ListItemWithPaymentGateway, ListItem };
//# sourceMappingURL=ListItem.js.map

/***/ }),

/***/ 31658:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useState } = __webpack_require__(96540);
const { NavigationList } = __webpack_require__(48990);
const { NavigationHeading } = __webpack_require__(70042);
const { ListItem } = __webpack_require__(78407);
const { NavigationDivider, NavigationWrapper, NavigationBlankHeader } = __webpack_require__(51418);
const { TrackComponentChannel } = __webpack_require__(78788);
const SummaryCarousel = __webpack_require__(87339);
/**
 * Navigation component
 * Render navigation links relevant to the brand
 *
 * @param {object} props - React Props
 * @param {object} [props.attributes] - Optional attributes to add top level i.e. aria-*, role, etc.
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object} [props.element] - React ref to pass down
 * @param {object} [props.headingAttributes] - Optional attributes to add top level for heading wrapper i.e. aria-*, role, etc.
 * @param {boolean} [props.hasBorder] - Whether the component needs to have a border
 * @param {boolean} [props.hasCardList] - Optional prop to render Carousel component for the list
 * @param {boolean} [props.hasUnderlineActiveLink] - Optional prop which has the underline for active tabs
 * @param {boolean} [props.heading] - Component heading
 * @param {string} [props.headingUrl] - Optional prop passed to make Navigation header as link
 * @param {string} [props.isCard] - Optional prop used to modify class name for card in Navigation
 * @param {boolean} [props.isCollapsible] - whether component is collapsible
 * @param {boolean} [props.isHeadingALink] - Optional prop to show Navigation header should be link or not
 * @param {boolean} [props.isHeadingEmpty] - Optional prop to hide or show NavigationDivider
 * @param {boolean} [props.isHeadingUrlExternal] - Optional prop which determines whether the links should open in new window
 * @param {string} [props.justify] - Component justification
 * @param {string} [props.linkClassName] - Class name for the link
 * @param {Array<object>} props.links - List of `{ text, url, isExternal, dangerousIcon }` objects for navigation links
 * @param {boolean} [props.shouldAllowNavItemHide] - When set true hide nav item that have their link prop showInTopNav set to false
 * @param {boolean} [props.shouldStyleListItems] - whether to style list items
 * @param {boolean} [props.showBlankHeading] - Optional flag to show show blank space in heading on heading empty
 * @param {boolean} [props.showContentDivider] - show content divider
 * @param {boolean} [props.showDividerOnTop] - Optional flag to append the NavigationDivider on top
 * @param {boolean} [props.showOneTrustButton] - show OneTrust button
 * @param {boolean} [props.trackingText] - Navigation click event tracking string for links
 * @param {boolean} [props.trackingTextIndex] - Index of link for navigation event tracking
 * @param {object} [props.variations] - Variation properties used in rendering the component.
 * @param {string} [props.variations.alignment] - ['horizontal', 'vertical'] Sets format
 * @param {boolean} [props.heading] - Whether the component needs to have a border
 * @param {boolean} [props.isNavigationActiveState] - Optionally style components based on navigaation to enable the active state of links
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.navHighlightColour] - colour code for highlighting navigation link
 *
 * @returns {ReactElement} <nav>
 */
const Navigation = ({ isCollapsible = false, attributes, className, element, headingAttributes, hasBorder = false, hasCardList, hasUnderlineActiveLink = true, heading, headingUrl, isCard, isHeadingALink, isHeadingEmpty = false, isHeadingUrlExternal, justify = 'left', linkClassName, links, isNavigationActiveState = false, shouldAllowNavItemHide = false, shouldStyleListItems = false, showBlankHeading = false, showContentDivider, showDividerOnTop = false, showOneTrustButton, trackingText = '', trackingTextIndex = 0, variations = {
    alignment: 'horizontal',
    section: false
}, variationName, navHighlightColour, ...props }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Navigation',
            variation: variationName
        });
    }, [variationName]);
    const [isCollapsed, setIsCollapsed] = useState(true);
    const isNavigationClosed = isCollapsible && isCollapsed;
    const hasNavigationSection = !!variations.section;
    const navigationClassNames = classnames(className);
    return (React.createElement(React.Fragment, null,
        showDividerOnTop && !isHeadingEmpty && (React.createElement(NavigationDivider, { className: "navigation__divider" })),
        React.createElement(NavigationWrapper, { isCollapsible: isCollapsible, isNavigationClosed: isNavigationClosed, hasNavigationSection: hasNavigationSection, hasBorder: hasBorder, navigationAlignment: variations.alignment, navigationJustification: justify, ...attributes, className: navigationClassNames, as: "nav", "data-testid": "navigation" },
            heading && (React.createElement(NavigationHeading, { clickFunction: () => setIsCollapsed(!isCollapsed), heading: heading, isCollapsed: isCollapsed, isCollapsible: isCollapsible, isExternal: isHeadingUrlExternal, isLink: isHeadingALink, showContentDivider: showContentDivider, url: headingUrl, attributes: headingAttributes, trackingText: trackingText, trackingTextIndex: trackingTextIndex })),
            !heading && showBlankHeading && React.createElement(NavigationBlankHeader, null),
            !hasCardList ? (React.createElement(NavigationList, { element: element, links: links, alignment: variations.alignment, shouldAllowNavItemHide: shouldAllowNavItemHide, shouldStyleListItems: shouldStyleListItems, showOneTrustButton: showOneTrustButton, linkClassName: linkClassName, isNavigationClosed: isNavigationClosed, navigationJustification: justify, hasNavigationSection: hasNavigationSection, hasUnderlineActiveLink: hasUnderlineActiveLink, className: !isCard ? 'navigation__list' : 'navigation__list list__card', trackingText: trackingText, trackingTextIndex: trackingTextIndex, isNavigationActiveState: isNavigationActiveState, navHighlightColour: navHighlightColour, ...props })) : (React.createElement(SummaryCarousel, { hasCarouselControls: false, hasPagination: false, items: links.map((link) => link[0].cardData), shouldShowViewAllButton: false }))),
        !showDividerOnTop && (React.createElement(NavigationDivider, { className: "navigation__divider" }))));
};
Navigation.propTypes = {
    attributes: PropTypes.object,
    className: PropTypes.string,
    element: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    hasBorder: PropTypes.bool,
    hasCardList: PropTypes.bool,
    hasUnderlineActiveLink: PropTypes.bool,
    heading: PropTypes.string,
    headingAttributes: PropTypes.object,
    headingUrl: PropTypes.string,
    isCard: PropTypes.bool,
    isCollapsible: PropTypes.bool,
    isHeadingALink: PropTypes.bool,
    isHeadingEmpty: PropTypes.bool,
    isHeadingUrlExternal: PropTypes.bool,
    isNavigationActiveState: PropTypes.bool,
    justify: PropTypes.oneOf(['center', 'left']),
    linkClassName: PropTypes.string,
    links: PropTypes.arrayOf(ListItem.propTypes.link).isRequired,
    navHighlightColour: PropTypes.string,
    shouldAllowNavItemHide: PropTypes.bool,
    shouldStyleListItems: PropTypes.bool,
    showBlankHeading: PropTypes.bool,
    showContentDivider: PropTypes.bool,
    showDividerOnTop: PropTypes.bool,
    showOneTrustButton: PropTypes.bool,
    trackingText: PropTypes.string,
    trackingTextIndex: PropTypes.number,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        alignment: PropTypes.oneOf(['horizontal', 'vertical']).isRequired,
        section: PropTypes.bool
    })
};
module.exports = Navigation;
//# sourceMappingURL=Navigation.js.map

/***/ }),

/***/ 70042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const ExternalLink = __webpack_require__(9573);
const Viewport = __webpack_require__(52089);
const { NavigationHeadingAsLink, NavigationHeadingWrapper, NavigationHeadingButton, NavigationHeadingArrow } = __webpack_require__(51418);
/**
 * Navigation Heading which considers viewport and collapse
 *
 * @param {object} props - React Props
 * @param {object} [props.attributes] - Optional attributes to add top level i.e. aria-*, id, role, etc.
 * @param {Function} [props.clickFunction] - function to call on header click
 * @param {string} [props.heading] - heading text
 * @param {boolean} [props.isCollapsed] - collapse state
 * @param {boolean} [props.isCollapsible] - on/off switch to wrap the header in a button
 * @param {boolean} [props.isExternal] - Optional. Whether the links should be open in new window
 * @param {boolean} [props.isLink] - Optional. Whether the heading should be link or normal text.
 * @param {boolean} [props.isNavigationClosed] - generates styled for when the navigation is in closed mode
 * @param {boolean} [props.showContentDivider] - optional
 * @param {boolean} [props.trackingText] - Navigation click event tracking string for links
 * @param {boolean} [props.trackingTextIndex] - Index of link for navigation event tracking
 * @param {string} [props.url] - Optional prop to make Navigation header as link
 * @returns {ReactElement} - content for a navigation heading
 */
const NavigationHeading = ({ attributes, clickFunction, heading, isCollapsed, isCollapsible, isExternal, isLink, isNavigationClosed = false, showContentDivider, trackingText, trackingTextIndex, url }) => {
    const handleClickNavigation = (text) => {
        if ( true && window.dataLayer) {
            window.dataLayer.push({
                event: 'navigation-click',
                navigationType: 'header',
                clickText: `${trackingText}${text}/CH${trackingTextIndex + 1}`
            });
        }
    };
    // eslint-disable-next-line no-shadow
    const renderHeading = (heading, isExternal, isLink, url) => {
        if (isLink && url) {
            return (React.createElement(NavigationHeadingAsLink, { as: isExternal ? ExternalLink : 'a', href: url, onClick: () => handleClickNavigation(heading) }, heading));
        }
        return heading;
    };
    return (React.createElement(NavigationHeadingWrapper, { "data-testid": "navigation__heading", isNavigationClosed: isNavigationClosed, className: "navigation__heading", ...attributes },
        React.createElement(Viewport, { max: "lg" }, (matches) => isCollapsible && matches ? (React.createElement(NavigationHeadingButton, { "data-testid": "navigation__heading-button", onClick: clickFunction, type: "button", "aria-expanded": !isCollapsed, isCollapsible: isCollapsible },
            heading,
            React.createElement(NavigationHeadingArrow, { "data-testid": "navigation__heading-arrow", isCollapsible: isCollapsible, isCollapsed: isCollapsed, isNavigationClosed: isNavigationClosed }))) : (renderHeading(heading, isExternal, isLink, url))),
        showContentDivider && (React.createElement("span", { className: "content-divider", "data-testid": "navigation__content-divider" }))));
};
NavigationHeading.propTypes = {
    attributes: PropTypes.object,
    clickFunction: PropTypes.func,
    heading: PropTypes.string,
    isCollapsed: PropTypes.bool,
    isCollapsible: PropTypes.bool,
    isExternal: PropTypes.bool,
    isLink: PropTypes.bool,
    isNavigationClosed: PropTypes.bool,
    showContentDivider: PropTypes.bool,
    trackingText: PropTypes.string,
    trackingTextIndex: PropTypes.number,
    url: PropTypes.string
};
module.exports = {
    NavigationHeading
};
//# sourceMappingURL=NavigationHeading.js.map

/***/ }),

/***/ 48990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(60700)/* ["default"] */ .A);
const Button = __webpack_require__(73730);
const { useClientStatus } = __webpack_require__(8877);
const { ListItemWithPaymentGateway, ListItem } = __webpack_require__(78407);
const { NavigationListWrapper, OneTrustButtonIconWrapper, OneTrustButtonIcon } = __webpack_require__(51418);
const PrivacyOT = __webpack_require__(97195);
const ButtonIcon = ({ isEthycaEnabled }) => {
    return (React.createElement(OneTrustButtonIconWrapper, { className: isEthycaEnabled
            ? 'consent-privacy-icon'
            : 'oneTrust_button__icon-container', iconPosition: "before", size: "default" },
        React.createElement(OneTrustButtonIcon, { className: "oneTrust_button-icon", as: PrivacyOT, size: "default", isinline: true })));
};
const useFidesModalLinkLabel = () => {
    const [fidesModalLinkLabel, setFidesModalLinkLabel] = React.useState();
    React.useEffect(() => {
        if (window.Fides?.initialized) {
            setFidesModalLinkLabel(window.Fides?.getModalLinkLabel());
            return () => { };
        }
        const fidesInitializedHandler = () => {
            setFidesModalLinkLabel(window.Fides?.getModalLinkLabel());
        };
        window.addEventListener('FidesInitialized', fidesInitializedHandler);
        return () => {
            window.removeEventListener('FidesInitialized', fidesInitializedHandler);
        };
    }, []);
    return fidesModalLinkLabel;
};
ButtonIcon.propTypes = {
    isEthycaEnabled: PropTypes.bool
};
/**
 * NavigationList list of links
 *
 * @param {object} props - React Props
 * @param {string} [props.alignment] - aligntmen of the list
 * @param {string} [props.className] - extra class to apply to the list
 * @param {React.ref} [props.element] - extra class to apply to the list
 * @param {boolean} [props.hasNavigationSection] - whether the component has a navigation section
 * @param {boolean} [props.hasUnderlineActiveLink] - optional for adding the underline for links
 * @param {boolean} [props.isCollapsible] - whether the component is collapsed
 * @param {boolean} [props.isNavigationClosed] - whether the component is collapsed
 * @param {boolean} [props.isEthycaEnabled] - Optional flag to see if Ethyca is enabled
 * @param {string} [props.linkClassName] - classname for child links
 * @param {string} props.links - link to display
 * @param {object} [props.listAttributes] - Optional HTML attributes to apply to list/ul element
 * @param {string} [props.navigationJustification] - justification of the nav
 * @param {boolean} [props.shouldAllowNavItemHide] - should allow the ability to hide stuff
 * @param {boolean} [props.shouldStyleListItems] - shouldStyleListItems
 * @param {boolean} [props.showOneTrustButton] - shouldshow onetrust button
 * @param {boolean} [props.trackingText] - Navigation click event tracking string for links
 * @param {boolean} [props.trackingTextIndex] - Index of link for navigation event tracking
 * @param {boolean} [props.isNavigationActiveState] - Optionally style components based on navigaation to enable the active state of links
 * @param {boolean} [props.isMegamenu] - Optional flag to disable snowplow tracking in header for mega menu
  * @param {string} [props.navHighlightColour] - colour code for highlighting navigation link

 * @returns {ReactElement} - content for a navigation heading
 */
const NavigationList = (props) => {
    const { className, element, hasUnderlineActiveLink, links, listAttributes = {}, alignment, linkClassName, shouldAllowNavItemHide, showOneTrustButton, shouldStyleListItems, isCollapsible = false, isEthycaEnabled = false, isNavigationClosed = false, isNavigationActiveState, navigationJustification, hasNavigationSection = false, trackingText, trackingTextIndex, isMegamenu, navHighlightColour } = props;
    const { formatMessage } = useIntl();
    const isClient = useClientStatus();
    const fidesModalLinkLabel = useFidesModalLinkLabel();
    const consentLink = (React.createElement("li", { className: isEthycaEnabled ? 'consent_btn' : 'oneTrust_btn' },
        React.createElement(ButtonIcon, { isEthycaEnabled: isEthycaEnabled }),
        isClient && (React.createElement(Button.Utility, { id: isEthycaEnabled ? 'fides-modal-link' : 'ot-sdk-btn', className: isEthycaEnabled
                ? 'consent-sdk-show-settings'
                : 'ot-sdk-show-settings ot-sdk-btn--visible', label: fidesModalLinkLabel ??
                formatMessage(translations.oneTrustButtonLabel), isInline: true }))));
    return (React.createElement(NavigationListWrapper, { alignment: alignment, as: "ul", ref: element, isCollapsible: isCollapsible, isNavigationClosed: isNavigationClosed, navigationJustification: navigationJustification, hasNavigationSection: hasNavigationSection, className: className, "data-testid": "navigation__list", ...listAttributes },
        links &&
            links.map((link, index) => (React.createElement(ListItemWithPaymentGateway, { alignment: alignment, className: linkClassName, link: link, key: index, shouldAllowNavItemHide: shouldAllowNavItemHide, shouldStyleListItems: shouldStyleListItems, paymentGroup: link.paymentGroup, isNavigationClosed: isNavigationClosed, navigationJustification: navigationJustification, hasNavigationSection: hasNavigationSection, trackingText: trackingText, trackingTextIndex: trackingTextIndex, isNavigationActiveState: isNavigationActiveState, hasUnderlineActiveLink: hasUnderlineActiveLink, isMegamenu: isMegamenu, navHighlightColour: navHighlightColour }))),
        isEthycaEnabled ? consentLink : showOneTrustButton && consentLink));
};
NavigationList.propTypes = {
    alignment: PropTypes.string,
    className: PropTypes.string,
    element: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    hasNavigationSection: PropTypes.bool,
    hasUnderlineActiveLink: PropTypes.bool,
    isCollapsible: PropTypes.bool,
    isEthycaEnabled: PropTypes.bool,
    isMegamenu: PropTypes.bool,
    isNavigationActiveState: PropTypes.bool,
    isNavigationClosed: PropTypes.bool,
    linkClassName: PropTypes.string,
    links: PropTypes.arrayOf(ListItem.propTypes.link).isRequired,
    listAttributes: PropTypes.object,
    navHighlightColour: PropTypes.string,
    navigationJustification: PropTypes.string,
    shouldAllowNavItemHide: PropTypes.bool,
    shouldStyleListItems: PropTypes.bool,
    showOneTrustButton: PropTypes.bool,
    trackingText: PropTypes.string,
    trackingTextIndex: PropTypes.number
};
module.exports = {
    NavigationList,
    ButtonIcon,
    useFidesModalLinkLabel
};
//# sourceMappingURL=NavigationList.js.map

/***/ }),

/***/ 31605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const VerboseText = __webpack_require__(34252);
/**
 * Switch between short and verbose text for responsive links
 *
 * @param {object} props - a linkObject containing text and verbose text
 * @param {string} props.text - default text for a link
 * @param {string} [props.verboseText] - optional longer text for larger screens
 * @returns {ReactElement} - content for a responsive link
 */
const ResponsiveLinkText = ({ text, verboseText }) => {
    if (!verboseText) {
        return text;
    }
    return React.createElement(VerboseText, { text: text, verboseText: verboseText });
};
ResponsiveLinkText.propTypes = {
    text: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,
    verboseText: PropTypes.string
};
module.exports = {
    ResponsiveLinkText
};
//# sourceMappingURL=ResponsiveLinkText.js.map

/***/ }),

/***/ 54790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(79726);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 51418:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css, keyframes } = __webpack_require__(92168);
const { BaseLink } = __webpack_require__(76955);
const { calculateSpacing, minScreen, getColorToken, getColorStyles, getTypographyStyles, styledProperty } = __webpack_require__(26865);
const { linkClean } = __webpack_require__(15737);
const { ARROW_DIRECTION, generateArrow } = __webpack_require__(54482);
const { INTERACTIVE, BREAKPOINTS } = __webpack_require__(96472);
const ExternalLink = __webpack_require__(39832);
const textColorAnimation = (theme) => keyframes `
  0% {
      color: ${getColorToken(theme, 'colors.consumption.body.special.display-signature')};
  }

  50% {
    color: ${getColorToken(theme, 'colors.consumption.body.special.display-texture')};
  }

  100% {
    color: ${getColorToken(theme, 'colors.consumption.body.special.display-signature')}
  }
`;
const animateTextColor = (theme) => css `
  animation: ${textColorAnimation(theme)} 7s ease forwards infinite;
`;
const NavigationHeadingButton = styled.button.withConfig({
    displayName: 'NavigationHeadingButton'
}) `
  ${styledProperty('isCollapsible', true, `
      border: none;
      margin: 0;
      padding: 0;
      background: none;
      text-decoration: none;
      text-transform: inherit;
    `)}
`;
const NavigationHeadingArrow = styled.span.withConfig({
    displayName: 'NavigationHeadingArrow'
}) `
  ${styledProperty('isCollapsed', true, css `
      ${({ theme }) => generateArrow(ARROW_DIRECTION.bottom, '4px', getColorToken(theme, 'colors.interactive.base.white'))}
      position: relative;
      transform: translateY(-50%);
      transition: transform 0.2s ease-out,
        border ${INTERACTIVE.timingLinkNavigation} ease;
      margin-left: 10px;
    `)}

  ${styledProperty('isCollapsed', false, css `
      ${({ theme }) => generateArrow(ARROW_DIRECTION.top, '5px', getColorToken(theme, 'colors.interactive.base.white'))}
      position: relative;
      transform: translateY(-50%);
      transition: transform 0.2s ease-out,
        border ${INTERACTIVE.timingLinkNavigation} ease;
      margin-left: 10px;
    `)}
`;
const NavigationHeadingWrapper = styled.p.withConfig({
    displayName: 'NavigationHeadingWrapper'
}) `
  margin: 0 0 ${calculateSpacing(2)};
  color: #fff;

  ${styledProperty('isCollapsible', true, `
      position: relative;
      margin: 0 0 ${calculateSpacing(4)};


      ${minScreen(BREAKPOINTS.lg)} {
        margin: 0 0 ${calculateSpacing(2)};
      }
    `)}

  ${styledProperty('isNavigationClosed', true, `
      margin: 0;
      text-decoration: none;

      ${minScreen(BREAKPOINTS.lg)} {
        margin-bottom: ${calculateSpacing(0.5)};
        margin: 0 0 ${calculateSpacing(2)} 0;
      }
    `)}
`;
const NavigationHeadingAsLink = styled(BaseLink).withConfig({
    displayName: 'NavigationHeadingAsLink'
}) ``;
const NavigationListWrapper = styled.div.withConfig({
    displayName: 'NavigationListWrapper'
}) `
  display: flex;
  flex-wrap: wrap;
  margin-bottom: ${calculateSpacing(3)};
  padding-left: 0;
  list-style: none;

  ${styledProperty('isCollapsible', true, `
      transition: all 0.6s ease-out;
      opacity: 1;
      height: 100%;
      transition-property: opacity, height;
    `)}

  ${styledProperty('isNavigationClosed', true, `
      display: none;

      ${minScreen(BREAKPOINTS.lg)} {
        display: flex;
      }
    `)}

  ${styledProperty('alignment', 'vertical', `
      flex-direction: column;
      flex-wrap: nowrap;
      margin: 0;
    `)}

  ${styledProperty('hasNavigationSection', true, `
      margin-top: 0;
      margin-bottom: 0;
      padding-top: ${calculateSpacing(2)};

      ${minScreen(BREAKPOINTS.md)} {
        padding-bottom: ${calculateSpacing(2)};
      }
    `)}

  ${styledProperty('navigationJustification', 'center', `
      justify-content: center;
    `)}

  .consent-privacy-icon {
    display: none;
  }

  .oneTrust_btn:not(:first-child)::before {
    margin-right: 5px;
    color: ${getColorToken('colors.foundation.footer.links.secondary')};
    content: '|';
  }
  @media (max-width: 767px) {
    .oneTrust_btn::before,
    .consent_btn::before {
      display: none;
    }
  }
`;
const NavigationListItemWrapper = styled.div.withConfig({
    displayName: 'NavigationListItemWrapper'
}) `
  display: flex;

  ${styledProperty('isNavigationClosed', true, `
      margin-bottom: 0;

      ${minScreen(BREAKPOINTS.lg)} {
        margin-bottom: ${calculateSpacing(0.5)};
      }
    `)}

  ${styledProperty('alignment', 'horizontal', `
      padding: 0 ${calculateSpacing(3)} 0 0;
    `)}

  ${styledProperty('alignment', 'vertical', `
      padding: 0;
    `)}

  ${styledProperty('hasNavigationSection', true, css `
      margin-bottom: ${calculateSpacing(4)};

      ${minScreen(BREAKPOINTS.md)} {
        margin-bottom: 0;
      }
    `)}

  .navigation__link.navigation__link.navigation__link.navigation__link {
    ${({ theme, linkData }) => (linkData || {}).footerText &&
    getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}
  }
`;
const activeLinkStyle = ({ isActiveLink, isNavigationActiveState }) => isActiveLink &&
    isNavigationActiveState &&
    css `
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.link')};

    &.navigation__link.navigation__link.navigation__link.navigation__link.navigation__link--active {
      position: relative;

      &::before {
        position: absolute;
        bottom: -${calculateSpacing(2)};
        width: 100%;
        height: 4px;
        content: '';
        ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.foundation.collapsed-menu.nav-link.hover')};
      }

      ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.body.standard.link-hover')};

      ${({ hasUnderlineActiveLink }) => hasUnderlineActiveLink && `text-decoration: underline;`}
    }
  `;
const NavigationExternalLink = styled(ExternalLink).withConfig({
    displayName: 'NavigationExternalLink'
}) `
  ${linkClean()}
  ${activeLinkStyle}
  ${styledProperty('hasNavigationSection', true, css `
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.link')};

      &:hover,
      &:focus {
        ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.link-hover')};
      }
    `)}
  &&& {
    ${({ shouldHighlight, navHighlightColour }) => shouldHighlight &&
    navHighlightColour &&
    `
        color: ${navHighlightColour} !important;
        font-weight: bold !important;
      `}
  }
`;
const NavigationInternalLink = styled.a.withConfig({
    displayName: 'NavigationInternalLink'
}) `
  ${linkClean()}

  ${activeLinkStyle}

   ${styledProperty('hasNavigationSection', true, css `
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.link')};

      &:hover,
      &:focus {
        ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.lead.primary.link-hover')};
      }
    `)}

  ${({ hasColorAnimation, theme }) => hasColorAnimation && animateTextColor(theme)}

    &&& {
    ${({ shouldHighlight, navHighlightColour }) => shouldHighlight &&
    navHighlightColour &&
    `
          color: ${navHighlightColour} !important;
          font-weight: bold !important;
        `}
  }
`;
const NavigationItemIcon = styled.div.withConfig({
    displayName: 'NavigationItemIcon'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: ${calculateSpacing(1)};
  width: ${calculateSpacing(3)};
  height: ${calculateSpacing(3)};
`;
const NavigationWrapper = styled.nav.withConfig({
    displayName: 'NavigationWrapper'
}) `
  /* Opening and closing of accordion
     Variations
     Horizontal Variation (for use in simple navigation, standard navigation) */
  ${styledProperty('hasBorder', true, css `
      border-width: 1px 0;
      border-style: solid;
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.discovery.lead.primary.divider')};
    `)}

  ${styledProperty('hasNavigationSection', true, css `
      ${getTypographyStyles('typography.definitions.foundation.link-secondary')}

      grid-column: 1 / span 12;
    `)}
`;
const NavigationDivider = styled.span.withConfig({
    displayName: 'NavigationDivider'
}) `
  display: none;
`;
const NavigationBlankHeader = styled.div.withConfig({
    displayName: 'NavigationBlankHeader'
}) `
  ${minScreen(BREAKPOINTS.lg)} {
    margin-top: ${calculateSpacing(6.6)};
  }
`;
const NavigationSummaryItem = styled.div.withConfig({
    displayName: 'NavigationSummaryItem'
}) ``;
const OneTrustButtonIconWrapper = styled.div.withConfig({
    displayName: 'OneTrustButtonIconWrapper'
}) `
  display: inline-block;
  height: 9.5px;
`;
const OneTrustButtonIcon = styled.span.withConfig({
    displayName: 'OneTrustButtonIcon'
}) `
  display: block;
`;
module.exports = {
    NavigationBlankHeader,
    NavigationDivider,
    NavigationWrapper,
    NavigationHeadingAsLink,
    NavigationHeadingButton,
    NavigationHeadingWrapper,
    NavigationHeadingArrow,
    NavigationListWrapper,
    NavigationListItemWrapper,
    NavigationExternalLink,
    NavigationInternalLink,
    NavigationItemIcon,
    NavigationSummaryItem,
    OneTrustButtonIconWrapper,
    OneTrustButtonIcon
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 60700:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    oneTrustButtonLabel: {
        id: 'Navigation.OneTrustButtonLabel',
        defaultMessage: 'Your Privacy Choices',
        description: 'Navigation component OneTrust button label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 79726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const Navigation = __webpack_require__(31658);
Navigation.Horizontal = asVariation(Navigation, 'Horizontal', {
    alignment: 'horizontal'
});
Navigation.Vertical = asVariation(Navigation, 'Vertical', {
    alignment: 'vertical'
});
Navigation.Section = asVariation(Navigation, 'Section', {
    alignment: 'horizontal',
    section: true
});
module.exports = Navigation;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 43824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useRef } = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useViewportObserver } = __webpack_require__(55030);
const { asConfiguredComponent } = __webpack_require__(12892);
const Clamp = __webpack_require__(48286);
const ItemsCount = __webpack_require__(78372);
const Rubric = __webpack_require__(34187);
const ResponsiveAsset = __webpack_require__(73275);
const LiveIndicator = __webpack_require__(77938);
const PlayIcon = __webpack_require__(25856);
const Bylines = __webpack_require__(52540);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const { OverlaySummaryItemBylines, OverlaySummaryItemContent, OverlaySummaryItemTopContent, OverlaySummaryItemDate, OverlaySummaryItemDek, OverlaySummaryItemHed, OverlaySummaryItemItemsCount, OverlayItemContentWrapper, OverylayItemGradientBlock, OverlaySummaryItemMetadataPrimary, OverlaySummaryItemResponsiveAsset, OverlaySummaryItemRubric, OverlaySummaryItemWrapper, OverlaySummaryItemSignage, SummaryItemImageSignage, OverlaySummaryItemCTAButton } = __webpack_require__(3265);
/**
 * OverlaySummaryItem component
 *
 * @param {object} props - React Props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} props.clickHandler - called when user click to link
 * @param {object} [props.contributors] - Optional object containing data to create contributors bylines.
 * @param {string} [props.ctaPrimaryLabel] - primary text on button
 * @param {string} [props.ctaSecondaryLabel] - secondary text on button
 * @param {string} props.dangerousHed - Article Hed.
 * @param {string} props.dangerousDek - Article dek.
 * @param {string} props.eventDate - Event Date.
 * @param {string} props.contentId - Content ID of summary item
 * @param {number} [props.totalItems] - Total items
 * @param {string} props.contentType - Content type of summary item
 * @param {ResponsiveAsset.propTypes} [props.image] - Object containing sources for a ResponsiveAsset
 * @param {boolean} [props.isContributor] - Boolean, set to true if contributor layout needs to be rendered
 * @param {boolean} [props.isFeatured] - Boolean, set to true if featured styles needs to be applied
 * @param {boolean} [props.isLazy] - Optional if assets are to be lazy-loaded
 * @param {ItemsCount.propTypes} [props.itemsCount] - Optional object containing sources for an ItemsCount component
 * @param {ItemsCount.propTypes} [props.hasEnableIcon] - Optional bool show hide play icon on button
 * @param {boolean} [props.hasLeftMargin] -  Optional, used to decide the content alignement and as live indicator
 * @param {string} [props.HedTag] - Optional heading tag setting for recirc units
 * @param {number} [props.maxHedLines] - Optional maximum number of visual lines for the hed to occupy
 * @param {string} [props.metadataPrimary] - Optional line of metadata
 * @param {object} [props.metadataVideo] - optional. Video properies used to render breadcrumb and other video stuff
 * @param {bool} [props.metadataVideo.isLive] - optional. check if video is live now
 * @param {string} [props.publishDate] - Optional Publish Date.
 * @param {string} [props.shouldDisplayDangerousDekOverlay] -  Optionally hide article Dek.
 * @param {string} [props.signage] - Optional signage label to display on top of ResponsiveImage and summaryImage.
 * @param {bool} [props.shouldDisplaySignage] - Optional boolean to display signage, defaults to false
 * @param {bool} [props.shouldCenterAlignContent] - Optional boolean to center align summary item content
 * @param {bool} [props.shouldDisplaySignageInline] - Optional boolean to display signage inline with content
 * @param {boolean} [props.shouldDisplayLiveIndicator] - flag to enable live indicator
 * @param {boolean} [props.shouldHideEventDate] - Optional Hide Event Date (defaults to true).
 * @param {boolean} [props.shouldHandleOverlayForLongHed] - Optional prop to enable new styling for recirc overlay summary items
 * @param {boolean} [props.shouldHideItemCount] - Optional Hide Item count and slide Icon (defaults to true).
 * @param {boolean} [props.shouldHidePublishDate] - Optional Hide Publish Date (defaults to true).
 * @param {boolean} [props.shouldLeftAlignContent] - Optional prop to enable left alignment withount background gradient.
 * @param {bool} [props.shouldUseMediumBreakpoint] - Optional. Set to `true` will enable a third medium breakpoint on
 *   ResponsiveImage.js
 * @param {bool} [props.showOnHoverEffect] - set  to true, when needs some effects on hovering.
 * @param {bool} [props.shouldDisableGradientContentBlock] - set  to true, when disabling gradient block of content
 * @param {bool} [props.sparrowPattern] - Special sparrow pattern dimension that sends with event
 * @param {object} [props.recircId] - Optional recircId for Sparrow tracking
 * @param {object} [props.rubric] - Optional rubric.
 * @param {string} [props.rubricVariation] - Optional rubric variation to use
 * @param {bool} [props.isRecircListItem] - Optional prop to determine if item is recirc item or not
 * @param {string} [props.recircPlacement] - Optional prop to determine placement of recirc item
 * @param {object} [props.recircRiver] - Optional recircRiver for Sparrow tracking
 * @param {string} props.url - URL path to the content
 * @param {string} [props.sectionTitleLabel] - SectionTitle value
 * @param {string} [props.subjectVersion] - subject versions are `default/mobile_dense`. `default` is for Desktop
 *
 * @returns {ReactElement} <div>
 */
// eslint-disable-next-line complexity
const OverlaySummaryItem = ({ className, clickHandler = () => { }, contentAlign = 'center', contributors, ctaPrimaryLabel, ctaSecondaryLabel, isRecircListItem, recircPlacement, contentId, contentType, dangerousHed, dangerousDek = '', eventDate, hasCTA = false, hasCoverCollage, shouldDisableGradientContentBlock, hasEnableIcon = true, hasLeftMargin = false, HedTag, hideRubricItemSummary = false, image, isContributor = true, isFeatured = false, isLazy = true, itemsCount, totalItems, layoutProportions = 'overlay', maxHedLines = 0, metadataPrimary, metadataVideo: { isLive } = {}, shouldHandleOverlayForLongHed, publishDate, shouldAutoPlay = true, shouldCenterAlignContent = false, shouldDisplayLiveIndicator = false, shouldDisplayDangerousDekOverlay = false, shouldDisplaySignage = false, shouldDisplaySignageInline = false, shouldHideEventDate = true, shouldHideItemCount = false, shouldHidePublishDate = true, shouldLeftAlignContent = false, shouldUseMediumBreakpoint, showOnHoverEffect = true, signage, sparrowPattern = 'overlay-summary-item', analyticsDataAttribute = {}, recircId, recircRiver, rubric, rubricVariation = 'Card', url, sectionTitleLabel, subjectVersion }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'OverlaySummaryItem'
        });
    }, []);
    const recircItemClassName = isRecircListItem && `${recircPlacement}-${recircId}`;
    useViewportObserver(`.${recircItemClassName}`, undefined, (isInViewport) => {
        if (isInViewport && isRecircListItem) {
            const entityData = {
                type: 'impression',
                label: sectionTitleLabel,
                subject: 'recirc_unit',
                strategy: extractStrategyFromURL(url),
                placement: recircPlacement,
                subject_version: subjectVersion,
                items: [
                    {
                        content_id: contentId,
                        content_title: dangerousHed,
                        content_type: contentType.toLowerCase(),
                        content_url: url
                    }
                ],
                index: recircId - 1,
                total_index: totalItems
            };
            trackNavigationEvent(entityData);
        }
    }, [subjectVersion]);
    const shouldClamp = maxHedLines > 0 && maxHedLines < Infinity;
    let hed = (React.createElement(OverlaySummaryItemHed, { as: HedTag, hasLeftMargin: hasLeftMargin, dangerouslySetInnerHTML: { __html: dangerousHed }, hasBottomMargin: !shouldClamp, isFeatured: isFeatured, shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed }));
    if (shouldClamp) {
        hed = React.createElement(Clamp, { lines: maxHedLines }, hed);
    }
    const RubricComponent = Rubric[rubricVariation];
    const videoElementRef = useRef(null);
    let eventListeners = {};
    // capture hover/leave events to play/pause video clip
    if (!shouldAutoPlay && image?.contentType === 'clip') {
        const onMouseEnterToPlay = () => {
            if (videoElementRef.current)
                videoElementRef.current.play();
        };
        const onMouseLeaveToPause = () => {
            if (videoElementRef.current)
                videoElementRef.current.pause();
        };
        eventListeners = {
            ...eventListeners,
            onTouchStart: onMouseEnterToPlay,
            onTouchEnd: onMouseLeaveToPause,
            onMouseEnter: onMouseEnterToPlay,
            onMouseLeave: onMouseLeaveToPause
        };
    }
    return (React.createElement(OverlaySummaryItemWrapper, { className: classnames('summary-item-tracking__image-link', className, recircItemClassName), contentAlign: contentAlign, ...analyticsDataAttribute, "data-component-title": recircRiver, "data-component-type": "recirc-river", "data-recirc-id": `item-image-${recircId}`, "data-recirc-pattern": sparrowPattern, showOnHoverEffect: showOnHoverEffect, href: url, layoutProportions: layoutProportions, onClick: clickHandler, ...eventListeners },
        image && (React.createElement(OverlaySummaryItemResponsiveAsset, { ...image, videoElementRef: videoElementRef, shouldAutoPlay: shouldAutoPlay, isLazy: isLazy, hasCoverCollage: hasCoverCollage, layoutProportions: layoutProportions, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, shouldDisableGradientContentBlock: shouldDisableGradientContentBlock, shouldYieldControlOfVideoPlayPause: !shouldAutoPlay, signage: signage })),
        shouldDisplayLiveIndicator && isLive && (React.createElement(OverlaySummaryItemTopContent, { liveIndicatorHeight: "13px", as: LiveIndicator })),
        React.createElement(OverlaySummaryItemContent, { hasLeftMargin: hasLeftMargin, shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed, shouldCenterAlignContent: !isRecircListItem && shouldCenterAlignContent, shouldDisableGradientContentBlock: shouldDisableGradientContentBlock },
            shouldHandleOverlayForLongHed &&
                !shouldDisableGradientContentBlock && React.createElement(OverylayItemGradientBlock, null),
            React.createElement(OverlayItemContentWrapper, { shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed, shouldLeftAlignContent: shouldLeftAlignContent, shouldCenterAlignContent: !isRecircListItem && shouldCenterAlignContent },
                !hideRubricItemSummary && rubric && (React.createElement(OverlaySummaryItemRubric, { isFeatured: isFeatured, as: RubricComponent, name: rubric.name, shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed })),
                signage && shouldDisplaySignage && (React.createElement(SummaryItemImageSignage, { name: signage })),
                hed,
                itemsCount && !shouldHideItemCount && (React.createElement(OverlaySummaryItemItemsCount, { ...itemsCount, shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed, shouldCenterAlignContent: !isRecircListItem && shouldCenterAlignContent })),
                eventDate && !shouldHideEventDate && (React.createElement(OverlaySummaryItemDate, { shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed }, eventDate)),
                isContributor &&
                    contributors &&
                    Object.entries(contributors).length !== 0 && (React.createElement(OverlaySummaryItemBylines, { contributors: contributors, 
                    // we don't want to link authors, so just get their names
                    shouldLink: false, shouldCenterAlignContent: !isRecircListItem && shouldCenterAlignContent, shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed })),
                publishDate && !shouldHidePublishDate && (React.createElement(OverlaySummaryItemDate, { shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed }, publishDate)),
                shouldDisplayDangerousDekOverlay && dangerousDek && (React.createElement(OverlaySummaryItemDek, { isFeatured: isFeatured, hasLeftMargin: hasLeftMargin, dangerouslySetInnerHTML: { __html: dangerousDek } })),
                shouldDisplaySignageInline && signage && (React.createElement(OverlaySummaryItemSignage, null, signage)),
                metadataPrimary && (React.createElement(OverlaySummaryItemMetadataPrimary, { shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed }, metadataPrimary)),
                hasCTA && ctaPrimaryLabel && (React.createElement(OverlaySummaryItemCTAButton, { label: isLive && ctaSecondaryLabel
                        ? ctaSecondaryLabel
                        : ctaPrimaryLabel, href: url, iconPosition: "before", hasEnableIcon: hasEnableIcon, ButtonIcon: PlayIcon, shouldUseFullWidth: false }))))));
};
OverlaySummaryItem.propTypes = {
    analyticsDataAttribute: PropTypes.object,
    className: PropTypes.string,
    clickHandler: PropTypes.func,
    contentAlign: PropTypes.string,
    contentId: PropTypes.string,
    contentType: PropTypes.string,
    contributors: PropTypes.shape(Bylines.propTypes.contributors),
    ctaPrimaryLabel: PropTypes.string,
    ctaSecondaryLabel: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    eventDate: PropTypes.string,
    hasCoverCollage: PropTypes.bool,
    hasCTA: PropTypes.bool,
    hasEnableIcon: PropTypes.bool,
    hasLeftMargin: PropTypes.bool,
    HedTag: PropTypes.string,
    hideRubricItemSummary: PropTypes.bool,
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    isContributor: PropTypes.bool,
    isFeatured: PropTypes.bool,
    isLazy: PropTypes.bool,
    isRecircListItem: PropTypes.bool,
    itemsCount: PropTypes.shape(ItemsCount.propTypes),
    layoutProportions: PropTypes.oneOf(['overlay', 'overlay-limited-height']),
    maxHedLines: PropTypes.number,
    metadataPrimary: PropTypes.string,
    metadataVideo: PropTypes.shape({
        isLive: PropTypes.bool,
        premiereDate: PropTypes.string,
        series: PropTypes.string,
        videoLength: PropTypes.number
    }),
    publishDate: PropTypes.string,
    recircId: PropTypes.number,
    recircPlacement: PropTypes.string,
    recircRiver: PropTypes.string,
    rubric: PropTypes.shape(Rubric.propTypes),
    rubricVariation: PropTypes.string,
    sectionTitleLabel: PropTypes.string,
    shouldAutoPlay: PropTypes.bool,
    shouldCenterAlignContent: PropTypes.bool,
    shouldDisableGradientContentBlock: PropTypes.bool,
    shouldDisplayDangerousDekOverlay: PropTypes.bool,
    shouldDisplayLiveIndicator: PropTypes.bool,
    shouldDisplaySignage: PropTypes.bool,
    shouldDisplaySignageInline: PropTypes.bool,
    shouldHandleOverlayForLongHed: PropTypes.bool,
    shouldHideEventDate: PropTypes.bool,
    shouldHideItemCount: PropTypes.bool,
    shouldHidePublishDate: PropTypes.bool,
    shouldLeftAlignContent: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    showOnHoverEffect: PropTypes.bool,
    signage: PropTypes.string,
    sparrowPattern: PropTypes.string,
    subjectVersion: PropTypes.string,
    totalItems: PropTypes.number,
    url: PropTypes.string.isRequired
};
OverlaySummaryItem.displayName = 'OverlaySummaryItem';
module.exports = asConfiguredComponent(OverlaySummaryItem, 'OverlaySummaryItem');
//# sourceMappingURL=OverlaySummaryItem.js.map

/***/ }),

/***/ 18463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(43824);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 3265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorStyles, minScreen, maxScreen, getColorToken, getTypographyStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(76955);
const { ItemsCountContent, ItemsCountIcon } = __webpack_require__(8544);
const ItemsCount = __webpack_require__(78372);
const Button = __webpack_require__(73730);
const { BylineWrapper, BylinePreamble, BylineName, BylineLink } = __webpack_require__(74423);
const Bylines = __webpack_require__(52540);
const { SpanWrapper } = __webpack_require__(18117);
const ResponsiveAsset = __webpack_require__(73275);
const Rubric = __webpack_require__(34187);
const { ButtonIcon, ButtonIconWrapper } = __webpack_require__(18974);
const OverlaySummaryItemBylines = styled(Bylines).withConfig({
    displayName: 'OverlaySummaryItemBylines'
}) `
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.white')};

  ${BylineWrapper},
  ${BylinePreamble},
  ${BylineName},
  ${BylineLink} {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.white')};
    ${({ shouldHandleOverlayForLongHed, shouldCenterAlignContent }) => shouldHandleOverlayForLongHed && !shouldCenterAlignContent
    ? `
    text-align: left;
    `
    : 'text-align: center;'}
  }
  margin: ${calculateSpacing(2)} 0;
  ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed && `margin: ${calculateSpacing(2)} 0 0 0;`}
`;
const SummaryItemImageSignage = styled(Rubric.Card).withConfig({
    displayName: 'SummaryItemImageSignage'
}) `
  ${getColorStyles('background-color', 'colors.consumption.lead.standard.context-signature')};
  ${getColorStyles('color', 'colors.consumption.lead.standard.context-texture')};
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
  position: absolute;
  top: ${calculateSpacing(2)};
  left: ${calculateSpacing(0)};
`;
const OverlaySummaryItemHed = styled(BaseText).withConfig({
    displayName: 'OverlaySummaryItemHed'
}) `
  ${({ hasBottomMargin }) => {
    const bottomMargin = hasBottomMargin ? 2 : 0;
    return `margin: ${calculateSpacing(2)} 0 ${calculateSpacing(bottomMargin)};`;
}}
  p {
    margin: 0;
  }
  ${minScreen(BREAKPOINTS.md)} {
    ${({ shouldHandleOverlayForLongHed }) => !shouldHandleOverlayForLongHed &&
    `margin: ${calculateSpacing(2)} auto ${calculateSpacing(3)};`}
    max-width: ${calculateSpacing(62.5)};
  }

  ${({ hasLeftMargin, isFeatured, theme }) => {
    if (isFeatured) {
        return css `
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-feature')}
      `;
    }
    if (hasLeftMargin) {
        return css `
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-feature')}
        margin: ${calculateSpacing(1)} 0 ${calculateSpacing(2)};
        ${minScreen(BREAKPOINTS.md)} {
          margin: ${calculateSpacing(1)} 0 ${calculateSpacing(2)};
          max-width: ${calculateSpacing(80)};
        }
        ${minScreen(BREAKPOINTS.xl)} {
          max-width: ${calculateSpacing(108)};
        }
      `;
    }
    return ``;
}}
`;
OverlaySummaryItemHed.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.white',
    typeIdentity: 'typography.definitions.discovery.hed-core-primary'
};
const OverylayItemGradientBlock = styled.div.withConfig({
    displayName: 'OverylayItemGradientBlock'
}) `
  z-index: 2;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0));
  height: 100px;
`;
const OverlayItemContentWrapper = styled.div.withConfig({
    displayName: 'OverlayItemContentWrapper'
}) `
  ${({ shouldHandleOverlayForLongHed, shouldCenterAlignContent }) => shouldHandleOverlayForLongHed && !shouldCenterAlignContent
    ? `
    text-align: -webkit-left;
    `
    : 'text-align: -webkit-center;'}

  ${({ shouldLeftAlignContent }) => shouldLeftAlignContent
    ? `
    text-align: -webkit-left;
    `
    : ''}
`;
const OverlaySummaryItemContent = styled.div.withConfig({
    displayName: 'OverlaySummaryItemContent'
}) `
  &&& {
    grid-column: 1;
    grid-row: 1;
    align-self: end;
    z-index: 2;
    ${({ shouldHandleOverlayForLongHed }) => !shouldHandleOverlayForLongHed &&
    `
      padding: 0 ${calculateSpacing(2)} ${calculateSpacing(3)};
  `}
    max-width: 1600px;
    text-decoration: none;

    > *:last-child,
    ${OverlaySummaryItemHed}:last-child {
      margin-bottom: 0;
    }

    ${minScreen(BREAKPOINTS.md)} {
      margin: 0 auto;
      ${({ shouldHandleOverlayForLongHed }) => !shouldHandleOverlayForLongHed &&
    `
      padding: 0 0 ${calculateSpacing(5)};
      `}
      width: 100%;
    }

    ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed &&
    `
    ${OverlayItemContentWrapper} {
      background: linear-gradient(
        to top,
        rgba(0, 0, 0, 0.9),
        rgba(0, 0, 0, 0.55)
      );
      padding: 0 ${calculateSpacing(6)} ${calculateSpacing(5)};
      ${maxScreen(BREAKPOINTS.lg)}{
        padding: ${calculateSpacing(3)};
        padding-top: 0;
      }
    }
    `}

    ${({ shouldDisableGradientContentBlock }) => shouldDisableGradientContentBlock &&
    `
      ${OverlayItemContentWrapper} {
        background: none;
      `}

    ${({ hasLeftMargin }) => {
    if (hasLeftMargin) {
        return css `
          padding: 0 ${calculateSpacing(3)} ${calculateSpacing(3)};
          ${minScreen(BREAKPOINTS.md)} {
            padding: 0 ${calculateSpacing(6)} ${calculateSpacing(9)}
              ${calculateSpacing(6)};
          }
          ${minScreen(BREAKPOINTS.xl)} {
            padding: 0 ${calculateSpacing(8)} ${calculateSpacing(9)}
              ${calculateSpacing(8)};
          }
        `;
    }
    return ``;
}}
  }
`;
const OverlaySummaryItemSignage = styled(BaseText).withConfig({
    displayName: 'OverlaySummaryItemSignage'
}) `
  margin: ${calculateSpacing(2)} 0;
  color: ${getColorToken('colors.interactive.base.white')};
  font-size: 14px;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-tertiary')};
`;
const OverlaySummaryItemDate = styled(BaseText).withConfig({
    displayName: 'OverlaySummaryItemDate'
}) `
  display: block;
  ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed && `margin: ${calculateSpacing(2)} 0 0 0;`}
`;
OverlaySummaryItemDate.defaultProps = {
    as: 'time',
    colorToken: 'colors.interactive.base.white',
    typeIdentity: 'typography.definitions.globalEditorial.context-tertiary'
};
const OverlaySummaryItemItemsCount = styled(ItemsCount).withConfig({
    displayName: 'OverlaySummaryItemItemsCount'
}) `
  display: flex;
  ${({ shouldHandleOverlayForLongHed, shouldCenterAlignContent }) => shouldHandleOverlayForLongHed && !shouldCenterAlignContent
    ? `
    justify-content: left;
    `
    : 'justify-content: center;'}
  margin: ${calculateSpacing(2)} 0;
  ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed && `margin: ${calculateSpacing(2)} 0 0 0;`}
  ${ItemsCountIcon} .icon {
    ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
  }

  ${ItemsCountContent} {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.white')};
  }

  ${ItemsCountContent}:hover {
    text-decoration: none;
  }
`;
const OverlaySummaryItemMetadataPrimary = styled(BaseText).withConfig({
    displayName: 'OverlaySummaryItemMetadataPrimary'
}) `
  display: block;
  margin: ${calculateSpacing(2)} 0;
  ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed && `margin: ${calculateSpacing(2)} 0 0 0;`}
`;
OverlaySummaryItemMetadataPrimary.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.base.white',
    typeIdentity: 'typography.definitions.globalEditorial.context-tertiary'
};
const OverlaySummaryItemDek = styled(OverlaySummaryItemMetadataPrimary).withConfig({
    displayName: 'OverlaySummaryItemDek'
}) `
  ${({ hasLeftMargin }) => {
    if (hasLeftMargin) {
        return css `
        ${minScreen(BREAKPOINTS.md)} {
          margin: ${calculateSpacing(2)} 0 ${calculateSpacing(3)};
          max-width: ${calculateSpacing(64)};
        }
        ${minScreen(BREAKPOINTS.xl)} {
          max-width: ${calculateSpacing(108)};
        }
      `;
    }
    return ``;
}}
`;
OverlaySummaryItemDek.defaultProps = {
    as: 'div',
    typeIdentity: 'typography.definitions.discovery.description-feature'
};
const OverlaySummaryItemResponsiveAsset = styled(ResponsiveAsset).withConfig({
    displayName: 'OverlaySummaryItemResponsiveAsset'
}) `
  position: relative;
  grid-column: 1;
  grid-row: 1;
  width: 100%;
  height: 100%;
  ${({ hasCoverCollage }) => !hasCoverCollage &&
    `
      z-index: 1;
  `};

  /* 1. the +1px fixes an issue with subpixel rounding / rendering in Chrome
     We also need to pass in the SpanWrapper as the actual class is passed down ffs */
  &${SpanWrapper}::after {
    position: absolute;
    top: 0;
    left: 0;
    transition: opacity 0.3s;
    opacity: 1;
    z-index: 2;
    ${({ shouldHandleOverlayForLongHed, shouldDisableGradientContentBlock }) => (!shouldHandleOverlayForLongHed || shouldDisableGradientContentBlock) &&
    `
      background: linear-gradient(to top, #000, transparent 65%);
    `}
    background-size: calc(100% + 1px) calc(100% + 1px); /* 1 */
    width: 100%;
    height: 100%;
    content: '';
    pointer-events: none;
  }

  img {
    width: 100%;
    height: 100%;

    ${({ layoutProportions }) => layoutProportions === 'overlay-limited-height'
    ? `
      height: auto;
      min-height: 100%;
    `
    : ''}
  }
`;
const OverlaySummaryItemRubric = styled(BaseText).withConfig({
    displayName: 'OverlaySummaryItemRubric'
}) `
  ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed &&
    `
& {
  display: block;
}
`}

  &.rubric--with-bg {
    ${({ shouldHandleOverlayForLongHed }) => shouldHandleOverlayForLongHed &&
    `
        & {
          display: inline-block;
        }
      `}

    ${({ theme }) => [
    getColorStyles(theme, 'background-color', 'colors.interactive.base.white'),
    getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-signature')
].join(';')};
  }
`;
OverlaySummaryItemRubric.defaultProps = {
    colorToken: 'colors.interactive.base.white'
};
const OverlaySummaryItemWrapper = styled.a.withConfig({
    displayName: 'OverlaySummaryItemWrapper'
}) `
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.dark')};
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: 1fr;
  text-align: ${({ contentAlign }) => contentAlign || 'center'};
  text-decoration: none;

  &:hover,
  &:focus {
    ${({ showOnHoverEffect }) => !showOnHoverEffect
    ? ``
    : `${OverlaySummaryItemResponsiveAsset}::after {
      opacity: 0.7;
    }`}
  }

  /* Outline gets hidden due to grid-gap: 0. In order to show outline in keyboard
    mode, adding some margin.
  */
  &:focus {
    margin: 2px;
  }

  ${({ layoutProportions }) => layoutProportions === 'overlay-limited-height' ? 'max-height: 100%;' : ''}
`;
const OverlaySummaryItemTopContent = styled(OverlaySummaryItemContent).withConfig({
    displayName: 'OverlaySummaryItemTopContent'
}) `
  &&& {
    align-self: start;
    justify-content: flex-start;
    background: transparent;
    padding: ${calculateSpacing(4)} ${calculateSpacing(3)};
    max-width: 1600px;

    ${minScreen(BREAKPOINTS.md)} {
      padding: ${calculateSpacing(4)} ${calculateSpacing(6)}
        ${calculateSpacing(4)};
    }
    ${minScreen(BREAKPOINTS.xl)} {
      padding: ${calculateSpacing(4)} ${calculateSpacing(8)};
    }
  }

  &.liveindicator--with-bg {
    ${({ theme }) => css `
        ${getColorStyles(theme, 'color', 'colors.interactive.base.white')}
      `}
  }
`;
const OverlaySummaryItemCTAButton = styled(Button.UtilityInverted).withConfig({
    displayName: 'WatchButton'
}) `
  &,
  &:focus,
  &:hover {
    border: none;
  }
  display: inline-flex;
  background-color: rgba(
    ${getColorToken('colors.interactive.base.white', {
    rgbOnly: true
})},
    0.1
  );
  ${({ hasEnableIcon }) => hasEnableIcon &&
    `
    padding-top: ${calculateSpacing(0.5)};
    padding-left: ${calculateSpacing(0.5)};
  `}
  .icon {
    ${({ theme }) => `${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};`}
  }

  ${ButtonIconWrapper} {
    margin-bottom: 4px;
  }
  ${ButtonIcon} {
    width: auto;
    height: auto;
  }
  ${({ theme }) => `${getColorStyles(theme, 'color', 'colors.interactive.base.white')};`}
`;
module.exports = {
    OverlaySummaryItemBylines,
    OverlaySummaryItemContent,
    OverlaySummaryItemTopContent,
    OverlaySummaryItemDate,
    OverlaySummaryItemDek,
    OverlaySummaryItemHed,
    OverlaySummaryItemItemsCount,
    OverlayItemContentWrapper,
    OverylayItemGradientBlock,
    OverlaySummaryItemMetadataPrimary,
    OverlaySummaryItemResponsiveAsset,
    OverlaySummaryItemRubric,
    OverlaySummaryItemWrapper,
    OverlaySummaryItemSignage,
    SummaryItemImageSignage,
    OverlaySummaryItemCTAButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 11501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useState, useEffect, useRef } = __webpack_require__(96540);
const { connect } = __webpack_require__(67851);
const { useIntl } = __webpack_require__(46984);
const { DrawerMessageBannerWrapper } = __webpack_require__(62389);
const { MessageBannerWrapper } = __webpack_require__(11586);
const translations = (__webpack_require__(77463)["default"]);
const getBannerProps = (action, bannerType, intl) => {
    let bannerProps = {};
    switch (bannerType) {
        case 'saveRemoved': {
            bannerProps = {
                message: intl.formatMessage(translations.SaveRemovedMessage),
                shouldHideBannerOnButtonClick: false,
                buttonLabel: intl.formatMessage(translations.UndoButtonLabel),
                action
            };
            break;
        }
        case 'savedWithoutAddingToList': {
            bannerProps = {
                message: intl.formatMessage(translations.SavedMessage),
                buttonLabel: intl.formatMessage(translations.SavedWithoutAddingToListLink),
                shouldHideBannerOnButtonClick: false,
                buttonHref: '/account/saved'
            };
            break;
        }
        case 'savedWithAddingToList': {
            bannerProps = {
                message: intl.formatMessage(translations.SavedMessage),
                buttonLabel: intl.formatMessage(translations.SavedWithAddingToListLink),
                shouldHideBannerOnButtonClick: false,
                buttonHref: '/account/saved/lists'
            };
            break;
        }
        default:
            break;
    }
    return bannerProps;
};
/**
 *
 * @param {object} props - DrawerMessageBanner props
 * @param {string} [props.bannerType] - required banner type to render the message banner
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - Feature flag to define whether enable bookmark drawers functionality
 * @param {Function} [props.action] - action to be performed for Undo operation on bookmarks
 *
 * @returns {ReactElement} <DrawerMessageBanner>
 */
const DrawerMessageBanner = ({ action, bannerType, shouldEnableBookmarkDrawers }) => {
    const intl = useIntl();
    const [showMessageBanner, setShowMessageBanner] = useState(false);
    const [messageBannerProps, setMessageBannerProps] = useState({});
    const hasShownBanner = useRef(false);
    const MESSAGE_BANNER_DELAY = 5000;
    useEffect(() => {
        let timer;
        if (!hasShownBanner.current && shouldEnableBookmarkDrawers && bannerType) {
            hasShownBanner.current = true;
            const bannerProps = getBannerProps(action, bannerType, intl);
            if (bannerProps) {
                setMessageBannerProps(bannerProps);
                setShowMessageBanner(true);
                timer = setTimeout(() => {
                    setShowMessageBanner(false);
                }, MESSAGE_BANNER_DELAY);
            }
        }
        return () => {
            if (timer)
                clearTimeout(timer);
            hasShownBanner.current = false;
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [shouldEnableBookmarkDrawers, bannerType]);
    return (showMessageBanner && (React.createElement(DrawerMessageBannerWrapper, { "data-testid": "DrawerMessageBanner" },
        React.createElement(MessageBannerWrapper, { alignBanner: "bottom", btnStyle: "text", buttonClickHandler: messageBannerProps.action, buttonHref: messageBannerProps.buttonHref, buttonLabel: messageBannerProps.buttonLabel, contentAlign: "left", delayDuration: MESSAGE_BANNER_DELAY, hasBorderRadius: true, isDisclaimer: true, isFixed: true, shouldAddButton: true, shouldHideBannerOnButtonClick: messageBannerProps.shouldHideBannerOnButtonClick, shouldOrderCloseButtonLast: true, shouldShowCloseButton: false }, messageBannerProps.message))));
};
DrawerMessageBanner.propTypes = {
    action: PropTypes.func,
    bannerType: PropTypes.string,
    shouldEnableBookmarkDrawers: PropTypes.bool
};
DrawerMessageBanner.displayName = 'DrawerMessageBanner';
const mapStateToProps = (state) => {
    const { config: { account } } = state;
    const shouldEnableBookmarkDrawers = account?.bookmark?.enableBookmarkDrawers || false;
    return {
        shouldEnableBookmarkDrawers
    };
};
module.exports = connect(mapStateToProps)(DrawerMessageBanner, 'DrawerMessageBanner');
//# sourceMappingURL=DrawerMessageBanner.js.map

/***/ }),

/***/ 87091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useEffect, useState } = __webpack_require__(96540);
const { connect } = __webpack_require__(67851);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(77463)["default"]);
const queryParamsHelper = __webpack_require__(12311);
const PhotoBookmarkActions = __webpack_require__(97316);
const { photoBookmarkDispatchActions } = __webpack_require__(86902);
const { BookmarkNew } = __webpack_require__(91470);
const { PhotoBookmarkButton, PhotoBookmarkWrapper } = __webpack_require__(62389);
const { usePhotoBookmarkingContext } = __webpack_require__(50624);
const { addExistingBookmarksToACollection } = __webpack_require__(74139);
const UNKNOWN_STATE = null;
/**
 *
 * @param {object} props - PhotoBookmark props
 * @param {object} [props.bookmarkMeta] - Optional meta information to be added while creating a bookmark
 * @param {string} [props.bookmarkMeta.slug] - Optional slug stored as part of meta information
 * @param {string} [props.bookmarkMeta.brandName] - Optional brand/designer name stored as part of meta information
 * @param {string} [props.bookmarkMeta.seasonName] - Optional season name stored as part of meta information
 * @param {string} [props.bookmarkMeta.title] - Optional street style gallery title stored as part of meta information
 * @param {string} [props.copilotID] - ID of the copilotID entity
 * @param {Function} [props.doUpdateUnsavedBookmarks] - Dispatch function to reset the redux state of an unsaved bookmark item
 * @param {object} [props.image] - the image data
 * @param {boolean} [props.isInverted] - Optional boolean value to display the inverted version of the PhotoBookmark
 * @param {boolean | null } [props.isSaved] - Specifying if the image is already bookmarked or not, defaults to null indicating unknown status
 * @param {object} [props.onBookmarkToggle] - Callback to execute when bookmark is toggled
 * @param {string} [props.organizationID] - Brand ID associated copilot entity(copilotID)
 * @param {Function} [props.setLastBookmarkedPhoto] - Dispatch function to set the id of the most recently bookmarked photo
 * @param {Function} [props.setShowPhotoBookmarkMessageBanner] - Dispatch function to hide the message banner
 * @param {string} [props.signInHed] - Header on signin alert shown to user
 * @param {string} [props.signInHedSpanTag] - Hed span tag on signin alert shown to user
 * @param {string} [props.signInMessage] - Message on signin alert shown to user
 * @param {object} [props.isAuthenticated] - If user is signed in
 * @param {object} [props.federatedGraphqlUrl] - GraphQl URL to call
 * @param {string} [props.trackingSubject] - Optional subject to be returned in Snowplow function
 * @param {string} [props.contentType] - content type of the story
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @param {Function} [props.unsavedBookmarks] - Properties of an unsaved item in redux
 *
 * @returns {ReactElement} <PhotoBookmark>
 */
const PhotoBookmark = ({ copilotID, contentType, bookmarkMeta = {}, doUpdateUnsavedBookmarks, image, isInverted, isSaved = UNKNOWN_STATE, onBookmarkToggle, organizationID, setLastBookmarkedPhoto, setShowPhotoBookmarkMessageBanner, signInHed, signInHedSpanTag, signInMessage, isAuthenticated, federatedGraphqlUrl, trackingSubject, subtype, unsavedBookmarks }) => {
    const intl = useIntl();
    const [isBookmarked, setIsBookmarked] = useState(isSaved);
    const [isLoading, setIsLoading] = useState(false);
    const { openSaveAlertCreateCollection, openCollectionsDrawer, hasCollections, shouldAutoSaveToCollection, lastCollectionSavedTo, openSaveAlertError, openSaveAlertWithMoveCTA } = usePhotoBookmarkingContext();
    const bookmarkProps = {
        contentType,
        subtype,
        setLastBookmarkedPhoto,
        setShowPhotoBookmarkMessageBanner,
        doUpdateUnsavedBookmarks,
        organizationID,
        signInHed,
        signInHedSpanTag,
        signInMessage,
        isAuthenticated,
        federatedGraphqlUrl,
        bookmarkMeta,
        trackingSubject
    };
    const { toggleBookmark, checkIsBookmarked, PHOTO_BOOKMARK_ACTION_NAME } = PhotoBookmarkActions(bookmarkProps);
    async function checkIsAlreadyBookmarked(imgId) {
        const isBookmarked = await checkIsBookmarked(imgId);
        unsavedBookmarks?.[copilotID] &&
            unsavedBookmarks?.[copilotID].isDeleted === true
            ? setIsBookmarked(false)
            : setIsBookmarked(isBookmarked);
    }
    useEffect(() => {
        if (!isAuthenticated) {
            // Avoiding the API call if user is not signed in
            setIsBookmarked(false);
            return;
        }
        async function addPhotoBookmark({ copilotID, image, meta }) {
            const { isSuccessful = false } = (await toggleBookmark({
                copilotID,
                image,
                isSaved: false,
                meta
            })) || {};
            setIsLoading(false);
            isSuccessful && setIsBookmarked(true);
            return isSuccessful;
        }
        function addBookmarkViaSignInModal({ copilotID, image, meta }) {
            const queryParams = queryParamsHelper.parseQueryParams(window.location.search);
            if (queryParams?.photoId === copilotID &&
                queryParams?.action === PHOTO_BOOKMARK_ACTION_NAME) {
                const isSuccessful = addPhotoBookmark({
                    copilotID,
                    image,
                    meta
                });
                // Success or failure, we want to remove ?action= from URL to prevent sharing of this URL
                window.history.replaceState({}, document.title, document.location.pathname + document.location.hash);
                return isSuccessful;
            }
            return false;
        }
        // If user is authenticated and
        // is redirected after sign in via modal
        if (window.location.search) {
            const bookmarkCreatedSuccessfully = addBookmarkViaSignInModal({
                copilotID,
                image,
                meta: bookmarkMeta
            });
            if (bookmarkCreatedSuccessfully) {
                return;
            } // If not successful, let the component's normal flow take over
        }
        async function verifyBookmarkStatus(copilotID) {
            await checkIsAlreadyBookmarked(copilotID);
        }
        if (isSaved === UNKNOWN_STATE) {
            verifyBookmarkStatus(copilotID);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [isAuthenticated, copilotID, unsavedBookmarks]);
    if (isBookmarked === UNKNOWN_STATE) {
        return null;
    }
    const onSuccessfulBookmarkUpdate = (isBookmarked) => {
        setIsBookmarked(isBookmarked);
        onBookmarkToggle?.({ isBookmarked });
        if (!isBookmarked) {
            return;
        }
        if (!hasCollections) {
            openSaveAlertCreateCollection?.();
            return;
        }
        if (shouldAutoSaveToCollection) {
            addExistingBookmarksToACollection?.({
                organizationId: organizationID,
                federatedGraphqlUrl,
                updateCollectionId: lastCollectionSavedTo.id,
                copilotIds: [copilotID]
            });
            openSaveAlertWithMoveCTA?.();
        }
        else {
            openCollectionsDrawer?.();
        }
    };
    const handleOnClick = async (event) => {
        event.stopPropagation();
        setIsLoading(true);
        await checkIsAlreadyBookmarked(copilotID);
        const { isSuccessful } = (await toggleBookmark({
            event,
            copilotID,
            image,
            isSaved: isBookmarked,
            meta: bookmarkMeta
        })) || {};
        setIsLoading(false);
        if (isSuccessful) {
            onSuccessfulBookmarkUpdate(!isBookmarked);
        }
        else if (isSuccessful === false) {
            openSaveAlertError?.();
        }
    };
    const iconTitle = intl.formatMessage(isBookmarked
        ? translations.photoBookmarkSavedIconTitle
        : translations.photoBookmarkSaveIconTitle);
    const iconType = isBookmarked ? 'fill' : 'outline';
    const buttonIcon = isLoading
        ? null
        : () => (React.createElement(BookmarkNew, { bookmarkIconTitle: iconTitle, className: `icon-bookmark-${iconType}` }));
    return (React.createElement(PhotoBookmarkWrapper, { isInverted: isInverted },
        React.createElement(PhotoBookmarkButton, { btnStyle: "text", ButtonIcon: buttonIcon, isDisabled: isLoading, isIconButton: true, label: isLoading ? 'Loading' : iconTitle, loadingSpinnerColor: isInverted ? 'white' : 'black', onClickHandler: handleOnClick, shouldShowLoadingState: true, size: "small" })));
};
PhotoBookmark.propTypes = {
    bookmarkMeta: PropTypes.shape({
        slug: PropTypes.string,
        brandName: PropTypes.string,
        seasonName: PropTypes.string,
        title: PropTypes.string
    }),
    contentType: PropTypes.string,
    copilotID: PropTypes.string,
    doUpdateUnsavedBookmarks: PropTypes.func,
    federatedGraphqlUrl: PropTypes.string,
    image: PropTypes.object,
    isAuthenticated: PropTypes.bool,
    isInverted: PropTypes.bool,
    isSaved: PropTypes.oneOf([UNKNOWN_STATE, true, false]),
    onBookmarkToggle: PropTypes.func,
    organizationID: PropTypes.string,
    setLastBookmarkedPhoto: PropTypes.func,
    setShowPhotoBookmarkMessageBanner: PropTypes.func,
    signInHed: PropTypes.string,
    signInHedSpanTag: PropTypes.string,
    signInMessage: PropTypes.string,
    subtype: PropTypes.string,
    trackingSubject: PropTypes.string,
    unsavedBookmarks: PropTypes.object
};
const mapStateToProps = (state) => {
    const { coreDataLayer: { site: { orgId: organizationID } }, user: { isAuthenticated }, userPlatform: { federatedGraphqlUrl }, unsavedBookmarks = {} } = state;
    return {
        organizationID,
        isAuthenticated,
        federatedGraphqlUrl,
        unsavedBookmarks
    };
};
const mapDispatchToProps = (dispatch) => {
    const { setLastBookmarkedPhoto, setShowPhotoBookmarkMessageBanner, doUpdateUnsavedBookmarks } = photoBookmarkDispatchActions(dispatch);
    return {
        setLastBookmarkedPhoto,
        setShowPhotoBookmarkMessageBanner,
        doUpdateUnsavedBookmarks
    };
};
module.exports = connect(mapStateToProps, mapDispatchToProps)(PhotoBookmark, 'PhotoBookmark');
//# sourceMappingURL=PhotoBookmark.js.map

/***/ }),

/***/ 97316:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { useIntl } = __webpack_require__(46984);
const PropTypes = __webpack_require__(5556);
const { default: translations } = __webpack_require__(77463);
const signInModalActions = __webpack_require__(22509);
const { errorType } = __webpack_require__(74139);
const { proxyCreateBookmark, proxyRemoveBookmark, isPhotoBookmarked, getBookmarkStatus } = __webpack_require__(16840);
const { usePhotoBookmarkingContext } = __webpack_require__(50624);
const { trackBookmarkOperation } = __webpack_require__(36647);
const PHOTO_BOOKMARK_ACTION_NAME = 'addPhotoBookmark';
const PHOTO_BOOKMARK_SOURCE = 'web';
const RESPONSE_CODES = {
    successCreated: 201,
    successRemoved: 204,
    alreadyExistsNoAction: 409
};
/**
 *
 * @param {object} props - PhotoBookmarkActions props
 * @param {Function} [props.setLastBookmarkedPhoto] - Dispatch function to set the id of the most recently bookmarked photo
 * @param {Function} [props.setShowPhotoBookmarkMessageBanner] - Dispatch function to hide the message banner
 * @param {Function} [props.doUpdateUnsavedBookmarks] - Dispatch function to reset the redux state of an unsaved bookmark item
 * @param {string} [props.organizationID] - organization ID
 * @param {string} [props.signInHed] - Header on signin alert shown to user
 * @param {string} [props.signInHedSpanTag] - Hed span tag on signin alert shown to user
 * @param {string} [props.signInMessage] - Message on signin alert shown to user
 * @param {object} props.isAuthenticated - Is user authenticated
 * @param {object} props.federatedGraphqlUrl - GraphQL url to call
 * @param {object} [props.bookmarkMeta] - Optional meta information to be added while creating a bookmark
 * @param {string} [props.bookmarkMeta.title] - Optional street style gallery title stored as part of meta information
 * @param {string} [props.trackingSubject] - Optional subject to be returned in Snowplow function
 * @param {string} [props.contentType] - content type of the story
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @returns {{toggleBookmark, checkIsBookmarked}} - Returns functions
 */
const PhotoBookmarkActions = ({ setLastBookmarkedPhoto, setShowPhotoBookmarkMessageBanner, doUpdateUnsavedBookmarks, organizationID, signInHed, signInHedSpanTag, signInMessage, isAuthenticated = false, federatedGraphqlUrl, bookmarkMeta, trackingSubject, contentType, subtype }) => {
    const { formatMessage } = useIntl();
    const CONTENT_TYPE = contentType === 'photo' ? 'Photo' : contentType;
    const { lastCollectionSavedTo, shouldAutoSaveToCollection } = usePhotoBookmarkingContext();
    /**
     * display sign in modal if user is not signed in
     *
     * @param event - event
     * @param copilotId - add bookmark for copilot id
     */
    const displaySignInModal = async (event, copilotId) => {
        if (event) {
            event.preventDefault();
        }
        const { pathname, search, hash } = window.location;
        const bookmarkQS = `action=${PHOTO_BOOKMARK_ACTION_NAME}&photoId=${copilotId}`;
        const documentURLWithActionQueryString = search
            ? `${pathname}${search}&${bookmarkQS}${hash}`
            : `${pathname}?${bookmarkQS}${hash}`;
        signInModalActions.doDisplayModal({
            authSource: 'sign-in-modal',
            source: 'VERSO_BOOKMARKING',
            dangerousHed: signInHed || formatMessage(translations.photoBookmarkSignInHed),
            dangerousHedSpanTag: signInHedSpanTag ||
                formatMessage(translations.photoBookmarkSignInHedSpanTag),
            dangerousDek: signInMessage || formatMessage(translations.photoBookmarkSignInMessage),
            redirectURL: documentURLWithActionQueryString,
            type: 'default',
            analyticsType: 'saved images'
        });
    };
    /**
     * Create image bookmark from user
     *
     * @param params - parameters
     * @param params.event - Button event reference
     * @param params.copilotID - create bookmark for copilot id
     * @param params.image - image for bookmark being created
     * @param params.meta - meta information
     *
     */
    const createBookmark = async ({ event, copilotID, image, meta }) => {
        if (event) {
            event.preventDefault();
        }
        try {
            const { statusCode, data: { id } = {} } = await proxyCreateBookmark({
                copilotID,
                contentType: subtype || CONTENT_TYPE,
                federatedGraphqlUrl,
                organizationID,
                meta: {
                    ...meta,
                    source: PHOTO_BOOKMARK_SOURCE
                }
            });
            if ((statusCode === RESPONSE_CODES.successCreated && id) ||
                statusCode === RESPONSE_CODES.alreadyExistsNoAction) {
                trackBookmarkOperation({
                    type: 'save',
                    label: 'Save Image',
                    copilotID,
                    bookmarkMeta,
                    contentType,
                    trackingSubject,
                    shouldAutoSaveToCollection,
                    ...(lastCollectionSavedTo && {
                        subjectId: lastCollectionSavedTo.id,
                        subjectName: lastCollectionSavedTo.name
                    })
                });
                setLastBookmarkedPhoto({ copilotID, image, contentType });
                doUpdateUnsavedBookmarks({
                    copilotID,
                    isDeleted: false
                });
            }
            return { isSuccessful: true };
        }
        catch (error) {
            trackBookmarkOperation({
                type: 'error',
                label: 'Save Image',
                copilotID,
                error: 'Failed saving an Image',
                bookmarkMeta,
                contentType,
                trackingSubject,
                errorType: 'save',
                errorMessage: formatMessage(translations.SaveBookmarkErrorText, {
                    collectionName: undefined
                })
            });
            if (error.message.includes(errorType.MISSING_ACCESS_TOKEN)) {
                return displaySignInModal(event, copilotID);
            }
            if (error.message.includes(errorType.RECORD_ALREADY_EXISTS)) {
                return { isSuccessful: true };
            }
            console.error(error);
            return { isSuccessful: false };
        }
    };
    /**
     * Delete image bookmark for the user
     *
     * @param event - Button event reference
     * @param copilotId - delete bookmark for copilot id
     */
    const removeBookmark = async (event, copilotId) => {
        if (event) {
            event.preventDefault();
        }
        let isSuccessful = false;
        try {
            const response = await proxyRemoveBookmark({
                copilotId,
                federatedGraphqlUrl
            });
            if (response.status === RESPONSE_CODES.successRemoved) {
                isSuccessful = true;
                trackBookmarkOperation({
                    type: 'unsave',
                    label: 'Unsave Image',
                    copilotID: copilotId,
                    bookmarkMeta,
                    contentType,
                    trackingSubject
                });
                setLastBookmarkedPhoto();
                doUpdateUnsavedBookmarks({
                    copilotID: copilotId,
                    isDeleted: true
                });
                return { isSuccessful };
            }
            return { isSuccessful };
        }
        catch (error) {
            trackBookmarkOperation({
                type: 'error',
                label: 'Unsave Image',
                copilotID: copilotId,
                error: 'Failed unsaving an Image',
                bookmarkMeta,
                contentType,
                trackingSubject
            });
            console.error(error);
            return { isSuccessful };
        }
    };
    const toggleBookmark = async ({ event, copilotID, image, meta, isSaved }) => {
        setShowPhotoBookmarkMessageBanner({ showBanner: false });
        if (!isAuthenticated) {
            return displaySignInModal(event, copilotID);
        }
        return isSaved
            ? removeBookmark(event, copilotID)
            : createBookmark({ event, copilotID, image, meta });
    };
    const checkIsBookmarked = async (copilotID) => {
        if (copilotID) {
            try {
                if (CONTENT_TYPE === 'Photo') {
                    return await isPhotoBookmarked({
                        copilotID,
                        federatedGraphqlUrl,
                        organizationID
                    });
                }
                const { bookmarkId } = await getBookmarkStatus({
                    copilotID,
                    federatedGraphqlUrl,
                    organizationID
                });
                return !!bookmarkId;
            }
            catch (error) {
                console.error(error);
                return false;
            }
        }
        return false;
    };
    return { toggleBookmark, checkIsBookmarked, PHOTO_BOOKMARK_ACTION_NAME };
};
PhotoBookmarkActions.propTypes = {
    doUpdateUnsavedBookmarks: PropTypes.func,
    federatedGraphqlUrl: PropTypes.string,
    isAuthenticated: PropTypes.bool,
    organizationID: PropTypes.string,
    setLastBookmarkedPhoto: PropTypes.func,
    setShowPhotoBookmarkMessageBanner: PropTypes.func,
    signInHed: PropTypes.string,
    signInHedSpanTag: PropTypes.string,
    signInMessage: PropTypes.string,
    subtype: PropTypes.string
};
module.exports = PhotoBookmarkActions;
//# sourceMappingURL=PhotoBookmarkActions.js.map

/***/ }),

/***/ 50624:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.usePhotoBookmarkingContext = exports.PhotoBookmarkingContext = void 0;
const react_1 = __webpack_require__(96540);
exports.PhotoBookmarkingContext = (0, react_1.createContext)({});
const usePhotoBookmarkingContext = () => (0, react_1.useContext)(exports.PhotoBookmarkingContext);
exports.usePhotoBookmarkingContext = usePhotoBookmarkingContext;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 43211:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PhotoBookmark = __webpack_require__(87091);
const { asConfiguredComponent } = __webpack_require__(12892);
module.exports = asConfiguredComponent(PhotoBookmark, 'PhotoBookmark');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86902:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.photoBookmarkDispatchActions = exports.photoBookmarkStateKey = void 0;
exports.photoBookmarkStateKey = {
    LAST_BOOKMARKED_PHOTO: 'lastBookmarkedPhoto',
    SHOW_MESSAGE_BANNER: 'showPhotoBookmarkMessageBanner',
    UNSAVED_BOOKMARK: 'unsavedBookmarks'
};
const photoBookmarkDispatchActions = (dispatch) => {
    const setLastBookmarkedPhoto = ({ copilotID, image, contentType, contentTitle } = {}) => {
        dispatch({
            type: 'SET_KEY',
            key: exports.photoBookmarkStateKey.LAST_BOOKMARKED_PHOTO,
            value: { copilotID, image, contentType, contentTitle }
        });
    };
    const setShowPhotoBookmarkMessageBanner = ({ showBanner }) => {
        dispatch({
            type: 'SET_KEY',
            key: exports.photoBookmarkStateKey.SHOW_MESSAGE_BANNER,
            value: showBanner
        });
    };
    const doUpdateUnsavedBookmarks = ({ copilotID, isDeleted }) => {
        dispatch({
            type: 'MERGE_KEY',
            key: exports.photoBookmarkStateKey.UNSAVED_BOOKMARK,
            value: { [copilotID]: { isDeleted } }
        });
    };
    return {
        setLastBookmarkedPhoto,
        setShowPhotoBookmarkMessageBanner,
        doUpdateUnsavedBookmarks
    };
};
exports.photoBookmarkDispatchActions = photoBookmarkDispatchActions;
//# sourceMappingURL=photoBookmarkDispatchActions.js.map

/***/ }),

/***/ 62389:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const MessageBanner = __webpack_require__(62282);
const { BaseLink, BaseText } = __webpack_require__(76955);
const { getColorStyles, getColorToken, calculateSpacing, getZIndex, isInverted, getTypographyStyles } = __webpack_require__(26865);
const { ResponsiveImageContainer, ResponsiveImagePicture } = __webpack_require__(7228);
const { SpanWrapper } = __webpack_require__(18117);
const Button = __webpack_require__(88456);
const { ButtonIconWrapper, ButtonLabel, ButtonWrapper, ButtonIcon } = __webpack_require__(18974);
const { MessageBannerCloseButton, MessageBannerContent } = __webpack_require__(8070);
const PhotoBookmarkWrapper = styled.div.withConfig({
    displayName: 'PhotoBookmarkWrapper'
}) `
  ${ButtonIconWrapper} {
    line-height: 0;

    .icon-bookmark-outline path {
      ${({ isInverted }) => isInverted
    ? getColorStyles('stroke', 'colors.interactive.base.white')
    : getColorStyles('stroke', 'colors.interactive.base.black')}
    }

    .icon-bookmark-fill path {
      ${({ isInverted }) => isInverted
    ? getColorStyles('stroke', 'colors.interactive.base.white')
    : getColorStyles('stroke', 'colors.interactive.base.black')}
      ${({ isInverted }) => isInverted
    ? getColorStyles('fill', 'colors.interactive.base.white')
    : getColorStyles('fill', 'colors.interactive.base.black')}
    }
  }
`;
const PhotoBookmarkButton = styled(Button.Utility).withConfig({
    displayName: 'PhotoBookmarkButton'
}) `
  cursor: pointer;
`;
const PhotoBookmarkButtonWithBackgroundStyles = ({ theme }) => `
  border: 1px solid ${getColorToken(theme, 'colors.interactive.base.border')};
  border-radius: ${calculateSpacing(1)};
  width: ${calculateSpacing(5)};
  height: ${calculateSpacing(5)};
  ${getColorStyles(theme, 'background-color', 'colors.interactive.base.black')};
`;
const PhotoBookmarkMessageBannerWrapper = styled(MessageBanner).withConfig({
    displayName: 'PhotoBookmarkMessageBannerWrapper'
}) `
  position: fixed;
  bottom: ${calculateSpacing(2.5)};
  left: 50%;
  transform: translateX(-50%);
  z-index: ${getZIndex('persistentAsideLayer') + 1};
  border: 1px solid;
  padding: ${calculateSpacing(1)} ${calculateSpacing(2)} ${calculateSpacing(1)}
    ${calculateSpacing(1)};
  ${({ theme }) => isInverted(theme)
    ? getColorStyles('border-color', 'colors.interactive.base.border')
    : getColorStyles('border-color', 'colors.interactive.base.light')};
  ${({ theme }) => isInverted(theme) &&
    getColorStyles('background', 'colors.interactive.base.black')};

  width: calc(100vw - ${calculateSpacing(4)});
  height: ${calculateSpacing(7)};

  @media (min-width: ${BREAKPOINTS.md}) {
    right: ${calculateSpacing(6)};
    bottom: ${calculateSpacing(6)};
    left: unset;
    transform: unset;
    width: ${calculateSpacing(45)};
  }

  ${MessageBannerContent} {
    display: flex;
    flex-direction: column;
    justify-content: center;
    height: 100%;
  }

  ${MessageBannerCloseButton} {
    align-self: center;
    margin: 0 0 0 ${calculateSpacing(1)};

    ${ButtonIcon} g {
      ${getColorStyles('stroke', 'colors.interactive.base.deemphasized')};
    }
  }
`;
const SaveBookmarkAlertContent = styled.div.withConfig({
    displayName: 'SaveBookmarkAlertContent'
}) `
  display: flex;
  align-items: center;
  width: 100%;
  height: 100%;
  overflow: hidden;

  ${SpanWrapper},
  ${ResponsiveImagePicture}, ${ResponsiveImageContainer} {
    flex-shrink: 0;
    margin-right: ${calculateSpacing(1)};
    height: 100%;
    aspect-ratio: 2/3;
    object-fit: cover;
  }
`;
const SaveBookmarkAlertLabel = styled(BaseText).withConfig({
    displayName: 'SaveBookmarkAlertLabel'
}) `
  flex: 2;
  margin-right: ${calculateSpacing(0.5)};
  margin-left: ${calculateSpacing(0.5)};
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  ${({ theme }) => isInverted(theme) &&
    getColorStyles('color', 'colors.interactive.base.white')};

  ${getTypographyStyles('typography.definitions.utility.assistive-text')};
`;
const SaveBookmarkAlertLink = styled(BaseLink).withConfig({
    displayName: 'SaveBookmarkAlertLink'
}) `
  /* This should be possible using baseLink's props colorStaticLinkToken, hasUnderline/linkStyle
  but due to the way styles are added in MessageBannerContent they are being overridden */
  &&:link,
  &&:visited,
  &&&:hover,
  &&&:focus {
    text-decoration: none;
    ${({ theme }) => isInverted(theme) &&
    getColorStyles('color', 'colors.interactive.base.white')};
  }

  ${getTypographyStyles('typography.definitions.foundation.link-primary')};
`;
const PhotoMessageBannerContent = styled.div.withConfig({
    displayName: 'PhotoMessageBannerContent'
}) `
  display: flex;
  align-items: center;
`;
const PhotoMessageBannerIcon = styled.div.withConfig({
    displayName: 'PhotoMessageBannerIcon'
}) `
  margin-right: ${calculateSpacing(1)};
  min-width: ${calculateSpacing(4)};

  path {
    ${({ theme }) => isInverted(theme)
    ? getColorStyles('stroke', 'colors.interactive.base.white')
    : getColorStyles('stroke', 'colors.interactive.base.black')};
  }
`;
const PhotoBookmarkMessageBannerMessage = styled(BaseText).withConfig({
    displayName: 'PhotoBookmarkMessageBannerMessage'
}) `
  ${({ theme }) => isInverted(theme)
    ? getColorStyles('color', 'colors.interactive.base.white')
    : getColorStyles('color', 'colors.interactive.base.black')};

  ${getTypographyStyles('typography.definitions.utility.assistive-text')};
`;
const SaveBookmarkAlertButton = styled(Button.Utility).withConfig({
    displayName: 'SaveBookmarkAlertButton'
}) `
  &,
  &:hover {
    border: none;
    background-color: transparent;
    padding: 0;
    min-width: unset;
    ${({ theme }) => isInverted(theme)
    ? getColorStyles('color', 'colors.interactive.base.white')
    : getColorStyles('color', 'colors.interactive.base.black')};
    ${getTypographyStyles('typography.definitions.foundation.link-primary')};
  }
`;
const DrawerMessageBannerWrapper = styled.div.withConfig({
    displayName: 'DrawerMessageBannerWrapper'
}) `
  && {
    ${ButtonLabel} {
      display: block;
    }
    ${ButtonWrapper} {
      width: auto;

      &:hover {
        border-radius: inherit;
        ${({ theme }) => getColorStyles(theme, 'background', 'colors.interactive.base.black')};
      }
    }
  }
`;
module.exports = {
    DrawerMessageBannerWrapper,
    PhotoBookmarkButton,
    PhotoBookmarkButtonWithBackgroundStyles,
    PhotoBookmarkWrapper,
    PhotoBookmarkMessageBannerWrapper,
    SaveBookmarkAlertContent,
    SaveBookmarkAlertLabel,
    SaveBookmarkAlertLink,
    SaveBookmarkAlertButton,
    PhotoMessageBannerContent,
    PhotoMessageBannerIcon,
    PhotoBookmarkMessageBannerMessage
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 36647:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trackBookmarkOperation = void 0;
const snowplow_tracking_1 = __webpack_require__(14307);
const PHOTO_STREETSTYLE = 'photo_streetstyle';
const PHOTO_RUNWAY = 'photo_runway';
const getSubject = (bookmarkMetaTitle) => {
    return bookmarkMetaTitle ? PHOTO_STREETSTYLE : PHOTO_RUNWAY;
};
const trackBookmarkOperation = ({ bookmarkMetaTitle, copilotID, error, label, shouldAutoSaveToCollection, subjectId, subjectName, trackingSubject, type, contentType, code, errorType, errorMessage }) => {
    const finalSubject = trackingSubject || getSubject(bookmarkMetaTitle?.title);
    const eventData = {
        ...(type && { type }),
        ...(label && { label }),
        ...(finalSubject && { subject: finalSubject }),
        ...(error && { error }),
        items: [
            {
                ...(copilotID && { content_id: copilotID }),
                ...(contentType && { content_type: contentType })
            }
        ]
    };
    const saveContext = (0, snowplow_tracking_1.buildSaveImageContext)({
        isAutoSelected: shouldAutoSaveToCollection,
        isDefault: !shouldAutoSaveToCollection,
        isFromBookmark: true,
        subject: 'account_saved_images',
        ...(subjectId && { subjectId: subjectId.toString() }),
        ...(subjectName && { subjectName })
    });
    const errorContext = {
        ...(code && { code }),
        ...(errorType && { type: errorType }),
        ...(errorMessage && { message: errorMessage }),
        ...(code || errorType || errorMessage ? { subject: finalSubject } : {})
    };
    (0, snowplow_tracking_1.trackSaveEvent)(eventData, saveContext, errorContext);
};
exports.trackBookmarkOperation = trackBookmarkOperation;
//# sourceMappingURL=trackBookmarkOperation.js.map

/***/ }),

/***/ 77463:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const react_intl_1 = __webpack_require__(46984);
exports["default"] = (0, react_intl_1.defineMessages)({
    GalleryDesktopMessageBannerText: {
        id: 'PhotoBookmark.GalleryDesktopMessageBannerText',
        defaultMessage: 'Click the icon to save an image to your account.',
        description: 'Desktop GalleryPage message banner text'
    },
    GalleryMobileMessageBannerText: {
        id: 'PhotoBookmark.GalleryMobileMessageBannerText',
        defaultMessage: 'Tap the icon to save an image to your account.',
        description: 'Mobile GalleryPage message banner text'
    },
    DefaultDesktopMessageBannerText: {
        id: 'PhotoBookmark.DefaultDesktopMessageBannerText',
        defaultMessage: 'Click the icon to save a story to your account.',
        description: 'Desktop message banner text for default channel'
    },
    DefaultMobileMessageBannerText: {
        id: 'PhotoBookmark.DefaultMobileMessageBannerText',
        defaultMessage: 'Tap the icon to save a story to your account.',
        description: 'Mobile message banner text for default channel'
    },
    photoBookmarkSignInHed: {
        id: 'PhotoBookmark.SignInHed',
        defaultMessage: 'Save images',
        description: 'Bookmark sign in hed'
    },
    photoBookmarkSignInHedSpanTag: {
        id: 'PhotoBookmark.SignInHedSpanTag',
        defaultMessage: 'to your Vogue account',
        description: 'Bookmark sign in hed span tag'
    },
    photoBookmarkSignInMessage: {
        id: 'PhotoBookmark.SignInMessage',
        defaultMessage: 'Sign in to save runway and street style images, then easily revisit them on any device.',
        description: 'Bookmark sign in message'
    },
    photoBookmarkSaveIconTitle: {
        id: 'PhotoBookmark.SaveIconTitle',
        defaultMessage: 'Save Image',
        description: 'Save bookmark icon title'
    },
    photoBookmarkSavedIconTitle: {
        id: 'PhotoBookmark.SavedIconTitle',
        defaultMessage: 'Image saved',
        description: 'Saved bookmark icon title'
    },
    ImageSearchDesktopMessageBannerText: {
        id: 'PhotoBookmark.ImageSearchDesktopMessageBannerText',
        defaultMessage: 'Click into your favorite images to start saving them to your account.',
        description: 'Desktop ImageSearchPage message banner text'
    },
    ImageSearchMobileMessageBannerText: {
        id: 'PhotoBookmark.ImageSearchMobileMessageBannerText',
        defaultMessage: 'Tap into your favorite images to start saving them to your account.',
        description: 'Mobile ImageSearchPage message banner text'
    },
    RunwayDesktopMessageBannerText: {
        id: 'PhotoBookmark.RunwayDesktopMessageBannerText',
        defaultMessage: 'Hover over an image and click the icon to save it to your account.',
        description: 'Desktop RunwayGalleryPage message banner text'
    },
    RunwayMobileMessageBannerText: {
        id: 'PhotoBookmark.RunwayMobileMessageBannerText',
        defaultMessage: 'Tap the icon to save an image to your account.',
        description: 'Mobile RunwayGalleryPage message banner text'
    },
    SaveAlertSavedToBoardMessage: {
        id: 'PhotoBookmark.SaveAlertSavedToBoardMessage',
        defaultMessage: 'Go To Boards',
        description: 'View link of board, image saved to'
    },
    SaveAlertWithBoardName: {
        id: 'PhotoBookmark.SaveAlertWithBoardName',
        defaultMessage: 'Saved to {collectionName}',
        description: 'Message showing image was saved to a specific collection'
    },
    SaveAlertMovedWithBoardName: {
        id: 'PhotoBookmark.SaveAlertMovedWithBoardName',
        defaultMessage: 'Moved to {collectionName}',
        description: 'Message showing image was moved to a specific collection'
    },
    SaveBookmarkAlertText: {
        id: 'PhotoBookmark.SaveBookmarkAlertText',
        defaultMessage: 'Image saved',
        description: 'View all saved images alert'
    },
    SaveBookmarkAlertLink: {
        id: 'PhotoBookmark.SaveBookmarkAlertLink',
        defaultMessage: 'Create a Board',
        description: 'Create a new board button'
    },
    SaveBookmarkAlertMoveLink: {
        id: 'PhotoBookmark.SaveBookmarkAlertMoveLink',
        defaultMessage: 'Move',
        description: 'Move bookmarks'
    },
    SaveBookmarkErrorText: {
        id: 'PhotoBookmark.SaveBookmarkErrorText',
        defaultMessage: 'Unable to save image{collectionName, select, undefined {} other { to {collectionName}}}. Please try again.',
        description: 'Error message when bookmark operation fails, optionally includes collection name'
    },
    SavedWithAddingToListLink: {
        id: 'DrawerMessageBanner.SavedWithAddingToListLink',
        defaultMessage: 'View List',
        description: 'View the list where story is saved to message'
    },
    SavedWithoutAddingToListLink: {
        id: 'DrawerMessageBanner.SavedWithoutAddingToListLink',
        defaultMessage: 'View All',
        description: 'View all saved content message'
    },
    SaveRemovedMessage: {
        id: 'DrawerMessageBanner.SaveRemovedMessage',
        defaultMessage: 'Save removed',
        description: 'Unsaved the content message'
    },
    SavedMessage: {
        id: 'DrawerMessageBanner.SavedMessage',
        defaultMessage: 'Saved',
        description: 'Saved the content message'
    },
    UndoButtonLabel: {
        id: 'DrawerMessageBanner.UndoButtonLabel',
        defaultMessage: 'Undo',
        description: 'Undo button label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 60688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable eslint-comments/disable-enable-pair */
/* eslint-disable react-hooks/exhaustive-deps */
const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const ProductOffer = __webpack_require__(36314);
const bookmark = __webpack_require__(48373);
const { ProductOfferListWrapper } = __webpack_require__(94037);
const { TrackComponentChannel } = __webpack_require__(78788);
const { getProductLocalisedOffers, countryCurrencyMapping } = __webpack_require__(63799);
const DEFAULT_COUNTRY = 'US';
/**
 * Renders an array of product offers
 *
 * @param {object} props - React props
 * @param {string} [props.btnStyle] - which button style to display product offers
 * @param {string} [props.buttonVariation] - which button variation to display product offers
 * @param {string} [props.className] - Optional classnames to add to product offer list block
 * @param {string} [props.copilotID] - Optional copilot id of the item
 * @param {string} [props.contentType] - optional content type
 * @param {object} [props.dataAttrs] - Optional data attributes for button
 * @param {string} [props.defaultCTAText] - optional cta label to show when product price is outside the button
 * @param {string} [props.defaultTextForEmbedSize] - optional label to show when product embed sizes are enabled
 * @param {string} [props.embedSize] - Optional property to know the size of product embeds
 * @param {boolean} props.hasMultipleLines - Boolean value that helps in clamping text on button to two line and ellipsis when the sentences is more than two lines
 * @param {boolean} [props.hasPriceSection] - Optional boolean to mark cta as no-follow
 * @param {Bool} [props.hasGallerySlideBackground] - optional flag for gallery product background
 * @param {Bool} [props.hasReadReviewCTA] - Optional flag to show a Read Review CTA with bookmark if no offer urls present
 * @param {boolean} [props.hidePriceComponentWhenNoPrice] - Optional flag to hide price when it is unavailable
 * @param {boolean} [props.isVenueCardItemContainer] - Optional flag to set venue seller token
 * @param {Function} [props.onClickHandler] - optinal function to call on button click
 * @param {string} [props.organizationID] - Optional organization id for fetching bookmark details
 * @param {Array} [props.offers] - optional array of offers to show
 * @param {string} [props.productId] - productId is id of product
 * @param {string} [props.productOfferVariation] - optional product offer variation to display text outside button
 * @param {number} [props.showCount] - optional number that limits max number of offers to show
 * @param {boolean} [props.shouldDisplayBookmarkWithOffers] - Optional flag to render bookmark button alongside offer button
 * @param {boolean} [props.showOffersSeller] - optional flag to toggle offer's seller name to display outside of button
 * @param {boolean} props.showOfferUrl - Determines whether offerUrl should be displayed or not based on flag
 * @param {boolean} [props.showPriceOnButton] - optional flag to toggle offer price display inside a button
 * @param {boolean} props.showSellerNameBelowButton -optional flag to determine whether seller name is displayed is displayed below button
 * @param {string} [props.venueSellerPreviewText] - optional text to display if showOffersSeller is true
 * @param {bool} [props.showOfferButtonSideBySide] - Optional to have offer Buttons SideBySide
 * @param {Array} props.dropShipSellers - array representing dropship sellers
 * @param {bool} props.showLocalisedOffers - optional flag to show localised offers
 * @param {bool} [props.shouldConsiderPriceText] - Optional, to consider default price text on offer buttons
 * @param {string} [props.urlToBookmark] - optional url string to pass into product offer bookmark button
 * @param {object} [props.user] - Optional user details for fetching bookmark details
 * @param {object} [props.userPlatform] - Optional user platform details for fetching bookmark details
 * @param {string} [props.ctaAtRetailerName] - Optional cta at text when price is not present
 * @param {boolean} [props.showSellerNameBelowPrice] - Optional flag for showing upc component type token
 * @param {boolean} [props.isProductSummaryGridOffer] - Optional prop for product offer with product summary grid component
 * @param {boolean} [props.shouldColorChangeBlueToBlack] - Optional prop to fetch the experiment variable
 * @param {boolean} [props.shouldColorChangeBlackToYellow] - Optional prop to fetch the experiment variable
 * @param {boolean} [props.shouldUseBlackButton] -optional prop to cta changes
 * @param {boolean} [props.isActionIdEnabledForComponent] -Optional prop to enable mapping actionId to snowplow and affiliate link on user click
 * @param {object} [props.image] - image object for collection drawer
 * @param {boolean} [props.shouldUseBookmarkV3] - feature flag to use the V3 bokmarking service
 * @param {string} [props.component] - Optional component name for tracking
 * @param {string} [props.contentTitle] - Optional content hed for item
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @param {boolean} [props.showDiscountPercentLabel] - Optional boolean to show discount percentage label
 * @returns {ReactElement} <div>
 */
const ProductOfferList = ({ buttonVariation, btnStyle, className, copilotID, contentType, subtype, contentTitle, dataAttrs, ctaAtRetailerName, defaultCTAText, defaultTextForEmbedSize, embedSize, shouldUseBookmarkV3, hasGallerySlideBackground, hasMultipleLines, hasPriceSection, hasReadReviewCTA, hidePriceComponentWhenNoPrice, isVenueCardItemContainer, image, onClickHandler, offers = [], organizationID, productId, productOfferVariation, shouldConsiderPriceText = false, showCount = 1, shouldDisplayBookmarkWithOffers = false, showOfferButtonSideBySide = false, showOffersSeller, showOfferUrl, showPriceOnButton, showSellerNameBelowButton, venueSellerPreviewText, dropShipSellers, showLocalisedOffers, urlToBookmark, user, userPlatform, showSellerNameBelowPrice, isProductSummaryGridOffer, shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow, isActionIdEnabledForComponent, shouldUseBlackButton, component, showDiscountPercentLabel = false }) => {
    const [bookmarkDetails, setBookmarkDetails] = React.useState({});
    const defaultCurrencyOffers = showLocalisedOffers && contentType !== 'hotel'
        ? offers?.filter((offer) => offer.countryCode && offer.countryCode !== ''
            ? offer.countryCode === DEFAULT_COUNTRY
            : offer.currency === countryCurrencyMapping[DEFAULT_COUNTRY])
        : offers;
    const [productOffers, setProductOffers] = React.useState(defaultCurrencyOffers);
    React.useEffect(() => {
        setProductOffers(showLocalisedOffers === true && contentType !== 'hotel'
            ? getProductLocalisedOffers(DEFAULT_COUNTRY, offers)
            : defaultCurrencyOffers);
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ProductOfferList'
        });
    }, []);
    React.useEffect(() => {
        const fetchBookmarkDetails = async () => {
            if (!user.amguuid) {
                setBookmarkDetails({
                    bookmarkId: null,
                    isUrlBookmark: null,
                    contentId: copilotID,
                    organizationID,
                    contentType
                });
                return;
            }
            const bookmarkHelper = bookmark(shouldUseBookmarkV3);
            const bookmarkStatus = await bookmarkHelper.getBookmarkStatus({
                amgUUID: user.amguuid,
                copilotID,
                documentUrl: `${window.location.origin}${urlToBookmark}`,
                organizationID,
                federatedGraphqlUrl: userPlatform.federatedGraphqlUrl,
                siteCode: userPlatform.siteCode,
                userPlatformProxy: userPlatform.userPlatformProxy,
                xClientID: userPlatform.xClientID
            });
            setBookmarkDetails({
                ...bookmarkStatus,
                contentId: copilotID,
                contentType
            });
        };
        if (shouldDisplayBookmarkWithOffers)
            fetchBookmarkDetails();
    }, [shouldDisplayBookmarkWithOffers]);
    const updateBookmark = (bookmarkStatus) => {
        const { contentId } = bookmarkStatus;
        setBookmarkDetails({
            ...bookmarkStatus,
            contentId: contentId || copilotID,
            contentType
        });
    };
    const ProductOfferComponent = ProductOffer[productOfferVariation] || ProductOffer;
    if (!productOffers?.length) {
        return null;
    }
    const isValidURL = (url) => {
        try {
            new URL(url);
            return true;
        }
        catch (err) {
            return false;
        }
    };
    return (React.createElement(ProductOfferListWrapper, { className: classnames('product-offer-list', className), showOfferButtonSideBySide: showOfferButtonSideBySide, hasReadReviewCTA: hasReadReviewCTA, shouldUseBlackButton: shouldUseBlackButton, "data-testid": "product-offer-list-wrapper", ...(embedSize && { 'data-embed-size': embedSize }) }, productOffers.slice(0, showCount).map((offer, index) => {
        let isExternalProduct = true;
        if (dropShipSellers?.length > 0) {
            isExternalProduct = dropShipSellers?.some((seller) => {
                if (offer.offerUrl && isValidURL(offer.offerUrl)) {
                    const { origin } = new URL(offer.offerUrl);
                    return !origin?.toLowerCase().includes(seller);
                }
                return true;
            });
        }
        const ctaHref = offer.purchaseUri;
        const venueSeller = (showOffersSeller && offer.seller?.name) || '';
        const key = offer.sellerName || venueSeller;
        const isPriceAvailable = !!offer.price;
        return (React.createElement(ProductOfferComponent, { ...offer, bookmarkDetails: bookmarkDetails, buttonVariation: buttonVariation, btnStyle: btnStyle, ctaHref: ctaHref, className: "product-offer-list__offer", copilotID: copilotID, contentType: contentType, subtype: subtype, dataAttrs: dataAttrs, ctaAtRetailerName: ctaAtRetailerName, defaultCTAText: defaultCTAText, defaultTextForEmbedSize: defaultTextForEmbedSize, embedSize: embedSize, hasMultipleLines: hasMultipleLines, hasPriceSection: hidePriceComponentWhenNoPrice ? isPriceAvailable : hasPriceSection, image: image, contentTitle: contentTitle, onClickHandler: onClickHandler, showSellerNameBelowPrice: showSellerNameBelowPrice, isProductSummaryGridOffer: isProductSummaryGridOffer, productId: productId, position: index, venueSeller: venueSeller, showOfferUrl: showOfferUrl, showPriceOnButton: showPriceOnButton, showSellerNameBelowButton: hidePriceComponentWhenNoPrice
                ? isPriceAvailable
                : showSellerNameBelowButton, key: key, venueSellerPreviewText: venueSellerPreviewText, isExternalProduct: isExternalProduct, isVenueCardItemContainer: isVenueCardItemContainer, shouldConsiderPriceText: shouldConsiderPriceText, showOfferButtonSideBySide: showOfferButtonSideBySide, hasBookmarkingEnabled: shouldDisplayBookmarkWithOffers, updateBookmark: updateBookmark, urlToBookmark: urlToBookmark, hasGallerySlideBackground: hasGallerySlideBackground, shouldColorChangeBlueToBlack: shouldColorChangeBlueToBlack, shouldColorChangeBlackToYellow: shouldColorChangeBlackToYellow, isActionIdEnabledForComponent: isActionIdEnabledForComponent, shouldUseBlackButton: shouldUseBlackButton, component: component, showDiscountPercentLabel: showDiscountPercentLabel, "data-testid": "product-offer", "data-action-id-enabled": isActionIdEnabledForComponent, ...(shouldDisplayBookmarkWithOffers && {
                'data-bookmark-enabled': 'true'
            }) }));
    })));
};
ProductOfferList.propTypes = {
    btnStyle: PropTypes.oneOf(['filled', 'outlined', 'text']),
    buttonVariation: PropTypes.string,
    className: PropTypes.string,
    component: PropTypes.string,
    contentTitle: PropTypes.string,
    contentType: PropTypes.string,
    copilotID: PropTypes.string,
    ctaAtRetailerName: PropTypes.string,
    dataAttrs: PropTypes.object,
    defaultCTAText: PropTypes.string,
    defaultTextForEmbedSize: PropTypes.string,
    dropShipSellers: PropTypes.array,
    embedSize: PropTypes.string,
    hasGallerySlideBackground: PropTypes.bool,
    hasMultipleLines: PropTypes.bool,
    hasPriceSection: PropTypes.bool,
    hasReadReviewCTA: PropTypes.bool,
    hidePriceComponentWhenNoPrice: PropTypes.bool,
    image: PropTypes.object,
    isActionIdEnabledForComponent: PropTypes.bool,
    isExternalProduct: PropTypes.bool,
    isProductSummaryGridOffer: PropTypes.bool,
    isVenueCardItemContainer: PropTypes.bool,
    offers: PropTypes.array,
    onClickHandler: PropTypes.func,
    organizationID: PropTypes.string,
    productId: PropTypes.string,
    productOfferVariation: PropTypes.string,
    shouldColorChangeBlackToYellow: PropTypes.bool,
    shouldColorChangeBlueToBlack: PropTypes.bool,
    shouldConsiderPriceText: PropTypes.bool,
    shouldDisplayBookmarkWithOffers: PropTypes.bool,
    shouldUseBlackButton: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    showCount: PropTypes.number,
    showDiscountPercentLabel: PropTypes.bool,
    showLocalisedOffers: PropTypes.bool,
    showOfferButtonSideBySide: PropTypes.bool,
    showOffersSeller: PropTypes.bool,
    showOfferUrl: PropTypes.bool,
    showPriceOnButton: PropTypes.bool,
    showSellerNameBelowButton: PropTypes.bool,
    showSellerNameBelowPrice: PropTypes.bool,
    subtype: PropTypes.string,
    urlToBookmark: PropTypes.string,
    user: PropTypes.object,
    userPlatform: PropTypes.object,
    venueSellerPreviewText: PropTypes.string
};
ProductOfferList.displayName = 'ProductOfferList';
module.exports = ProductOfferList;
//# sourceMappingURL=ProductOfferList.js.map

/***/ }),

/***/ 18059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { connect: connectToStore } = __webpack_require__(67851);
const { asConfiguredComponent } = __webpack_require__(12892);
const ProductOfferList = __webpack_require__(60688);
// this allows us to pass props in ProductOffer which can be used to get bookmark details of the item
const mapStateToProps = (state) => {
    const { coreDataLayer = {}, user, userPlatform, featureFlags = {} } = state;
    const { shouldUseBookmarkV3 } = featureFlags;
    return {
        shouldUseBookmarkV3,
        organizationID: coreDataLayer?.site?.orgId || '',
        user,
        userPlatform
    };
};
const ConfiguredProductOfferList = asConfiguredComponent(ProductOfferList, 'ProductOfferList');
module.exports = connectToStore(mapStateToProps)(ConfiguredProductOfferList);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { ProductOfferWrapper } = __webpack_require__(61366);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, minScreen, maxScreen } = __webpack_require__(26865);
const ProductOfferListWrapper = styled.div.withConfig({
    displayName: 'ProductOfferListWrapper'
}) `
  ${({ hasReadReviewCTA }) => hasReadReviewCTA &&
    `
      width:100%;
   `}
  ${({ showOfferButtonSideBySide }) => {
    if (showOfferButtonSideBySide) {
        return `
        ${minScreen(BREAKPOINTS.md)} {
            display: grid;
            grid-template-columns: 1fr 1fr;
            row-gap: 1rem;
            column-gap: 1rem;
          }
       `;
    }
    return '';
}};

  ${ProductOfferWrapper} {
    width: 100%;

    &:not(:last-child) {
      margin-bottom: ${calculateSpacing(1)};
    }

    ${({ showOfferButtonSideBySide }) => {
    if (showOfferButtonSideBySide) {
        return `
        ${maxScreen(BREAKPOINTS.md)} {
          &:not(:last-child) {
            margin-bottom: ${calculateSpacing(1.5)};
          }
        }
        ${minScreen(BREAKPOINTS.md)} {
          &:not(:last-child) {
            margin-bottom: 0px;
          }
        }
          `;
    }
    return '';
}};
  }
`;
module.exports = {
    ProductOfferListWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 62340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const { useEffect, useState } = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
const { RatingForm, RatingFormWrapper, RatingInput, RatingLabel, RatingLink, RatingLinkWrapper, RatingRating, RatingRatings, RatingStar, RatingStarHalf, RatingStars, RatingTriangle, RatingWrapper } = __webpack_require__(97927);
const translations = (__webpack_require__(43473)/* ["default"] */ .A);
const Rating = ({ averageRatingCount = 0, brandSlug = '', className, hasBorderTop = false, isRatingDisabled = true, link = {}, onChange, onSubmit, totalRatingCount = 0, isRatingClickable, showReviewLink = true, shouldShowOutline = true }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Rating'
        });
    }, []);
    const { formatMessage } = useIntl();
    const [roundedRating, setRoundedRating] = useState(averageRatingCount);
    const hasRating = !!averageRatingCount && !!totalRatingCount;
    const { onClick, label, url } = link || {};
    const changeHandler = (e) => {
        const newRating = Number(e.target.value);
        setRoundedRating(newRating);
        if (onChange) {
            onChange(newRating);
        }
    };
    const submitHandler = (e) => {
        e.preventDefault();
        if (onSubmit) {
            onSubmit(e.target.value);
        }
    };
    useEffect(() => {
        setRoundedRating(averageRatingCount);
    }, [averageRatingCount, brandSlug]);
    const [isFocussed, setIsFocussed] = useState(false);
    return (React.createElement(RatingWrapper, { className: className, "data-testid": "RatingWrapper", hasBorderTop: hasBorderTop },
        React.createElement(RatingFormWrapper, { onClick: label && url && isRatingClickable && onClick, href: url, showReviewLink: showReviewLink },
            hasRating ? (React.createElement(RatingRating, null, Number(brandSlug === 'epicurious' ? roundedRating : averageRatingCount).toFixed(1))) : null,
            React.createElement(RatingForm, { "data-testid": "rating-form", action: "", onSubmit: submitHandler, isRatingDisabled: isRatingDisabled, isFocussed: isFocussed },
                React.createElement(RatingStars, { role: "group", "aria-label": formatMessage(translations.ratingAriaLabel) }, ['', 's', 't', 'a', 'r', 's'].map((_, i) => {
                    // we need a random hash in the id to prevent issues when a rating is used multiple times on a page
                    const randomHash = Math.random().toString(36).substring(7);
                    const starId = `Rating${i}-${randomHash}`;
                    return (React.createElement(React.Fragment, { key: `Rating${i}` },
                        React.createElement(RatingInput, { "aria-label": `${i} ${formatMessage(translations.ratingAriaLabel)}`, defaultChecked: i === Math.floor(roundedRating), disabled: isRatingDisabled, id: starId, name: "Rating", onClick: changeHandler, value: i, onFocus: () => {
                                setIsFocussed(i === 0);
                            }, shouldShowOutline: shouldShowOutline }),
                        React.createElement(RatingLabel, { htmlFor: starId }, i > 0 ? (React.createElement(RatingStar, null,
                            React.createElement(RatingStarHalf, { "$shouldHalfFill": i === Math.floor(roundedRating) + 1 &&
                                    roundedRating % 1 !== 0 }))) : null)));
                }))),
            hasRating ? React.createElement(RatingRatings, null,
                "(",
                totalRatingCount,
                ")") : null),
        showReviewLink && label && url ? (React.createElement(RatingLinkWrapper, null,
            React.createElement(RatingLink, { onClick: onClick, href: url },
                label,
                React.createElement(RatingTriangle, null)))) : null));
};
Rating.propTypes = {
    averageRatingCount: PropTypes.number,
    brandSlug: PropTypes.string,
    className: PropTypes.string,
    hasBorderTop: PropTypes.bool,
    isRatingClickable: PropTypes.bool,
    isRatingDisabled: PropTypes.bool,
    link: PropTypes.shape({
        onClick: PropTypes.func,
        label: PropTypes.string,
        url: PropTypes.string
    }),
    onChange: PropTypes.func,
    onSubmit: PropTypes.func,
    shouldShowOutline: PropTypes.bool,
    showReviewLink: PropTypes.bool,
    totalRatingCount: PropTypes.number
};
module.exports = Rating;
//# sourceMappingURL=Rating.js.map

/***/ }),

/***/ 21093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(62340);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 97927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const RatingHalfIcon = __webpack_require__(60703);
const TriangleIcon = __webpack_require__(91583);
const { BaseLink, BaseText } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorStyles } = __webpack_require__(26865);
const { hideVisually } = __webpack_require__(52813);
const RatingTriangle = styled(TriangleIcon).withConfig({
    displayName: 'RatingTriangle'
}) `
  transform: scale(0.7);
  margin-left: ${calculateSpacing(1)};
`;
const RatingLink = styled(BaseLink).withConfig({ displayName: 'RatingLink' }) `
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  text-transform: uppercase;
`;
RatingLink.defaultProps = {
    colorToken: 'colors.consumption.lead.standard.description',
    typeIdentity: 'typography.definitions.utility.button-bulletin'
};
const RatingLinkWrapper = styled.div.withConfig({
    displayName: 'RatingLinkWrapper'
}) `
  margin-top: ${calculateSpacing(1)};
`;
const RatingRatings = styled(BaseText).withConfig({
    displayName: 'RatingRatings'
}) `
  margin-left: ${calculateSpacing(1)};
`;
RatingRatings.defaultProps = {
    colorToken: 'colors.consumption.lead.standard.context-tertiary',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
const RatingStarHalf = styled(RatingHalfIcon).withConfig({
    displayName: 'RatingStarHalf'
}) `
  &&& {
    position: absolute;
    top: 7px;
    left: 7px;
    width: 18px;
    height: 18px;

    path {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};
    }

    ${({ $shouldHalfFill, theme }) => $shouldHalfFill &&
    ` &&{
          path:nth-of-type(1) {
            ${getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')}
          }
        }`}
  }
`;
RatingStarHalf.defaultProps = {
    showTitle: false
};
const RatingStar = styled.div.withConfig({ displayName: 'RatingStar' }) `
  position: relative;
  width: 32px;
  height: 32px;
`;
const RatingStars = styled.div.withConfig({ displayName: 'RatingStars' }) `
  display: flex;
  flex-direction: row;
`;
const RatingLabel = styled.label.withConfig({ displayName: 'RatingLabel' }) `
  /*
    src/styles/scss/base/forms are being applied to all input elements
    &&& forces specificity to reset all styles :(
  */

  &&& {
    all: unset;

    cursor: pointer;

    &::before {
      content: none;
    }

    &::after {
      content: none;
    }
  }
`;
const RatingInput = styled.input
    .withConfig({ displayName: 'RatingInput' })
    .attrs(() => ({
    type: 'radio'
})) `
  &&& {
    all: unset;
    ${hideVisually()};

    ${({ defaultChecked, theme }) => defaultChecked
    ? `+ ${RatingLabel} ~ ${RatingLabel} {
      ${RatingStarHalf} path {
        ${getColorStyles(theme, 'fill', 'colors.interactive.base.light')};
      }
    }`
    : null}

    &:disabled + ${RatingLabel} {
      ${({ showReviewLink }) => !showReviewLink ? `cursor: pointer;` : `cursor: initial;`}
    }
    &:focus + ${RatingLabel} {
      ${({ shouldShowOutline }) => shouldShowOutline && `outline: #2360c5 auto 1px;`}
    }
  }
`;
const RatingForm = styled.form.withConfig({ displayName: 'RatingForm' }) `
  &&& {
    &:focus-within {
      outline: ${({ isFocussed }) => (isFocussed ? '#2360C5 auto 1px' : '')};
    }

    &:hover {
      && {
        ${RatingInput} + ${RatingLabel} ${RatingStarHalf} path {
          ${({ theme, isRatingDisabled }) => isRatingDisabled
    ? ``
    : `${getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};}`}
          ${RatingInput}:hover + ${RatingLabel} ~ ${RatingLabel} {
            ${RatingStarHalf} path {
              ${({ theme, isRatingDisabled }) => isRatingDisabled
    ? ``
    : `: ${getColorStyles(theme, 'fill', 'colors.interactive.base.light')};}`}
            }
          }
        }
      }
    }
  }
`;
const RatingRating = styled(BaseText).withConfig({
    displayName: 'RatingRating'
}) `
  margin-right: ${calculateSpacing(1)};
`;
RatingRating.defaultProps = {
    colorToken: 'colors.consumption.lead.standard.description',
    typeIdentity: 'typography.definitions.globalEditorial.numerical-large'
};
const RatingFormWrapper = styled.div.withConfig({
    displayName: 'RatingFormWrapper'
}) `
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  ${({ showReviewLink }) => !showReviewLink &&
    `&&&:hover {
    cursor: pointer;
  }`}
`;
const RatingWrapper = styled.div.withConfig({
    displayName: 'RatingWrapper'
}) `
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: ${calculateSpacing(3)} 0 ${calculateSpacing(4)};
  width: 100%;

  ${({ hasBorderTop, theme }) => hasBorderTop
    ? `border-top: 1px solid;
        ${getColorStyles(theme, 'border-color', 'colors.consumption.lead.standard.accent')};
        margin-top: ${calculateSpacing(3)};

        @media (min-width: ${BREAKPOINTS.lg}){
          border-top: none;
          margin-top: 0;
        }`
    : ''};
`;
module.exports = {
    RatingForm,
    RatingFormWrapper,
    RatingInput,
    RatingLabel,
    RatingLink,
    RatingLinkWrapper,
    RatingRating,
    RatingRatings,
    RatingStar,
    RatingStarHalf,
    RatingStars,
    RatingTriangle,
    RatingWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 43473:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    ratingAriaLabel: {
        id: 'Rating.RatingAriaLabel',
        defaultMessage: 'Rating',
        description: 'Default aria label for rating text'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 86157:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const ResponsiveClip = __webpack_require__(17637);
const ResponsiveImage = __webpack_require__(43608);
const ResponsiveCartoon = __webpack_require__(44597);
const GridContext = __webpack_require__(66552);
const { calculateSizes } = __webpack_require__(65226);
const imageContentTypes = new Set(['photo', 'cartoon']);
const videoContentTypes = new Set(['clip', 'cnevideo']);
const { SpanWrapper, CNEVideoEmbedWrapper } = __webpack_require__(18117);
const { TrackComponentChannel } = __webpack_require__(78788);
const ResponsiveImageNext = __webpack_require__(46674);
/**
 * ResponsiveAsset component
 *
 * @param {object} props - Either ResponsiveClip OR ResponsiveImage props
 * @param {string} props.altText - alternative media text content
 * @param {string} [props.className] - wrapper classname
 * @param {string} [props.contentType] - can be 'photo', 'clip', 'cartoon' or 'cnevideo'. Defaults to 'photo'.
 * @param {string} [props.imageAttributes] - object of props passed directly into ResponsiveImage
 * @param {string} [props.isLazy] - defaults to FALSE. Marks the asset to be lazyloaded
 * @param {string} [props.itemProp] - Optional string value to pass to the image
 * @param {string} [props.responsiveCartoonVariation] - apply responsive cartoon variation if present
 * @param {string} [props.scriptUrl] - CNE video scriptUrl
 * @param {bool} [props.shouldAutoplay] - should autoplay CNE video or not
 * @param {string} [props.sizes] - if provided, directly passed as `sizes` attribute. If not, dynamically generated from Grid.
 * @param {string} [props.sources] - object with media sources
 * @param {bool}  [shouldRestrictCropping] - optional restriction on crop property of image
 * @param {string} [masterAspectRatio] - aspect ratio for image
 * @param {boolean}  [shouldHoldImageSpace] - Optional boolean to hold image space based on aspect ratio prior to loading. Requires parent container to have a fixed width for proper calculation.
 * @param {Function} [props.setCartoonLinkedGalleries] - Set Cartoon linked gallery items in Article Page Modal
 * @param {bool} [props.shouldUseMediumBreakpoint] - Flag to define whether generate a medium breakpoint.
 * @param {bool} [props.shouldDisableImageClick] - To disable the image click
 * @param {object} [props.analyticsData] - Analytics Data for the cartoon in the Article page
 * @param {string}[props.signalType] - Specifying the icon to be displayed.
 * @param {object} [props.actionBarConfig] - Config for Actionbar
 * @param {boolean} [props.shouldHideCartoonCaption] - Optional hides the cartoon caption
 * @param {boolean} [props.shouldHideCartoonCredit] - Optional hides the cartoon credit
 * @param {boolean} [shouldLoopVideo] - Optional flag to loop play videos after a video ends. Defaults to false.
 * @param {string} [props.shouldDisableAds] - Optional shouldDisableAds to disable ads of video.
 * @param {boolean} [props.hasCNEVideoInProductCard] - Optional prop for cne video inside product card
 * @param {string} [props.upcId] - Optional prop for unique unified product card id
 * @param {string} [props.hasNativeImgLazyLoading] - Optional prop for native lazy loading og img
 * @param {string} [props.psgId] - Optional prop for unique unified product card id
 * @returns {ReactElement} containing ResponsiveClip OR ResponsiveImage
 */
class ResponsiveAsset extends React.Component {
    constructor(props) {
        super(props);
        /**
         * Receives a ref for the wrapper element. Begins lazy-observation if needed.
         *
         * @param {HTMLElement} assetElement - the DOM node of the asset
         * @returns {undefined} undefined
         */
        this.handleRef = (assetElement) => {
            if (this.state.shouldLoadAsset || !assetElement) {
                return;
            }
            if (!this.observer) {
                // 0 for 'load this now' (900px from viewport).
                // 0.75 for 'show this now' (vaguely chosen, but roughly when image comes in view).
                const rootMargin = '900px 0px 900px 0px';
                const upcShowNowThreshold = this.props.imageAttributes?.loading === 'lazy' ? 0 : 0.75;
                const threshold = [0, upcShowNowThreshold];
                this.observer = new IntersectionObserver(this.handleIntersection, {
                    rootMargin,
                    threshold
                });
            }
            this.observer.observe(assetElement);
            this.element = assetElement;
        };
        /**
         * Receives height and returns a boolean which determines whether it is a long image or not.
         *
         * @param {number} height - height of the image
         * @returns {boolean} - Deternmines whether image is very long
         */
        this.isLongImage = (height) => {
            return 0.75 * height > window.innerHeight;
        };
        /**
         * Receives boundingClientRect object and returns a boolean which determines whether
         * the image is located on the right or left edge of a viewport and partly is not in a viewport.
         * If most of the image is not in a viewport, it can not reach 75% intersectionRatio and therefore can not be lazy loaded.
         * It happens frequently in carousels.
         *
         * @param {object} boundingClientRect - boundingClientRect object of element
         * @returns {boolean} - Deternmines whether image is located on the right or left edge of a viewport
         */
        this.isEdgeImage = (boundingClientRect) => {
            const width = document.documentElement.clientWidth;
            return ((boundingClientRect.right > width && boundingClientRect.left < width) ||
                (boundingClientRect.right > 0 && boundingClientRect.left < 0));
        };
        /**
         * Callback from the inner asset component when it's ready to be animated in.
         *
         * @param {object} sizes - the size parameters of an asset
         * @returns {undefined} undefined
         */
        this.handleAssetLoaded = (sizes) => {
            this.props.onAssetLoaded && this.props.onAssetLoaded(sizes);
            this.setState({
                assetLoaded: true
            });
            // Need to restart the observer if the image is not cached
            if (this.isLongImage(sizes?.height) && !this.state.isInView) {
                this.observer.unobserve(this.element);
                this.observer.observe(this.element);
            }
        };
        /**
         * Callback from the inner asset component when it's container is loaded.
         *
         * @param {object} containerNode - the container node element of the asset
         * @returns {undefined} undefined
         */
        this.handleAssetContainerLoaded = (containerNode) => {
            if (videoContentTypes.has(this.props.contentType)) {
                this.props.onAssetContainerLoaded &&
                    this.props.onAssetContainerLoaded(containerNode);
            }
        };
        /**
         * Response to an intersection event from IntersectionObserver.
         *
         * @param {Array<IntersectionObserverEntry>} entries - an object with details about this intersection
         * @returns {undefined} undefined
         */
        this.handleIntersection = (entries) => {
            const { contentType } = this.props;
            entries
                .filter((entry) => entry.isIntersecting)
                .forEach(({ target, isIntersecting, intersectionRatio, boundingClientRect }) => {
                this.setState({ shouldLoadAsset: true });
                // This will try to load the image as soon as it intersects if the image is very long
                const isLongImageIntersecting = ['photo', 'cartoon'].includes(contentType) &&
                    this.isLongImage(target.querySelector('img') &&
                        target.querySelector('img').naturalHeight) &&
                    isIntersecting;
                const isEdgeImageIntersecting = this.isEdgeImage(boundingClientRect) && isIntersecting;
                if (intersectionRatio >= 0.75 ||
                    isLongImageIntersecting ||
                    isEdgeImageIntersecting) {
                    this.setState({ isInView: true });
                    this.observer.disconnect();
                }
            });
        };
        this.observer = null;
        this.element = null;
        this.state = {
            assetLoaded: !imageContentTypes.has(props.contentType),
            shouldLoadAsset: !this.props.isLazy,
            isInView: !this.props.isLazy
        };
    }
    async componentDidMount() {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ResponsiveAsset',
            variation: this.props.contentType
        });
    }
    componentWillUnmount() {
        this.observer && this.observer.disconnect();
    }
    render() {
        const { className, contentType = 'photo', isLazy, scriptUrl, shouldAutoplay, shouldHoldImageSpace = false, sizes, itemProp, masterAspectRatio, shouldRestrictCropping, responsiveCartoonVariation, showPublishedDate, setCartoonLinkedGalleries, shouldPlayContinuously, shouldUseMediumBreakpoint, shouldDisableImageClick, analyticsData, signalType, actionBarConfig, imageAttributes, videoEmbedPosition, shouldDisableAds, shouldLoopVideo, hasCNEVideoInProductCard, hasNativeImgLazyLoading, upcId, psgId } = this.props;
        const ResponsiveCartoonWrapper = responsiveCartoonVariation
            ? ResponsiveCartoon[responsiveCartoonVariation]
            : ResponsiveCartoon;
        const { assetLoaded, shouldLoadAsset, isInView } = this.state;
        const componentProps = {
            ...this.props,
            shouldHideCaption: this.props.shouldHideCartoonCaption,
            shouldHideCredit: this.props.shouldHideCartoonCredit,
            shouldLoadAsset
        };
        return (React.createElement(GridContext.Consumer, null, (context) => (React.createElement(SpanWrapper, { className: classnames('responsive-asset', className), isInVisible: !hasNativeImgLazyLoading && isLazy && (!isInView || !assetLoaded), ref: !hasNativeImgLazyLoading ? this.handleRef : null, responsiveCartoonVariation: responsiveCartoonVariation, hasCNEVideoInProductCard: hasCNEVideoInProductCard, isUpcOrPlpPage: Boolean(upcId) || Boolean(psgId) },
            contentType === 'clip' && (React.createElement(ResponsiveClip, { ...componentProps, onLoadedMetadata: this.handleAssetContainerLoaded })),
            contentType === 'cnevideo' && (React.createElement(CNEVideoEmbedWrapper, { shouldAutoplay: shouldAutoplay, shouldPlayContinuously: shouldPlayContinuously, scriptUrl: scriptUrl, videoEmbedPosition: videoEmbedPosition || '', onVideoLoad: this.handleAssetContainerLoaded, shouldLoopVideo: shouldLoopVideo, shouldDisableAds: shouldDisableAds, hasCNEVideoInProductCard: hasCNEVideoInProductCard, upcId: this.props.upcId })),
            contentType === 'photo' &&
                (!hasNativeImgLazyLoading ? (React.createElement(ResponsiveImage, { ...componentProps, onAssetLoaded: this.handleAssetLoaded, shouldHoldImageSpace: shouldHoldImageSpace, sizes: sizes || calculateSizes(context), masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping, itemProp: itemProp, signalType: signalType, actionBarConfig: actionBarConfig, imageAttributes: imageAttributes })) : (React.createElement(ResponsiveImageNext, { ...componentProps, sizes: sizes || calculateSizes(context), masterAspectRatio: masterAspectRatio, shouldRestrictCropping: shouldRestrictCropping, itemProp: itemProp, signalType: signalType, actionBarConfig: actionBarConfig, imageAttributes: imageAttributes }))),
            contentType === 'cartoon' && (React.createElement(ResponsiveCartoonWrapper, { ...componentProps, onAssetLoaded: this.handleAssetLoaded, sizes: sizes || calculateSizes(context), showPublishedDate: showPublishedDate, setCartoonLinkedGalleries: setCartoonLinkedGalleries, shouldHoldImageSpace: shouldHoldImageSpace, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, shouldDisableImageClick: shouldDisableImageClick, analyticsData: analyticsData }))))));
    }
}
ResponsiveAsset.propTypes = {
    actionBarConfig: PropTypes.object,
    altText: PropTypes.string.isRequired,
    analyticsData: PropTypes.object,
    className: PropTypes.string,
    contentType: PropTypes.oneOf(['cartoon', 'photo', 'clip', 'cnevideo']),
    hasCNEVideoInProductCard: PropTypes.bool,
    hasNativeImgLazyLoading: PropTypes.bool,
    imageAttributes: PropTypes.object,
    isInVisible: PropTypes.bool,
    isLazy: PropTypes.bool,
    itemProp: PropTypes.string,
    masterAspectRatio: PropTypes.string,
    onAssetContainerLoaded: PropTypes.func,
    onAssetLoaded: PropTypes.func,
    psgId: PropTypes.string,
    responsiveCartoonVariation: PropTypes.oneOf([
        'SliderCartoon',
        'InlineCartoon',
        'Card',
        'WithNoSocialIcons'
    ]),
    scriptUrl: PropTypes.string,
    segmentedSources: PropTypes.oneOfType([
        ResponsiveClip.propTypes.segmentedSources,
        ResponsiveImage.propTypes.segmentedSources
    ]),
    setCartoonLinkedGalleries: PropTypes.func,
    shouldAutoplay: PropTypes.bool,
    shouldDisableAds: PropTypes.bool,
    shouldDisableImageClick: PropTypes.bool,
    shouldHideCartoonCaption: PropTypes.bool,
    shouldHideCartoonCredit: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldLoopVideo: PropTypes.bool,
    shouldPlayContinuously: PropTypes.bool,
    shouldRestrictCropping: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    showPublishedDate: PropTypes.bool,
    signalType: PropTypes.string,
    sizes: PropTypes.string,
    sources: PropTypes.oneOfType([
        ResponsiveClip.propTypes.sources,
        ResponsiveImage.propTypes.sources
    ]),
    upcId: PropTypes.string,
    upcLazyLoading: PropTypes.string,
    videoElementRef: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.shape({ current: PropTypes.object })
    ]),
    videoEmbedPosition: PropTypes.string
};
module.exports = ResponsiveAsset;
//# sourceMappingURL=ResponsiveAsset.js.map

/***/ }),

/***/ 65226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Breakpoints = __webpack_require__(99906);
/**
 * Converts something like '3/12' to an integer 25.
 *
 * @param {string} stringFraction - the string literal of the fraction
 * @returns {number} - the percentage (0-100)
 */
const stringFractionToPercentage = (stringFraction) => {
    const [numerator, denominator] = stringFraction.split('/');
    return Math.ceil((100 * numerator) / denominator);
};
/**
 * Convert the number of columns this component spans (provided per-breakpoint)
 * into a `sizes` string for responsive media.
 *
 * @param {object} context - Grid context
 * @param {object} [context.columnSpans] - grid column spans
 * @param {string} context.columnSpans.sm - a fractional string representing column span e.g. '2/4'
 * @param {string} context.columnSpans.md - a fractional string representing column span e.g. '2/4'
 * @param {string} context.columnSpans.lg - a fractional string representing column span e.g. '2/4'
 * @param {string} context.columnSpans.xl - a fractional string representing column span e.g. '6/12'
 * @param {string} context.columnSpans.xxl - a fractional string representing column span e.g. '6/12'
 * @param {string} context.columnSpans.xxxl - a fractional string representing column span e.g. '6/12'
 * @param {bool} context.isFullBleed - true if the xxxl breakpoint should fullbleed the viewport
 *
 * @returns {string} sizes data
 */
const calculateSizes = (context) => {
    const { columnSpans, isFullBleed } = context || {};
    if (!columnSpans) {
        // If we don't have a Grid specification here, we'll just assume the image is full-bleed.
        // This covers images not inside a `<Grid>` as well as unspecified `<Grid>` variations.
        return '100vw';
    }
    return Breakpoints.sizesDescending
        .reduce((acc, bp, index) => {
        const percent = stringFractionToPercentage(columnSpans[bp]);
        const nextBreakpoint = Breakpoints.sizesDescending[index + 1];
        const nextPercent = nextBreakpoint
            ? stringFractionToPercentage(columnSpans[nextBreakpoint])
            : 0;
        // for the top breakpoint, each column is a fixed pixel width.
        if (bp === 'xxxl' && !isFullBleed) {
            const minWidth = Breakpoints.minThresholds.xxxl;
            const spanWidth = Math.ceil((minWidth * percent) / 100);
            acc.push(`(min-width: ${minWidth}px) ${spanWidth}px`);
        }
        // for the bottom breakpoint, we specify the fallback without a media query.
        else if (bp === 'sm') {
            acc.push(`${percent}vw`);
        }
        // we'll specify _this_ value if the _next_ one is going to be different.
        // in this way, we specify the floors of each change.
        else if (percent !== nextPercent) {
            acc.push(`(min-width: ${Breakpoints.minThresholds[bp]}px) ${percent}vw`);
        }
        return acc;
    }, [])
        .join(', ');
};
/**
 *
 * @param {string} aspectRatio - aspect ratio string in format width:height
 * @returns {number} height to width ratio
 */
function getAspectRatioValue(aspectRatio) {
    if (!aspectRatio)
        return NaN;
    const [width, height] = aspectRatio.split(':').map((v) => parseInt(v, 10));
    return height / width;
}
/**
 * From an object of form { width, height }, return a percentage figure of height / width.
 *
 * @param {object} source - object of the form { width, height }
 * @returns {number} percentage from 0-100
 */
function getPercentageHeight(source) {
    const heightToWidth = source.height / source.width;
    const aspectRatio = getAspectRatioValue(source.aspectRatio);
    return Math.round(10000 * (heightToWidth || aspectRatio)) / 100;
}
/**
 * Based on a CSS className and an object with sources, construct a string of CSS
 * rules to ensure that the identified elements maintain proportional scaling.
 *
 * @param {string} className - the selector to apply the rules under
 * @param {object} sources - an object of image sources of the form { sm: Source, lg: Source }
 * @returns {string} css rule data
 */
function getCSSHeightRules(className, sources) {
    if (!className || !sources.sm) {
        return '';
    }
    const smPadding = getPercentageHeight(sources.sm);
    let output = `
  .${className} {
    height: 0;
    padding-bottom: ${smPadding}%;
  }`;
    if (sources.lg) {
        const lgPadding = getPercentageHeight(sources.lg);
        if (lgPadding !== smPadding) {
            output += `
      @media (min-width: ${Breakpoints.minThresholds.lg}px) {
        .${className} {
          padding-bottom: ${lgPadding}%;
        }
      }`;
        }
    }
    return output;
}
/**
 * Use the greatest common divisor to reduce a fraction like 200/300 down to it's
 * lowest form, e.g. 2/3.
 *
 * @param {number} numerator - top number
 * @param {number} denominator - bottom number
 * @returns {Array<number>} new numerator, new denominator
 */
function reduceFraction(numerator, denominator) {
    let gcd = function gcd(a, b) {
        return b ? gcd(b, a % b) : a;
    };
    gcd = gcd(numerator, denominator);
    return [numerator / gcd, denominator / gcd];
}
/**
 * Reduce an object of image source objects down to a CSS-safe identifier which
 * is unique to the aspect ratios encoded within them.
 *
 * @param {string} type - the media type (picture, video)
 * @param {object} sources - object of form { [bp]: { width, height } }
 * @returns {string} the css-safe identifier.
 */
function getSourcesIdentifier(type, sources) {
    const ratioSlug = Object.values(sources)
        .filter((v) => v.width && v.height)
        .map(({ height, width }) => reduceFraction(width, height).join('x'))
        .join('-');
    return ratioSlug ? `${type}-${ratioSlug}` : '';
}
module.exports = {
    calculateSizes,
    getAspectRatioValue,
    getCSSHeightRules,
    getPercentageHeight,
    getSourcesIdentifier
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 73275:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { connect: connectToStore } = __webpack_require__(67851);
const ResponsiveAsset = __webpack_require__(86157);
// This allows a global switch for "never lazyload anything".
function mapStateToProps(state) {
    if (state.disableLazyLoad) {
        return { isLazy: false };
    }
    return {};
}
const ReduxConnectedResponsiveAsset = connectToStore(mapStateToProps)(ResponsiveAsset);
module.exports = ReduxConnectedResponsiveAsset;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const CNEVideoEmbed = __webpack_require__(64930);
const SpanWrapper = styled.span.withConfig({ displayName: 'SpanWrapper' }) `
  display: block;
  transition: ${({ isUpcOrPlpPage }) => !isUpcOrPlpPage ? 'opacity 1s' : 'none'};
  opacity: ${({ isInVisible, hasCNEVideoInProductCard }) => isInVisible && !hasCNEVideoInProductCard ? 0 : 1};
  overflow: ${({ responsiveCartoonVariation }) => responsiveCartoonVariation === 'InlineCartoon' ? 'visible' : 'hidden'};
`;
const CNEVideoEmbedWrapper = styled(CNEVideoEmbed).withConfig({
    displayName: 'CNEVideoEmbedWrapper'
}) `
  margin: 0;
  padding-bottom: 56.25%;
  width: 100%;
  height: 0;
`;
module.exports = {
    SpanWrapper,
    CNEVideoEmbedWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 43917:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { connect } = __webpack_require__(67851);
const { useState, useEffect } = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(4577)/* ["default"] */ .A);
const ResponsiveImage = __webpack_require__(43608);
const ExternalLink = __webpack_require__(39832);
const SocialIconsDef = __webpack_require__(67783);
const { TrackComponentChannel } = __webpack_require__(78788);
const modalActions = __webpack_require__(59319);
const { CartOutlined, DownloadCloud, CopyLink } = __webpack_require__(97504);
const PhotoStack = __webpack_require__(5232);
const ViewportMonitor = __webpack_require__(3990);
const { googleAnalytics } = __webpack_require__(90090);
const useAnalytics = __webpack_require__(36132);
const { ResponsiveCartoonWrapper, ResponsiveCartoonImage, ResponsiveCartoonIcons, ResponsiveCartoonCredit, ResponsiveCartoonCaption, ResponsiveCartoonTagCloud, ResponsiveCartoonCTA, ResponsiveCartoonCTAWrapper, ResponsiveCartoonIconButton, ResponsiveCartoonOpenGallery, ResponsiveCartoonLinkAlertPopup, ResponsiveCartoonLinkButtonWrapper } = __webpack_require__(77527);
/**
 * ResponsiveCartoon component
 *
 * @param {object} props - React props
 * @param {string} props.altText - Required text description to be added to the image `alt` attribute
 * @param {string} [props.caption] - Caption for the cartoon
 * @param {string} [props.className] - Optional top-level class to add to component
 * @param {string} [props.credit] - Credit for the Cartoon
 * @param {string} [props.dangerousCaption] - Optional HTML text caption for the cartoon
 * @param {string} [props.dangerousCredit] - HTML credit for cartoon
 * @param {string} [props.id] - Cartoon id
 * @param {object} [props.imageAttributes] - Optional attributes to add to the img element
 * @param {object} [props.links] - Link object ({ handle, label, network, url }) properties. `label` and `network` are both required, but only one of `handle` OR `url` are required.
 * @param {Function} [props.onAssetLoaded] - Optional function to callback on img.onload
 * @param {string} [props.publishedDate] - Cartoon published date
 * @param {boolean} [props.shouldLoadAsset] - Optional flag indicating we should load the image. Default: TRUE.
 * @param {boolean} [props.showOpenGalleyButton] - Optional flag to fetch the linked gallery and show the open galley button If the linked gallery exist.
 * @param {boolean} [props.showPublishedDate] - Flag to hide/show published date
 * @param {boolean} [props.showSocialIcons] - Flag to hide/show social Icons
 * @param {string} [props.sizes] - Optional image sizes attribute e.g. '100vw' or '(min-width: 769px) 50vw, 100vw'
 * @param {object} props.sources - Transformed urls (with correct ratio and size) to render as sources. Usually these urls are formatted vulcan urls with the correct aspect ratio and size parameters.
 * @param {object} [props.tagCloud] - Tag data for Cartoon
 * @param {Function} [props.openModal] - Redux Action to toggle Modal
 * @param {boolean} [props.variations.isCard] - Adds padding and a white background (useful on non-white pages)
 * @param {boolean} [props.variations.isCartoonEmbed] - Adds padding and top bottom border if it's a article embed
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {boolean} [props.showCartActionButtons] - Flag to show hide cart button
 * @param {boolean} [props.showDownloadActionButton] - Flag to show hide download button
 * @param {boolean} [props.showLinkActionButton] - Flag to show hide link button
 * @param {boolean} [props.isCartoonCaption] - Flag to show hide cartoon caption
 * @param {Function} [props.setCartoonLinkedGalleries] - Set Cartoon linked gallery items in Article Page Modal
 * @param {bool} [props.shouldHoldImageSpace] - To jold the image space
 * @param {bool} [props.shouldUseMediumBreakpoint] - Flag to define whether generate a medium breakpoint.
 * @param {bool} [props.shouldDisableImageClick] - To disable the image click
 * @param {object} [props.analyticsData] - Analytics Data for the cartoon in the Article page
 * @param {boolean} [props.shouldHideCaption] - Optional hides the caption
 * @param {boolean} [props.shouldHideCredit] - Optional hides the credit
 *
 * @returns {ResponsiveCartoon} <div>
 */
const ResponsiveCartoon = (props) => {
    const { formatMessage } = useIntl();
    const [linkedGallery, setLinkedGallery] = React.useState({});
    const { caption, credit, className, dangerousCaption, dangerousCredit, id, links = [], publishedDate, showCartActionButtons = false, showDownloadActionButton = false, showLinkActionButton = false, showOpenGalleyButton = false, showPublishedDate = false, showSocialIcons = true, sources, tagCloud, openModal, variations = {
        isCartoonEmbed: false,
        isCard: false
    }, isCartoonCaption = true, setCartoonLinkedGalleries, variationName, shouldHoldImageSpace, shouldUseMediumBreakpoint, shouldDisableImageClick = false, analyticsData = {}, shouldHideCaption, shouldHideCredit } = props;
    const { triggerCartoonEvent } = useAnalytics(analyticsData);
    // Cartoon data for analytics
    const cartoonData = {
        id,
        dangerousCaption,
        linkedGallery,
        links
    };
    const { isCartoonEmbed, isCard } = variations;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ResponsiveCartoon',
            variation: variationName
        });
    }, [variationName]);
    const shouldShowOpenGalleyButton = React.useMemo(() => showOpenGalleyButton && linkedGallery?.id, [showOpenGalleyButton, linkedGallery?.id]);
    const shouldRenderCartoonCTA = React.useMemo(() => showCartActionButtons ||
        showDownloadActionButton ||
        showLinkActionButton ||
        shouldShowOpenGalleyButton, [
        showCartActionButtons,
        showDownloadActionButton,
        showLinkActionButton,
        shouldShowOpenGalleyButton
    ]);
    const WrapperComponent = analyticsData.cartoonPlacement === 'inline' || analyticsData.isSmallDevice
        ? ViewportMonitor
        : 'div';
    const cartoonDataLayer = {
        cartoon_placement: analyticsData?.cartoonPlacement,
        cartoon_id: id,
        gallery_title: linkedGallery?.dangerousHed || analyticsData?.galleryTitle || ''
    };
    const cartoonCanonical = links.find((link) => link.network === 'canonical');
    const showCaption = (dangerousCaption || caption) && !shouldHideCaption;
    const showCredit = Boolean((dangerousCredit || credit || (showPublishedDate && publishedDate)) &&
        !shouldHideCredit);
    const hasSocialIcons = showSocialIcons && links?.length > 0;
    const cartoonInteractionEvent = (interaction) => {
        googleAnalytics.emitGoogleTrackingEvent('cartoon-interaction', {
            ...cartoonDataLayer,
            cartoon_interaction: interaction
        });
        triggerCartoonEvent(interaction, cartoonData);
    };
    React.useEffect(() => {
        if (showOpenGalleyButton && cartoonCanonical?.url) {
            const queryParams = new URLSearchParams({
                format: 'json',
                page: 1,
                includeGallery: true,
                hierarchies: 'channels/cartoons',
                galleryLimit: 1,
                includeRecirc: true,
                recircLimit: 3
            });
            const slug = cartoonCanonical.url.split('/').splice(3).join('/');
            const url = `/${slug}?${queryParams}`;
            fetch(url)
                .then((fetched) => fetched.json())
                .then((response) => {
                const gallery = response.cartoon?.gallery || [];
                if (gallery.length && gallery[0]?.items.length) {
                    setLinkedGallery(gallery[0]);
                }
            })
                .catch((error) => {
                console.warn(error);
            });
        }
    }, [showOpenGalleyButton, cartoonCanonical]);
    const [linkCopied, setLinkCopied] = useState(false);
    const copyToClipboard = async (text) => {
        try {
            if (!navigator.clipboard) {
                // If clipboard api is not supported, go with 'copy' command
                const textArea = document.createElement('textarea');
                textArea.value = text;
                // Avoid scrolling to bottom
                textArea.style.top = '0';
                textArea.style.left = '0';
                textArea.style.position = 'fixed';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                let successful;
                try {
                    successful = document.execCommand('copy');
                }
                catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                }
                document.body.removeChild(textArea);
                if (!successful) {
                    throw new Error('Fallback: Oops, unable to copy');
                }
            }
            else {
                await navigator.clipboard.writeText(text);
            }
            // Copied to clipboard
            setLinkCopied(true);
        }
        catch (err) {
            // Copy to clipboard failed
            console.error(err);
        }
    };
    const downloadCartoonImage = () => {
        let imgUrl;
        // Pick the smallest image url from 'sources'
        const breakPoints = ['sm', 'md', 'lg', 'xl', 'xxl'];
        for (const bp of breakPoints) {
            if (sources?.[bp]?.url) {
                imgUrl = sources[bp].url;
                break;
            }
        }
        if (!imgUrl) {
            return;
        }
        const a = document.createElement('a');
        a.href = imgUrl;
        a.download = 'Cartoon.png';
        a.target = '_blank';
        a.click();
    };
    const analyticsInteractionNames = {
        openCartoonGallery: 'open',
        download: 'download',
        share: 'share_link',
        shop: 'go_to_shop'
    };
    const handleModalAction = () => {
        cartoonInteractionEvent(analyticsInteractionNames.openCartoonGallery);
        setCartoonLinkedGalleries(linkedGallery, () => openModal(true));
    };
    const handleCartoonClick = (e) => {
        e.stopPropagation();
        if (shouldShowOpenGalleyButton) {
            e.preventDefault();
            handleModalAction();
        }
    };
    const getResponsiveCartoonTagCloud = (tagCloud) => tagCloud && (React.createElement(ResponsiveCartoonTagCloud, { ...tagCloud, className: "responsive-cartoon__tags" }));
    const getResponsiveCartoonCaption = (showCaption, dangerousCaption, caption, isCartoonCaption, handleModalAction, shouldShowOpenGalleyButton) => showCaption && (React.createElement(ResponsiveCartoonCaption, { dangerousCaptionText: dangerousCaption || caption, className: "responsive-cartoon__caption", "data-testid": "responsive-cartoon__caption", isCartoonCaption: isCartoonCaption, hasLinebreak: true, ...(shouldShowOpenGalleyButton && {
            onClickHandler: handleModalAction
        }) }));
    const getCredit = (dangerousCredit, credit, showPublishedDate, publishedDate) => {
        const creditData = dangerousCredit || credit;
        if (showPublishedDate && publishedDate && creditData) {
            return {
                dangerousCredit: `<span>${dangerousCredit || credit}</span><span>${publishedDate}</span>`,
                hasMultipleCredit: true
            };
        }
        if (showPublishedDate && publishedDate && !creditData) {
            return {
                dangerousCredit: publishedDate,
                hasMultipleCredit: false
            };
        }
        return {
            dangerousCredit: creditData,
            hasMultipleCredit: false
        };
    };
    const getResponsiveCartoonCredit = (showCredit, credit, dangerousCredit, isCartoonCaption, showPublishedDate, publishedDate, shouldShowOpenGalleyButton) => showCredit && (React.createElement(ResponsiveCartoonCredit, { ...getCredit(dangerousCredit, credit, showPublishedDate, publishedDate), "data-testid": "responsive-cartoon__credit", className: "responsive-cartoon__credit", isCartoonCaption: isCartoonCaption, ...(shouldShowOpenGalleyButton && {
            onClickHandler: handleModalAction
        }) }));
    const onIntersectionViewport = (isInViewport, unsubscribeCallback) => {
        if (isInViewport) {
            googleAnalytics.emitGoogleTrackingEvent('cartoon-impression', {
                ...cartoonDataLayer,
                cartoon_numbering: `${analyticsData.cartoonPosition || ''}/${analyticsData.totalNumberOfCartoons}` || ''
            });
            unsubscribeCallback();
            triggerCartoonEvent('impression', cartoonData);
        }
    };
    useEffect(() => {
        const timeout = setTimeout(() => {
            setLinkCopied(false);
        }, 3000);
        return () => clearTimeout(timeout);
    }, [linkCopied]);
    // Analytics - Pass onIntersectionViewport only for small devices
    const setIntersectionViewport = () => {
        if (analyticsData.cartoonPlacement === 'inline' ||
            analyticsData.isSmallDevice) {
            return {
                onIntersectionViewport
            };
        }
        return {};
    };
    const shouldAddImageExternalLink = !shouldDisableImageClick && Boolean(cartoonCanonical?.url);
    return (React.createElement(ResponsiveCartoonWrapper, { as: WrapperComponent, className: classnames('responsive-cartoon', className), "data-testid": "responsive-cartoon", isCartoonEmbed: isCartoonEmbed, isCard: isCard, shouldShowOpenGalleyButton: shouldShowOpenGalleyButton, ...setIntersectionViewport() },
        shouldAddImageExternalLink ? (React.createElement(ExternalLink, { "data-testid": "responsive-cartoon__image-link", className: "responsive-cartoon__image-link", href: cartoonCanonical.url, onClick: handleCartoonClick },
            React.createElement(ResponsiveCartoonImage, { ...props, "data-testid": "responsive-cartoon__image", className: "responsive-cartoon__image", shouldHoldImageSpace: shouldHoldImageSpace, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint }))) : (React.createElement(ResponsiveCartoonImage, { ...props, "data-testid": "responsive-cartoon__image", className: "responsive-cartoon__image" })),
        getResponsiveCartoonCaption(showCaption, dangerousCaption, caption, isCartoonCaption, handleModalAction, shouldShowOpenGalleyButton),
        hasSocialIcons && (React.createElement(ResponsiveCartoonIcons, { links: links, "data-testid": "responsive-cartoon__social-icons", className: "responsive-cartoon__social-icons" })),
        getResponsiveCartoonCredit(showCredit, credit, dangerousCredit, isCartoonCaption, showPublishedDate, publishedDate, shouldShowOpenGalleyButton),
        shouldRenderCartoonCTA && (React.createElement(ResponsiveCartoonCTA, null,
            React.createElement(ResponsiveCartoonCTAWrapper, null,
                showLinkActionButton && (React.createElement(ResponsiveCartoonLinkButtonWrapper, null,
                    React.createElement(ResponsiveCartoonIconButton, { ariaLabel: formatMessage(translations.copyLinkButtonMessage), label: formatMessage(translations.copyLinkButtonMessage), btnStyle: "outlined", isIconButton: true, hasEnableIcon: true, onClickHandler: () => {
                            copyToClipboard(cartoonCanonical ? cartoonCanonical.url : '');
                            cartoonInteractionEvent(analyticsInteractionNames.share);
                        }, ButtonIcon: () => (React.createElement(CopyLink, { title: formatMessage(translations.copyLinkButtonMessage) })), cornerRadius: "FullyRoundedCorner", size: "small" }),
                    React.createElement(ResponsiveCartoonLinkAlertPopup, { alertPosition: "under", ariaRole: "dialog", arrowPosition: 50, className: "shopping-alert", iconPosition: "after", isTooltip: true, isVisible: true, shouldUseArrow: true, isActive: linkCopied },
                        React.createElement("p", { "aria-hidden": true }, formatMessage(translations.copiedLinkAlertMessage))))),
                showDownloadActionButton && (React.createElement(ResponsiveCartoonIconButton, { ariaLabel: formatMessage(translations.downloadButtonMessage), label: formatMessage(translations.downloadButtonMessage), btnStyle: "outlined", isIconButton: true, hasEnableIcon: true, onClickHandler: () => {
                        downloadCartoonImage();
                        cartoonInteractionEvent(analyticsInteractionNames.download);
                    }, ButtonIcon: () => (React.createElement(DownloadCloud, { title: formatMessage(translations.downloadButtonMessage) })), cornerRadius: "FullyRoundedCorner", size: "small" })),
                showCartActionButtons && (React.createElement(ResponsiveCartoonIconButton, { ariaLabel: formatMessage(translations.cartButtonMessage), label: formatMessage(translations.cartButtonMessage), btnStyle: "outlined", isIconButton: true, hasEnableIcon: true, onClickHandler: () => {
                        window.open('https://condenaststore.com/conde-nast-brand/cartoons', '_blank');
                        cartoonInteractionEvent(analyticsInteractionNames.shop);
                    }, ButtonIcon: () => (React.createElement(CartOutlined, { title: formatMessage(translations.cartButtonMessage) })), cornerRadius: "FullyRoundedCorner", size: "small" })),
                shouldShowOpenGalleyButton && (React.createElement(ResponsiveCartoonOpenGallery, { ariaLabel: formatMessage(translations.openCartoonGalleryButtonMessage), label: formatMessage(translations.openCartoonGalleryButtonMessage), iconPosition: "after", hasEnableIcon: true, onClickHandler: handleModalAction, ButtonIcon: () => (React.createElement(PhotoStack, { title: formatMessage(translations.openCartoonGalleryButtonIconMessage) })), cornerRadius: "FullyRoundedCorner", btnStyle: "outlined", size: "small" }))))),
        getResponsiveCartoonTagCloud(tagCloud)));
};
ResponsiveCartoon.propTypes = {
    ...ResponsiveImage.propTypes,
    analyticsData: PropTypes.shape({
        cartoonPlacement: PropTypes.string,
        cartoonPosition: PropTypes.number,
        totalNumberOfCartoons: PropTypes.number
    }),
    dangerousCaption: PropTypes.string,
    dangerousCredit: PropTypes.string,
    id: PropTypes.string,
    isCartoonCaption: PropTypes.bool,
    links: SocialIconsDef.propTypes.links,
    setCartoonLinkedGalleries: PropTypes.func,
    shouldDisableImageClick: PropTypes.bool,
    shouldHideCaption: PropTypes.bool,
    shouldHideCredit: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    showCartActionButtons: PropTypes.bool,
    showDownloadActionButton: PropTypes.bool,
    showLinkActionButton: PropTypes.bool,
    showOpenGalleyButton: PropTypes.bool,
    showPublishedDate: PropTypes.bool,
    showSocialIcons: PropTypes.bool,
    tagCloud: PropTypes.shape({
        sectionHeader: PropTypes.string,
        tags: PropTypes.arrayOf(PropTypes.shape({
            tag: PropTypes.string.isRequired,
            url: PropTypes.string
        }).isRequired)
    }),
    variations: PropTypes.shape({
        isCartoonEmbed: PropTypes.bool,
        isCard: PropTypes.bool
    })
};
const mapDispatchToProps = (dispatch) => {
    const { openModal } = modalActions(dispatch);
    return {
        openModal
    };
};
module.exports = connect(null, mapDispatchToProps)(ResponsiveCartoon);
//# sourceMappingURL=ResponsiveCartoon.js.map

/***/ }),

/***/ 44597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(33683);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 77527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const ResponsiveImage = __webpack_require__(43608);
const Caption = __webpack_require__(14760);
const { CaptionText, CaptionCredit } = __webpack_require__(38860);
const SocialIcons = __webpack_require__(35676);
const Button = __webpack_require__(73730);
const { ButtonIconWrapper } = __webpack_require__(18974);
const { SocialIconsListItem, SocialIconsList } = __webpack_require__(51000);
const TagCloud = __webpack_require__(6494);
const Alert = __webpack_require__(54330);
const { calculateSpacing, getColorStyles, getTypographyStyles, getColorToken } = __webpack_require__(26865);
const ResponsiveCartoonImage = styled(ResponsiveImage).withConfig({
    displayName: 'ResponsiveCartoonImage'
}) `
  margin: 0 auto;
`;
const ResponsiveCartoonCredit = styled(Caption).withConfig({
    displayName: 'ResponsiveCartoonCredit'
}) `
  margin: 0;
  text-align: center;

  ${CaptionCredit} {
    ${({ hasMultipleCredit }) => hasMultipleCredit &&
    `
        display: inline-block;
        justify-content: center;
        align-items: center;
        
        span {
          display: inline-block;
        }
        
        span:nth-child(2) {
          margin-left: ${calculateSpacing(1)};
        }
    `}
  }
`;
const ResponsiveCartoonCaption = styled(Caption).withConfig({
    displayName: 'ResponsiveCartoonCaption'
}) `
  &,
  ${CaptionText} {
    text-align: center;
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.consumption.lead.standard.description')};
    ${getTypographyStyles('typography.definitions.consumptionEditorial.description-embed')}
  }
`;
// Social Icons is not complete and as such has to rely on class names.
const ResponsiveCartoonIcons = styled(SocialIcons.Standard).withConfig({
    displayName: 'ResponsiveCartoonIcons'
}) `
  display: flex;
  justify-content: center;
  margin: 0 auto;

  ${SocialIconsList} {
    margin: 0;
  }

  ${SocialIconsListItem} {
    margin: 0;
    padding: 0;

    &:last-of-type {
      display: flex;
      align-items: center;

      &::before {
        display: inline-block;
        margin: 0 ${calculateSpacing(1)};
        border-left: solid 1px;
        ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.divider')};
        height: ${calculateSpacing(4)};
        content: '';
      }
    }
  }

  .social-icons__list-item--standard.thinner .icon {
    object-fit: contain;

    path {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.dark')};

      &.stroke-only {
        ${({ theme }) => getColorStyles(theme, 'stroke', 'colors.interactive.base.dark')};
      }
    }

    &:hover path {
      ${({ theme }) => getColorStyles(theme, 'fill', 'colors.interactive.base.black')};

      &.stroke-only {
        ${({ theme }) => getColorStyles(theme, 'stroke', 'colors.interactive.base.black')};
      }
    }
  }
`;
const ResponsiveCartoonWrapper = styled.div.withConfig({
    displayName: 'ResponsiveCartoonWrapper'
}) `
  display: grid;
  grid-gap: ${calculateSpacing(2)};
  grid-template-columns: 100%;
  ${({ theme, isCard }) => isCard &&
    css `
      padding: ${calculateSpacing(2)};
      ${getColorStyles(theme, 'background-color', 'colors.background.white')}
    `}

  ${({ isCartoonEmbed, shouldShowOpenGalleyButton }) => isCartoonEmbed &&
    css `
      grid-gap: 0;
      margin: auto;
      border-top: 1px solid
        ${getColorToken('colors.consumption.body.standard.divider')};
      border-bottom: 1px solid
        ${getColorToken('colors.consumption.body.standard.divider')};
      padding-top: ${calculateSpacing(4)};
      padding-bottom: ${calculateSpacing(4)};
      justify-items: center;

      ${ResponsiveCartoonImage} {
        cursor: zoom-in;
        max-width: ${calculateSpacing(70)};
      }

      ${ResponsiveCartoonCaption} {
        margin-top: 0;
        cursor: ${shouldShowOpenGalleyButton ? 'zoom-in' : 'auto'};
        padding-top: ${calculateSpacing(2)};
        padding-right: ${calculateSpacing(0.25)};
        max-width: ${calculateSpacing(70)};
      }

      ${ResponsiveCartoonCredit} {
        margin-bottom: ${calculateSpacing(3)};
        cursor: ${shouldShowOpenGalleyButton ? 'zoom-in' : 'auto'};
        padding-top: ${calculateSpacing(1)};
        max-width: ${calculateSpacing(70)};
      }
    `}
`;
const ResponsiveCartoonTagCloud = styled(TagCloud).withConfig({
    displayName: 'ResponsiveCartoonTagCloud'
}) ``;
const ResponsiveCartoonCTAWrapper = styled.div.withConfig({
    displayName: 'ResponsiveCartoonCTAWrapper'
}) `
  display: grid;
  position: absolute;
  grid-auto-flow: column;
  align-items: center;
  gap: ${calculateSpacing(2)};
`;
const ResponsiveCartoonCTA = styled.div.withConfig({
    displayName: 'ResponsiveCartoonCTA'
}) `
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: ${calculateSpacing(5)};

  button {
    border: 1px solid ${getColorToken('colors.interactive.base.light')};

    &:hover {
      border: 1px solid ${getColorToken('colors.interactive.base.light')};
      background: ${getColorToken('colors.interactive.base.light')};
    }
  }
`;
const ResponsiveCartoonIconButton = styled(Button).withConfig({
    displayName: 'ResponsiveCartoonIconButton'
}) `
  width: ${calculateSpacing(5)};
  height: ${calculateSpacing(5)};
  transition-timing-function: ease-in-out;

  &:active::before {
    background: none;
  }

  &:focus {
    border: 1px solid ${getColorToken('colors.interactive.base.light')};
  }

  &:hover {
    color: ${getColorToken('colors.interactive.base.brand-primary')};
  }

  .icon-cart path,
  circle {
    stroke: ${getColorToken('colors.interactive.base.dark')};
  }

  svg path {
    fill: ${getColorToken('colors.interactive.base.dark')};
  }

  svg {
    transform: scale(0.7);
  }

  ${ButtonIconWrapper} {
    display: flex;
  }
`;
const ResponsiveCartoonOpenGallery = styled(Button).withConfig({
    displayName: 'ResponsiveCartoonOpenGallery'
}) `
  display: grid;
  grid-auto-flow: column;
  padding: 0 ${calculateSpacing(2)};
  height: ${calculateSpacing(5)};
  gap: ${calculateSpacing(0.5)};

  &:active::before {
    background: none;
  }

  &:focus {
    border: 1px solid ${getColorToken('colors.interactive.base.light')};
  }

  &:hover {
    color: ${getColorToken('colors.interactive.base.brand-primary')};
  }

  ${ButtonIconWrapper} {
    display: flex;
    padding: 0;
  }
`;
const ResponsiveCartoonLinkButtonWrapper = styled.div.withConfig({
    displayName: 'ResponsiveCartoonLinkButtonWrapper'
}) `
  position: relative;
`;
const ResponsiveCartoonLinkAlertPopup = styled(Alert).withConfig({
    displayName: 'ResponsiveCartoonLinkAlertPopup'
}) `
  top: calc(100% + ${calculateSpacing(2)});
  left: calc(50% - ${calculateSpacing(5.5)});
  transition: opacity ease-in-out 200ms;
  opacity: ${({ isActive }) => (isActive ? 1 : 0)};
  background-color: ${getColorToken('colors.interactive.base.light')};
  padding: ${calculateSpacing(1)};
  width: ${calculateSpacing(11)};

  .alert-arrow {
    border-bottom-color: ${getColorToken('colors.interactive.base.light')};
  }

  .alert-message {
    margin-right: auto;
    width: 100%;
    min-width: unset;

    p {
      ${getTypographyStyles('typography.definitions.globalEditorial.context-tertiary')}
      margin-top: 0;
      margin-bottom: 0;
      text-align: center;
      white-space: nowrap;
      color: ${getColorToken('colors.interactive.base.dark')};
    }
  }
`;
module.exports = {
    ResponsiveCartoonWrapper,
    ResponsiveCartoonImage,
    ResponsiveCartoonCaption,
    ResponsiveCartoonCredit,
    ResponsiveCartoonIcons,
    ResponsiveCartoonTagCloud,
    ResponsiveCartoonCTA,
    ResponsiveCartoonCTAWrapper,
    ResponsiveCartoonIconButton,
    ResponsiveCartoonOpenGallery,
    ResponsiveCartoonLinkAlertPopup,
    ResponsiveCartoonLinkButtonWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 4577:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    copiedLinkAlertMessage: {
        id: 'ResponsiveCartoon.copiedLinkAlertMessage',
        defaultMessage: 'Link copied',
        description: 'Link copied alert message.'
    },
    copyLinkButtonMessage: {
        id: 'ResponsiveCartoon.copyLinkButtonMessage',
        defaultMessage: 'Copy link to cartoon',
        description: 'Copy link to cartoon message.'
    },
    downloadButtonMessage: {
        id: 'ResponsiveCartoon.downloadButtonMessage',
        defaultMessage: 'Download',
        description: 'Download message.'
    },
    cartButtonMessage: {
        id: 'ResponsiveCartoon.cartButtonMessage',
        defaultMessage: 'Shop',
        description: 'Shop message.'
    },
    openCartoonGalleryButtonIconMessage: {
        id: 'ResponsiveCartoon.openCartoonGalleryButtonIconMessage',
        defaultMessage: 'Open Gallery',
        description: 'Open gallery message.'
    },
    openCartoonGalleryButtonMessage: {
        id: 'ResponsiveCartoon.openCartoonGalleryButtonMessage',
        defaultMessage: 'Open cartoon gallery',
        description: 'Open cartoon gallery message.'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 36132:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// const React = require('react');
// const PropTypes = require('prop-types');
const { trackNavigationEvent } = __webpack_require__(14307);
const useAnalytics = ({ cartoonPosition, totalNumberOfCartoons, cartoonPlacement, currentSlideIndex, slides, galleryID }) => {
    /**
     *
     * @param {object} props - props to function
     * @param {string} props.type - type of the event
     * @param {string} [props.subject] - Where the item is placed
     * @param {Array} [props.items] - Array of items for the event
     * @param {string} [props.placement] - Where the recirculation content is placed
     * @param {string} [props.label] - Label of the content
     * @param {number} [props.total_index] - Total number of items
     * @param {string} [props.subject_id] - Id of the Gallery
     * @param {number} [props.index] - current index of the slide
     *
     * @returns {object} - Return object for snowplow
     */
    const generateSnowplowEventData = ({ type, subject, items = [], placement = '', label = '', total_index = slides.length || 0, subject_id = '', index = currentSlideIndex }) => {
        const data = {
            type,
            label,
            subject,
            items,
            index,
            placement,
            subject_id,
            subject_version: cartoonPlacement,
            total_index
        };
        // Removing empty properties
        Object.keys(data).forEach((key) => {
            if (data[key] == null || data[key] === '') {
                delete data[key];
            }
        });
        return data;
    };
    const triggerCartoonEvent = (interaction, cartoonData) => {
        // Snowplow event
        const subject = cartoonPlacement === 'inline' ? 'inline_cartoon' : 'cartoon_gallery';
        let snowplowData = {
            type: interaction === 'open cartoon gallery' ? 'open' : interaction,
            subject
        };
        if (cartoonPlacement === 'inline') {
            const contentUrl = cartoonData?.links.find((item) => item.network === 'canonical').url;
            const items = [
                {
                    content_title: cartoonData?.dangerousCaption || '',
                    content_id: cartoonData?.id,
                    content_type: 'cartoon',
                    content_url: contentUrl
                }
            ];
            snowplowData = {
                ...snowplowData,
                items,
                subject_id: cartoonData?.linkedGallery?.id,
                total_index: totalNumberOfCartoons || 0,
                index: cartoonPosition ? cartoonPosition - 1 : 0
            };
        }
        else {
            const currentSlide = slides[currentSlideIndex];
            const contentUrl = currentSlide?.links.find((item) => item.network === 'canonical').url;
            const items = [
                {
                    content_title: cartoonData?.dangerousCaption || '',
                    content_id: currentSlide?.id,
                    content_type: currentSlide?.contentType || 'cartoon',
                    content_url: contentUrl
                }
            ];
            snowplowData = {
                ...snowplowData,
                items,
                subject_id: galleryID
            };
        }
        const snowplowEventData = generateSnowplowEventData(snowplowData);
        trackNavigationEvent(snowplowEventData);
    };
    return {
        triggerCartoonEvent
    };
};
module.exports = useAnalytics;
//# sourceMappingURL=useAnalytics.js.map

/***/ }),

/***/ 33683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const ResponsiveCartoon = __webpack_require__(43917);
ResponsiveCartoon.Card = asVariation(ResponsiveCartoon, 'Card', {
    isCard: true
});
ResponsiveCartoon.WithNoSocialIcons = asVariation(ResponsiveCartoon, 'WithNoSocialIcons', {}, { showSocialIcons: false });
ResponsiveCartoon.SliderCartoon = asVariation(ResponsiveCartoon, 'SliderCartoon', { isCartoonEmbed: true }, {
    showSocialIcons: false,
    showCartActionButtons: true,
    showDownloadActionButton: false,
    showLinkActionButton: true
});
ResponsiveCartoon.InlineCartoon = asVariation(ResponsiveCartoon, 'InlineCartoon', { isCartoonEmbed: true }, {
    showCartActionButtons: true,
    showDownloadActionButton: false,
    showLinkActionButton: true,
    showOpenGalleyButton: true,
    showSocialIcons: false
});
module.exports = ResponsiveCartoon;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 90098:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseLink } = __webpack_require__(76955);
const { calculateSpacing, getLinkStyles, getTypographyStyles, getColorStyles } = __webpack_require__(26865);
const { GridItem } = __webpack_require__(40653);
const Grid = __webpack_require__(86659);
const Navigation = __webpack_require__(54790);
const NavigationDropdown = __webpack_require__(36062);
const { NavigationDropdownButton } = __webpack_require__(77906);
const SocialIcons = __webpack_require__(35676);
const { SocialIconExternalLink } = __webpack_require__(51000);
const drawerSecondarySpacing = calculateSpacing(2);
const drawerTertiarySpacing = calculateSpacing(5);
const drawerPrimarySpacing = calculateSpacing(4);
const commonNavigationStyles = css `
  .navigation__list-item {
    display: flex;
    position: relative;
    align-items: center;

    .navigation__link {
      display: block;
    }

    &:last-of-type {
      margin-bottom: 0;
    }
  }

  .navigation__list {
    display: flex;
    flex-direction: column;
    margin: 0;
  }

  ${({ contentAlign }) => {
    if (contentAlign === 'center') {
        return `
        .navigation__list,
        .navigation__list-item {
          align-items: center;
        }
      `;
    }
    return '';
}}
`;
const SecondaryMenuGridWrapper = styled(Grid.WithMargins).withConfig({
    displayName: 'SecondaryMenuGridWrapper'
}) `
  && {
    width: auto;
  }
  height: 100%;
  overflow-y: scroll;
  box-sizing: content-box;

  scrollbar-width: none;

  &::-webkit-scrollbar {
    width: 0;
    height: 0;
  }

  ${GridItem} {
    grid-column: 1 / -1;
  }

  ${({ isInverted, theme }) => isInverted &&
    getColorStyles(theme, 'background-color', 'colors.consumption.lead.inverted.background')};

  ${({ contentAlign, showUtilityLinksOnTop }) => {
    if (contentAlign === 'left') {
        return css `
        grid-template-columns: repeat(4, 1fr);
        max-width: none;
      `;
    }
    else if (contentAlign === 'center' && showUtilityLinksOnTop === true) {
        return css `
        @media (min-width: ${BREAKPOINTS.md}) {
          ${GridItem} {
            grid-column: 4 / span 6;
          }
        }
        @media (min-width: ${BREAKPOINTS.lg}) {
          padding-top: ${calculateSpacing(4)};
        }
      `;
    }
    else if (contentAlign === 'center') {
        return css `
        @media (min-width: ${BREAKPOINTS.md}) {
          ${GridItem} {
            grid-column: 5 / span 4;
          }
        }
      `;
    }
    return '';
}}
`;
const SecondaryMenuContent = styled.div.withConfig({
    displayName: 'SecondaryMenuContent'
}) `
  padding-bottom: ${calculateSpacing(4)};
`;
const SecondaryMenuNavigationPrimary = styled(Navigation.Vertical).withConfig({
    displayName: 'SecondaryMenuNavigationPrimary'
}) `
  margin-top: ${calculateSpacing(6)};
  margin-bottom: ${drawerPrimarySpacing};

  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-feature')};
    ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default')};

    &:focus,
    &:hover {
      ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-utility.nav-link.hover')};
    }
  }

  .navigation__list-item {
    margin-bottom: ${drawerPrimarySpacing};
  }

  ${commonNavigationStyles}

  ${({ hasExtraTopMargin }) => {
    if (hasExtraTopMargin) {
        return `
        @media (max-width: calc(${BREAKPOINTS.lg} - 1px)) {
          margin-top: ${calculateSpacing(12)};
        }
      `;
    }
    return '';
}}
`;
const SecondaryMenuNavigationUtility = styled(Navigation.Vertical).withConfig({
    displayName: 'SecondaryMenuNavigationUtility'
}) `
  margin-top: ${calculateSpacing(4)};
  margin-bottom: ${calculateSpacing(-2)};

  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-feature')};
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.brand-primary')};

    &:focus,
    &:hover {
      ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.brand-primary')};
    }
  }

  .navigation__list-item {
    margin-bottom: ${drawerPrimarySpacing};
  }
  ${commonNavigationStyles}
`;
const SecondaryMenuBottom = styled.div.withConfig({
    displayName: 'SecondaryMenuBottom'
}) `
  border-top: 1px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.consumption.lead.inverted.divider')};
  padding-top: ${drawerPrimarySpacing};
  padding-bottom: ${drawerPrimarySpacing};

  @media (min-width: ${BREAKPOINTS.md}) {
    padding-top: ${drawerPrimarySpacing};
  }

  .navigation__list {
    ${({ contentAlign }) => {
    if (contentAlign === 'center') {
        return `
        justify-content: center;
        align-items: center;
        `;
    }
    return '';
}}
  }

  &:empty {
    border: 0;
    padding: 0;
  }
`;
const SecondaryMenuSearch = styled.div.withConfig({
    displayName: 'SecondaryMenuSearch'
}) `
  display: flex;

  ${({ contentAlign }) => {
    if (contentAlign === 'center') {
        return `
        justify-content: center;
      `;
    }
    return '';
}}
`;
const SecondaryMenuSearchLink = styled(BaseLink).withConfig({
    displayName: 'SecondaryMenuSearchLink'
}) `
  &:hover {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.foundation.expanded-utility.nav-link.hover')};
  }

  display: inline-block;
  margin-bottom: ${drawerSecondarySpacing};

  ${({ hasInvertedSearchStyles, isInverted, theme }) => hasInvertedSearchStyles && isInverted
    ? getLinkStyles(theme, 'colors.consumption.lead.inverted.link', null, 'navigation')
    : getLinkStyles(theme, 'colors.foundation.expanded-menu.utility-link.default', null, 'navigation')};
`;
SecondaryMenuSearchLink.defaultProps = {
    colorStaticLinkToken: 'colors.foundation.expanded-utility.nav-link.default',
    typeToken: 'typography.definitions.foundation.link-secondary'
};
const SecondaryMenuAccount = styled.div.withConfig({
    displayName: 'SecondaryMenuAccount'
}) `
  line-height: 0.8em;

  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};

    ${({ isInverted, theme }) => isInverted
    ? getLinkStyles(theme, 'colors.consumption.lead.inverted.link', null, 'navigation')
    : getLinkStyles(theme, 'colors.foundation.expanded-menu.nav-link.default', null, 'navigation')};

    &:hover {
      ${({ theme, isInverted }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-utility.nav-link.hover')};
    }
  }

  .navigation__list-item {
    display: flex;
    align-items: center;
    margin-bottom: ${drawerSecondarySpacing};

    .navigation__link {
      display: block;
    }
  }

  .account-links__sign-out {
    margin-bottom: ${drawerSecondarySpacing};
    padding: 0;
  }

  ${({ contentAlign }) => {
    if (contentAlign === 'center') {
        return `
        text-align: center;
        .navigation__list-item {
          justify-content: center;
        }
      `;
    }
    return '';
}}
`;
const SecondaryMenuSignInLink = styled(BaseLink).withConfig({
    displayName: 'SecondaryMenuSignInLink'
}) `
  &:hover {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.foundation.expanded-utility.nav-link.hover')};
  }

  ${({ isInverted, theme }) => isInverted
    ? getLinkStyles(theme, 'colors.consumption.lead.inverted.link', null, 'navigation')
    : getLinkStyles(theme, 'colors.foundation.expanded-menu.utility-link.default', null, 'navigation')};

  display: inline-block;
  margin-bottom: ${drawerSecondarySpacing};
`;
SecondaryMenuSignInLink.defaultProps = {
    colorStaticLinkToken: 'colors.foundation.expanded-menu.nav-link.default',
    typeToken: 'typography.definitions.foundation.link-secondary'
};
const SecondaryMenuUtilityLinks = styled(Navigation.Vertical).withConfig({
    displayName: 'SecondaryMenuUtilityLinks'
}) `
  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};
    ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default')};

    &:focus,
    &:hover {
      ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default')};
    }
  }

  .navigation__list-item {
    margin-bottom: ${drawerSecondarySpacing};
  }

  ${commonNavigationStyles}

  margin-bottom: ${drawerSecondarySpacing};

  ${({ utilityLinksOneItem }) => utilityLinksOneItem && `margin-bottom: 0;`}
`;
const SecondaryMenuSecondaryLinks = styled(Navigation.Vertical).withConfig({
    displayName: 'SecondaryMenuSecondaryLinks'
}) `
  .navigation__link {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-secondary')};

    ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default')};

    &:focus,
    &:hover {
      ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.link')
    : getColorStyles(theme, 'color', 'colors.foundation.expanded-menu.nav-link.default', 'colors.foundation.expanded-utility.nav-link.default')};
    }
  }

  .navigation__list-item {
    margin-bottom: ${drawerSecondarySpacing};
  }

  ${commonNavigationStyles}
`;
const SecondaryMenuNavigationDropdownHeader = styled.div.withConfig({
    displayName: 'SecondaryMenuNavigationDropdownHeader'
}) `
  ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.interactive.base.white')
    : getColorStyles(theme, 'color', 'colors.interactive.base.black')};

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.label')};
  border-top: 2px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.consumption.lead.inverted.divider')};
  padding: ${calculateSpacing(4)} 0 ${calculateSpacing(1)};
`;
const SecondaryMenuNavigationDropdown = styled(NavigationDropdown).withConfig({
    displayName: 'SecondaryMenuNavigationDropdown'
}) `
  border: 1px solid;
  ${({ theme, isInverted }) => isInverted
    ? getColorStyles(theme, 'border-color', 'colors.consumption.lead.inverted.divider')
    : getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};

  ${NavigationDropdownButton} {
    ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'color', 'colors.interactive.base.light')
    : getColorStyles(theme, 'color', 'colors.interactive.base.black')};
  }

  ul {
    left: ${calculateSpacing(-0.16)};
    margin: 0;
    border: inherit;
    padding: 0;
  }

  li {
    border: inherit;

    &:hover {
      ${({ theme }) => getColorStyles(theme, 'background', 'colors.interactive.base.light')};
    }
  }
`;
const SecondaryMenuSocialIcons = styled(SocialIcons.Standard).withConfig({
    displayName: 'SecondaryMenuSocialIcons'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  ${({ showBorderTop, theme }) => showBorderTop
    ? `border-top: 2px solid;
        ${getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')}`
    : ''};
  padding-top: ${drawerPrimarySpacing};

  @media (min-width: ${BREAKPOINTS.md}) {
    padding-top: ${drawerTertiarySpacing};
  }

  ${SocialIconExternalLink} {
    @media (min-width: ${BREAKPOINTS.md}) {
      width: ${calculateSpacing(5)};
      height: ${calculateSpacing(5)};
    }

    .icon {
      path {
        ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'fill', 'colors.interactive.base.white')
    : getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
      }
    }

    &:focus,
    &:hover {
      .icon {
        path {
          ${({ isInverted, theme }) => isInverted
    ? getColorStyles(theme, 'fill', 'colors.interactive.base.white')
    : getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
        }
      }
    }
  }
`;
module.exports = {
    SecondaryMenuGridWrapper,
    SecondaryMenuContent,
    SecondaryMenuNavigationPrimary,
    SecondaryMenuNavigationUtility,
    SecondaryMenuBottom,
    SecondaryMenuSearch,
    SecondaryMenuSearchLink,
    SecondaryMenuAccount,
    SecondaryMenuSignInLink,
    SecondaryMenuUtilityLinks,
    SecondaryMenuSecondaryLinks,
    SecondaryMenuNavigationDropdown,
    SecondaryMenuNavigationDropdownHeader,
    SecondaryMenuSocialIcons
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 24277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { asConfiguredComponent } = __webpack_require__(12892);
const ResponsiveAsset = __webpack_require__(73275);
const { TrackComponentChannel } = __webpack_require__(78788);
const { SectionTitleRoot, SectionTitleDek, SectionTitleDivider, SectionTitleHed, SectionTitleSubHed, SectionTitleImageWrapper, SectionTitleLinkWrapper, SectionTitleLink, SectionTitleLinkHTML } = __webpack_require__(33500);
function getStackAndCenterItems(dangerousDek, linkUrl, textAlign) {
    // Note: We still want to render the links even if an empty object comes
    // through. I'm not ready to argue with the teams yet to change this - Dan P
    const hasLinkUrl = linkUrl !== undefined && linkUrl !== null;
    const stackAndCenterItems = !!dangerousDek === true && hasLinkUrl && textAlign === 'center';
    return stackAndCenterItems;
}
/**
 * SectionTitle component
 *
 * @param {object} props - React Props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dangerousDek] -  A string (possibly HTML) to use as the subTitle
 * @param {string} props.dangerousHed - A string (possibly HTML) to use as the title
 * @param {string} props.contentSize - A string to define the content size
 * @param {string} props.dangerousSubHed - A string (possibly HTML) to use as the sub title
 * @param {string} [props.fullPageTheme] - Optional prop to apply an inverted (dark) theme to the entire page
 * @param {boolean} [props.hasDividerAbove] - Optional. Display a top border
 * @param {boolean} [props.hasContributorIcon] - Display image as a contributor
 * @param {boolean} [props.hasLinkInHed] - Optional. Display link url from Hed
 * @param {boolean} [props.variations.hasDivider] - Optional. Display a divider between hed and dek if the dek is present
 * @param {boolean} [props.hasDividerAboveDek] - Optional. Display a border between hed and dek if the dek is present
 * @param {boolean} [props.hasDividerBelow] - Optional. Display a bottom border
 * @param {boolean} [props.hasLineAboveBelowHead] - Optional. Enable or disable LineAboveBelow class only for HedTag
 * @param {boolean} [props.hasHedBackground] - Optional. hed with background
 * @param {string} [props.hasMinimalMargins] - Amount of spacing between title and dek
 * @param {boolean} [props.hasNoDividerWidth] - Optional to make divider width 0px
 * @param {boolean} [props.hasNoMargins] - Optional to make margin 0px
 * @param {boolean} [props.hasOrnament] - Adds modifier class for ornament above HedTag
 * @param {string} [props.hasReducedTopAndBottomPadding] - Optional. Top and Bottom Padding
 * @param {boolean} [props.hasSpacingBelowTitle] - optional spacing either below or above and below title
 * @param {boolean} [props.hasTopBottomSpacing] - Optional. Adds a padding-top and padding-bottom in SectionTitleRoot
 * @param {boolean} [props.hasTopPadding] - Optional. Adds an extra padding between section hed and border top.
 * @param {boolean} [props.hasTopSpacing] - Optional. Adds a padding-top when there is no border-top
 * @param {string} [props.hedTag] - Option to override the default header html tag when nested within a higher level header
 * @param {object} [props.image] - Object containing image sources for a ResponsiveAsset
 * @param {string} [props.imagePosition] - Positions image to left or right of title
 * @param {string} [props.imageSize] - Adjusts image size to selected option
 * @param {boolean} [props.isBorderContextSignature] - optional. assign ContextSignature for ornamental border
 * @param {boolean} [props.isFeatured] - optional, add typography style to the hed/dek
 * @param {boolean} [props.isFullBleed] - Width extends to full-bleed
 * @param {object} [props.link] - Optional object containing data about a landing page related to this section
 * @param {string} [props.link.label] - String with the text value for the link pointing to the landing page
 * @param {string} [props.link.url] - String with the url link for the landing page
 * @param {string} [props.link.html] - raw HTML to render for landing page link
 * @param {string} [props.marginBottom] - Optional margin bottom spacing: 'full' or 'reduced'
 * @param {string} [props.textAlign] - Aligns text left or center
 * @param {string} [props.hasSectionTitleDekColor] - Optional. dek color
 * @param {string} [props.shouldUseAlternateHedColor] - Optional. hed color
 * @param {string} [props.shouldUseAlternateStyle] - Optional shouldUseAlternateStyle: false to set brand specific styles
 * @param {string} [props.variations.shouldUseCustomColorToken] - Optional shouldUseCustomColorToken: true to set divider style
 * @param {boolean} [props.shouldUseDiscoveryTypeToken] - can be used for applying brand specific typography
 * @param {object} [props.variations] - Optional. Variation properties used in rendering the component.
 * @param {boolean} [props.variations.iconPosition] - This will be placed icon above the section title hed or below the section title dek for the variations isIconAbove or isIconBelow respectively
 * @param {boolean} [props.variations.dividerStyle] - It's value will be soft for the variation SoftDivider and render above Section title hed without icon
 * @returns {ReactElement} <div>
 */
const SectionTitle = ({ className, contentSize, dangerousDek, dangerousHed, dangerousSubHed, fullPageTheme = 'standard', hasContributorIcon = false, hasDividerAbove = false, hasLinkInHed = false, hasDividerAboveDek = false, hasDividerBelow = false, hasHedBackground = false, hasMinimalMargins = false, hasNoDividerWidth = false, hasNoMargins = false, hasOrnament = false, hasReducedTopAndBottomPadding = false, hasSpacingBelowTitle = false, hasTopBottomSpacing = false, hasTopPadding = false, hasTopSpacing = false, hedTag = 'h2', image, imagePosition = 'left', imageSize, isBorderContextSignature = false, isFeatured, isFullBleed = false, link, marginBottom, textAlign = 'left', hasSectionTitleDekColor, shouldUseAlternateHedColor = false, shouldUseAlternateStyle = false, shouldUseDiscoveryTypeToken = false, showRichTextInDek, variations: { iconPosition, dividerStyle, hasDivider, shouldUseCustomColorToken } = {} }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SectionTitle'
        });
    }, []);
    if (!(dangerousHed || image)) {
        return null;
    }
    let newDangerousHed = dangerousHed;
    let newLink = {};
    if (hasLinkInHed && dangerousHed.indexOf('<a ', 2) > 0) {
        const hedUrl = dangerousHed.split('<a ');
        newDangerousHed = hedUrl[0];
        newLink = hedUrl[1] ? { html: '<a '.concat(hedUrl[1]) } : {};
    }
    const { url: linkUrl, label: linkLabel, html: linkHTML } = !hasLinkInHed ? link || {} : newLink;
    const stackAndCenterItems = getStackAndCenterItems(dangerousDek, linkUrl, textAlign);
    const SectionTitleImage = () => {
        if (!image)
            return null;
        return (React.createElement(SectionTitleImageWrapper, { imagePosition: imagePosition, iconPosition: iconPosition, imageSize: imageSize, hasContributorIcon: hasContributorIcon },
            React.createElement(ResponsiveAsset, { ...image, imageAttributes: { 'aria-hidden': true } })));
    };
    return (React.createElement(SectionTitleRoot, { className: className, "data-testid": "SectionTitle", hasDek: !!dangerousDek, contentSize: contentSize, hasDividerAbove: hasDividerAbove, hasDividerBelow: hasDividerBelow, hasHedBackground: hasHedBackground, hasMinimalMargins: hasMinimalMargins, hasNoDividerWidth: hasNoDividerWidth, hasNoMargins: hasNoMargins, hasReducedTopAndBottomPadding: hasReducedTopAndBottomPadding, hasOrnament: hasOrnament, hasSubHed: !!dangerousSubHed, hasSpacingBelowTitle: hasSpacingBelowTitle, hasTopBottomSpacing: hasTopBottomSpacing, hasTopSpacing: hasTopSpacing, imagePosition: imagePosition, isFullBleed: isFullBleed, marginBottom: marginBottom, stackAndCenterItems: stackAndCenterItems, shouldUseAlternateStyle: shouldUseAlternateStyle, shouldUseCustomColorToken: shouldUseCustomColorToken, iconPosition: iconPosition, dividerStyle: dividerStyle },
        iconPosition === 'above' && React.createElement(SectionTitleImage, null),
        React.createElement(SectionTitleHed, { as: hedTag, dangerouslySetInnerHTML: { __html: newDangerousHed }, fullPageTheme: fullPageTheme, hasOrnament: hasOrnament, isFullBleed: isFullBleed, textAlign: textAlign, hasHedBackground: hasHedBackground, isBorderContextSignature: isBorderContextSignature, shouldUseAlternateHedColor: shouldUseAlternateHedColor, shouldUseAlternateStyle: shouldUseAlternateStyle, iconPosition: iconPosition, hasTopPadding: hasTopPadding, isFeatured: isFeatured }),
        hasDivider && (React.createElement(SectionTitleDivider, { shouldUseCustomColorToken: shouldUseCustomColorToken, hasDek: !!dangerousDek })),
        dangerousSubHed && (React.createElement(SectionTitleSubHed, { as: hedTag, "data-testid": "SectionTitleSubHed", dangerouslySetInnerHTML: { __html: dangerousSubHed } })),
        dangerousDek && (React.createElement(SectionTitleDek, { dangerouslySetInnerHTML: { __html: dangerousDek }, "data-testid": "SectionTitleDek", hasDividerAboveDek: hasDividerAboveDek, textAlign: textAlign, hasSectionTitleDekColor: hasSectionTitleDekColor, shouldUseAlternateStyle: shouldUseAlternateStyle, iconPosition: iconPosition, isFeatured: isFeatured, shouldUseDiscoveryTypeToken: shouldUseDiscoveryTypeToken, showRichTextInDek: showRichTextInDek })),
        (iconPosition === 'below' ||
            (iconPosition !== 'above' && imagePosition)) && React.createElement(SectionTitleImage, null),
        (linkUrl || linkHTML) && (React.createElement(SectionTitleLinkWrapper, { "data-testid": "SectionTitleLink", isFullBleed: isFullBleed, hasOrnament: hasOrnament, stackAndCenterItems: stackAndCenterItems, hasLinkInHed: hasLinkInHed }, linkHTML ? (React.createElement(SectionTitleLinkHTML, { dangerouslySetInnerHTML: { __html: linkHTML } })) : (React.createElement(SectionTitleLink, { href: linkUrl }, linkLabel))))));
};
SectionTitle.propTypes = {
    className: PropTypes.string,
    contentSize: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string,
    dangerousSubHed: PropTypes.string,
    fullPageTheme: PropTypes.oneOf(['inverted', 'standard']),
    hasContributorIcon: PropTypes.bool,
    hasDividerAbove: PropTypes.bool,
    hasDividerAboveDek: PropTypes.bool,
    hasDividerBelow: PropTypes.bool,
    hasHedBackground: PropTypes.bool,
    hasLinkInHed: PropTypes.bool,
    hasMinimalMargins: PropTypes.bool,
    hasNoDividerWidth: PropTypes.bool,
    hasNoMargins: PropTypes.bool,
    hasOrnament: PropTypes.bool,
    hasReducedTopAndBottomPadding: PropTypes.bool,
    hasSectionTitleDekColor: PropTypes.bool,
    hasSpacingBelowTitle: PropTypes.bool,
    hasTopBottomSpacing: PropTypes.bool,
    hasTopPadding: PropTypes.bool,
    hasTopSpacing: PropTypes.bool,
    hedTag: PropTypes.oneOf(['div', 'h1', 'h2', 'header']),
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    imagePosition: PropTypes.oneOf(['left', 'right']),
    imageSize: PropTypes.oneOf(['Default', 'Icon', 'Banner']),
    isBorderContextSignature: PropTypes.bool,
    isFeatured: PropTypes.bool,
    isFullBleed: PropTypes.bool,
    link: PropTypes.shape({
        label: PropTypes.string,
        url: PropTypes.string,
        html: PropTypes.string
    }),
    marginBottom: PropTypes.oneOf(['full', 'reduced']),
    shouldUseAlternateHedColor: PropTypes.bool,
    shouldUseAlternateStyle: PropTypes.bool,
    shouldUseDiscoveryTypeToken: PropTypes.bool,
    showRichTextInDek: PropTypes.bool,
    textAlign: PropTypes.oneOf(['center', 'left']),
    variations: PropTypes.shape({
        iconPosition: PropTypes.oneOf(['above', 'below']),
        dividerStyle: PropTypes.string,
        hasDivider: PropTypes.bool,
        shouldUseCustomColorToken: PropTypes.bool
    })
};
SectionTitle.displayName = 'SectionTitle';
module.exports = asConfiguredComponent(SectionTitle, 'SectionTitle');
//# sourceMappingURL=SectionTitle.js.map

/***/ }),

/***/ 35864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(81340);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 33500:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css, default: styled } = __webpack_require__(92168);
const { BaseLink, BaseText } = __webpack_require__(76955);
const { calculateSpacing, getColorStyles, getDecoration, getLinkStyles, getTypographyStyles, getColorToken } = __webpack_require__(26865);
const { cssVariablesGrid } = __webpack_require__(1123);
const ResponsiveAsset = __webpack_require__(73275);
const { ResponsiveImageContainer } = __webpack_require__(7228);
const { BREAKPOINTS } = __webpack_require__(96472);
const getLayouts = (imagePosition, hasDek, hasSubHed, stackAndCenterItems) => {
    let layout = '';
    if (stackAndCenterItems) {
        // stack hed, link, and dek when all are present and centered
        if (imagePosition === 'left') {
            layout = 'stackAndCenterItems_imagePositionLeft';
        }
        else {
            layout = 'stackAndCenterItems_imagePositionRight';
        }
    }
    else if (imagePosition === 'left' &&
        hasDek === true &&
        hasSubHed === false) {
        // image on left; link on right; dek below
        layout = 'imagePositionLeft_hasDek';
    }
    else if (imagePosition === 'right' &&
        hasDek === true &&
        hasSubHed === false) {
        // image on right; link in center; dek below
        layout = 'imagePositionRight_hasDek';
    }
    else if (imagePosition === 'left' &&
        hasDek === false &&
        hasSubHed === false) {
        // image on left; link on right; text vertically centered; no dek
        layout = 'imagePositionLeft_hasDekFalse';
    }
    else if (imagePosition === 'left' &&
        hasDek === false &&
        hasSubHed === true) {
        // image on left; link on right; text and sub vertically centered; no dek
        layout = 'imagePositionLeft_hasSubHed';
    }
    else {
        // image on right; link in center; text vertically centered; no dek
        layout = 'imagePositionRight_hasDekFalse';
    }
    return layout;
};
const gridLayouts = (imagePosition, hasDek, hasSubHed, stackAndCenterItems, minumumContentSize = '5em') => {
    const layout = getLayouts(imagePosition, hasDek, hasSubHed, stackAndCenterItems);
    switch (layout) {
        case 'stackAndCenterItems_imagePositionLeft':
            return `
        grid-template-areas: 'image hed' 'image link' 'image disclaimer' 'image dek';
        grid-template-columns: auto minmax(${minumumContentSize},1fr);
      `;
        case 'stackAndCenterItems_imagePositionRight':
            return `
        grid-template-areas: 'hed image' 'link image' 'disclaimer image' 'dek image';
        grid-template-columns: minmax(${minumumContentSize},1fr) auto;
      `;
        case 'imagePositionLeft_hasDek':
            return `
        grid-template-areas: 'image hed link' 'image disclaimer disclaimer' 'image dek dek';
        grid-template-columns: auto minmax(${minumumContentSize},1fr) auto;
      `;
        case 'imagePositionRight_hasDek':
            return `
        grid-template-areas: 'hed link image' 'disclaimer disclaimer image' 'dek dek image';
        grid-template-columns: minmax(${minumumContentSize},1fr) auto;
      `;
        case 'imagePositionLeft_hasDekFalse':
            return `
        grid-template-areas: 'image hed link' 'image disclaimer disclaimer';
        grid-template-columns: auto minmax(${minumumContentSize},1fr) auto;
      `;
        case 'imagePositionLeft_hasSubHed':
            return `
            grid-template-areas: 'image hed subHed link' 'image disclaimer disclaimer disclaimer';
            grid-template-columns: auto auto minmax(${minumumContentSize},1fr) auto  auto;
          `;
        default:
            return `
        grid-template-areas: 'hed link image' 'disclaimer disclaimer disclaimer';
        grid-template-columns: minmax(${minumumContentSize},1fr) auto auto;
      `;
    }
};
const SectionTitleRoot = styled.div.withConfig({
    displayName: 'SectionTitleRoot'
}) `
  --divider-width: ${({ theme, hasNoDividerWidth }) => hasNoDividerWidth ? 0 : getDecoration(theme, 'dividerWidth')};
  --section-ornament-top: ${({ theme }) => getDecoration(theme, 'sectionOrnamentWidth')};
  --section-title-margin: ${({ hasMinimalMargins }) => hasMinimalMargins ? calculateSpacing(1) : calculateSpacing(2)};
  grid-gap: 0;
  align-items: center;

  .disclaimer {
    grid-area: disclaimer;
    margin-top: var(--section-title-margin);
    padding-top: var(--section-title-margin);
    padding-bottom: unset;
  }

  .disclaimer p {
    ${getTypographyStyles('typography.definitions.globalEditorial.context-secondary')};
  }

  ${({ hasSpacingBelowTitle, hasDividerAbove, hasHedBackground, hasOrnament, hasTopSpacing, theme, iconPosition, dividerStyle }) => hasDividerAbove
    ? css `
          border-top: var(--divider-width) solid;

          ${hasHedBackground
        ? getColorStyles(theme, 'border-color', 'colors.consumption.lead.standard.context-signature')
        : getColorStyles(theme, 'border-top-color', 'colors.discovery.body.white.divider')};
          ${hasOrnament ? `` : `padding-top: ${calculateSpacing(2)};`};
          ${hasSpacingBelowTitle && `padding-bottom: ${calculateSpacing(2)};`};
          ${hasHedBackground ? `padding-top: ${calculateSpacing(0)}` : ``}
          ${(iconPosition === 'above' ||
        iconPosition === 'below' ||
        dividerStyle === 'soft') &&
        `margin: ${calculateSpacing(5)} ${calculateSpacing(5)} 0;   
              `};

          ${(iconPosition === 'above' || dividerStyle === 'soft') &&
        !hasHedBackground &&
        getColorStyles(theme, 'border-top-color', 'colors.discovery.body.white.border')};
        `
    : css `
          ${hasTopSpacing ? `padding-top: ${calculateSpacing(2)};` : ``};
        `};

  ${({ hasOrnament, iconPosition }) => {
    if (iconPosition) {
        return ` display: block;
          ${hasOrnament ? `` : `padding-top: ${calculateSpacing(0)};`};`;
    }
    return `  display: grid;    `;
}};

  ${({ hasDividerBelow, hasReducedTopAndBottomPadding }) => hasDividerBelow
    ? css `
          border-bottom: var(--divider-width) solid;
          ${({ theme }) => getColorStyles(theme, 'border-bottom-color', `colors.discovery.body.white.border`)};
          ${hasReducedTopAndBottomPadding
        ? `padding-bottom: ${calculateSpacing(1)}`
        : `
                padding-bottom: ${calculateSpacing(2.5)};
                @media (max-width: ${BREAKPOINTS.md}) {
                  padding-bottom: ${calculateSpacing(2)};
                }
              `};
        `
    : ``};

  ${({ imagePosition, hasDek, hasSubHed, stackAndCenterItems, contentSize }) => {
    return gridLayouts(imagePosition, hasDek, hasSubHed, stackAndCenterItems, contentSize);
}};

  ${({ isFullBleed }) => {
    if (isFullBleed) {
        return `
        position: relative;

        &::before,
        &::after {
          content: '';
          height: var(--divider-width);
          left: calc(50% - 50vw);
          position: absolute;
          right: calc(50% - 50vw);
          width: 100vw;
        }

        &::before {
          border-top: inherit;
          top: calc(var(--divider-width) * -1);
        }

        &::after {
          border-bottom: inherit;
          bottom: calc(var(--divider-width) * -1);
        }
      `;
    }
    return ``;
}};

  ${({ hasTopBottomSpacing }) => hasTopBottomSpacing && `padding: ${calculateSpacing(4)} 0; `};

  @media (max-width: ${BREAKPOINTS.md}) {
    ${({ hasHedBackground }) => hasHedBackground
    ? css `
            display: block;
          `
    : ``}
  }
  ${({ shouldUseAlternateStyle }) => shouldUseAlternateStyle &&
    `
    border-top: 3px solid;
    `};
  ${({ marginBottom }) => {
    switch (marginBottom) {
        case 'full':
            return `
          margin-bottom: ${calculateSpacing(4)};
        `;
        case 'reduced':
            return `
          margin-bottom: ${calculateSpacing(3)};
        `;
        default:
            return null;
    }
}}

  ${({ hasReducedTopAndBottomPadding, hasHedBackground }) => hasReducedTopAndBottomPadding
    ? css `
          padding-bottom: ${calculateSpacing(1)};
          ${hasHedBackground
        ? `padding-top: ${calculateSpacing(0)}`
        : `padding-top: ${calculateSpacing(1)};`}
        `
    : ``}

  ${({ hasNoMargins }) => hasNoMargins &&
    css `
      margin: 0;
    `}
`;
const SectionTitleHed = styled(BaseText).withConfig({
    displayName: 'SectionTitleHed'
}) `
  grid-area: ${({ shouldUseAlternateStyle }) => (shouldUseAlternateStyle && 'unset') || 'hed'};

  ${({ hasTopPadding }) => hasTopPadding &&
    `padding-top: ${calculateSpacing(1.5)};
    `};

  a {
    cursor: pointer;
    text-decoration: none;
  }
  ${({ isFeatured, theme }) => isFeatured &&
    ` 
    ${getTypographyStyles(theme, 'typography.definitions.discovery.page-hed-section')};
  `};
  ${({ shouldUseAlternateStyle, theme }) => shouldUseAlternateStyle &&
    ` 
    ${getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-primary')};
    ${getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
  `};

  ${({ hasHedBackground, isFullBleed }) => {
    if (!isFullBleed && hasHedBackground) {
        return getTypographyStyles('typography.definitions.discovery.subhed-section-tertiary');
    }
    return '';
}};

  ${({ textAlign }) => textAlign === 'left' ? `justify-self: start;` : `justify-self: center;`};

  ${({ iconPosition }) => iconPosition &&
    `padding-top: ${calculateSpacing(2)};
      text-align: center;`};

  ${({ hasHedBackground, theme }) => hasHedBackground
    ? css `
          ${getColorStyles(theme, 'background-color', 'colors.consumption.lead.standard.context-signature')};
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-texture')};
          padding: ${calculateSpacing(0.5)} ${calculateSpacing(1.5)};
        `
    : ``}

  ${({ hasOrnament, isBorderContextSignature, theme }) => {
    if (hasOrnament && !isBorderContextSignature) {
        return `
              align-self: start;
              padding-top: ${calculateSpacing(1)};
              border-top: var(--section-ornament-top) solid;
              ${getColorStyles(theme, 'border-color', 'colors.discovery.body.white.divider')};
            `;
    }
    else if (hasOrnament && isBorderContextSignature) {
        return `
              align-self: start;
              padding-top: ${calculateSpacing(1)};
              border-top: var(--section-ornament-top) solid;
              ${getColorStyles(theme, 'border-color', 'colors.discovery.body.white.context-signature')};
              `;
    }
    return '';
}};

  ${({ fullPageTheme, theme }) => fullPageTheme === 'inverted'
    ? `${getColorStyles(theme, 'color', 'colors.discovery.body.black.heading')}`
    : ''};
  ${({ shouldUseAlternateHedColor, theme }) => shouldUseAlternateHedColor &&
    `${getColorStyles(theme, 'color', 'colors.discovery.lead.primary.hed')}`}

  .verso-bundle-cne-embed & {
    ${cssVariablesGrid()}
    margin: 0 calc(1* var(--grid-margin));
  }
`;
SectionTitleHed.defaultProps = {
    as: 'h2',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.subhed-section-primary'
};
const SectionTitleSubHed = styled(BaseText).withConfig({
    displayName: 'SectionTitleSubHed'
}) `
  grid-area: subHed;
  padding-left: ${calculateSpacing(3)};

  @media (max-width: ${BREAKPOINTS.md}) {
    display: none;
  }
`;
SectionTitleSubHed.defaultProps = {
    as: 'h2',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.subhed-section-tertiary'
};
const SectionTitleDivider = styled.div.withConfig({
    displayName: 'SectionTitleDivider'
}) `
  grid-column: 1 / -1;
  margin-top: ${calculateSpacing(2)};
  justify-self: center;
  border-bottom-width: ${calculateSpacing(0.25, 'px')};
  border-bottom-style: solid;
  ${({ shouldUseCustomColorToken, theme }) => shouldUseCustomColorToken
    ? `border-bottom-color: ${getColorToken(theme, 'colors.discovery.body.white.context-signature')};`
    : `border-bottom-color: ${getColorToken(theme, 'colors.consumption.lead.standard.accent')};`};
  width: ${calculateSpacing(12.5, 'px')};
  ${({ hasDek }) => !hasDek && ` margin-bottom: 40px;`};
`;
const SectionTitleDek = styled(BaseText).withConfig({
    displayName: 'SectionTitleDek'
}) `
  grid-area: dek;
  ${({ shouldUseAlternateStyle }) => shouldUseAlternateStyle ? `grid-column: 1 / span 10` : ''};
  margin-top: var(--section-title-margin);
  padding-top: var(--section-title-margin);

  ${({ isFeatured, iconPosition, theme }) => isFeatured || iconPosition
    ? `${getTypographyStyles(theme, `typography.definitions.discovery.description-page`)};`
    : ``};
  ${({ iconPosition, theme }) => iconPosition &&
    ` 
  ${getColorStyles(theme, 'color', 'colors.discovery.body.white.description')};
    `};

  ${({ iconPosition }) => iconPosition &&
    `
    margin-top: 0;
    padding-top: ${calculateSpacing(2)};
    text-align: center;`};

  ${({ hasSectionTitleDekColor, theme }) => hasSectionTitleDekColor &&
    `${getColorStyles(theme, 'color', 'colors.discovery.body.white.description')};
    ${getTypographyStyles(theme, 'typography.definitions.discovery.description-core')};
    `}
  ${({ shouldUseAlternateStyle, theme }) => shouldUseAlternateStyle &&
    `${getTypographyStyles(theme, 'typography.definitions.discovery.description-feature')};
      margin-top: 0;
      padding-top: 0;
      margin-bottom: 2rem;
    `};
  ${({ hasDividerAboveDek }) => hasDividerAboveDek
    ? css `
          border-top: var(--divider-width) solid;
          ${({ theme }) => getColorStyles(theme, 'border-color', `colors.discovery.body.white.divider`)};
        `
    : ``};
  ${({ shouldUseDiscoveryTypeToken, theme }) => shouldUseDiscoveryTypeToken &&
    `${getTypographyStyles(theme, `typography.definitions.discovery.description-page`)};`};

  ${({ showRichTextInDek }) => showRichTextInDek &&
    `
      ol, ul {
        list-style-position: inside;
        padding-left: 0
      }
      a {
        text-decoration: underline;
      }
  `}
`;
SectionTitleDek.defaultProps = {
    as: 'p',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.description-page'
};
const SectionTitleImageWrapper = styled.div.withConfig({
    displayName: 'SectionTitleImageWrapper'
}) `
  grid-area: image;

  ${({ hasContributorIcon, theme }) => hasContributorIcon
    ? css `
          ${ResponsiveImageContainer} {
            border-radius: 50%;
            background: ${getColorToken(theme, 'colors.discovery.lead.secondary.background')};
          }
        `
    : ``};

  ${({ imageSize }) => imageSize
    ? `
    img {
      max-width: ${imageSize === 'Icon' ? '48px' : '300px'};
      height: auto;
   }`
    : ``};

  ${({ imagePosition }) => imagePosition === 'left'
    ? `padding-right: ${calculateSpacing(4)};`
    : `padding-left: ${calculateSpacing(4)};`};

  ${({ iconPosition }) => {
    if (iconPosition === 'above') {
        return `
        text-align: center;
    padding-top: ${calculateSpacing(2)};
    padding-right: ${calculateSpacing(0)};
        `;
    }
    return `
        text-align: center;
    padding-top: ${calculateSpacing(2)};
    padding-right: ${calculateSpacing(0)};
       `;
}};

  ${ResponsiveAsset} img {
    vertical-align: middle;
  }
`;
const SectionTitleLinkWrapper = styled.div.withConfig({
    displayName: 'SectionTitleLinkWrapper'
}) `
  grid-area: link;

  ${({ hasLinkInHed }) => hasLinkInHed
    ? `
position:absolute;
margin-left:calc(100% - 20vw);
@media (max-width: ${BREAKPOINTS.md}) {
grid-area: none;
grid-column: 1/-1;
text-align: center;
margin-top: var(--section-title-margin);
position:relative;
margin-left:0;
}
`
    : `
padding-left: ${calculateSpacing(2)};`};

  ${({ hasOrnament, stackAndCenterItems }) => hasOrnament && stackAndCenterItems === false
    ? `margin-top: calc(var(--section-ornament-top) + ${calculateSpacing(1)})`
    : ``};

  ${({ stackAndCenterItems }) => stackAndCenterItems ? `justify-self: center;` : ``};

  ${({ isFullBleed }) => !isFullBleed &&
    getTypographyStyles('typography.definitions.discovery.subhed-section-secondary')}
`;
const SectionTitleLink = styled(BaseLink).withConfig({
    displayName: 'SectionTitleLink'
}) ``;
SectionTitleLink.defaultProps = {
    colorSecondaryLinkToken: 'colors.foundation.collapsed-menu.utility-link.hover',
    colorStaticLinkToken: 'colors.foundation.collapsed-menu.utility-link.default',
    colorToken: 'colors.foundation.collapsed-menu.utility-link.default',
    hasUnderline: false,
    linkStyle: 'navigation',
    typeIdentity: 'typography.definitions.foundation.link-primary'
};
const SectionTitleLinkHTML = styled(BaseText).withConfig({
    displayName: 'SectionTitleLinkHTML'
}) `
  a {
    cursor: pointer;
    text-decoration: none;
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.foundation.collapsed-menu.utility-link.default')};
    transition-property: color, background, text-shadow;
    transition-timing-function: ease-in-out;
    transition-duration: 5s;

    ${({ theme }) => getLinkStyles(theme, 'colors.foundation.collapsed-menu.utility-link.default', 'colors.foundation.collapsed-menu.utility-link.hover', 'navigation')}
  }
`;
SectionTitleLinkHTML.defaultProps = {
    as: 'span',
    colorToken: 'colors.foundation.collapsed-menu.utility-link.default',
    typeIdentity: 'typography.definitions.foundation.link-primary'
};
module.exports = {
    SectionTitleRoot,
    SectionTitleDek,
    SectionTitleDivider,
    SectionTitleHed,
    SectionTitleSubHed,
    SectionTitleImageWrapper,
    SectionTitleLinkWrapper,
    SectionTitleLink,
    SectionTitleLinkHTML
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 81340:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const SectionTitle = __webpack_require__(24277);
SectionTitle.TextCenter = asVariation(SectionTitle, 'TextCenter', {}, {
    textAlign: 'center'
});
SectionTitle.TextCenterPaddingTop = asVariation(SectionTitle, 'TextCenter', {}, {
    textAlign: 'center',
    hasTopPadding: true
});
SectionTitle.TextLeft = asVariation(SectionTitle, 'TextLeft', {}, {
    textAlign: 'left'
});
SectionTitle.LogoLeftTextLeft = asVariation(SectionTitle, 'LogoLeftTextLeft', {}, {
    imagePosition: 'left',
    textAlign: 'left'
});
SectionTitle.LineAboveLineBelowTextCenter = asVariation(SectionTitle, 'LineAboveLineBelowTextCenter', {}, {
    hasDividerAbove: true,
    hasDividerBelow: true,
    textAlign: 'center'
});
SectionTitle.LineBelowTextCenter = asVariation(SectionTitle, 'LineBelowTextCenter', {}, {
    hasDividerBelow: true,
    textAlign: 'center'
});
SectionTitle.LineAboveLineBelowTextLeft = asVariation(SectionTitle, 'LineAboveLineBelowTextLeft', {}, {
    hasDividerAbove: true,
    hasDividerBelow: true,
    textAlign: 'left'
});
SectionTitle.FullBleedLineAboveOrnamentAboveTextLeft = asVariation(SectionTitle, 'FullBleedLineAboveOrnamentAboveTextLeft', {}, {
    hasDividerAbove: true,
    hasOrnament: true,
    isFullBleed: true,
    textAlign: 'left'
});
SectionTitle.OrnamentAboveTextLeft = asVariation(SectionTitle, 'OrnamentAboveTextLeft', {}, {
    hasDividerAbove: true,
    hasOrnament: true,
    isFullBleed: false,
    textAlign: 'left'
});
SectionTitle.TextLeftWithLineAboveTitle = asVariation(SectionTitle, 'TextLeftWithLineAboveTitle', {}, {
    hasDividerAbove: true,
    textAlign: 'left'
});
SectionTitle.TextLeftWithLineBelowTitle = asVariation(SectionTitle, 'TextLeftWithLineBelowTitle', {}, {
    hasDividerBelow: true,
    textAlign: 'left'
});
SectionTitle.TextLeftLineAboveWithHedBackground = asVariation(SectionTitle, 'TextLeftLineAboveWithHedBackground', {}, {
    hasDividerAbove: true,
    hasHedBackground: true,
    textAlign: 'left'
});
SectionTitle.FullBleedLineAboveLineBelowTextCenter = asVariation(SectionTitle, 'FullBleedLineAboveLineBelowTextCenter', {}, {
    hasDividerAbove: true,
    hasDividerBelow: true,
    isFullBleed: true,
    textAlign: 'center'
});
SectionTitle.LineAboveTextLeft = asVariation(SectionTitle, 'LineAboveTextLeft', {}, {
    hasDividerAbove: true,
    shouldUseAlternateStyle: true,
    textAlign: 'left',
    hasTopPadding: true,
    contentSize: '0'
});
SectionTitle.LineAboveTextCenter = asVariation(SectionTitle, 'LineAboveTextCenter', {}, {
    hasDividerAbove: true,
    textAlign: 'center'
});
SectionTitle.SoftDivider = asVariation(SectionTitle, 'SoftDivider', {
    dividerStyle: 'soft'
}, {
    hasDividerAbove: true,
    hasNoMargins: true,
    textAlign: 'center'
});
SectionTitle.IconAbove = asVariation(SectionTitle, 'IconAbove', {
    iconPosition: 'above'
}, {
    hasDividerAbove: true,
    hasNoMargins: true,
    imageSize: 'Icon'
});
SectionTitle.LineBelowHedTextCenter = asVariation(SectionTitle, 'TextCenter', { hasDivider: true, shouldUseCustomColorToken: true }, {
    hasDividerAboveDek: false,
    textAlign: 'center',
    hasMinimalMargins: true
});
module.exports = SectionTitle;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 93246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classNames = __webpack_require__(32485);
const { SelectionControlListWrapper, SelectionControlListLegend } = __webpack_require__(18619);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * SelectionControlList component
 *
 * @param {object} props - React Props
 * @param {ReactElement} [props.children] - Optional React children
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} props.dangerousLegend - Dangerous legend text for screen reader
 * @param {boolean} props.hasChildStyling - Added the spacing style to the children
 * @param {object} [props.variations] - Optional Variation properties used in rendering the component.
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
const SelectionControlList = ({ children, className, dangerousLegend, hasChildStyling = true, variations = {
    theme: 'standard'
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SelectionControlList',
            variation: variationName
        });
    }, [variationName]);
    const isInverted = variations.theme === 'inverted';
    return (React.createElement(SelectionControlListWrapper, { role: "radiogroup", className: className, isInverted: isInverted, "data-testid": "SelectionControlListWrapper" },
        React.createElement(SelectionControlListLegend, { className: "selection-control-list__legend--hidden", "data-testid": "SelectionControlListLegend", dangerouslySetInnerHTML: {
                __html: dangerousLegend
            } }),
        React.Children.map(children, (child) => {
            // eslint-disable-next-line no-shadow
            const { className } = child.props;
            return React.cloneElement(child, {
                className: classNames(className, {
                    'selection-control-list__item': hasChildStyling
                })
            });
        })));
};
SelectionControlList.propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,
    dangerousLegend: PropTypes.string.isRequired,
    hasChildStyling: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        theme: PropTypes.oneOf(['standard', 'inverted'])
    })
};
module.exports = SelectionControlList;
//# sourceMappingURL=SelectionControlList.js.map

/***/ }),

/***/ 10673:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(77887);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18619:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { getColorStyles, calculateSpacing } = __webpack_require__(26865);
const { hideVisually } = __webpack_require__(52813);
const { BREAKPOINTS } = __webpack_require__(96472);
const { UtilitySelectionControlLabelWrapper } = __webpack_require__(20404);
const { DiscoverySelectionControlLabelWrapper } = __webpack_require__(69741);
const SelectionControlListWrapper = styled.fieldset.withConfig({
    displayName: 'SelectionControlListWrapper-sc'
}) `
  ${({ theme, isInverted }) => isInverted &&
    getColorStyles(theme, 'background', 'colors.interactive.base.black')};

  .selection-control-list__item {
    &${UtilitySelectionControlLabelWrapper} {
      padding: ${calculateSpacing(2)} 0 ${calculateSpacing(1)};
    }
    &${DiscoverySelectionControlLabelWrapper} {
      border-bottom: 1px solid;
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.discovery.body.white.divider')};
      padding: ${calculateSpacing(4)} 0;
    }

    &:first-of-type {
      padding-top: 0;
    }
    @media (min-width: ${BREAKPOINTS.sm}) {
      &:last-of-type {
        border: 0;
        padding-bottom: 0;
      }
    }
  }
`;
const SelectionControlListLegend = styled.legend.withConfig({
    displayName: 'SelectionControlListLegend'
}) `
  ${hideVisually()}
`;
module.exports = {
    SelectionControlListWrapper,
    SelectionControlListLegend
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 77887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const SelectionControlList = __webpack_require__(93246);
SelectionControlList.Inverted = asVariation(SelectionControlList, 'Inverted', {
    theme: 'inverted'
});
module.exports = SelectionControlList;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 36291:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const { connector } = __webpack_require__(57744);
const ResponsiveAsset = __webpack_require__(73275);
const translations = (__webpack_require__(83164)/* ["default"] */ .A);
const { default: isLinkExternal } = __webpack_require__(13659);
const { googleAnalytics } = __webpack_require__(90090);
const { TrackComponentChannel } = __webpack_require__(78788);
const { SeriesNavigationAsset, SeriesNavigationItemContainer, SeriesNavigationDek, SeriesNavigationHeadingContainer, SeriesNavigationHed, SeriesNavigationItemDek, SeriesNavigationItemHed, SeriesNavigationItemNowReading, SeriesNavigationList, SeriesNavigationListItem, SeriesNavigationResponsiveAssetComingSoonText, SeriesNavigationResponsiveAssetContainer, SeriesNavigationTextContainer, SeriesNavigationWrapper, UnpublishedResponsiveAssetContainer } = __webpack_require__(54362);
const COMING_SOON_TEXT_DEFAULT = 'Coming soon';
const NOW_READING_TEXT_DEFAULT = 'Now reading';
const TEXT_TRANSLATIONS = {
    [COMING_SOON_TEXT_DEFAULT]: translations.comingSoonText,
    [NOW_READING_TEXT_DEFAULT]: translations.nowReadingText
};
/**
 * Render the items: heds, deks, images, links
 *
 * @param {object} viewProps - View props
 * @param {string} [viewProps.comingSoonText] - Optional prop to label unpublished items
 * @param {string} [viewProps.nowReadingText] - Optional prop to label the current item
 * @param {Array} viewProps.links - Array of link objects
 *
 * @returns {ReactElement} <div>
 */
const SeriesItems = ({ comingSoonText, nowReadingText, links = [] }) => {
    const { formatMessage } = useIntl();
    const classNames = classnames('grid');
    const trackingStoryClickEvent = (title) => {
        googleAnalytics.emitGoogleTrackingEvent('seriesnavigation', {
            title
        });
    };
    const onClick = (url) => {
        isLinkExternal(url, window.location.hostname)
            ? window.open(url, '_blank')
            : (window.location = url);
    };
    return links.length ? (React.createElement(SeriesNavigationList, { className: classNames }, links.map((link, idx) => {
        const key = idx;
        const { dek, hed, image, isCurrent, isExternal, isPublished, url } = link;
        const isComingSoon = !isPublished && !isExternal;
        const imageSources = image && (image.segmentedSources || image.sources);
        return (React.createElement(SeriesNavigationListItem, { key: key, onClick: () => onClick(url) },
            React.createElement(SeriesNavigationItemContainer, null,
                imageSources && (React.createElement(SeriesNavigationAsset, { isComingSoon: isComingSoon },
                    React.createElement(SeriesNavigationResponsiveAssetContainer, { isComingSoon: isComingSoon }, isComingSoon ? (React.createElement(React.Fragment, null,
                        React.createElement(SeriesNavigationResponsiveAssetComingSoonText, null, formatMessage(TEXT_TRANSLATIONS[comingSoonText])),
                        React.createElement(UnpublishedResponsiveAssetContainer, null,
                            React.createElement(ResponsiveAsset, { ...image, isLazy: true })))) : (React.createElement(ResponsiveAsset, { ...image, isLazy: true }))))),
                React.createElement(SeriesNavigationTextContainer, null,
                    hed &&
                        (isComingSoon ? (React.createElement(SeriesNavigationItemHed, { isComingSoon: isComingSoon, dangerouslySetInnerHTML: { __html: hed } })) : (React.createElement(SeriesNavigationItemHed, null,
                            React.createElement("a", { href: url, dangerouslySetInnerHTML: {
                                    __html: hed
                                }, onClick: () => trackingStoryClickEvent(hed) })))),
                    !isCurrent && dek && (React.createElement(SeriesNavigationItemDek, { isComingSoon: isComingSoon, dangerouslySetInnerHTML: {
                            __html: dek
                        } })),
                    isCurrent && (React.createElement(SeriesNavigationItemNowReading, { isCurrent: isCurrent, dangerouslySetInnerHTML: {
                            __html: formatMessage(TEXT_TRANSLATIONS[nowReadingText])
                        } }))))));
    }))) : null;
};
SeriesItems.propTypes = {
    comingSoonText: PropTypes.string,
    links: PropTypes.arrayOf(PropTypes.shape({
        dek: PropTypes.string,
        hed: PropTypes.string,
        isExternal: PropTypes.bool,
        url: PropTypes.string
    })),
    nowReadingText: PropTypes.string
};
/**
 * SeriesNavigation component
 *
 * @param {object} props - React props
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.comingSoonText] - Optional prop to label unpublished items
 * @param {string} [props.nowReadingText] - Optional prop to label the current item
 * @param {object} [props.seriesData] - link banner information from the redux store
 * @param {string} [props.pageBackgroundTheme] - Optional prop to get article page background color from copilot
 * @param {string} [props.dividerColor] - Optional prop to get divider color for article page from copilot
 *
 * @returns {ReactElement} <div>
 */
const SeriesNavigation = ({ className, comingSoonText = COMING_SOON_TEXT_DEFAULT, nowReadingText = NOW_READING_TEXT_DEFAULT, dividerColor, pageBackgroundTheme, seriesData = null }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SeriesNavigation'
        });
    }, []);
    if (!seriesData) {
        return null;
    }
    const { hed, dek, links } = seriesData;
    const viewProps = {
        comingSoonText,
        hed,
        dek,
        links,
        nowReadingText
    };
    const classNames = classnames('grid', className);
    return (React.createElement(SeriesNavigationWrapper, { className: classNames, pageBackgroundTheme: pageBackgroundTheme, dividerColor: dividerColor },
        React.createElement(SeriesNavigationHeadingContainer, null,
            hed && (React.createElement(SeriesNavigationHed, { dangerouslySetInnerHTML: {
                    __html: hed
                } })),
            dek && (React.createElement(SeriesNavigationDek, { dangerouslySetInnerHTML: {
                    __html: dek
                } }))),
        React.createElement(SeriesItems, { ...viewProps })));
};
SeriesNavigation.displayName = 'SeriesNavigation';
SeriesNavigation.propTypes = {
    className: PropTypes.string,
    comingSoonText: PropTypes.string,
    dividerColor: PropTypes.string,
    nowReadingText: PropTypes.string,
    pageBackgroundTheme: PropTypes.string,
    seriesData: PropTypes.shape({
        hed: PropTypes.string,
        dek: PropTypes.string,
        image: PropTypes.object,
        links: PropTypes.arrayOf(PropTypes.shape({
            hed: PropTypes.string,
            dek: PropTypes.string,
            image: PropTypes.object,
            isCurrent: PropTypes.bool,
            isExternal: PropTypes.bool,
            isPublished: PropTypes.bool,
            promoHed: PropTypes.string,
            url: PropTypes.string
        }))
    })
};
module.exports = connector(SeriesNavigation, {
    keysToPluck: ['seriesData']
});
//# sourceMappingURL=SeriesNavigation.js.map

/***/ }),

/***/ 78118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const SeriesNavigation = __webpack_require__(36291);
module.exports = asConfiguredComponent(SeriesNavigation, 'SeriesNavigation');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 54362:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { applyGridSpacing, cssVariablesGrid, applyCustomDividerColor } = __webpack_require__(1123);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getTypographyStyles, getColorStyles } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { universalGridCore } = __webpack_require__(89085);
const { applyCustomBackgroundColor } = __webpack_require__(1123);
const SeriesNavigationAsset = styled.div.withConfig({
    displayName: 'SeriesNavigationAsset'
}) `
  ${({ isComingSoon }) => (isComingSoon ? `background: black;` : ``)}
`;
const SeriesNavigationItemContainer = styled.div.withConfig({
    displayName: 'SeriesNavigationItemContainer'
}) `
  @media (max-width: ${BREAKPOINTS.md}) {
    width: ${calculateSpacing(22)};
  }
`;
const SeriesNavigationDek = styled.div.withConfig({
    displayName: 'SeriesNavigationDek'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.description-page')};
`;
const SeriesNavigationHeadingContainer = styled.div.withConfig({
    displayName: 'SeriesNavigationHeadingContainer'
}) `
  grid-column: 1/-1;
  padding-top: ${calculateSpacing(2)};
`;
const SeriesNavigationHed = styled.p.withConfig({
    displayName: 'SeriesNavigationHed'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')};

  margin-top: 0;
  margin-bottom: ${calculateSpacing(0.25)};
`;
const SeriesNavigationItemDek = styled(BaseText).withConfig({
    displayName: 'SeriesNavigationItemDek'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-secondary')};
  ${({ isComingSoon }) => (isComingSoon ? `opacity: 43%` : ``)}
`;
SeriesNavigationItemDek.defaultProps = {
    isComingSoon: false
};
const SeriesNavigationItemHed = styled(BaseText).withConfig({
    displayName: 'SeriesNavigationItemHed'
}) `
  ${({ isComingSoon }) => (isComingSoon ? `opacity: 43%;` : ``)};

  a {
    text-decoration: none;
    color: inherit;

    &:hover {
      text-decoration: underline;
    }
  }
`;
SeriesNavigationItemHed.defaultProps = {
    as: 'p',
    bottomSpacing: 0.6875,
    isComingSoon: false,
    topSpacing: 1,
    typeIdentity: 'typography.definitions.discovery.hed-bulletin-primary'
};
const SeriesNavigationItemNowReading = styled(BaseText).withConfig({
    displayName: 'SeriesNavigationItemNowReading'
}) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-secondary')};

  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.feedback.invalid-primary')};
`;
const SeriesNavigationList = styled.ul.withConfig({
    displayName: 'SeriesNavigationList'
}) `
  grid-column: 1/-1;
  margin: 0;
  padding: 0 0 0.5rem 0;
  height: 100%;
  list-style: none;

  &.grid {
    ${universalGridCore()}
  }
  @media (max-width: ${BREAKPOINTS.md}) {
    &.grid {
      display: flex;
      flex-wrap: nowrap;
      align-items: flex-start;
      padding: 0 0 1rem 0;
      width: 100%;
      overflow-x: scroll;
    }
  }
`;
const SeriesNavigationListItem = styled.li.withConfig({
    displayName: 'SeriesNavigationListItem'
}) `
  display: inline-block;
  grid-column: span 3;
  cursor: pointer;

  @media (max-width: ${BREAKPOINTS.md}) {
    &:last-child {
      padding-right: ${calculateSpacing(3)};
    }
  }

  @media (min-width: ${BREAKPOINTS.lg}) {
    grid-column: span 2;
  }
`;
const SeriesNavigationResponsiveAssetContainer = styled.div.withConfig({
    displayName: 'SeriesNavigationResponsiveAssetContainer'
}) `
  position: relative;
`;
const SeriesNavigationResponsiveAssetComingSoonText = styled(BaseText).withConfig({ displayName: 'SeriesNavigationResponsiveAssetComingSoonText' }) `
  position: absolute;
  top: ${calculateSpacing(1)};
  left: ${calculateSpacing(1.25)};
  z-index: 1;
`;
SeriesNavigationResponsiveAssetComingSoonText.defaultProps = {
    as: 'span',
    colorToken: 'colors.background.adContainer.special',
    typeIdentity: 'typography.definitions.discovery.subhed-section-secondary'
};
const SeriesNavigationWrapper = styled.div.withConfig({
    displayName: 'SeriesNavigationWrapper'
}) `
  ${cssVariablesGrid()}
  ${applyGridSpacing('padding')};

  grid-template-rows: auto auto;
  border-bottom: 1px solid;
  padding-bottom: ${calculateSpacing(1)};
  width: 100%;

  ${({ dividerColor, theme }) => `${dividerColor
    ? `${applyCustomDividerColor(dividerColor)};`
    : `${getColorStyles(theme, 'border-color', 'colors.consumption.body.standard.divider')};`}`}

  ${({ pageBackgroundTheme, theme }) => `${pageBackgroundTheme
    ? `${applyCustomBackgroundColor(pageBackgroundTheme)};`
    : `${getColorStyles(theme, 'background', 'colors.foundation.menu-bg.collapsed')};`}`}
  &.grid {
    ${universalGridCore()}
  }
`;
const SeriesNavigationTextContainer = styled.div.withConfig({
    displayName: 'SeriesNavigationTextContainer'
}) `
  margin-top: ${calculateSpacing(2)};
`;
const UnpublishedResponsiveAssetContainer = styled.div.withConfig({
    displayName: 'UnpublishedResponsiveAssetContainer'
}) `
  opacity: 43%;
`;
module.exports = {
    SeriesNavigationAsset,
    SeriesNavigationItemContainer,
    SeriesNavigationDek,
    SeriesNavigationHeadingContainer,
    SeriesNavigationHed,
    SeriesNavigationItemDek,
    SeriesNavigationItemHed,
    SeriesNavigationItemNowReading,
    SeriesNavigationList,
    SeriesNavigationListItem,
    SeriesNavigationResponsiveAssetComingSoonText,
    SeriesNavigationResponsiveAssetContainer,
    SeriesNavigationTextContainer,
    SeriesNavigationWrapper,
    UnpublishedResponsiveAssetContainer
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 83164:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    comingSoonText: {
        id: 'ComingSoon.SeriesNavigation',
        defaultMessage: 'COMING SOON',
        description: 'ChannelFilter component Coming Soon text'
    },
    nowReadingText: {
        id: 'NowReading.SeriesNavigation',
        defaultMessage: 'Now Reading',
        description: 'SeriesNavigation component Now Reading text'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 72964:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { injectIntl } = __webpack_require__(46984);
const { connect: connectToStore } = __webpack_require__(67851);
const { googleAnalytics } = __webpack_require__(90090);
const SocialIcon = __webpack_require__(69496);
const { SocialIconButton } = __webpack_require__(51000);
const Bookmark = __webpack_require__(70931);
const BookmarkActivated = __webpack_require__(64736);
const bookmarkHelper = __webpack_require__(48373);
const signInModalActions = __webpack_require__(22509);
const Alert = __webpack_require__(54330);
const { asConfiguredComponent } = __webpack_require__(12892);
const withOnboarding = __webpack_require__(91056);
const { trackSaveEvent, buildSaveImageContext } = __webpack_require__(14307);
const queryParamsHelper = __webpack_require__(12311);
const DrawerMessageBanner = __webpack_require__(11501);
const translations = (__webpack_require__(54890)/* ["default"] */ .A);
const BOOKMARK_UPDATE_SOURCE = 'verso-story-page';
const mapStateToProps = (state, ownProps) => {
    const { coreDataLayer: { content: { contentType }, site: { orgId: organizationID } }, config: { account }, featureFlags: { shouldUseBookmarkV3 }, 'head.contentID': contentID, 'head.canonicalUrl': documentUrl, pageState: { bookmarkStatus: { bookmarkId, isUrlBookmark } }, unsavedBookmarks = {}, user, userPlatform } = state;
    const enableBookmarkDrawers = account?.bookmark?.enableBookmarkDrawers || false;
    const { copilotID, bookmarkDetails = {}, isPageScoped = true } = ownProps;
    if (!isPageScoped) {
        return {
            bookmarkId: bookmarkDetails.bookmarkId,
            contentID: bookmarkDetails.contentId || copilotID,
            contentType: bookmarkDetails.contentType || contentType,
            documentUrl,
            isUrlBookmark: bookmarkDetails.isUrlBookmark,
            organizationID,
            shouldUseBookmarkV3,
            unsavedBookmarks,
            user,
            userPlatform,
            shouldEnableBookmarkDrawers: enableBookmarkDrawers
        };
    }
    return {
        bookmarkId,
        contentID,
        contentType,
        documentUrl,
        isUrlBookmark,
        organizationID,
        shouldUseBookmarkV3,
        unsavedBookmarks,
        user,
        userPlatform,
        shouldEnableBookmarkDrawers: enableBookmarkDrawers
    };
};
const mapDispatchToProps = (dispatch) => ({
    displayBookmarkAlert: () => {
        dispatch({
            type: 'MERGE_KEY',
            key: 'bookmarkAlert',
            value: { isVisible: true }
        });
    },
    doUpdateBookmarkedStatus: (bookmarkStatus) => {
        dispatch({
            type: 'SET_KEY',
            key: 'pageState.bookmarkStatus',
            value: bookmarkStatus
        });
    },
    doUpdateUnsavedBookmarks: ({ copilotID, isDeleted }) => {
        dispatch({
            type: 'MERGE_KEY',
            key: 'unsavedBookmarks',
            value: { [copilotID]: { isDeleted } }
        });
    },
    setLastBookmarkedPhoto: (copilotID, image, contentType, contentTitle) => {
        dispatch({
            type: 'SET_KEY',
            key: 'lastBookmarkedPhoto',
            value: { copilotID, image, contentType, contentTitle }
        });
    }
});
/**
 * BookmarkIcon component (wrapper for the SocialIcon component)
 *
 * @param {object} props - React Props
 * @param {string} [props.bookmarkAlert] - Message to be shown in the tooltip of bookmark
 * @param {string} [props.bookmarkCompletionAriaLabel] - Bookmark icon completion aria-label
 * @param {number} [props.bookmarkId] - Id of bookmark in user platform system
 * @param {string} [props.bookmarkIconAlertDesktopLeft] - optional string representing the css left property for the bookmark onboarding tooltip
 * @param {string} [props.bookmarkIconAlertDesktopTop] - optional string representing the css top property for the bookmark onboarding tooltip
 * @param {string} [props.bookmarkIconAriaLabel] - Bookmark icon aria-label
 * @param {string} [props.bookmarkIconTitle] - Bookmark icon title
 * @param {string} [props.bookmarkIconTitleForSaved] - Bookmark icon title for saved content
 * @param {string} [props.bookmarkTrackingType] - bookmark tracking position
 * @param {boolean} [props.isBookmarkButton] - whether the bookmark was saved using the button or list item.
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} props.completeOnboarding - Function used to signal that the onboarding for this component is complete
 * @param {string} [props.contentID] - ID of the Copilot entity
 * @param {string} props.contentType - Type of content rendered
 * @param {string} [props.contentTitle] - Optional content hed for item
 * @param {string} [props.documentUrl] - canonical url of the content, derived from head.canonicalUrl
 * @param {Function} props.doUpdateBookmarkedStatus - Function to update global store, see mapDispatchToProps
 * @param {Function} [props.doUpdateUnsavedBookmarks] - Dispatch function to update global store of an unsaved bookmarks
 * @param {boolean} [props.isIconButton] - Optional prop to make icon a button.
 * @param {boolean} props.isUrlBookmark - whether the bookmark was saved using the documentUrl or the organizationID/copilotID combo.
 * @param {Array<object>} props.links - A list of `{ handle, label, network, url, behavior }` objects. `label` and `network` are required, one of `handle` OR `url` are required, `behavior` is optional.
 * @param {string} props.organizationID - ID of the brand associated with the Copilot entity
 * @param {string} [props.onboardingStep] - Current Saved Stories onboarding step
 * @param {string} [props.onboardingAriaLabel] - Bookmark icon onboarding ARIA label
 * @param {string} props.signInHed - Hed shown to users that are required to sign in before bookmarking
 * @param {string} props.signInHedSpanTag - Hed span tag shown to users that are required to sign in before bookmarking
 * @param {string} props.signInMessage - Message shown to users that are required to sign in before bookmarking
 * @param {boolean} props.shouldUseBookmarkV3 - use bookmarks v3 version
 * @param {string} [props.subject] - describes the content of the subject.
 * @param {object} [props.variations] - Optional variations
 * @param {string} [props.variations.theme] - Optional theme ['footer', 'has-background', 'overlay', 'standard']
 * @param {object} intl - react-intl internationalisation props
 * @param {Function} [props.openCollectionsDrawer] - Dispatch function to open the collection drawer
 * @param {object} [props.image] - image object for collection drawer
 * @param {Function} props.setLastBookmarkedPhoto - Dispatch function to set the id of the most recently bookmarked photo
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - Feature flag to define whether enable bookmark drawers functionality
 * @param {Function} [props.unsavedBookmarks] - Properties of an unsaved item in redux
 * @param {string} [props.copilotID] - Optional copilot id of the item for fetching bookmark details
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 *
 * @returns {ReactElement} <div>
 */
class BookmarkIcon extends React.Component {
    constructor(props) {
        super(props);
        // Update localStorage with bookmarked item
        this.updateLocalStorageWithBookmarkedItem = (itemContentID) => {
            this.setState(() => {
                window?.localStorage?.setItem('bookmarkedItem', JSON.stringify(itemContentID));
                return { bookmarkedItem: itemContentID };
            });
        };
        // Handle first-time bookmark usage
        this.handleFirstTimeBookmarkUsage = (intl) => {
            if (!window.localStorage?.getItem('userHasUsedBookmarkFeature')) {
                this.props.displayBookmarkAlert();
                window.localStorage.setItem('userHasUsedBookmarkFeature', 'true');
                this.setState({
                    completionLabel: this.props.bookmarkCompletionAriaLabel ||
                        intl.formatMessage(translations.completionLabel)
                });
            }
        };
        /**
         * Save the bookmark for the user and fire off related events (analytics,
         * state updates for copy, etc).
         *
         * @param {object} e - the event object
         * @param {string} itemContentID - copilot Id of an item in a bundle
         * @param {string} itemContentType - content type of an item in a bundle
         * @param {boolean} unique - whether the analytics event should be a unique
         * event or not. This is needed because two instances of this component exist
         * on each content page, and we only want unique events for create requests
         * when starting the bookmark flow as an unauthenticated user who is
         * redirected from the sign in page with the action=addBookmark query.
         *
         * @returns {undefined} undefined
         */
        this.createBookmark = async (e, itemContentID, itemContentType, unique = false) => {
            if (e) {
                e.preventDefault();
            }
            const { bookmarkTrackingType, contentID, contentTitle, contentType, subtype, doUpdateBookmarkedStatus, doUpdateUnsavedBookmarks, setLastBookmarkedPhoto, image, intl, organizationID, subject, snowplowEvent, updateBookmark, openCollectionsDrawer, user: { amguuid: amgUUID }, userPlatform: { federatedGraphqlUrl, siteCode, userPlatformProxy, xClientID }, shouldEnableBookmarkDrawers } = this.props;
            const copilotID = itemContentID || contentID;
            const finalContentType = subtype || itemContentType || contentType;
            let bookmarkedID = null;
            let bookmarkDetails = {};
            let ledeImage = image ? { ...image } : {};
            let contentDangerousHed = contentTitle || '';
            try {
                const storedTitle = window.localStorage?.getItem('contentTitle');
                const storedImage = window.localStorage?.getItem('ledeImage');
                if (storedTitle) {
                    contentDangerousHed = storedTitle;
                    window.localStorage.removeItem('contentTitle');
                }
                if (storedImage) {
                    ledeImage = JSON.parse(storedImage);
                    window.localStorage.removeItem('ledeImage');
                }
            }
            catch (error) {
                console.error('Error parsing stored content', error);
            }
            try {
                const { statusCode, data: { id } = {} } = await this.bookmarkHelper.proxyCreateBookmark({
                    amgUUID,
                    copilotID,
                    contentType: finalContentType,
                    federatedGraphqlUrl,
                    organizationID,
                    siteCode,
                    source: BOOKMARK_UPDATE_SOURCE,
                    userPlatformProxy,
                    xClientID
                });
                if ((statusCode === 201 && id) || statusCode === 409) {
                    const saveContext = buildSaveImageContext({
                        subject: 'my_saved_recipes'
                    });
                    const eventData = {
                        type: 'save',
                        label: 'Save Recipe',
                        subject,
                        placement: snowplowEvent?.placement,
                        index: snowplowEvent?.index,
                        total_index: snowplowEvent?.total_index
                    };
                    trackSaveEvent(eventData, saveContext);
                    setLastBookmarkedPhoto(copilotID, ledeImage, finalContentType, contentDangerousHed);
                    bookmarkDetails = {
                        bookmarkId: id,
                        isUrlBookmark: false,
                        contentId: copilotID
                    };
                    bookmarkedID = id;
                    this.trackBookmarkEvent(`bookmarks-click-tracking-save-${bookmarkTrackingType}`, unique);
                    if (shouldEnableBookmarkDrawers && id) {
                        doUpdateUnsavedBookmarks({
                            copilotID,
                            isDeleted: false
                        });
                        openCollectionsDrawer?.();
                    }
                }
                else {
                    this.trackBookmarkEvent(`bookmarks-click-tracking-save-fail-${bookmarkTrackingType}`, unique);
                }
            }
            catch (error) {
                console.error(error);
                this.trackBookmarkEvent(`bookmarks-click-tracking-save-fail-${bookmarkTrackingType}`, unique);
            }
            finally {
                // Success or fail, we want to remove ?action= from URL to prevent sharing of this URL
                window.history.replaceState({}, document.title, document.location.pathname);
            }
            this.handleFirstTimeBookmarkUsage(intl);
            // If bookmark was successful, update bookmark status
            if (bookmarkedID) {
                if (updateBookmark)
                    updateBookmark(bookmarkDetails);
                doUpdateBookmarkedStatus(bookmarkDetails);
                if (itemContentID) {
                    this.updateLocalStorageWithBookmarkedItem(itemContentID);
                }
            }
        };
        /**
         * Delete the bookmark for the user and fire off related events (analytics,
         * state updates, etc).
         *
         * @param {object} e - the event object
         *
         * @returns {undefined} undefined
         */
        this.removeBookmark = async (e) => {
            e.preventDefault();
            const { bookmarkId, bookmarkTrackingType, doUpdateBookmarkedStatus, setLastBookmarkedPhoto, isUrlBookmark, updateBookmark, shouldEnableBookmarkDrawers, user: { amguuid: amgUUID }, userPlatform: { federatedGraphqlUrl, userPlatformProxy, xClientID } } = this.props;
            shouldEnableBookmarkDrawers && this.setState({ showMessageBanner: false });
            try {
                const response = await this.bookmarkHelper.proxyRemoveBookmark({
                    amgUUID,
                    bookmarkId,
                    federatedGraphqlUrl,
                    isUrlBookmark,
                    source: BOOKMARK_UPDATE_SOURCE,
                    userPlatformProxy,
                    xClientID
                });
                if (response && response.status !== 204) {
                    this.trackBookmarkEvent(`bookmarks-click-tracking-unsave-fail-${bookmarkTrackingType}`);
                    return;
                }
                setLastBookmarkedPhoto();
                const bookmarkDetails = { bookmarkId: null, isUrlBookmark: null };
                doUpdateBookmarkedStatus(bookmarkDetails);
                if (updateBookmark)
                    updateBookmark(bookmarkDetails);
                this.trackBookmarkEvent(`bookmarks-click-tracking-unsave-${bookmarkTrackingType}`);
                this.setState({
                    bannerProps: {
                        action: (e) => {
                            e.stopPropagation();
                            this.createBookmark(e);
                        }
                    }
                });
                shouldEnableBookmarkDrawers && this.setState({ showMessageBanner: true });
            }
            catch (error) {
                console.error(error);
                this.trackBookmarkEvent(`bookmarks-click-tracking-unsave-fail-${bookmarkTrackingType}`);
            }
        };
        this.checkIsAlreadyBookmarked = async (itemContentID) => {
            const { contentID, doUpdateBookmarkedStatus, organizationID, user: { amguuid: amgUUID }, userPlatform: { federatedGraphqlUrl, siteCode, userPlatformProxy, xClientID } } = this.props;
            if (window.localStorage.setItem('bookmarkedItem', null))
                ;
            this.setState({
                bookmarkedItem: null
            });
            try {
                const bookmarkStatus = await this.bookmarkHelper.getBookmarkStatus({
                    amgUUID,
                    copilotID: itemContentID || contentID,
                    organizationID,
                    federatedGraphqlUrl,
                    siteCode,
                    userPlatformProxy,
                    xClientID
                });
                doUpdateBookmarkedStatus(bookmarkStatus);
            }
            catch (error) {
                console.info(error);
            }
        };
        this.iconLinkRef = React.createRef();
        this.state = {
            completionLabel: '',
            hasLoaded: false,
            hover: false,
            bookmarkedItem: null,
            showMessageBanner: false,
            bannerProps: {}
        };
        this.handleUnauthenticatedAction =
            this.handleUnauthenticatedAction.bind(this);
        this.iconFocus = this.toggleIconHover(true);
        this.iconBlur = this.toggleIconHover(false);
        this.bookmarkHelper = bookmarkHelper(this.props.shouldUseBookmarkV3);
    }
    componentDidMount() {
        const queryParams = queryParamsHelper.parseQueryParams(window.location.search);
        const uniqueTrackingEvent = true; // Using a named variable for context
        this.setState({ hasLoaded: true });
        // This should only run when user has ?action=addBookmark qs
        if (queryParams.action &&
            queryParams.action === 'addBookmark' &&
            this.props.user.isAuthenticated) {
            this.completeOnboarding();
            this.createBookmark(null, queryParams.contentId, queryParams.contentType, uniqueTrackingEvent);
            window.history.replaceState({}, document.title, document.location.pathname);
        }
        const iconElement = this.iconLinkRef.current;
        if (iconElement) {
            iconElement.addEventListener('mouseenter', this.iconFocus);
            iconElement.addEventListener('mouseleave', this.iconBlur);
            iconElement.addEventListener('focus', this.iconFocus);
            iconElement.addEventListener('blur', this.iconBlur);
        }
        setTimeout(() => {
            this.getLocalStorageBookmarkItem();
        }, 3000);
    }
    componentWillUnmount() {
        const iconElement = this.iconLinkRef.current;
        if (iconElement) {
            iconElement.removeEventListener('mouseenter', this.iconFocus);
            iconElement.removeEventListener('mouseleave', this.iconBlur);
            iconElement.removeEventListener('focus', this.iconFocus);
            iconElement.removeEventListener('blur', this.iconBlur);
        }
    }
    getLocalStorageBookmarkItem() {
        const { bookmarkedItem } = this.state;
        if (!bookmarkedItem && window?.localStorage?.getItem('bookmarkedItem')) {
            const storedBookmark = JSON.parse(window?.localStorage?.getItem('bookmarkedItem'));
            if (storedBookmark?.length > 0) {
                this.setState({
                    bookmarkedItem: storedBookmark
                });
            }
        }
    }
    toggleIconHover(hover) {
        return () => this.setState({ hover });
    }
    trackBookmarkEvent(eventName, unique = false) {
        const trackingPayload = {
            bookmarks: {
                contentId: this.props.contentID,
                contentUrl: this.props.documentUrl
            }
        };
        // We are doing this because we have 2 bookmark icons loaded all the time in the dom, one for mobile
        // and one for desktop, however, there are things that should not run all the functionalities on both
        // always, this change makes it clear that on a few places like componentDidMount we just want to fire this once.
        if (unique) {
            googleAnalytics.emitUniqueGoogleTrackingEvent(eventName, trackingPayload);
        }
        else {
            googleAnalytics.emitGoogleTrackingEvent(eventName, trackingPayload);
        }
    }
    handleUnauthenticatedAction(event) {
        if (event) {
            event.preventDefault();
        }
        const { intl, image, contentTitle } = this.props;
        window.localStorage.setItem('ledeImage', JSON.stringify(image));
        window.localStorage.setItem('contentTitle', contentTitle);
        const { pathname, search } = window.location;
        const bookmarkQS = `action=addBookmark&contentId=${this.props.contentID}&contentType=${this.props.contentType}`;
        const documentURLWithActionQueryString = search
            ? `${pathname}${search}&${bookmarkQS}`
            : `${pathname}?${bookmarkQS}`;
        signInModalActions.doDisplayModal({
            authSource: 'sign-in-modal',
            source: 'VERSO_BOOKMARKING',
            dangerousHed: this.props.signInHed || '',
            dangerousHedSpanTag: this.props.signInHedSpanTag || '',
            dangerousDek: this.props.signInMessage ||
                intl.formatMessage(translations.signInMessage),
            redirectURL: documentURLWithActionQueryString,
            type: 'default',
            analyticsType: 'saved stories',
            shouldHideIllustration: false
        });
    }
    isOnboarding() {
        return this.props.onboardingStep === 'bookmarkAwareness';
    }
    completeOnboarding() {
        this.isOnboarding() && this.props.completeOnboarding();
    }
    render() {
        const { bookmarkAlert, bookmarkId, bookmarkIconAlertDesktopLeft, bookmarkIconAlertDesktopTop, bookmarkIconAriaLabel, bookmarkIconTitle, bookmarkIconTitleForSaved, bookmarkSideBarLabel, contentID, copilotID, intl, isIconButton, isBookmarkButton, link, onboardingAriaLabel, showDistinctiveBookmark, shouldEnableBookmarkDrawers, theme, type, unsavedBookmarks, user: { isAuthenticated } } = this.props;
        const { completionLabel, hasLoaded, hover, bookmarkedItem, showMessageBanner, bannerProps } = this.state;
        const isOnboarding = this.isOnboarding() && hasLoaded && !bookmarkId;
        const isTooltipVisible = isOnboarding && hover;
        // we have to update this when the page is bookmarked so it will render the proper icon and title
        let linkObj = link;
        let bookmarkTitleToUse = bookmarkIconTitle;
        if (bookmarkId) {
            bookmarkTitleToUse = bookmarkIconTitleForSaved;
            linkObj = {
                behavior: 'bookmarkactivated',
                label: bookmarkIconAriaLabel ||
                    intl.formatMessage(translations.bookmarkIconLabel),
                network: 'bookmarkactivated',
                url: '#'
            };
        }
        const toggleBookmark = (event) => {
            if (!isAuthenticated) {
                return this.handleUnauthenticatedAction(event);
            }
            this.completeOnboarding();
            this.checkIsAlreadyBookmarked();
            const isUnsaved = !!unsavedBookmarks?.[contentID]?.isDeleted;
            return hasLoaded && bookmarkId && !isUnsaved
                ? this.removeBookmark(event)
                : this.createBookmark(event);
        };
        const isBookmarkActive = () => {
            const isUnsaved = !!unsavedBookmarks?.[contentID]?.isDeleted;
            if (((contentID !== copilotID || !bookmarkId) &&
                bookmarkedItem !== copilotID) ||
                (bookmarkId && shouldEnableBookmarkDrawers && isUnsaved)) {
                return Bookmark;
            }
            return BookmarkActivated;
        };
        let ariaLabel = completionLabel || linkObj.label;
        if (isOnboarding) {
            ariaLabel =
                onboardingAriaLabel ||
                    intl.formatMessage(translations.onboardingAriaLabel);
        }
        const bookmarkButtonLabel = bookmarkId
            ? bookmarkIconTitleForSaved ||
                intl.formatMessage(translations.bookmarkButtonLabelSaved)
            : bookmarkIconTitle ||
                intl.formatMessage(translations.bookmarkButtonLabelBookmark);
        return !isBookmarkButton ? (React.createElement(React.Fragment, null,
            React.createElement(SocialIcon, { bookmarkIconTitle: bookmarkTitleToUse, bookmarkSideBarLabel: bookmarkSideBarLabel, linkRef: this.iconLinkRef, link: { ...linkObj, label: ariaLabel }, theme: theme, type: type, onClick: toggleBookmark, shouldDisableBookmark: !hasLoaded, isOnboarding: isOnboarding, hideOnboardingSpotlight: isOnboarding && isTooltipVisible, showDistinctiveBookmark: showDistinctiveBookmark }),
            isOnboarding && (React.createElement(Alert.BookmarkIcon, { bookmarkIconAlertDesktopLeft: bookmarkIconAlertDesktopLeft, bookmarkIconAlertDesktopTop: bookmarkIconAlertDesktopTop, isVisible: isTooltipVisible },
                React.createElement("div", null, bookmarkAlert || intl.formatMessage(translations.alert)))))) : (React.createElement(React.Fragment, null,
            React.createElement(SocialIconButton, { hasEnableIcon: true, isIconButton: isIconButton, iconPosition: "before", ButtonIcon: isBookmarkActive(), label: bookmarkButtonLabel, onClickHandler: (e) => {
                    e.stopPropagation();
                    toggleBookmark(e);
                } }),
            showMessageBanner && (React.createElement(DrawerMessageBanner, { action: bannerProps.action, bannerType: "saveRemoved" }))));
    }
}
BookmarkIcon.propTypes = {
    bookmarkAlert: PropTypes.string,
    bookmarkCompletionAriaLabel: PropTypes.string,
    bookmarkIconAlertDesktopLeft: PropTypes.string,
    bookmarkIconAlertDesktopTop: PropTypes.string,
    bookmarkIconAriaLabel: PropTypes.string,
    bookmarkIconTitle: PropTypes.string,
    bookmarkIconTitleForSaved: PropTypes.string,
    bookmarkId: PropTypes.number,
    bookmarkSideBarLabel: PropTypes.string,
    bookmarkTrackingType: PropTypes.string,
    completeOnboarding: PropTypes.func,
    contentID: PropTypes.string,
    contentTitle: PropTypes.string,
    contentType: PropTypes.string,
    copilotID: PropTypes.string,
    displayBookmarkAlert: PropTypes.func,
    documentUrl: PropTypes.string,
    doUpdateBookmarkedStatus: PropTypes.func,
    doUpdateUnsavedBookmarks: PropTypes.func,
    image: PropTypes.object,
    intl: PropTypes.object,
    isBookmarkButton: PropTypes.bool,
    isIconButton: PropTypes.bool,
    // eslint-disable-next-line react/no-unused-prop-types
    isPageScoped: PropTypes.bool,
    isUrlBookmark: PropTypes.bool,
    link: PropTypes.shape({
        behavior: PropTypes.string,
        className: PropTypes.string,
        handle: PropTypes.string,
        label: PropTypes.string.isRequired,
        network: PropTypes.oneOf([
            'bookmark',
            'Bookmark',
            'bluesky',
            'BlueSky',
            'email',
            'Email',
            'facebook',
            'Facebook',
            'flipboard',
            'Flipboard',
            'GoogleNews',
            'googlenews',
            'instagram',
            'Instagram',
            'line',
            'Line',
            'linkedin',
            'LinkedIn',
            'ok',
            'OK',
            'pinterest',
            'Pinterest',
            'print',
            'Print',
            'snapchat',
            'Snapchat',
            'spotify',
            'Spotify',
            'store',
            'Store',
            'telegram',
            'Telegram',
            'threads',
            'Threads',
            'tiktok',
            'Tiktok',
            'tumblr',
            'Tumblr',
            'twitter',
            'Twitter',
            'vero',
            'Vero',
            'viber',
            'Viber',
            'vk',
            'VK',
            'wechat',
            'WeChat',
            'weibo',
            'Weibo',
            'whatsapp',
            'Whatsapp',
            'yandexzen',
            'YandexZen',
            'youtube',
            'YouTube'
        ]).isRequired,
        url: PropTypes.string
    }),
    onboardingAriaLabel: PropTypes.string,
    onboardingStep: PropTypes.string,
    openCollectionsDrawer: PropTypes.func,
    organizationID: PropTypes.string,
    setLastBookmarkedPhoto: PropTypes.func,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    showDistinctiveBookmark: PropTypes.bool,
    signInHed: PropTypes.string,
    signInHedSpanTag: PropTypes.string,
    signInMessage: PropTypes.string,
    snowplowEvent: PropTypes.shape({
        index: PropTypes.number,
        total_index: PropTypes.number,
        placement: PropTypes.string
    }),
    subject: PropTypes.string,
    subtype: PropTypes.string,
    theme: PropTypes.oneOf([
        'footer',
        'has-background',
        'circular',
        'overlay',
        'standard'
    ]),
    type: PropTypes.oneOf(['thinner', 'thin', 'standard']).isRequired,
    unsavedBookmarks: PropTypes.object,
    updateBookmark: PropTypes.func,
    user: PropTypes.shape({
        amguuid: PropTypes.string,
        isAuthenticated: PropTypes.bool
    }),
    userPlatform: PropTypes.shape({
        federatedGraphqlUrl: PropTypes.string,
        siteCode: PropTypes.string,
        userPlatformProxy: PropTypes.string,
        xClientID: PropTypes.string
    })
};
BookmarkIcon.defaultProps = {
    bookmarkTrackingType: 'header',
    isIconButton: false,
    shouldUseBookmarkV3: false,
    showDistinctiveBookmark: true
};
BookmarkIcon.displayName = 'BookmarkIcon';
const OnboardedBookmarkIcon = withOnboarding(injectIntl(BookmarkIcon), 'bookmarks');
module.exports = {
    BookmarkIcon: connectToStore(mapStateToProps, mapDispatchToProps)(asConfiguredComponent(OnboardedBookmarkIcon, 'BookmarkIcon')),
    // Note BookmarkIconWithoutHOCs is now wrapped in a HOC for i18n - renaming feels potentially more confusing?
    BookmarkIconWithoutHOCs: injectIntl(BookmarkIcon)
};
//# sourceMappingURL=BookmarkIcon.js.map

/***/ }),

/***/ 69496:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { combinedOnClick, getUrl } = __webpack_require__(5177);
// Standard Icons
const BookmarkStd = __webpack_require__(43706);
const BookmarkActivatedStd = __webpack_require__(20215);
const BlueSkyStd = __webpack_require__(59257);
const EmailStd = __webpack_require__(49140);
const FacebookStd = __webpack_require__(67818);
const FlipboardStd = __webpack_require__(73137);
const GoogleNewsStd = __webpack_require__(15514);
const InstagramStd = __webpack_require__(33528);
const LineStd = __webpack_require__(80636);
const LinkedInStd = __webpack_require__(41876);
const NewsletterStd = __webpack_require__(86173);
const OKStd = __webpack_require__(56148);
const PinterestStd = __webpack_require__(80890);
const PrintStd = __webpack_require__(7967);
const RssStd = __webpack_require__(94416);
const ShoppingStd = __webpack_require__(10934);
const SnapchatStd = __webpack_require__(10312);
const SpotifyStd = __webpack_require__(84502);
const TelegramStd = __webpack_require__(74561);
const ThreadsStd = __webpack_require__(10033);
const TiktokStd = __webpack_require__(28304);
const TumblrStd = __webpack_require__(30920);
const TwitterStd = __webpack_require__(63579);
const VeroStd = __webpack_require__(35788);
const ViberStd = __webpack_require__(81058);
const VKStd = __webpack_require__(74921);
const WeChatStd = __webpack_require__(36108);
const WeiboStd = __webpack_require__(75088);
const WhatsappStd = __webpack_require__(87924);
const XingStd = __webpack_require__(40426);
const YandexZenStd = __webpack_require__(94342);
const YouTubeStd = __webpack_require__(57961);
// Thin Icons
const BookmarkThin = __webpack_require__(315);
const BookmarkActivatedThin = __webpack_require__(52585);
const BlueSkyThin = __webpack_require__(81463);
const EmailThin = __webpack_require__(57942);
const FacebookThin = __webpack_require__(69192);
const FlipboardThin = __webpack_require__(50907);
const GoogleNewsThin = __webpack_require__(24596);
const InstagramThin = __webpack_require__(7994);
const LineThin = __webpack_require__(8990);
const LinkedInThin = __webpack_require__(25534);
const OKThin = __webpack_require__(22650);
const PinterestThin = __webpack_require__(24888);
const PrintThin = __webpack_require__(40641);
const ShoppingThin = __webpack_require__(64964);
const SnapchatThin = __webpack_require__(74170);
const SpotifyThin = __webpack_require__(59596);
const TelegramThin = __webpack_require__(46119);
const ThreadsThin = __webpack_require__(29011);
const TiktokThin = __webpack_require__(50610);
const TumblrThin = __webpack_require__(32262);
const TwitterThin = __webpack_require__(33189);
const VeroThin = __webpack_require__(34214);
const ViberThin = __webpack_require__(16576);
const VKThin = __webpack_require__(52783);
const WeChatThin = __webpack_require__(85858);
const WeiboThin = __webpack_require__(93470);
const WhatsappThin = __webpack_require__(90370);
const YouTubeThin = __webpack_require__(92459);
// Thinner Icons
const BookmarkThr = __webpack_require__(70931);
const BookmarkActivatedThr = __webpack_require__(64736);
const EmailThr = __webpack_require__(43403);
const FacebookThr = __webpack_require__(23871);
const ShoppingThr = __webpack_require__(61599);
const TwitterThr = __webpack_require__(98152);
const PrintThr = __webpack_require__(19368);
const WhatsappThr = __webpack_require__(69301);
const { SocialIconsListItem, SocialIconViewBox, SocialIconContainer, SocialIconExternalLink, SocialIconNetworkIconComponent } = __webpack_require__(51000);
const NETWORK_ICONS_NAME_MAP = {
    bookmark: 'Bookmark',
    bookmarkactivated: 'BookmarkActivated',
    bluesky: 'BlueSky',
    email: 'Email',
    facebook: 'Facebook',
    flipboard: 'Flipboard',
    googlenews: 'GoogleNews',
    instagram: 'Instagram',
    line: 'Line',
    linkedin: 'LinkedIn',
    newsletter: 'Newsletter',
    ok: 'OK',
    pinterest: 'Pinterest',
    print: 'Print',
    rss: 'Rss',
    snapchat: 'Snapchat',
    spotify: 'Spotify',
    store: 'Shopping',
    telegram: 'Telegram',
    threads: 'Threads',
    tiktok: 'Tiktok',
    tumblr: 'Tumblr',
    twitter: 'Twitter',
    vero: 'Vero',
    viber: 'Viber',
    vk: 'VK',
    wechat: 'WeChat',
    weibo: 'Weibo',
    whatsapp: 'Whatsapp',
    xing: 'Xing',
    yandexzen: 'YandexZen',
    youtube: 'YouTube'
};
const STANDARD_ICON_MAP = {
    Bookmark: BookmarkStd,
    BookmarkActivated: BookmarkActivatedStd,
    BlueSky: BlueSkyStd,
    Email: EmailStd,
    Facebook: FacebookStd,
    Flipboard: FlipboardStd,
    GoogleNews: GoogleNewsStd,
    Instagram: InstagramStd,
    Line: LineStd,
    LinkedIn: LinkedInStd,
    Newsletter: NewsletterStd,
    OK: OKStd,
    Pinterest: PinterestStd,
    Print: PrintStd,
    Rss: RssStd,
    Shopping: ShoppingStd,
    Snapchat: SnapchatStd,
    Spotify: SpotifyStd,
    Telegram: TelegramStd,
    Threads: ThreadsStd,
    Tiktok: TiktokStd,
    Tumblr: TumblrStd,
    Twitter: TwitterStd,
    Vero: VeroStd,
    Viber: ViberStd,
    VK: VKStd,
    WeChat: WeChatStd,
    Weibo: WeiboStd,
    Whatsapp: WhatsappStd,
    Xing: XingStd,
    YandexZen: YandexZenStd,
    YouTube: YouTubeStd
};
const THIN_ICON_MAP = {
    Bookmark: BookmarkThin,
    BookmarkActivated: BookmarkActivatedThin,
    BlueSky: BlueSkyThin,
    Email: EmailThin,
    Facebook: FacebookThin,
    Flipboard: FlipboardThin,
    GoogleNews: GoogleNewsThin,
    Instagram: InstagramThin,
    Line: LineThin,
    LinkedIn: LinkedInThin,
    OK: OKThin,
    Pinterest: PinterestThin,
    Print: PrintThin,
    Shopping: ShoppingThin,
    Snapchat: SnapchatThin,
    Spotify: SpotifyThin,
    Telegram: TelegramThin,
    Threads: ThreadsThin,
    Tiktok: TiktokThin,
    Tumblr: TumblrThin,
    Twitter: TwitterThin,
    Vero: VeroThin,
    Viber: ViberThin,
    VK: VKThin,
    WeChat: WeChatThin,
    Weibo: WeiboThin,
    Whatsapp: WhatsappThin,
    YouTube: YouTubeThin
};
const THINNER_ICON_MAP = {
    Bookmark: BookmarkThr,
    BookmarkActivated: BookmarkActivatedThr,
    Email: EmailThr,
    Facebook: FacebookThr,
    Shopping: ShoppingThr,
    Twitter: TwitterThr,
    Print: PrintThr,
    Whatsapp: WhatsappThr
};
const ICON_SIZE = {
    standard: '32px',
    thin: '24px',
    thinner: '16px'
};
/**
 * SocialIcon component
 *
 * @param {object} props - React Props
 * @param {string} [props.bookmarkIconTitle] - bookmark icon title
 * @param {string} [props.bookmarkSideBarLabel] - new bookmark sidebar text
 * @param {string} [props.className] - Optional top-level class to add
 * @param {object} props.link - Link object ({ handle, label, network, url }) properties. `label` and `network` are both required, but only one of `handle` OR `url` are required.
 * @param {string} [props.link.behavior] - Whether to open the link in a new window
 * @param {string} [props.link.handle] - The social media handle
 * @param {string} props.link.label - Aria label for icon
 * @param {string} props.link.network - The social media network
 * @param {string} [props.link.url] - The URL for the social account
 * @param {object} [props.linkRef] - Optional React ref to the SocialIcon's link component
 * @param {Function} [props.onClick] - Optional onClick function to override the onClick behavior of this component
 * @param {string} [props.theme] - Optional theme ['footer', 'has-background', 'circular', 'overlay', 'standard']
 * @param {string} [props.type] - The type of icon
 * @param {integer} [props.totalItems] - The total social icons in a particular list
 * @param {integer} [props.itemIndex] - The index of social icon
 * @param {bool} [props.shouldDisableBookmark] - disable bookmark
 * @param {bool} [props.isOnboarding] - onboarding spotlight
 * @param {bool} [props.hideOnboardingSpotlight] - hide onboarding spotlight
 * @param {string} [props.iconColor] - Optional Icon fill color
 * @param {bool} [props.showDistinctiveBookmark] - Optional prop to style bookmark differently to other social icons, defaults to true to preserve original behavior
 * @returns {ReactElement} <div>
 */
const SocialIcon = ({ bookmarkIconTitle, bookmarkSideBarLabel = 'New!', className, iconColor, link, itemIndex, linkRef, totalItems, onClick, theme, type, shouldDisableBookmark, isOnboarding, hideOnboardingSpotlight, showDistinctiveBookmark }) => {
    const isOverlay = theme === 'overlay';
    const socialLink = getUrl(link);
    const network = link.network.toLowerCase();
    const networkIconName = NETWORK_ICONS_NAME_MAP[network];
    if (!networkIconName) {
        return null;
    }
    const thinIcon = type === 'thin' && THIN_ICON_MAP[networkIconName];
    const thinnerIcon = type === 'thinner' && THINNER_ICON_MAP[networkIconName];
    const NetworkIconComponent = thinIcon || thinnerIcon || STANDARD_ICON_MAP[networkIconName];
    return (React.createElement(SocialIconsListItem, { network: network, shouldDisableBookmark: shouldDisableBookmark, isOnboarding: isOnboarding, hideOnboardingSpotlight: hideOnboardingSpotlight, bookmarkSideBarLabel: bookmarkSideBarLabel, themeType: theme, thinner: !!thinnerIcon, thin: !!thinIcon, className: classnames(`social-icons__list-item social-icons__list-item--${network}`, {
            'social-icons__list-item--has-background': isOverlay
        }, `social-icons__list-item--${theme}`, { thinner: !!thinnerIcon }, className) },
        React.createElement(SocialIconExternalLink, { attributes: {
                'aria-label': link.label,
                ...(networkIconName === NETWORK_ICONS_NAME_MAP.pinterest && {
                    'data-pin-do': 'nothing'
                })
            }, className: `social-icons__link social-icons__link--${network}`, href: socialLink, onClick: (event) => combinedOnClick(onClick, link, itemIndex, totalItems, socialLink, event), isExternal: false, linkRef: linkRef, themeType: theme, network: network, thin: !!thinIcon, iconColor: iconColor, showDistinctiveBookmark: showDistinctiveBookmark },
            React.createElement(SocialIconViewBox, { className: "social-icons__icon-container" },
                React.createElement(SocialIconContainer, { size: ICON_SIZE[type] }, bookmarkIconTitle ? (React.createElement(SocialIconNetworkIconComponent, { as: NetworkIconComponent, bookmarkIconTitle: bookmarkIconTitle, bookmarkSideBarLabel: bookmarkSideBarLabel })) : (React.createElement(SocialIconNetworkIconComponent, { as: NetworkIconComponent })))))));
};
SocialIcon.propTypes = {
    bookmarkIconTitle: PropTypes.string,
    bookmarkSideBarLabel: PropTypes.string,
    className: PropTypes.string,
    hideOnboardingSpotlight: PropTypes.bool,
    iconColor: PropTypes.string,
    isOnboarding: PropTypes.bool,
    itemIndex: PropTypes.number,
    link: PropTypes.shape({
        behavior: PropTypes.string,
        className: PropTypes.string,
        handle: PropTypes.string,
        label: PropTypes.string.isRequired,
        network: PropTypes.oneOf([
            'bookmark',
            'Bookmark',
            'BookmarkActivated',
            'bookmarkactivated',
            'bluesky',
            'BlueSky',
            'canonical',
            'Canonical',
            'email',
            'Email',
            'facebook',
            'Facebook',
            'flipboard',
            'Flipboard',
            'GoogleNews',
            'googlenews',
            'instagram',
            'Instagram',
            'line',
            'Line',
            'linkedin',
            'LinkedIn',
            'newsletter',
            'Newsletter',
            'ok',
            'OK',
            'pinterest',
            'Pinterest',
            'print',
            'Print',
            'rss',
            'Rss',
            'snapchat',
            'Snapchat',
            'spotify',
            'Spotify',
            'store',
            'Store',
            'telegram',
            'Telegram',
            'threads',
            'Threads',
            'tiktok',
            'Tiktok',
            'TikTok',
            'tumblr',
            'Tumblr',
            'twitter',
            'Twitter',
            'vero',
            'Vero',
            'viber',
            'Viber',
            'vk',
            'VK',
            'wechat',
            'WeChat',
            'xing',
            'Xing',
            'weibo',
            'Weibo',
            'Whatsapp',
            'yandexzen',
            'YandexZen',
            'youtube',
            'YouTube'
        ]).isRequired,
        url: PropTypes.string
    }),
    linkRef: PropTypes.object,
    onClick: PropTypes.func,
    shouldDisableBookmark: PropTypes.bool,
    showDistinctiveBookmark: PropTypes.bool,
    theme: PropTypes.oneOf([
        'footer',
        'has-background',
        'circular',
        'overlay',
        'standard'
    ]),
    totalItems: PropTypes.number,
    type: PropTypes.oneOf(['thinner', 'thin', 'standard']).isRequired
};
module.exports = SocialIcon;
//# sourceMappingURL=SocialIcon.js.map

/***/ }),

/***/ 67783:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const SocialIcon = __webpack_require__(69496);
const { BookmarkIcon } = __webpack_require__(72964);
const { SocialIconsList, SocialIconsWrapper } = __webpack_require__(51000);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * SocialIcons component
 *
 * @param {string} [bookmarkTrackingType] - bookmark position for tracking
 * @param {string} [className] - Optional top-level class to add
 * @param {boolean} [hasRoundedBorders] - Optional borders around the social icons, defaults to false.
 * @param {boolean} [hasSocialShare] - Optional flag for social share, defaults to false.
 * @param {string} [icons] - Optional icon type
 * @param {Array<object>} links - A list of `{ handle, label, network, url, behavior }` objects. `label` and `network` are required, one of `handle` OR `url` are required, `behavior` is optional.
 * @param {boolean} [showBookmark] - Optional bookmark visibility flag
 * @param {object} [props.variations] - Optional variations
 * @param {string} [props.variations.theme] - Optional theme ['footer', 'has-background', 'overlay', 'standard']
 * @param {string} [props.iconColor] - Optional string for social icon fill color
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @returns {ReactElement} <div>
 */
const SocialIcons = ({ bookmarkTrackingType, className, links, iconColor = null, icons = 'standard', variations = {
    theme: 'has-background'
}, showBookmark, hasRoundedBorders = false, hasSocialShare = false, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SocialIcons'
        });
    }, [variationName]);
    // If the bookmarking feature is not enabled we are filtering out the object that includes its data
    const filteredLinks = !showBookmark
        ? links.filter((i) => i.network !== 'bookmark' && i.network !== 'bookmarkactivated')
        : links;
    return (React.createElement(SocialIconsWrapper, { className: classnames(`social-icons social-icons--${variations.theme}`, className), themeType: variations.theme, hasRoundedBorders: hasRoundedBorders, hasSocialShare: hasSocialShare, "data-testid": "social-icons" },
        React.createElement(SocialIconsList, { themeType: variations.theme, "data-testid": "socialIconslist", className: "social-icons__list" }, filteredLinks.map((item, index) => {
            return item.behavior && item.behavior === 'bookmark' ? (React.createElement(BookmarkIcon, { bookmarkIconAlertDesktopLeft: variations.theme === 'footer' ? 'calc(100% + 1rem)' : '120%', bookmarkIconAlertDesktopTop: variations.theme === 'footer' ? '0' : '70%', bookmarkTrackingType: bookmarkTrackingType, key: index, link: item, theme: variations.theme, type: icons || 'standard' })) : (React.createElement(SocialIcon, { key: index, itemIndex: index, link: item, totalItems: filteredLinks.length, theme: variations.theme, type: icons || 'standard', iconColor: iconColor }));
        }))));
};
SocialIcons.propTypes = {
    bookmarkTrackingType: PropTypes.string,
    className: PropTypes.string,
    hasRoundedBorders: PropTypes.bool,
    hasSocialShare: PropTypes.bool,
    iconColor: PropTypes.string,
    icons: PropTypes.oneOf(['thinner', 'thin', 'standard']),
    links: PropTypes.arrayOf(SocialIcon.propTypes.link).isRequired,
    showBookmark: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        theme: PropTypes.oneOf([
            'footer',
            'has-background',
            'circular',
            'overlay',
            'standard'
        ])
    })
};
SocialIcons.displayName = 'SocialIcons';
module.exports = SocialIcons;
//# sourceMappingURL=SocialIcons.js.map

/***/ }),

/***/ 5177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { trackNavigationEvent } = __webpack_require__(14307);
function generateOnClick(behavior, url) {
    if (behavior === 'popup') {
        return (event) => {
            event.preventDefault();
            window.open(url, 'targetWindow', 'toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes,width=550,height=450');
        };
    }
    if (behavior === 'print') {
        return (event) => {
            event.preventDefault();
            window.print();
        };
    }
    // default to no onClick behavior
    return undefined;
}
function normalizeHandle(handle, network) {
    switch (network) {
        case 'snapchat':
            return `add/${handle.replace('@', '')}`;
        default:
            return handle.replace('@', '');
    }
}
function normalizeSocialLink(handle, network) {
    const normalizedHandle = normalizeHandle(handle, network);
    /** If it is a valid URL, it should be returned without change.
     * If it throws an error, then it is not a valid URL and should be normalized.
     * */
    try {
        new URL(normalizedHandle);
        return normalizedHandle;
    }
    catch (e) {
        return `https://www.${network}.com/${normalizedHandle}`;
    }
}
function getUrl({ handle, network, url }) {
    const networkLower = network.toLowerCase();
    const isEmailAddress = networkLower === 'email';
    if (isEmailAddress) {
        return handle || url;
    }
    const shouldNormalized = !url && handle;
    if (shouldNormalized) {
        return normalizeSocialLink(handle, networkLower);
    }
    return url;
}
function trackSnowplowEvent(link, index, totalItems) {
    if (!link) {
        return;
    }
    const eventData = {
        type: 'click',
        label: link.label,
        subject: 'social_icon',
        index,
        total_index: totalItems,
        share_platform: link.network.toLowerCase()
    };
    trackNavigationEvent(eventData);
}
function combinedOnClick(onClick, link, itemIndex, totalItems, socialLink, event) {
    trackSnowplowEvent(link, itemIndex, totalItems);
    const onClickHandler = onClick || generateOnClick(link.behavior, socialLink);
    if (onClickHandler) {
        onClickHandler(event);
    }
}
module.exports = {
    normalizeHandle,
    normalizeSocialLink,
    getUrl,
    trackSnowplowEvent,
    combinedOnClick
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 35676:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(85584);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 51000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const ExternalLink = __webpack_require__(39832);
const { linkClean } = __webpack_require__(15737);
const Button = __webpack_require__(73730);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const iconSocialSmall = calculateSpacing(5, 'px');
const disableBookmarkStyle = `
  pointer-events: none;
  touch-action: none;
`;
const printIconStyle = `
  display: none;
  @media (min-width: ${BREAKPOINTS.lg}) {
    display: inline;
  }
`;
const SocialIconViewBox = styled.div.withConfig({
    displayName: 'SocialIconViewBox'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;

  .icon {
    width: 100%;
    height: 100%;
  }

  .icon-shopping {
    width: initial;
    height: initial;
  }
`;
const SocialIconContainer = styled.div.withConfig({
    displayName: 'SocialIconContainer'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  ${({ size }) => `
    height: ${size};
    width: ${size};
  `}

  &&&& .icon {
    transform: none;
    width: 100%;
    height: 100%;
  }
`;
const interactiveBaseBrandPrimary = 'colors.interactive.base.brand-primary';
const interactiveSocialPrimaryHover = 'colors.interactive.social.primary-hover';
const iconBookmarkFillStrokeColor = (theme, color) => `
  .icon-bookmark-fill,
  .icon-bookmark-stroke {
    ${getColorStyles(theme, 'fill', color)};
  }
`;
const hasBackgroundBookmarkExternalLinkStyle = (network, thin, theme) => {
    if (network === 'bookmark') {
        return `
    ${getColorStyles(theme, 'background', 'colors.interactive.base.dark')};
    @media (min-width: ${BREAKPOINTS.lg}) {
      ${getColorStyles(theme, 'background', 'colors.interactive.social.primary')};
    }
    ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.white')};
    &:hover {
      ${getColorStyles(theme, 'background', interactiveBaseBrandPrimary)};
    }
    ${thin &&
            `
      &:focus,
      &:hover {
        ${getColorStyles(theme, 'background', interactiveSocialPrimaryHover)};
      }
    `};
  `;
    }
    else if (network === 'bookmarkactivated') {
        return `
    background: none;
    &:hover {
      ${getColorStyles(theme, 'background', 'colors.interactive.base.light')};
      .icon-bookmark--activated-checkmark-stroke {
        ${getColorStyles(theme, 'stroke', 'colors.interactive.base.light')};
      }
    }
    ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.white')}
  `;
    }
    return '';
};
const hasBackgroundExternalLinkStyle = (network, thin, theme, showDistinctiveBookmark) => `      
  ${getColorStyles(theme, 'background', 'colors.interactive.social.primary')};
  path {
    ${getColorStyles(theme, 'fill', 'colors.interactive.social.secondary')};
  }
  &:hover {
    background: ${getColorStyles(theme, interactiveSocialPrimaryHover)};
    path {
      ${getColorStyles(theme, 'fill', 'colors.interactive.social.secondary-hover')};
    }
  }
  ${showDistinctiveBookmark &&
    hasBackgroundBookmarkExternalLinkStyle(network, thin, theme)}
`;
const circularNetworkExternalLinkStyle = (network, theme) => {
    if (network === 'bookmark') {
        return `
      ${getColorStyles(theme, 'background', 'colors.interactive.base.light')};
      @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
        background: ${getColorStyles(theme, interactiveBaseBrandPrimary)};
      }
      @media (min-width: ${BREAKPOINTS.md}) {
        ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.black')}
        &:hover {
          ${getColorStyles(theme, 'background', 'colors.interactive.base.dark')};
          ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.white')}
        }
      }
    `;
    }
    else if (network === 'bookmarkactivated') {
        return `
      ${getColorStyles(theme, 'background', interactiveBaseBrandPrimary)};
      border-radius: 50%;
      width: ${iconSocialSmall};
      height: ${iconSocialSmall};
    `;
    }
    else if (network === 'print') {
        return `
      rect {
        &.background {
          ${getColorStyles(theme, 'fill', 'colors.interactive.social.primary')};
        }
      }
      &:hover {
        rect {
          &.background {
            ${getColorStyles(theme, 'fill', interactiveSocialPrimaryHover)};
          }
        }
      }
    `;
    }
    return '';
};
const standardExternalLinkStyle = (network, thin, theme) => {
    if (network === 'bookmark') {
        return `
    border-radius: 50%;
    ${getColorStyles(theme, 'background', 'colors.interactive.base.light')};
    width: ${iconSocialSmall};
    height: ${iconSocialSmall};
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.lg}) {
      margin-top: ${calculateSpacing(0.25)};
    }
    @media (min-width: ${BREAKPOINTS.md}) {
      ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.black')}
      &:hover {
        ${getColorStyles(theme, 'background', interactiveSocialPrimaryHover)};
        ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.white')}
      }
    }
    path.icon-bookmark-stroke,
    path.icon-bookmark-fill {
      ${getColorStyles(theme, 'fill', 'colors.interactive.base.black')};
    }
    path.icon-bookmark-fill {
      ${getColorStyles(theme, 'fill', 'colors.interactive.social.primary')};
    }
    ${thin &&
            `
      ${getColorStyles(theme, 'background', 'colors.interactive.base.light')};
      &:focus,
      &:hover {
        ${getColorStyles(theme, 'background', interactiveSocialPrimaryHover)};
      }
    `};
  `;
    }
    else if (network === 'bookmarkactivated') {
        return `
    border-radius: 50%;
    ${getColorStyles(theme, 'background', interactiveBaseBrandPrimary)};
    width: ${iconSocialSmall};
    height: ${iconSocialSmall};
    @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
      margin-top: ${calculateSpacing(0.25)};
    }
    @media (min-width: ${BREAKPOINTS.md}) {
      ${getColorStyles(theme, 'background', interactiveBaseBrandPrimary)};
      ${iconBookmarkFillStrokeColor(theme, 'colors.interactive.base.white')}
    }
    path.icon-bookmark-fill,
    path.icon-bookmark-stroke {
      ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
    }
    path.icon-bookmark--activated-checkmark-stroke {
      @media (min-width: 0) and (max-width: ${BREAKPOINTS.lg}) {
        ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
        transition: all 0.2s ease-in-out;
      }
    } 
  `;
    }
    return '';
};
const SocialIconExternalLink = styled(ExternalLink).withConfig({
    displayName: 'SocialIconExternalLink'
}) `
  ${linkClean()}
  display: flex;
  align-items: center;
  justify-content: center;
  width: ${calculateSpacing(6)};
  height: ${calculateSpacing(6)};

  ${({ themeType, network, theme }) => themeType === 'circular' &&
    `
    margin-bottom: 10px;
    border-radius: 100%;
    width: ${iconSocialSmall};
    height: ${iconSocialSmall};
    path {
      fill: white;
    }
    ${getColorStyles(theme, 'background', 'colors.interactive.social.primary')};
    ${circularNetworkExternalLinkStyle(network, theme)}
    &:hover {
      ${getColorStyles(theme, 'background', interactiveSocialPrimaryHover)};
    }
  `};

  ${({ themeType, theme }) => themeType === 'footer' &&
    `
    path {
      ${getColorStyles(theme, 'fill', 'colors.foundation.footer.links.primary')};
    }
    &:hover {
      path {
        ${getColorStyles(theme, 'fill', 'colors.foundation.footer.social.hover')};
      }
    }
  `};

  ${({ themeType, network, thin, theme, showDistinctiveBookmark }) => themeType === 'has-background' &&
    hasBackgroundExternalLinkStyle(network, thin, theme, showDistinctiveBookmark)};

  ${({ themeType, network, thin, theme, showDistinctiveBookmark }) => themeType === 'overlay' &&
    `
    ${hasBackgroundExternalLinkStyle(network, thin, theme, showDistinctiveBookmark)}
    border-radius: 50%;
    &:focus {
      outline: 0;
      box-shadow: 0 0 3pt 2pt rgba(94, 158, 214, 1);
    }
    .icon {
      width: 32px;
      height: 32px;
    }
  `};

  ${({ themeType, network, thin, theme, iconColor, showDistinctiveBookmark }) => {
    if (themeType === 'standard') {
        const activatedBookmarkCheckmarkStrokeColor = showDistinctiveBookmark
            ? 'colors.interactive.social.primary'
            : 'colors.interactive.base.white';
        const iconStyles = `
      .icon {
        path {
          ${iconColor
            ? getColorStyles(theme, 'fill', `colors.interactive.social.${iconColor}`)
            : getColorStyles(theme, 'fill', 'colors.interactive.social.primary')}
        }
        .icon-bookmark--activated-checkmark-stroke {
          fill: none;
          ${getColorStyles(theme, 'stroke', activatedBookmarkCheckmarkStrokeColor)};
        } 
      }`;
        if (!showDistinctiveBookmark) {
            return iconStyles;
        }
        return `
              ${iconStyles}
              &:hover {
                .icon {
                  .icon-bookmark--activated-checkmark-stroke {
                    ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
                    transition: all 0.2s ease-in-out;
                  }
                }
                .icon-bookmark.icon {
                  path {
                    ${getColorStyles(theme, 'fill', 'colors.interactive.base.white')};
                  }
                }
                .icon,
                .icon-bookmark--activated.icon {
                  path {
                    ${getColorStyles(theme, 'fill', interactiveSocialPrimaryHover)};
                  }
                }
              }
              ${standardExternalLinkStyle(network, thin, theme)}
            `;
    }
    return ``;
}};
`;
const onboardingSpotlightThemeVariation = (themeType, theme) => {
    if (themeType === 'circular') {
        return `
      &::before {
        width: ${iconSocialSmall};
        height: ${iconSocialSmall};
      }
      @media (min-width: ${BREAKPOINTS.lg}) {
        &::after {
          ${getColorStyles(theme, 'color', interactiveBaseBrandPrimary)};
        }
      }
      ${SocialIconExternalLink} {
        margin-bottom: 0;
      }
    `;
    }
    else if (themeType === 'footer') {
        return `
      &::before {
        left: 15px;
      }
    `;
    }
    else if (themeType === 'has-background' || themeType === 'overlay') {
        return `
      @media (min-width: 0) and (max-width: ${BREAKPOINTS.md}) {
        &::before {
          margin-top: ${calculateSpacing(0.25)};
        }
      }
      &::before {
        top: 0;
        left: 0;
        transform: scale(1);
      }
    `;
    }
    else if (themeType === 'standard') {
        return `
      ::before {
        padding: 5px;
        @media (min-width: 0) and (max-width: ${BREAKPOINTS.lg}) {
          left: 50%;
          transform: translateX(-50%) scale(1.08); /* centered horizontally; scaled 108% */
          padding: 0;
          width: ${iconSocialSmall};
          height: ${iconSocialSmall};
        }
      }
      @media (min-width: 0) and (max-width: ${BREAKPOINTS.lg}) {
        &::before {
          margin-top: ${calculateSpacing(0.25)};
          margin-left: ${calculateSpacing(1)};
        }
      }
    `;
    }
    return '';
};
const onboardingSpotlightStyle = (themeType, theme, bookmarkSideBarLabel) => `
  position: relative;
  > * {
    position: relative;
    z-index: 10;
  }
  &::before {
    display: block;
    position: absolute;
    top: -1px;
    left: -1px;
    transform: scale(1.08); /* scaled to 108% */
    transform-origin: center;
    transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
    z-index: 1;
    border: 1px solid;
    ${getColorStyles(theme, 'border-color', interactiveBaseBrandPrimary)};
    border-radius: 100%;
    width: ${calculateSpacing(6)}; //1
    height: ${calculateSpacing(6)}; //1
    content: '';
  }
  @media (min-width: ${BREAKPOINTS.lg}) {
    &::after {
      ${getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};
      display: block;
      position: relative;
      bottom: 0;
      left: 0;
      transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
      z-index: 1;
      margin: 8px 0 10px;
      width: 100%;
      text-align: center;
      ${getColorStyles(theme, 'color', 'colors.interactive.base.white')};
      content: '${bookmarkSideBarLabel}';
    }
  }
  ${onboardingSpotlightThemeVariation(themeType, theme)}
`;
const hideOnboardingSpotlightStyle = `
  &::before,
  &::after {
    visibility: hidden;
    opacity: 0;
  }
`;
const defaultBookmarkActivatedStyle = `
  @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
    margin-top: ${calculateSpacing(0.25)};
  }
  .icon-bookmark {
    @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
      margin-top: 0;
    }
  }
`;
const defaultNetworkStyle = (thin, thinner, network) => {
    if (thin) {
        if (network === 'bookmarkactivated') {
            return `${defaultBookmarkActivatedStyle}`;
        }
        else if (network === 'bookmark') {
            return `
      @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
        margin-top: ${calculateSpacing(0.25)};
      }`;
        }
    }
    else if (thinner) {
        if (network === 'bookmarkactivated') {
            return defaultBookmarkActivatedStyle;
        }
        else if (network === 'bookmark') {
            return `
      @media (min-width: ${BREAKPOINTS.md}) {
        margin-top: ${calculateSpacing(0.25)};
      }
      @media (min-width: ${BREAKPOINTS.lg}) {
        margin-top: ${calculateSpacing(0)};
      }
    `;
        }
    }
    return '';
};
const SocialIconsListItem = styled.li.withConfig({
    displayName: 'SocialIconsListItem'
}) `
  ${({ thin, thinner, network }) => defaultNetworkStyle(thin, thinner, network)}

  ${({ shouldDisableBookmark }) => shouldDisableBookmark && disableBookmarkStyle}

  ${({ network }) => network === 'print' && printIconStyle}

  ${({ themeType, thinner }) => themeType === 'circular' &&
    `
    &.social-icons--share {
      background: white;
    }
    ${thinner &&
        `
      .icon {
        object-fit: contain;
        &.icon-bookmark {
          margin-top: -2px;
        }
      }
    `};
    .icon {
      width: 32px;
      height: 32px;
    }
  `}
    
  ${({ isOnboarding, themeType, theme, bookmarkSideBarLabel }) => isOnboarding &&
    onboardingSpotlightStyle(themeType, theme, bookmarkSideBarLabel)}

  ${({ hideOnboardingSpotlight }) => hideOnboardingSpotlight && hideOnboardingSpotlightStyle}

  ${({ themeType, thinner }) => themeType === 'standard' &&
    `
    ${thinner &&
        `
      &.social-icons--share {
        background: white;
      }
      .icon {
        object-fit: contain;
        &.icon-bookmark {
          margin-top: -2px;
        }
        &.icon-bookmark--activated{
          margin-top: -2px;
          @media (min-width: ${BREAKPOINTS.md}) and (max-width: ${BREAKPOINTS.lg}) {
            margin-top: 0px;
          }
        }
      }
    `};
  `}

  ${({ themeType, thinner }) => themeType === 'footer' &&
    thinner &&
    `
      ${SocialIconViewBox} {
        width: 22px;
        height: 22px;
      }
  `}
`;
const SocialIconsList = styled.ul.withConfig({
    displayName: 'SocialIconsList'
}) `
  display: flex;
  flex-wrap: wrap;
  gap: ${calculateSpacing(2)};
  align-items: center;
  margin-top: 0;
  margin-bottom: 0;
  margin-left: ${calculateSpacing(-2)};
  padding-left: 0;
  list-style: none;
  ${({ themeType }) => themeType === 'overlay' && 'justify-content: center;'};
  ${({ themeType }) => themeType === 'footer' &&
    `
      justify-content: center;
      margin-left: ${calculateSpacing(0)};
      @media (min-width: ${BREAKPOINTS.lg}) {
        justify-content: start;
      }
    `};
`;
const roundedBordersExternalLinkStyle = (primaryColor, hoverColor, theme) => `
  ${SocialIconExternalLink} {
    transition: all 0.2s cubic-bezier(0, 0, 0, 0.8) 0s;
    border: 1px solid;
    ${getColorStyles(theme, 'border-color', primaryColor)};
    border-radius: 50%;
    &:hover,
    &:focus {
      ${getColorStyles(theme, 'border-color', hoverColor)};
    }
  }
`;
const SocialIconsWrapper = styled.div.withConfig({
    displayName: 'SocialIconsWrapper'
}) `
  ${({ themeType }) => themeType === 'overlay' &&
    `
    position: absolute;
    right: ${calculateSpacing(2)};
    bottom: ${calculateSpacing(2)};
    z-index: 10;
  `}
  ${({ themeType, hasRoundedBorders, theme }) => themeType === 'footer' &&
    `
    @media (min-width: ${BREAKPOINTS.sm}) {
      justify-content: start;
    }
    ${hasRoundedBorders &&
        `
      ${roundedBordersExternalLinkStyle('colors.foundation.footer.links.primary', 'colors.foundation.footer.social.hover', theme)}
      ${SocialIconsListItem} {
        padding-bottom: ${calculateSpacing(2)};
      }
    `}
  `};

  ${({ hasRoundedBorders, hasSocialShare, theme }) => {
    if (hasRoundedBorders) {
        return `
      &.content-header__social-share {
        ${roundedBordersExternalLinkStyle('colors.interactive.base.light', interactiveSocialPrimaryHover, theme)}
      }
      ${hasSocialShare &&
            `${roundedBordersExternalLinkStyle('colors.interactive.base.light', interactiveSocialPrimaryHover, theme)}`}`;
    }
    return '';
}}
`;
const SocialIconNetworkIconComponent = styled.div.withConfig({
    displayName: 'SocialIconNetworkIconComponent'
}) `
  .icon-bookmark path {
    transition: all 0.2s ease-in-out;
  }
`;
const SocialIconButton = styled(Button).withConfig({
    displayName: 'SocialIconButton'
}) `
  ${getTypographyStyles('typography.definitions.utility.button-core')};
  align-items: center;
  justify-content: center;
  margin: 24px 0 32px 0;
  border-color: white;
  background: rgba(51, 51, 51, 0.08);
  padding: 17px 20px;

  ${getColorStyles('color', 'colors.interactive.base.black')};

  &:hover {
    ${getTypographyStyles('typography.definitions.utility.button-core')};
    border-color: white;
    background: rgba(51, 51, 51, 0.3);
    ${getColorStyles('color', 'colors.interactive.base.black')};
  }

  &:focus {
    ${getTypographyStyles('typography.definitions.utility.button-core')};
    border-color: white;
    background: rgba(51, 51, 51, 0.3);
    ${getColorStyles('color', 'colors.interactive.base.black')};
  }

  &:active {
    ${getTypographyStyles('typography.definitions.utility.button-core')};
    border-color: white;
    background: rgba(51, 51, 51, 0.08);
    ${getColorStyles('color', 'colors.interactive.base.black')};
  }

  ${({ isIconButton }) => isIconButton &&
    `
    justify-content: center;
    align-items: center;
    padding: 14px 16px;
    width: 48px;
    margin: 0px;
    @media (min-width: ${BREAKPOINTS.md}) {
      display: none;
    }
    `}
`;
module.exports = {
    SocialIconViewBox,
    SocialIconContainer,
    SocialIconsList,
    SocialIconExternalLink,
    SocialIconsWrapper,
    SocialIconsListItem,
    SocialIconNetworkIconComponent,
    SocialIconButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 54890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    bookmarkIconLabel: {
        id: 'BookmarkIcon.Label',
        defaultMessage: 'Story saved',
        description: 'Bookmark icon label'
    },
    onboardingAriaLabel: {
        id: 'BookmarkIcon.OnboardingAriaLabel',
        defaultMessage: 'Save story. Press Enter to save this story for later. Press Escape to dismiss tooltip.',
        description: 'Bookmark icon onboarding ARIA label'
    },
    signInMessage: {
        id: 'BookmarkIcon.SignInMessage',
        defaultMessage: 'After signing in, you can save stories and easily revisit them on any deviceeven off-line.',
        description: 'Bookmark icon sign in message',
        isConfigurable: true
    },
    completionLabel: {
        id: 'BookmarkIcon.CompletionLabel',
        defaultMessage: 'Story saved. To revisit this article, select My Account, then View Saved Stories. Press Escape to dismiss tooltip.',
        description: 'Bookmark icon completion label'
    },
    alert: {
        id: 'BookmarkIcon.Alert',
        defaultMessage: 'Save this story for later.',
        description: 'Bookmark icon alert'
    },
    bookmarkButtonLabelSaved: {
        id: 'BookmarkButton.LabelSaved',
        defaultMessage: 'recipe saved',
        description: 'Bookmark saved button'
    },
    bookmarkButtonLabelBookmark: {
        id: 'BookmarkButton.Label',
        defaultMessage: 'save recipe',
        description: 'Bookmark button label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 85584:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const { asConfiguredComponent } = __webpack_require__(12892);
const SocialIcons = asConfiguredComponent(__webpack_require__(67783), 'SocialIcons');
SocialIcons.Footer = asVariation(SocialIcons, 'Footer', {
    theme: 'footer'
});
SocialIcons.HasBackground = asVariation(SocialIcons, 'HasBackground', {
    theme: 'has-background'
});
SocialIcons.Circular = asVariation(SocialIcons, 'Circular', {
    theme: 'circular'
});
SocialIcons.Overlay = asVariation(SocialIcons, 'Overlay', {
    theme: 'overlay'
});
SocialIcons.Standard = asVariation(SocialIcons, 'Standard', {
    theme: 'standard'
});
module.exports = SocialIcons;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 68712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const isEmpty = __webpack_require__(62193);
const classnames = __webpack_require__(32485);
const { useInView } = __webpack_require__(26855);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const { useViewportObserver } = __webpack_require__(55030);
const Clamp = __webpack_require__(48286);
const ResponsiveAsset = __webpack_require__(86157);
const Rubric = __webpack_require__(51330);
const { sizesFullName } = __webpack_require__(99906);
const StackedRatingsCardSkeleton = __webpack_require__(56915);
const { trackSearchFilterEvent } = __webpack_require__(14307);
const { getIconComponent, RenderRatings } = __webpack_require__(27234);
const { TrackComponentChannel } = __webpack_require__(78788);
const { handlSnowplowNavigationEvent } = __webpack_require__(39182);
const UtilityFeatures = __webpack_require__(23261);
const { StackedRatingsCardWrapper, ImageWrapper, Image, Label, Link, ContentWrapper, Content, Body, Hed, Dek, MetaData, StackedRatingsCardImageIcon, StackedRatingsCardRubric, StackedRatingsCardRubricWrapper, AuthorNameWrapper, StyledUtilityFeaturesWrapper, StyledRatings } = __webpack_require__(1817);
/**
 * StackedRatingsCard component
 *
 * @param {object} [analyticsDataAttribute] - Optional data-section-title attribute for component level tracking
 * @param {string} [authorName] - Optional prop used to display author name
 * @param {string} [props.bookmarkId] - Id of bookmark in user platform system
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} [props.clickHandler] - called when user clicks hed
 * @param {Function} [props.clickHandlerHed] - called when user clicks hed
 * @param {Function} [props.clickHandlerRubric] - called when user clicks rubric
 * @param {string} [contentType] - Optional value needed to show gallery icon
 * @param {string} dangerousHed - Required string value to display hed
 * @param {string} [dangerousDek] - Required value to show the ingredients or dek
 * @param {bool} [hasBookmark] - Optional, used to toggle bookmark icon
 * @param {bool} [hasIcon] - Optional, used to toggle icon
 * @param {bool} [hasRubric] - Optional, used to toggle rubric
 * @param {bool} [hasUnderline] - Optional, used to toggle the underline
 * @param {string} [hedTag] - Option to override the default header html tag when nested within a higher level header
 * @param {Function} [props.iconBookmarkOnClickHandler] - called when user clicks on bookmark icon
 * @param {ResponsiveAsset.propTypes} [image] - Object containing sources for a ResponsiveAsset
 * @param {Array} [imageLabels] - String values to specify imageLabels
 * @param {bool} [isLoading] - Optional value to indicate loading status
 * @param {boolean} [props.isRecircListItem] - Indicates whether the component is used in a recirculation list
 * @param {bool} [hasRoundedBorder] - Optional, used to remove border radius
 * @param {string} layoutPlacement - Optional, decides the layout placement
 * @param {number} [maxDekLines] - Optional, decides the max number of lines of dek to show before truncating
 * @param {number} [maxHedLines] - Optional, decides the max number of lines of hed to show before truncating
 * @param {number} [rating] - Optional one used to showing ratings
 * @param {number} [itemIndex] - Optional prop that contains index of item
 * @param {string} [ratingMethod] - Required to toggle between rating methods
 * @param {string} [ratingPosition] - Optional one used to position the rating section
 * @param {string} [props.recircPlacement] - Flag that determines placement of recirc item
 * @param {string} [props.recircId] - Flag that determines index of the recirc item
 * @param {number} [reviewsCount] - Optional one used to displaying number of reviewers
 * @param {object} [rubric] - Required when rubric is enabled
 * @param {string} [rubricVariation] - Optional rubric variation to use
 * @param {bool} [showAuthorTitle] - Optional property to show the author title.
 * @param {Function} [impressionHandler] - OPtional prop that contains impression handling function
 * @param {bool} [shouldEnableCardLevelBookmark] - Optional prop to include bookmarks on bundle page
 * @param {bool} [shouldEnableCommentsCount] - Optional prop include comment count icon on bundle page
 * @param {bool} [shouldHideDekOnMobileView] - Optional prop to hide dek on mobile view.
 * @param {bool} [shouldHoldImageSpace] - Option to hold image space
 * @param {Array} [props.shouldLimitSavingToContentTypes] - flag to determine if saving should be enabled only on certain content types
 * @param {number} [shouldTrackSnowplowEvent] - Optional prop to track data through snowplow
 * @param {number} [totalItems] - Optional to track the number of results returned
 * @param {object} [props.snowplowEvent] - Optional. Properties that can be passed to snowplow event navigation on click
 * @param {string} [props.shouldUseLargeIconSize] - Optional to use large size icon
 * @param {string} url - Required url to direct to content
 * @param {Function} [props.clickItem] - Optional click item handler for call to action
 * @param {string} [props.copilotID] - Copilot id of the content
 * @param {bool} [props.shouldShowSourceTagName] - Optional to show the source tag names for the recipe in place of rubric
 * @param {bool} [props.sourceTag] - Source tag names for the recipe
 * @param {bool} [props.commentsCount] - total primary comments count added for the story
 * @param {bool} [props.isDenseDesktopVariation] - displays denseDesktop variation (this prop is only for experiment do not use it for any other purpose)
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - flag to enable bookmark drawer functionality
 *
 * @returns {ReactElement} <div>
 */
// eslint-disable-next-line complexity
const StackedRatingsCard = ({ analyticsDataAttribute, authorName, bookmarkId, className, clickHandler = () => { }, clickHandlerHed, clickHandlerRubric, clickItem = () => { }, commentsCount, contentType, iconBookmarkOnClickHandler, dangerousHed, dangerousDek, hasBookmark, hasIcon, hasRoundedBorder = true, hasRubric, hasUnderline, hedTag = 'h3', copilotID, image, imageLabels, isLoading = false, isRecircListItem, itemIndex, shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark, shouldEnableCommentsCount, shouldTrackItemImpressionForSnowplow, shouldTrackSnowplowEvent, layoutPlacement, impressionHandler, maxDekLines = 2, maxHedLines = 2, rating, rubric, ratingMethod, ratingPosition = 'default', recircId, recircPlacement, reviewsCount, rubricVariation = 'DiscoveryItem', sectionTitle, showAuthorTitle = false, shouldHideDekOnMobileView = false, shouldHoldImageSpace = true, shouldLimitSavingToContentTypes, shouldShowSourceTagName, sourceTag, totalItems, snowplowEvent = {}, url, shouldUseLargeIconSize = false, isDenseDesktopVariation = false }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'StackedRatingsCard'
        });
    }, []);
    let rubricName = rubric?.name;
    let rubricUrl = rubric?.url;
    if (shouldShowSourceTagName && sourceTag?.name && sourceTag?.url) {
        rubricName = sourceTag?.name;
        rubricUrl = sourceTag?.url;
    }
    const { ref: recircItemRef, entry } = useInView({
        threshold: 0.5,
        trackVisibility: true,
        delay: 100,
        triggerOnce: true
    });
    const recircItemClassName = isRecircListItem && `${recircPlacement}-${recircId}`;
    React.useEffect(() => {
        if (entry?.isIntersecting && isRecircListItem) {
            const eventData = {
                type: 'impression',
                label: dangerousHed,
                subject: 'recirc_unit',
                items: [
                    {
                        content_id: copilotID,
                        content_title: dangerousHed,
                        content_type: (contentType || '').toLowerCase(),
                        content_url: url
                    }
                ],
                strategy: extractStrategyFromURL(url),
                placement: recircPlacement,
                index: recircId - 1,
                total_index: totalItems
            };
            trackNavigationEvent(eventData);
        }
    }, [
        copilotID,
        contentType,
        dangerousHed,
        entry,
        isRecircListItem,
        recircId,
        recircPlacement,
        url,
        totalItems
    ]);
    const searchItemClassName = shouldTrackItemImpressionForSnowplow && `search_result_item-${copilotID}`;
    useViewportObserver(`.${searchItemClassName}`, undefined, (isInViewport) => {
        if (isInViewport) {
            impressionHandler();
            clickItem(null, null, copilotID, itemIndex, 'result_in_view', contentType, dangerousHed, url, true);
        }
    });
    const { xxxLarge } = sizesFullName;
    if (!isLoading && (!url || !dangerousHed || isEmpty(image)))
        return null;
    const Icon = getIconComponent(contentType, layoutPlacement);
    const RubricVariation = Rubric[rubricVariation];
    const linkClickHandler = (e) => {
        e.stopPropagation();
        shouldTrackSnowplowEvent &&
            trackSearchFilterEvent({
                type: 'click_result',
                label: sectionTitle,
                subject: 'filter_summary_list',
                platform: 'verso',
                results_content: [
                    {
                        result_type: contentType,
                        no_of_results_returned: totalItems
                    }
                ],
                items: [
                    {
                        content_title: dangerousHed,
                        content_id: copilotID,
                        content_type: contentType,
                        content_url: window && window.location + url
                    }
                ],
                index: itemIndex,
                criteria: {
                    filter: [
                        {
                            label: null,
                            name: dangerousHed
                        }
                    ]
                }
            });
        if (!isEmpty(snowplowEvent))
            handlSnowplowNavigationEvent({
                ...snowplowEvent,
                items: snowplowEvent.items.map(({ content_title }) => ({
                    content_title,
                    content_url: window && window.location.origin + url,
                    content_id: copilotID,
                    content_type: contentType
                }))
            });
        if (clickHandlerHed)
            clickHandlerHed();
        if (clickHandlerRubric)
            clickHandlerRubric();
        if (clickHandler)
            clickHandler(); // Called here as well due to e.stopPropagation();
    };
    const imageNewAltText = { ...image, altText: dangerousHed };
    const goToLink = () => {
        if (clickHandler)
            clickHandler();
        if (!isEmpty(snowplowEvent))
            handlSnowplowNavigationEvent({
                ...snowplowEvent,
                items: snowplowEvent.items.map(({ content_title }) => ({
                    content_title,
                    content_url: window && window.location.origin + url,
                    content_id: copilotID,
                    content_type: contentType
                }))
            });
        clickItem(null, null, copilotID, itemIndex, 'click_result', contentType, dangerousHed, url);
        if (true) {
            window.location = url;
        }
    };
    const hasImage = image && Object.keys(image).length > 0;
    const imageComponent = (React.createElement(ImageWrapper, { hasImage: hasImage, isDenseDesktopVariation: isDenseDesktopVariation },
        React.createElement(Image, { ...imageNewAltText, shouldHoldImageSpace: shouldHoldImageSpace, hasRoundedBorder: hasRoundedBorder, onClick: linkClickHandler }),
        imageLabels && imageLabels.length
            ? imageLabels.map((imageLabel, i) => (React.createElement(Label, { key: i.toString() }, imageLabel)))
            : null,
        hasIcon && Icon && (React.createElement(StackedRatingsCardImageIcon, { shouldUseLargeIconSize: shouldUseLargeIconSize, ButtonIcon: Icon, inputKind: "text", isIconButton: true, label: "icon" }))));
    return isLoading ? (React.createElement(StackedRatingsCardSkeleton, null)) : (React.createElement(StackedRatingsCardWrapper, { ...analyticsDataAttribute, className: classnames(className, searchItemClassName, recircItemClassName), ratingPosition: ratingPosition, onClick: goToLink, isDenseDesktopVariation: isDenseDesktopVariation },
        imageComponent,
        React.createElement(ContentWrapper, { hasUnderline: hasUnderline, hasRubric: hasRubric, ratingPosition: ratingPosition, isDenseDesktopVariation: isDenseDesktopVariation },
            React.createElement(Content, null,
                hasRubric && rubric && (React.createElement(StackedRatingsCardRubricWrapper, { onClick: linkClickHandler },
                    React.createElement(StackedRatingsCardRubric, { as: RubricVariation, name: rubricName, url: rubricUrl }))),
                React.createElement(Body, null,
                    React.createElement(Clamp, { lines: maxHedLines, breakpoint: xxxLarge },
                        React.createElement(Link, { href: url, onClick: linkClickHandler },
                            React.createElement(Hed, { as: hedTag, dangerouslySetInnerHTML: { __html: dangerousHed }, onClick: () => {
                                    clickItem(null, null, copilotID, itemIndex, 'click_result', contentType, dangerousHed, url);
                                }, ref: recircItemRef }))),
                    isDenseDesktopVariation && imageComponent,
                    dangerousDek && (React.createElement(Clamp, { lines: maxDekLines, breakpoint: xxxLarge },
                        React.createElement(Dek, { dangerouslySetInnerHTML: { __html: dangerousDek }, shouldHideDekOnMobileView: shouldHideDekOnMobileView }))))),
            !showAuthorTitle &&
                (rating ||
                    hasBookmark ||
                    shouldEnableCardLevelBookmark ||
                    shouldEnableCommentsCount) ? (React.createElement(MetaData, { shouldEnableBookmarkDrawers: shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark: shouldEnableCardLevelBookmark, shouldEnableCommentsCount: shouldEnableCommentsCount },
                (rating || hasBookmark) && (React.createElement(StyledRatings, { shouldEnableBookmarkDrawers: shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark: shouldEnableCardLevelBookmark, shouldEnableCommentsCount: shouldEnableCommentsCount }, RenderRatings(rating, ratingMethod, reviewsCount, hasBookmark, bookmarkId, iconBookmarkOnClickHandler))),
                (shouldEnableCardLevelBookmark || shouldEnableCommentsCount) &&
                    !hasBookmark && (React.createElement(StyledUtilityFeaturesWrapper, { rating: rating },
                    React.createElement(UtilityFeatures, { totalCommentsCount: commentsCount, urlToBookmark: url, copilotID: copilotID, contentType: contentType, isPageScoped: false, shouldEnableBookmarkDrawers: shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark: shouldEnableCardLevelBookmark, shouldEnableCommentsCount: shouldEnableCommentsCount, subject: "stacked_ratings_card", snowplowEvent: snowplowEvent, shouldUseBookmarkV3: true, shouldLimitSavingToContentTypes: shouldLimitSavingToContentTypes }))))) : null,
            showAuthorTitle && authorName && (React.createElement(AuthorNameWrapper, null, authorName)))));
};
StackedRatingsCard.propTypes = {
    analyticsDataAttribute: PropTypes.object,
    authorName: PropTypes.string,
    bookmarkId: PropTypes.string,
    className: PropTypes.string,
    clickHandler: PropTypes.func,
    clickHandlerHed: PropTypes.func,
    clickHandlerRubric: PropTypes.func,
    clickItem: PropTypes.func,
    commentsCount: PropTypes.number,
    contentType: PropTypes.string,
    copilotID: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    hasBookmark: PropTypes.bool,
    hasIcon: PropTypes.bool,
    hasRoundedBorder: PropTypes.bool,
    hasRubric: PropTypes.bool,
    hasUnderline: PropTypes.bool,
    hedTag: PropTypes.string,
    iconBookmarkOnClickHandler: PropTypes.func,
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    imageLabels: PropTypes.arrayOf(PropTypes.string),
    impressionHandler: PropTypes.func,
    isDenseDesktopVariation: PropTypes.bool,
    isLoading: PropTypes.bool,
    isRecircListItem: PropTypes.bool,
    itemIndex: PropTypes.number,
    layoutPlacement: PropTypes.string,
    maxDekLines: PropTypes.number,
    maxHedLines: PropTypes.number,
    rating: PropTypes.number,
    ratingMethod: PropTypes.string,
    ratingPosition: PropTypes.oneOf(['default', 'bottom']),
    recircId: PropTypes.number,
    recircPlacement: PropTypes.string,
    reviewsCount: PropTypes.number,
    rubric: PropTypes.shape({
        name: PropTypes.string,
        url: PropTypes.string
    }),
    rubricVariation: PropTypes.string,
    sectionTitle: PropTypes.string,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldEnableCardLevelBookmark: PropTypes.bool,
    shouldEnableCommentsCount: PropTypes.bool,
    shouldHideDekOnMobileView: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldLimitSavingToContentTypes: PropTypes.array,
    shouldShowSourceTagName: PropTypes.bool,
    shouldTrackItemImpressionForSnowplow: PropTypes.bool,
    shouldTrackSnowplowEvent: PropTypes.bool,
    shouldUseLargeIconSize: PropTypes.bool,
    showAuthorTitle: PropTypes.bool,
    snowplowEvent: PropTypes.object,
    sourceTag: PropTypes.shape({
        name: PropTypes.string,
        url: PropTypes.string
    }),
    totalItems: PropTypes.number,
    url: PropTypes.string.isRequired
};
StackedRatingsCard.displayName = 'StackedRatingsCard';
module.exports = StackedRatingsCard;
//# sourceMappingURL=StackedRatingsCard.js.map

/***/ }),

/***/ 56915:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const SkeletonScreen = (__webpack_require__(90340)["default"]);
const { StackedRatingsCardSkeletonWrapper, ContentWrapper, Body, Hed, Dek, MetaData, ImageWrapper, StackedRatingsCardImageSkeleton } = __webpack_require__(1817);
/**
 * StackedRatingsCardSkeleton component
 *
 * @returns {ReactElement} <div>
 */
const StackedRatingsCardSkeleton = () => {
    return (React.createElement(StackedRatingsCardSkeletonWrapper, null,
        React.createElement(ImageWrapper, { hasImage: true },
            React.createElement(StackedRatingsCardImageSkeleton, { width: "auto", height: "auto", variant: "box", animation: "pulse" })),
        React.createElement(ContentWrapper, { disableSpacing: true },
            React.createElement(Body, null,
                React.createElement(Hed, null,
                    React.createElement(SkeletonScreen, { width: "75%", height: "auto" })),
                React.createElement(Dek, null, ['100%', '75%', '50%'].map((w) => (React.createElement(SkeletonScreen, { key: w, height: "auto", width: w }))))),
            React.createElement(MetaData, null,
                new Array(5).fill(0).map((_, i) => (React.createElement(SkeletonScreen, { key: i.toString(), height: "16px", width: "16px" }))),
                React.createElement(SkeletonScreen, { height: "16px", width: "16px" })))));
};
module.exports = StackedRatingsCardSkeleton;
//# sourceMappingURL=StackedRatingsCardSkeleton.js.map

/***/ }),

/***/ 62586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const GalleryIcon = __webpack_require__(39336);
const PlayIcon = __webpack_require__(11118);
const SUPPORTED_ICONS = {
    gallery: GalleryIcon,
    video: PlayIcon,
    cnevideo: PlayIcon
};
// exlude icons on these layout placements
const ICON_EXCLUSIONS = ['side-by-side'];
module.exports = { ICON_EXCLUSIONS, SUPPORTED_ICONS };
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 97111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(68712);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1817:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseLink, BaseText, BaseWrap } = __webpack_require__(76955);
const { maxThresholds } = __webpack_require__(99906);
const { minScreen, calculateSpacing, getColorStyles, getColorToken, getDecoration, minMaxScreen } = __webpack_require__(26865);
const ResponsiveAsset = __webpack_require__(86157);
const RatingStars = __webpack_require__(21093);
const { RatingRating, RatingRatings, RatingStar } = __webpack_require__(97927);
const { InlineVideoItemIconButton } = __webpack_require__(41803);
const { SkeletonScreenWrapper } = __webpack_require__(65344);
const { SocialIconContainer, SocialIconButton } = __webpack_require__(51000);
const { UtilityFeaturesWrapper } = __webpack_require__(27490);
const ImageWrapper = styled.div.withConfig({ displayName: 'ImageWrapper' }) `
  position: relative;
  ${({ hasImage, theme }) => !hasImage &&
    `background: ${getColorToken(theme, 'colors.interactive.base.light')};`}
  ${({ isDenseDesktopVariation }) => isDenseDesktopVariation &&
    `
     grid-area:image;
  
    `}
`;
const ContentWrapper = styled.div.withConfig({ displayName: 'ContentWrapper' }) `
  ${({ ratingPosition }) => ratingPosition === 'bottom' &&
    `flex-grow: 1;
     display: flex;
     flex-direction: column;
     justify-content: space-between;`}

  border-radius: ${({ theme }) => getDecoration(theme, 'cardRadiusSm')};
  padding: ${calculateSpacing(2)} ${calculateSpacing(0.5)}
    ${calculateSpacing(1)};

  ${minScreen(BREAKPOINTS.md)} {
    border-radius: ${({ theme }) => getDecoration(theme, 'cardRadiusMd')};
    padding: ${calculateSpacing(3)} ${calculateSpacing(1)}
      ${calculateSpacing(1)};
  }

  ${minScreen(BREAKPOINTS.lg)} {
    border-radius: ${({ theme }) => getDecoration(theme, 'cardRadiusLg')};
  }

  ${({ hasUnderline, theme }) => hasUnderline &&
    `
    border-bottom: 1px solid;
    border-bottom-color: ${getColorToken(theme, 'colors.interactive.base.light')};
    `};

  ${({ hasRubric }) => hasRubric &&
    `
    padding-top: ${calculateSpacing(0.5)};
    ${minScreen(BREAKPOINTS.md)} {
      padding-top: ${calculateSpacing(1)};
    }
  `};

  ${({ disableSpacing }) => disableSpacing &&
    `
    && {
      padding: 0;
    }
  `};
  ${({ isDenseDesktopVariation }) => isDenseDesktopVariation &&
    `
   grid-area:content;

  `};
`;
const Content = styled.div.withConfig({ displayName: 'Content' }) `
  padding: 0 0 ${calculateSpacing(2)};
`;
const StackedRatingsCardWrapper = styled.div.withConfig({
    displayName: 'StackedRatingsCardWrapper'
}) `
  cursor: pointer;
  ${({ ratingPosition }) => ratingPosition === 'bottom' &&
    `height: 100%;
     display: flex;
     flex-direction: column;`};
  ${({ isDenseDesktopVariation }) => isDenseDesktopVariation &&
    `
    ${ContentWrapper} ${ImageWrapper} {
      display:none;
    }
      
    ${minMaxScreen(BREAKPOINTS.md, `${maxThresholds.lg}px`)} {
      &&&{
      border-bottom:none;
      margin-bottom: ${calculateSpacing(2)};
      }
      margin-bottom:${calculateSpacing(2)};
      & > div:nth-child(1) {
        span,img{
          aspect-ratio:4/3;
        }
      }
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-areas:"content content image";
      grid-column: 1 / -1;
      grid-gap:  ${calculateSpacing(3)};
      margin-bottom: ${calculateSpacing(1)};
    }
    ${minMaxScreen(`0px`, `${maxThresholds.md}px`)} {
      &&& {
      border-bottom:none;
      margin-bottom: ${calculateSpacing(2)};
      }
      padding-top: ${calculateSpacing(2)};
      padding-bottom: ${calculateSpacing(2)};
      & > div:nth-child(1) {
           display:none
      }
      ${ContentWrapper} ${ImageWrapper} {
        display:block;
        float:right;
        width:${calculateSpacing(14)};
        height:${calculateSpacing(10.5)};
        margin-left:${calculateSpacing(1)};
        span{
          height:100%;
          > div:first-child{
            float:right;
            width:${calculateSpacing(14)};
            height:100%;
            margin: ${calculateSpacing(0.5)} 0 ${calculateSpacing(1)} ${calculateSpacing(2)};
          }
        }
        span img{
          float:right;
          max-height:${calculateSpacing(10.5)};
          aspect-ratio: 4 / 3;
        }
      }
        ${ContentWrapper} {
          padding:0px;
          ${Content} {
            padding-bottom: 0px;
          }
          ${BaseWrap} {
            padding-top:0px;
          }
        }
  
    }

    `}
`;
const Link = styled(BaseLink).withConfig({ displayName: 'Link' }) ``;
Link.defaultProps = {
    colorToken: 'colors.discovery.body.white.heading',
    linkStyle: 'global'
};
const Image = styled(ResponsiveAsset).withConfig({ displayName: 'Image' }) `
  img {
    ${({ theme, hasRoundedBorder }) => hasRoundedBorder &&
    `border-radius: ${getDecoration(theme, 'cardRadiusSm')}`};
    width: fill-available;

    ${minScreen(BREAKPOINTS.md)} {
      ${({ theme, hasRoundedBorder }) => hasRoundedBorder &&
    `border-radius: ${getDecoration(theme, 'cardRadiusMd')}`};
      width: fill-available;
    }

    ${minScreen(BREAKPOINTS.lg)} {
      ${({ theme, hasRoundedBorder }) => hasRoundedBorder &&
    `border-radius: ${getDecoration(theme, 'cardRadiusMd')}`};
      width: fill-available;
    }
  }
`;
const Label = styled(BaseText).withConfig({ displayName: 'Label' }) `
  position: absolute;
  top: ${calculateSpacing(1)};
  left: ${calculateSpacing(1)};
  margin: 0 ${calculateSpacing(1)} 0 0;
  border-radius: ${calculateSpacing(3)};
  padding: ${calculateSpacing(0.5)} ${calculateSpacing(1)};

  ${({ theme }) => getColorStyles(theme, 'background', 'colors.discovery.body.brand.background')};

  ${minScreen(BREAKPOINTS.md)} {
    padding: ${calculateSpacing(1)} ${calculateSpacing(2)};
  }

  ${minScreen(BREAKPOINTS.lg)} {
    top: ${calculateSpacing(2)};
    left: ${calculateSpacing(2)};
  }
`;
Label.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.brand.heading',
    typeIdentity: 'typography.definitions.globalEditorial.tags'
};
const Body = styled.div.withConfig({ displayName: 'Body' }) `
  ${SkeletonScreenWrapper} {
    margin: ${calculateSpacing(1)} 0;
  }
`;
const Hed = styled(BaseText).withConfig({ displayName: 'Hed' }) `
  display: inline;

  ${({ dek }) => !dek && `margin: 0 0 ${calculateSpacing(1)}`}
`;
Hed.defaultProps = {
    as: 'h3',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.hed-core-secondary'
};
const Dek = styled(BaseText).withConfig({ displayName: 'Dek' }) `
  ${({ shouldHideDekOnMobileView }) => shouldHideDekOnMobileView &&
    `
  display: none;

  ${minScreen(BREAKPOINTS.md)} {
    display: block;
  }
  `}
  margin: ${calculateSpacing(1)} 0 0;
`;
Dek.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
const MetaData = styled.div.withConfig({ displayName: 'MetaData' }) `
  display: flex;
  position: relative;
  flex-direction: row;
  align-content: center;
  align-items: center;
  height: ${calculateSpacing(4)};
  ${SocialIconContainer} {
    height: ${calculateSpacing(2.2)};
  }

  ${SocialIconButton} {
    display: flex;
    margin-left: auto;
    border: 0;
    background: none;
    padding: 0;
    width: ${calculateSpacing(2.5)};
    list-style: none;

    .icon-bookmark.icon {
      height: ${calculateSpacing(2.5)};
    }
  }

  ${SkeletonScreenWrapper} {
    margin-right: ${calculateSpacing(0.25)};
  }
  ${SkeletonScreenWrapper}:last-child {
    margin-left: auto;
  }

  ${({ shouldEnableCardLevelBookmark, shouldEnableCommentsCount }) => shouldEnableCardLevelBookmark || shouldEnableCommentsCount
    ? `display: block`
    : ''}
`;
const AuthorNameWrapper = styled(BaseText).withConfig({
    displayName: 'AuthorNameWrapper'
}) `
  padding-top: 6px;
`;
AuthorNameWrapper.defaultProps = {
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.globalEditorial.accreditation-core'
};
const Rating = styled(BaseText).withConfig({ displayName: 'Rating' }) `
  margin: 0 ${calculateSpacing(1)};
`;
Rating.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.accreditation',
    typeIdentity: 'typography.definitions.globalEditorial.numerical-small'
};
const StackedRatingsCardStars = styled(RatingStars).withConfig({
    displayName: 'StackedRatingsCardStars'
}) `
  align-items: flex-start;
  margin-left: -${calculateSpacing(0.9)};
  padding: 0;

  ${RatingRating}, ${RatingRatings} {
    display: none;
  }

  ${RatingStar} {
    width: ${calculateSpacing(2.1)};
  }
`;
const StackedRatingsCardImageIcon = styled(InlineVideoItemIconButton).withConfig({
    displayName: 'StackedRatingsCardImageIcon'
}) `
  width: ${calculateSpacing(4)};
  height: ${calculateSpacing(4)};
  ${({ shouldUseLargeIconSize }) => shouldUseLargeIconSize &&
    `
      width: ${calculateSpacing(6)};
      height: ${calculateSpacing(6)};
    `};
`;
const StackedRatingsCardRubricWrapper = styled.div.withConfig({
    displayName: 'StackedRatingsCardRubricWrapper'
}) `
  ${SkeletonScreenWrapper} {
    margin: ${calculateSpacing(2)} 0;
  }
`;
const StackedRatingsCardRubric = styled.div.withConfig({
    displayName: 'StackedRatingsCardRubric'
}) ``;
const StackedRatingsBookmark = styled(SocialIconButton).withConfig({
    displayName: 'StackedRatingsBookmark'
}) ``;
const StackedRatingsCardSkeletonWrapper = styled.div.withConfig({
    displayName: 'StackedRatingsCardSkeletonWrapper'
}) ``;
const StackedRatingsCardImageSkeleton = styled(SkeletonScreenWrapper).withConfig({
    displayName: 'StackedRatingsCardImageSkeleton'
}) `
  ::before {
    display: block;
    padding-top: 100%;
    width: 100%;
  }
`;
const StyledUtilityFeaturesWrapper = styled.div.withConfig({
    displayName: 'StyledUtilityFeaturesWrapper'
}) `
  ${SocialIconButton} {
    .icon-bookmark.icon {
      height: ${calculateSpacing(3)};
    }
  }
  ${UtilityFeaturesWrapper} {
    margin-top: ${calculateSpacing(0.5)};
    ${({ rating }) => rating ? `padding-left: ${calculateSpacing(2)};` : 'padding-left: 0px;'}
  }
  ${minScreen(BREAKPOINTS.sm)} {
    ${({ rating }) => rating ? `margin-left: ${calculateSpacing(2)};` : 'margin-left: 0px;'}
    ${UtilityFeaturesWrapper} {
      ${({ rating }) => rating ? `margin-left: ${calculateSpacing(1)};` : 'margin-left: 0px;'}
    }
  }
`;
const StyledRatings = styled.div.withConfig({
    displayName: 'StyledRatings'
}) `
  display: flex;
  align-items: center;
  float: inline-start;
  ${({ shouldEnableCardLevelBookmark, shouldEnableCommentsCount }) => !shouldEnableCardLevelBookmark && !shouldEnableCommentsCount
    ? 'width: 100%'
    : ''}
`;
module.exports = {
    AuthorNameWrapper,
    StackedRatingsCardWrapper,
    ImageWrapper,
    Image,
    Label,
    Link,
    ContentWrapper,
    Content,
    Body,
    Hed,
    Dek,
    MetaData,
    Rating,
    StackedRatingsCardStars,
    StackedRatingsCardImageIcon,
    StackedRatingsCardRubric,
    StackedRatingsCardRubricWrapper,
    StackedRatingsBookmark,
    StackedRatingsCardSkeletonWrapper,
    StackedRatingsCardImageSkeleton,
    StyledRatings,
    StyledUtilityFeaturesWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 39182:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handlSnowplowNavigationEvent = void 0;
const { trackNavigationEvent } = __webpack_require__(14307);
const handlSnowplowNavigationEvent = (itemData = {}) => {
    trackNavigationEvent(itemData);
};
exports.handlSnowplowNavigationEvent = handlSnowplowNavigationEvent;
//# sourceMappingURL=tracking.js.map

/***/ }),

/***/ 39315:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    bookmarkButtonLabelSaved: {
        id: 'BookmarkButton.LabelSaved',
        defaultMessage: 'recipe saved',
        description: 'Bookmark saved button'
    },
    bookmarkButtonLabelBookmark: {
        id: 'BookmarkButton.Label',
        defaultMessage: 'save recipe',
        description: 'Bookmark button label'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 27234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const { ICON_EXCLUSIONS, SUPPORTED_ICONS } = __webpack_require__(62586);
const Star = __webpack_require__(68642);
const Bookmark = __webpack_require__(70931);
const BookmarkActivated = __webpack_require__(64736);
const translations = (__webpack_require__(39315)/* ["default"] */ .A);
const { Rating, StackedRatingsCardStars, StackedRatingsBookmark } = __webpack_require__(1817);
/**
 * Based on the content type and placement, get the icon component
 *
 * @param  {string} contentType - the content type of the article
 * @param  {string} layoutPlacement - the layout placement variation
 * @returns {ReactComponent|null} the icon component
 */
const getIconComponent = (contentType, layoutPlacement) => {
    if (ICON_EXCLUSIONS.indexOf(layoutPlacement) === -1 &&
        SUPPORTED_ICONS[contentType]) {
        return SUPPORTED_ICONS[contentType];
    }
    return null;
};
/**
 * Based on the number, get the decimal value
 *
 * @param  {string} num - the number value
 * @returns {number} the decimal value
 */
function getDecimalPart(num) {
    if (Number.isInteger(num)) {
        return 0;
    }
    const decimalStr = num.toString().split('.')[1];
    return Number(decimalStr);
}
/**
 * Based on the rating value, get the final computed rating
 * For ratings 4.1 & 4.2 - only four stars reflect.
 * For ratings 4.3 to 4.7 - four and half stars reflect.
 * And for 4.8 to 5 - 5 stars reflect.
 *
 * @param  {string} rating - the content type of the article
 * @returns {number} the coputed rating value
 */
const getComputedRating = (rating) => {
    const finalRating = Math.round(rating * 10) / 10;
    const decimal = getDecimalPart(finalRating);
    if (decimal < 3)
        return Math.floor(finalRating);
    if (decimal < 8)
        return finalRating;
    return Math.round(finalRating);
};
const ratingHandler = (rating, ratingMethod, reviewsCount) => ratingMethod === 'starRating' ? (React.createElement(StackedRatingsCardStars, { averageRatingCount: getComputedRating(rating), hasBorderTop: false, totalRatingCount: rating })) : (reviewsCount > 0 && (React.createElement(React.Fragment, null,
    React.createElement(Star, null),
    React.createElement(Rating, null,
        rating,
        " (",
        reviewsCount,
        ")"))));
const RenderRatings = (rating, ratingMethod, reviewsCount, hasBookmark, bookmarkId, iconBookmarkOnClickHandler) => {
    const { formatMessage } = useIntl();
    return (React.createElement(React.Fragment, null,
        rating ? ratingHandler(rating, ratingMethod, reviewsCount) : null,
        hasBookmark && (React.createElement(StackedRatingsBookmark, { hasEnableIcon: true, isIconButton: true, iconPosition: "before", ButtonIcon: bookmarkId ? BookmarkActivated : Bookmark, label: bookmarkId
                ? formatMessage(translations.bookmarkButtonLabelSaved)
                : formatMessage(translations.bookmarkButtonLabelBookmark), onClickHandler: iconBookmarkOnClickHandler }))));
};
module.exports = { getIconComponent, RenderRatings };
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 87339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const _uniqueId = __webpack_require__(97200);
const { useIntl } = __webpack_require__(46984);
const { TrackComponentChannel } = __webpack_require__(78788);
const { trackNavigationEvent } = __webpack_require__(14307);
const Carousel = __webpack_require__(30830);
const SummaryItem = __webpack_require__(74992);
const translations = (__webpack_require__(81081)/* ["default"] */ .A);
const PaletteProvider = __webpack_require__(49235);
const { SummaryCarouselRow, CarouselSectionTitle, CarouselSummaryItem } = __webpack_require__(34751);
const SectionTitle = __webpack_require__(35864);
const Button = __webpack_require__(73730);
const { asConfiguredComponent } = __webpack_require__(12892);
const { componentTracking } = __webpack_require__(90090);
const { getVariationNames } = __webpack_require__(81372);
const CAROUSEL_SLIDE_SIZING = {
    width: {
        sm: '85%',
        lg: '40%',
        xl: '28%'
    },
    spacing: { sm: '9px', md: '12px', lg: '16px', xl: '16px', xxl: '20px' }
};
const SummaryCarousel = ({ backgroundColor = 'white', btnStyle = 'outlined', carouselContentAlign = 'center', carouselSlideSizing = CAROUSEL_SLIDE_SIZING, customViewAllButtonText, dangerousDek = '', dangerousHed = '', hasCarouselControls = true, hasDividerAbove, hasDividerBelow, hasDividerAboveDek = false, hasModerateSpacing = true, hasNoHorizontalScrollCarousel = false, hasPagination = true, hasSectionTitleMargin = true, hasSummaryItemExtraPadding = false, href = '', impressionHandler, items = [], isDotClickable = false, isInverted = false, isSpecial = false, isSummaryHeadingSecondary = false, onClickHandler, paginationStyle = 'bullet', placement, sectionTitleVariation = 'TextCenter', shouldAlignCenterIfContentIsLess = false, shouldApplyGridSpacing = false, shouldApplySpecialCard = false, shouldEnableBundleComponentAnalytics = false, shouldEnableChannelFeatures = false, shouldEnableRecircTracking = false, shouldHaveBorderBottomOnItem = false, shouldHideBylines = false, shouldHideCarouselFooter = false, shouldHideContributors = false, shouldHideDangerousDek = false, shouldHideMarginOnCarousel = false, shouldHidePublishDate = false, shouldReduceSpaceOnCarouselRow = false, shouldShowAllContentWhenDense, shouldShowViewAllButton = true, shouldTrackItemImpressionForSnowplow, snowplowEvent, summaryItemVariation = 'TextBelowImageLeftHasRuleNoDek', theme = 'standard', totalItems, viewAllButtonVariation = 'Utility', version }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SummaryCarousel'
        });
    }, []);
    const { formatMessage } = useIntl();
    const [pid] = React.useState(parseInt(_uniqueId(), 10));
    const ButtonComponent = Button[viewAllButtonVariation];
    const getPalette = (paletteTheme, isInvertedTheme) => {
        if (paletteTheme === 'special')
            return paletteTheme;
        return isInvertedTheme ? 'inverted' : 'standard';
    };
    const palette = getPalette(theme, isInverted);
    const SummaryItemComponent = SummaryItem[summaryItemVariation];
    const CarouselSectionTitleComponent = CarouselSectionTitle[sectionTitleVariation];
    const carouselItemClickHandler = (carouselTitle, pos, carouselItemIndex, item) => {
        if ( true && window.dataLayer) {
            if (shouldEnableRecircTracking) {
                window.dataLayer.push({
                    event: 'recirc',
                    eventCategory: 'recirc',
                    eventAction: 'recirc-see-related-recipes-click',
                    eventLabel: `See Related Recipes/${carouselItemIndex}`
                });
            }
            else {
                trackNavigationEvent({
                    type: 'click',
                    label: carouselTitle,
                    subject: 'carousel',
                    items: [
                        {
                            content_title: item?.dangerousHed,
                            content_type: item?.contentType,
                            content_url: window && window.location.origin + (item?.url || ''),
                            content_id: item?.id
                        }
                    ],
                    placement: 'mid-content',
                    index: carouselItemIndex - 1,
                    total_index: items?.length
                });
                window.dataLayer.push({
                    event: 'carousel-click',
                    'carousel-name': carouselTitle,
                    'carousel-position': pos,
                    'carousel-click-position': carouselItemIndex,
                    'carousel-click-text': item?.dangerousHed
                });
            }
        }
    };
    return (React.createElement(PaletteProvider, { palette: palette },
        React.createElement(SummaryCarouselRow, { backgroundColor: backgroundColor, hasModerateSpacing: hasModerateSpacing, isSummaryHeadingSecondary: isSummaryHeadingSecondary, shouldShowViewAllButton: shouldShowViewAllButton, shouldReduceSpaceOnCarouselRow: shouldReduceSpaceOnCarouselRow, shouldEnableChannelFeatures: shouldEnableChannelFeatures, shouldApplyGridSpacing: shouldApplyGridSpacing, shouldApplySpecialCard: shouldApplySpecialCard },
            dangerousHed && (React.createElement(CarouselSectionTitle, { as: CarouselSectionTitleComponent, dangerousHed: dangerousHed, dangerousDek: dangerousDek, hasDividerAbove: hasDividerAbove, hasDividerBelow: hasDividerBelow, hasDividerAboveDek: hasDividerAboveDek, hasSectionTitleMargin: hasSectionTitleMargin })),
            React.createElement(Carousel, { dangerousHed: dangerousHed, pos: pid, contentAlign: carouselContentAlign, controlPosition: "center", controlPlacement: "space-between", hasControls: hasCarouselControls, hasModerateSpacing: hasModerateSpacing, hasNoHorizontalScrollCarousel: hasNoHorizontalScrollCarousel, hasPagination: hasPagination, paginationStyle: paginationStyle, hideHeaderBorder: true, isDotClickable: isDotClickable, shouldEnableRecircTracking: shouldEnableRecircTracking, shouldAlignCenterIfContentIsLess: shouldAlignCenterIfContentIsLess, shouldHideMarginOnCarousel: shouldHideMarginOnCarousel, shouldHideCarouselFooter: shouldHideCarouselFooter }, items.map((item, index) => {
                return (React.createElement(Carousel.CarouselItem, { ...carouselSlideSizing, key: `product-bundle-${index}`, carouselTitle: dangerousHed, carouselItemIndex: index, carouselItemName: item.dangerousHed, pos: pid, isSpecial: isSpecial },
                    React.createElement(CarouselSummaryItem, { analyticsDataAttribute: componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, `${dangerousHed}/` || 'Section Title/', index, false), as: SummaryItemComponent, ...item, hasBorder: false, hasBorderOnMobileAndTabletOnly: false, hasRule: true, hasSummaryItemExtraPadding: hasSummaryItemExtraPadding, hasUnderlineHed: false, hedTag: "h3", hideRubricItemSummary: false, isLazy: false, shouldHideIcon: false, shouldHideMetadataSecondary: false, shouldHideVideoDek: false, shouldHideDangerousDek: shouldHideDangerousDek, shouldHidePublishDate: shouldHidePublishDate, playIconStyle: "white", clickHandlerHed: (item) => carouselItemClickHandler(dangerousHed, pid, index + 1, item), shouldHideBylines: shouldHideBylines, shouldHideContributors: shouldHideContributors, shouldHaveBorderBottomOnItem: shouldHaveBorderBottomOnItem, isSpecial: isSpecial, shouldShowAllContentWhenDense: shouldShowAllContentWhenDense, shouldApplySpecialCard: shouldApplySpecialCard, mobileDenseItemClassCarousel: `mobile_dense_carousel_item-${index}`, shouldTrackSnowplow: shouldTrackItemImpressionForSnowplow, impressionHandler: () => impressionHandler('impression', item, index, placement, totalItems, version), snowplowEvent: snowplowEvent && {
                            ...snowplowEvent,
                            items: [
                                {
                                    content_title: item.dangerousHed,
                                    content_url: item.url,
                                    content_id: item.copilotID,
                                    content_type: item.contentType
                                }
                            ],
                            index,
                            total_index: snowplowEvent?.total_index
                                ? snowplowEvent?.total_index
                                : items.length,
                            placement,
                            subject_version: version
                        } })));
            })),
            shouldShowViewAllButton && (React.createElement("div", { className: "more-videos" },
                React.createElement(ButtonComponent, { btnStyle: btnStyle, label: customViewAllButtonText ||
                        formatMessage(translations.seeMoreAriaLabel), ariaLabel: customViewAllButtonText ||
                        formatMessage(translations.seeMoreAriaLabel), href: href, inputKind: "link", onClickHandler: onClickHandler, isSpecial: isSpecial }))))));
};
const SUMMARY_ITEM_VARIATIONS = getVariationNames(SummaryItem);
const SECTION_TITLE_VARIATIONS = getVariationNames(SectionTitle);
SummaryCarousel.propTypes = {
    backgroundColor: PropTypes.oneOf([
        null,
        'light',
        'dark',
        'brand',
        'black',
        'white'
    ]),
    btnStyle: PropTypes.oneOf(['filled', 'outlined', 'text']),
    carouselContentAlign: PropTypes.oneOf(['left', 'center']),
    carouselSlideSizing: PropTypes.object,
    customViewAllButtonText: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string,
    hasCarouselControls: PropTypes.bool,
    hasDividerAbove: PropTypes.bool,
    hasDividerAboveDek: PropTypes.bool,
    hasDividerBelow: PropTypes.bool,
    hasModerateSpacing: PropTypes.bool,
    hasNoHorizontalScrollCarousel: PropTypes.bool,
    hasPagination: PropTypes.bool,
    hasSectionTitleMargin: PropTypes.bool,
    hasSummaryItemExtraPadding: PropTypes.bool,
    href: PropTypes.string,
    impressionHandler: PropTypes.func,
    isDotClickable: PropTypes.bool,
    isInverted: PropTypes.bool,
    isSpecial: PropTypes.bool,
    isSummaryHeadingSecondary: PropTypes.bool,
    items: PropTypes.array,
    onClickHandler: PropTypes.func,
    paginationStyle: PropTypes.string,
    placement: PropTypes.string,
    sectionTitleVariation: PropTypes.oneOf(SECTION_TITLE_VARIATIONS),
    shouldAlignCenterIfContentIsLess: PropTypes.bool,
    shouldApplyGridSpacing: PropTypes.bool,
    shouldApplySpecialCard: PropTypes.bool,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldEnableChannelFeatures: PropTypes.bool,
    shouldEnableRecircTracking: PropTypes.bool,
    shouldHaveBorderBottomOnItem: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideCarouselFooter: PropTypes.bool,
    shouldHideContributors: PropTypes.bool,
    shouldHideDangerousDek: PropTypes.bool,
    shouldHideMarginOnCarousel: PropTypes.bool,
    shouldHidePublishDate: PropTypes.bool,
    shouldReduceSpaceOnCarouselRow: PropTypes.bool,
    shouldShowAllContentWhenDense: PropTypes.bool,
    shouldShowViewAllButton: PropTypes.bool,
    shouldTrackItemImpressionForSnowplow: PropTypes.bool,
    snowplowEvent: PropTypes.object,
    summaryItemVariation: PropTypes.oneOf(SUMMARY_ITEM_VARIATIONS),
    theme: PropTypes.oneOf(['standard', 'inverted', 'special']),
    totalItems: PropTypes.number,
    version: PropTypes.string,
    viewAllButtonVariation: PropTypes.oneOf([
        'Primary',
        'Utility',
        'UtilityInverted'
    ])
};
SummaryCarousel.displayName = 'SummaryCarousel';
SummaryCarousel.displayName = 'SummaryCarousel';
module.exports = asConfiguredComponent(SummaryCarousel, 'SummaryCarousel');
//# sourceMappingURL=SummaryCarousel.js.map

/***/ }),

/***/ 34751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { calculateSpacing, getColorStyles, getTypographyStyles, minScreen } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const Row = __webpack_require__(66657);
const { CarouselControlButton, CarouselList, CarouselListItem, CarouselWrapper, CarouselStrapline } = __webpack_require__(44802);
const SectionTitle = __webpack_require__(35864);
const { SummaryItemBylinePublishDate } = __webpack_require__(277);
const Button = __webpack_require__(73730);
const { RubricName } = __webpack_require__(6613);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const { SummaryItemHedBase } = __webpack_require__(36211);
const { SummaryItemContent } = __webpack_require__(68116);
const SummaryCarouselRow = styled(Row).withConfig({
    displayName: 'CarouselRow'
}) `
  margin: 0 auto;
  overflow: auto;

  ${({ shouldShowViewAllButton, hasModerateSpacing }) => !shouldShowViewAllButton &&
    `
      padding: 0 0 ${calculateSpacing(hasModerateSpacing ? 4 : 0)} 0;
    `}

  ${({ theme }) => {
    if (theme.palette === 'inverted') {
        return `
        ${getColorStyles(theme, 'background', 'colors.discovery.body.black.background')};
      `;
    }
    if (theme.palette === 'special') {
        return `
      ${getColorStyles(theme, 'background', 'colors.consumption.lead.special.background')};
      @media (max-width: ${BREAKPOINTS.md}) {
        padding: ${calculateSpacing(4)} 0 ${calculateSpacing(3)} ${calculateSpacing(3)};
      }
      @media (min-width: ${BREAKPOINTS.md}) {
        padding: ${calculateSpacing(6)} 0 ${calculateSpacing(3)} ${calculateSpacing(8)};
      }   
      `;
    }
    return `
    ${cssVariablesGrid()}
    padding-left: var(--grid-margin);
    padding-right: var(--grid-margin);
    @media (min-width: ${BREAKPOINTS.xxl}) {
      ${applyGridSpacing('padding')};
      max-width: ${calculateSpacing(200)};
    }
    ${getColorStyles(theme, 'background', 'colors.discovery.body.white.background')};
    `;
}}

  ${({ theme, shouldApplyGridSpacing }) => theme.palette === 'inverted' &&
    shouldApplyGridSpacing &&
    `
    @media (max-width: ${BREAKPOINTS.md}) {
      padding: ${calculateSpacing(4)} 0 ${calculateSpacing(3)} ${calculateSpacing(3)};
    }
    @media (min-width: ${BREAKPOINTS.md}) {
      padding: ${calculateSpacing(6)} ${calculateSpacing(6)} ${calculateSpacing(3)} ${calculateSpacing(8)};
    }
    `}   

  ${({ shouldEnableChannelFeatures }) => shouldEnableChannelFeatures &&
    `
${minScreen(BREAKPOINTS.md)} {
     display: none;
  }
    grid-column: 1/ span 12;
    grid-row: 3;
    padding-left: 0;
    padding-right: 0;
    padding-top: ${calculateSpacing(5)};
    `}

  ${CarouselWrapper} {
    ${({ theme, shouldApplyGridSpacing }) => theme.palette === 'inverted' && !shouldApplyGridSpacing
    ? `${cssVariablesGrid()}
          margin: 0 auto;
          padding-left: var(--grid-margin);
          padding-right: var(--grid-margin);
          @media (min-width: ${BREAKPOINTS.xxl}) {
            ${applyGridSpacing('padding')};
            max-width: ${calculateSpacing(200)};
          }`
    : ''};

    ${({ shouldApplyGridSpacing }) => shouldApplyGridSpacing &&
    `@media (min-width: ${BREAKPOINTS.xxl}) {
        padding-right: ${calculateSpacing(6)};
        padding-left: ${calculateSpacing(6)};
      }
    `}

    ${({ shouldEnableChannelFeatures }) => shouldEnableChannelFeatures &&
    `margin-top: 0;
       margin-bottom: 0;
       `}
  }

  ${CarouselStrapline} {
    margin-bottom: ${calculateSpacing(4)};
    text-transform: initial;

    ${({ theme }) => theme.palette === 'inverted'
    ? getColorStyles(theme, 'color', 'colors.discovery.body.black.heading')
    : getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
  }

  ${CarouselList} {
    margin-top: 0;
    background: none;
    overflow-x: auto;
    scroll-snap-type: x mandatory;

    @media (min-width: ${BREAKPOINTS.xxl}) {
      padding-right: 0;
      padding-left: 0;
    }
  }

  ${CarouselControlButton} {
    &:disabled {
      display: none;
    }
  }

  ${CarouselListItem} {
    ${({ shouldEnableChannelFeatures }) => shouldEnableChannelFeatures &&
    ` width: 70%;
      margin-right: ${calculateSpacing(2)};`}

    ${({ theme, shouldApplySpecialCard }) => shouldApplySpecialCard &&
    `
          border-style: solid;
          border-width: 4px;
          ${getColorStyles(theme, 'border-color', 'colors.interactive.base.black')};
          ${getColorStyles(theme, 'background-color', 'colors.consumption.body.standard.bg-card')};
      `}
    .summary-item__content {
      padding-bottom: ${calculateSpacing(0)};
      width: auto;

      @media (min-width: ${BREAKPOINTS.xxl}) {
        ${({ hasModerateSpacing }) => `padding-bottom: ${calculateSpacing(hasModerateSpacing ? 4 : 0)};`}
      }
    }

    .summary-item--bundle {
      @media (min-width: ${BREAKPOINTS.lg}) {
        ${({ hasModerateSpacing }) => `padding-bottom: ${calculateSpacing(hasModerateSpacing ? 6 : 2)};`}
      }

      .summary-item__content {
        width: auto;
      }

      .summary-item__hed {
        margin-top: 0;
        margin-bottom: ${calculateSpacing(1)};
      }
    }

    .summary-item {
      a.summary-item__hed-link {
        ${({ theme, shouldApplySpecialCard }) => {
    return theme.palette === 'inverted' && !shouldApplySpecialCard
        ? getColorStyles(theme, 'color', 'colors.discovery.body.black.heading')
        : getColorStyles(theme, 'color', 'colors.discovery.body.white.heading');
}};
      }

      .summary-item__hed {
        width: auto;
        ${({ theme, isSummaryHeadingSecondary }) => getTypographyStyles(theme, isSummaryHeadingSecondary
    ? 'typography.definitions.discovery.hed-core-secondary'
    : 'typography.definitions.discovery.hed-core-primary')};

        ${({ theme, shouldApplySpecialCard }) => {
    return theme.palette === 'inverted' && !shouldApplySpecialCard
        ? getColorStyles(theme, 'color', 'colors.discovery.body.black.heading')
        : getColorStyles(theme, 'color', 'colors.discovery.body.white.heading');
}};
      }
    }
  }

  .more-videos {
    margin: ${calculateSpacing(4)} auto ${calculateSpacing(8)};
    @media (min-width: ${BREAKPOINTS.lg}) {
      margin: ${calculateSpacing(3)} auto ${calculateSpacing(8)};
    }
    max-width: fit-content;
  }
`;
const sectionTitleMargin = (hasSectionTitleMargin) => {
    if (hasSectionTitleMargin) {
        return `${calculateSpacing(8)} auto 0`;
    }
    return '0 auto';
};
const themes = ['special', 'inverted'];
const CarouselSectionTitle = styled(SectionTitle).withConfig({
    displayName: 'CarouselSectionTitle'
}) `
  margin: ${({ hasSectionTitleMargin }) => sectionTitleMargin(hasSectionTitleMargin)};
  max-width: ${calculateSpacing(200)};

  ${({ hasDividerBelow }) => !hasDividerBelow &&
    `
  padding-bottom:  ${calculateSpacing(4)} ;
  `}

  h2,
  h3,
  p {
    ${({ theme }) => themes.includes(theme.palette)
    ? getColorStyles(theme, 'color', 'colors.discovery.body.black.heading')
    : getColorStyles(theme, 'color', 'colors.discovery.body.white.heading')};
  }
`;
const CarouselSummaryItem = styled.div.withConfig({
    displayName: 'CarouselSummaryItem'
}) `
  ${({ theme, shouldApplySpecialCard }) => {
    if (theme.palette === 'inverted' && !shouldApplySpecialCard) {
        return `
        ${RubricName} {
          ${getColorStyles(theme, 'color', 'colors.discovery.body.black.context-signature')}
        }

        ${SummaryItemBylinePublishDate} {
          ${getColorStyles(theme, 'color', 'colors.discovery.body.black.context-tertiary')}
        }
      `;
    }
    return ``;
}}
  && {
    ${SummaryItemContent} {
      ${SummaryItemHedBase} {
        @media (max-width: ${BREAKPOINTS.md}) {
          ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')};
        }
      }
    }
  }
`;
const ArticleGalleryCarouselBtnWrapper = styled.div.withConfig({
    displayName: 'ArticleGalleryCarouselBtnWrapper'
}) `
  position: relative;
  top: 32px;

  .more-products {
    margin: 0 auto;
    max-width: fit-content;
  }
`;
const ArticleGalleryCarouselButton = styled(Button.Utility).withConfig({
    displayName: 'ArticleGalleryCarouselButton'
}) `
  margin: ${calculateSpacing(1)} auto ${calculateSpacing(8)};

  @media (min-width: ${BREAKPOINTS.lg}) {
    margin: ${calculateSpacing(6)} auto ${calculateSpacing(8)};
  }
`;
module.exports = {
    ArticleGalleryCarouselButton,
    ArticleGalleryCarouselBtnWrapper,
    SummaryCarouselRow,
    CarouselSectionTitle,
    CarouselSummaryItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 81081:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    seeMoreAriaLabel: {
        id: 'SummaryCarousel.seeMoreAriaLabel',
        defaultMessage: 'See more videos',
        description: 'label text for carousel button'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 57613:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { asConfiguredComponent } = __webpack_require__(12892);
const { SummaryDekDefault } = __webpack_require__(95015);
const SummaryDek = ({ contentAlign = 'center', dangerousDek, hasCustomTypeToken = false, hasMarginBottom = false, shouldDisplayDangerousDek = false }) => {
    const hasDangerousDek = shouldDisplayDangerousDek && dangerousDek;
    if (!hasDangerousDek)
        return false;
    return (React.createElement(SummaryDekDefault, { contentAlign: contentAlign, dangerouslySetInnerHTML: { __html: dangerousDek }, hasCustomTypeToken: hasCustomTypeToken, hasMarginBottom: hasMarginBottom }));
};
SummaryDek.propTypes = {
    contentAlign: PropTypes.oneOf(['left', 'center']),
    dangerousDek: PropTypes.string,
    hasCustomTypeToken: PropTypes.bool,
    hasMarginBottom: PropTypes.bool,
    shouldDisplayDangerousDek: PropTypes.bool
};
SummaryDek.displayName = 'SummaryDek';
module.exports = asConfiguredComponent(SummaryDek, 'SummaryDek');
//# sourceMappingURL=SummaryDek.js.map

/***/ }),

/***/ 49989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SummaryDek = __webpack_require__(57613);
module.exports = SummaryDek;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 95015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { BaseText } = __webpack_require__(76955);
const { calculateSpacing, getTypographyStyles, getColorToken } = __webpack_require__(26865);
const SummaryDekDefault = styled(BaseText).withConfig({
    displayName: 'SummaryDekDefault'
}) `
  ${({ hasCustomTypeToken }) => hasCustomTypeToken
    ? css `
          ${getTypographyStyles('typography.definitions.discovery.description-feature')};
        `
    : css `
          ${getTypographyStyles('typography.definitions.discovery.subhed-section-collection')};
        `}

  grid-column: 1 / -1;
  margin: auto;
  padding-right: ${calculateSpacing(1)};
  padding-left: ${calculateSpacing(1)};
  color: ${getColorToken('colors.discovery.body.light.heading')};

  ${({ contentAlign }) => contentAlign &&
    `
      text-align: ${contentAlign};
    `}

  ${({ hasMarginBottom }) => hasMarginBottom
    ? `margin-bottom: ${calculateSpacing(4)};`
    : `@media (min-width: ${BREAKPOINTS.xxl}) {
    margin-bottom: ${calculateSpacing(1.5)};
    }
   `}
`;
module.exports = {
    SummaryDekDefault
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 64236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const translations = (__webpack_require__(71681)/* ["default"] */ .A);
const { SummaryItemFeaturedWrapper, FeaturedTitle, FeaturedLink } = __webpack_require__(56503);
const { TrackComponentChannel } = __webpack_require__(78788);
const SummaryItem = __webpack_require__(74992);
const { componentTracking } = __webpack_require__(90090);
/**
 * SummaryItemFeatured component
 *
 * @param {object} props - React props
 * @param {string} props.header - featured item header
 * @param {object} [props.analyticsDataAttribute] - Optional data-section-title attribute for component level tracking
 * @param {boolean} [props.hasRubricBelowHed] - Optional. Positions the rubric under Hed
 * @param {string} [props.hedTag] - optional string of hed tag
 * @param {boolean} [props.isHiddenOnMobile] - optional flag to hide featured item on mobile view
 * @param {string} [props.linkLabel] - optional cta link label
 * @param {Function} [props.clickHandler] - Optional prop which will have click tracking function
 * @param {string} [props.ctaUrl] - optional cta link url
 * @param {Function} [props.impressionHandler] - Optional prop which will have impression tracking function
 * @param {bool} [props.shouldEnableBundleComponentAnalytics] - Optional feature flag to append data-section-title attribute for analytics
 * @param {boolean} [props.shouldHideFeaturedDek] - Optional boolean to hide dangerousDek
 * @param {boolean} [props.shouldHoldImageSpace] - Option to hold image space
 * @param {boolean} [props.shouldTrackItemImpressionForSnowplow] - Optional boolean to tell item impression event to be tracked for snowplow
 * @param {object} props.summaryItemProps - object containing item data or SummaryItem
 * @param {string} props.summaryItemVariation - summary item variation name
 * @param {object} [props.trackingNamespace] - Optional override the base namespace of data-section-title for component tracking
 * @returns {ReactElement} <div>
 */
const SummaryItemFeatured = ({ hasRubricBelowHed = false, header, hedTag = 'h2', linkLabel, clickHandler, ctaUrl, impressionHandler, isHiddenOnMobile, shouldEnableBundleComponentAnalytics, shouldHideFeaturedDek = false, shouldHoldImageSpace, summaryItemProps, summaryItemVariation = 'TextBelowCenter', trackingNamespace }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SummaryItemFeatured'
        });
    }, []);
    const { url, rubric } = !!summaryItemProps && summaryItemProps; // adding a validation check for undefined summaryItemProps
    const SummaryItemComponent = SummaryItem[summaryItemVariation];
    const { formatMessage } = useIntl();
    const analyticsDataAttributeSummaryItem = componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, trackingNamespace?.summaryItem);
    const analyticsDataAttributeFeatureLink = componentTracking.addDataSectionTitleAttribute(shouldEnableBundleComponentAnalytics, trackingNamespace?.featureLink);
    return (React.createElement(SummaryItemFeaturedWrapper, { isHiddenOnMobile: isHiddenOnMobile, "data-testid": "SummaryItemFeatured" },
        React.createElement(FeaturedTitle, { as: hedTag, dangerouslySetInnerHTML: {
                __html: header || formatMessage(translations.featuredTitle)
            } }),
        React.createElement(SummaryItemComponent, { ...summaryItemProps, rubric: rubric, shouldHideDangerousDek: shouldHideFeaturedDek, analyticsDataAttribute: analyticsDataAttributeSummaryItem, hedTag: "div", shouldHideMetadataSecondary: true, shouldHidePublishDate: true, shouldHoldImageSpace: shouldHoldImageSpace, hasRubricBelowHed: hasRubricBelowHed, mobileDenseItemClassCarousel: "carousel_item-featured", impressionHandler: impressionHandler, clickHandler: clickHandler }),
        linkLabel && (React.createElement(FeaturedLink, { ...analyticsDataAttributeFeatureLink },
            React.createElement("a", { href: ctaUrl || url, dangerouslySetInnerHTML: { __html: linkLabel } })))));
};
SummaryItemFeatured.propTypes = {
    analyticsDataAttribute: PropTypes.object,
    clickHandler: PropTypes.func,
    ctaUrl: PropTypes.string,
    hasRubricBelowHed: PropTypes.bool,
    header: PropTypes.string,
    hedTag: PropTypes.oneOf(['h2', 'h3', 'div']),
    impressionHandler: PropTypes.func,
    isHiddenOnMobile: PropTypes.bool,
    linkLabel: PropTypes.string,
    shouldEnableBundleComponentAnalytics: PropTypes.bool,
    shouldHideFeaturedDek: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldTrackItemImpressionForSnowplow: PropTypes.bool,
    summaryItemProps: PropTypes.shape(SummaryItem.propTypes).isRequired,
    summaryItemVariation: PropTypes.string,
    trackingNamespace: PropTypes.object
};
SummaryItemFeatured.displayName = 'SummaryItemFeatured';
module.exports = SummaryItemFeatured;
//# sourceMappingURL=SummaryItemFeatured.js.map

/***/ }),

/***/ 29237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asConfiguredComponent } = __webpack_require__(12892);
const SummaryItemFeatured = __webpack_require__(64236);
module.exports = asConfiguredComponent(SummaryItemFeatured, 'SummaryItemFeatured');
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 56503:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BREAKPOINTS } = __webpack_require__(96472);
const { getTypographyStyles, getColorStyles, calculateSpacing } = __webpack_require__(26865);
const SummaryItemFeaturedWrapper = styled.div.withConfig({
    displayName: 'SummaryItemFeaturedWrapper'
}) `
  :not(:last-child) {
    margin-bottom: ${calculateSpacing(4)};
    border-bottom: 1px solid;
    ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.discovery.body.white.border')};
    padding-bottom: ${calculateSpacing(5)};
  }

  ${({ isHiddenOnMobile }) => isHiddenOnMobile &&
    `
    @media (max-width: calc(${BREAKPOINTS.lg} - 1px)) {
      display: none;
    }
  `};

  .summary-item {
    display: grid;
    border-bottom: none;
    padding: 0;
  }

  .summary-item__content {
    order: 1;
    padding: ${calculateSpacing(2)} 0;
  }

  .summary-item__content .summary-item__hed {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};

    margin-bottom: ${calculateSpacing(0.5)};
  }

  .summary-item__content .summary-item__dek {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};

    margin-bottom: 0;
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.context-signature')};
  }

  .summary-item__asset-container {
    order: 2;
    margin: auto;
    max-width: 67%;

    span {
      box-shadow: 0 0 24px 0 rgba(45, 45, 45, 0.16);
    }
  }
`;
const FeaturedTitle = styled.h2.withConfig({ displayName: 'FeaturedTitle' }) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-collection')};

  margin: 0;
  border-bottom: 1px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.discovery.body.white.border')};

  padding-bottom: ${calculateSpacing(1)};

  .small {
    font-variant: small-caps;
    text-transform: lowercase;
    font-style: normal;
  }
`;
const FeaturedLink = styled.div.withConfig({ displayName: 'FeaturedLink' }) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')};

  padding: ${calculateSpacing(2)} 0;
  text-align: center;

  a {
    text-decoration: none;
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.brand-primary')};
  }

  a:hover {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.dark')};
  }
`;
module.exports = {
    SummaryItemFeaturedWrapper,
    FeaturedTitle,
    FeaturedLink
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 71681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    featuredTitle: {
        id: 'SummaryItemFeatured.FeaturedTitle',
        defaultMessage: 'Featured',
        description: 'SummaryItemFeatured component featured title'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 67619:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const uniqBy = __webpack_require__(50014);
const React = __webpack_require__(96540);
const { useEffect, useState, useCallback, useMemo } = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const { useInView } = __webpack_require__(26855);
const debounce = __webpack_require__(38221);
const isEmpty = __webpack_require__(62193);
const { useViewportObserver } = __webpack_require__(55030);
const { TrackComponentChannel } = __webpack_require__(78788);
const Breakpoints = __webpack_require__(99906);
const { trackNavigationEvent, extractStrategyFromURL } = __webpack_require__(14307);
const { getCookie } = __webpack_require__(56892);
const { asConfiguredComponent } = __webpack_require__(12892);
const { asThemedComponent } = __webpack_require__(20223);
const { default: isLinkExternal } = __webpack_require__(13659);
const { googleAnalytics } = __webpack_require__(90090);
const { getAltTextForSeo } = __webpack_require__(27287);
const { getThemedBylineVariation } = __webpack_require__(27053);
const sparrow = 
// eslint-disable-next-line global-require
 true && __webpack_require__(31170);
const { formatGtmData, productImpressionTracking } = __webpack_require__(60162);
const Clamp = __webpack_require__(48286);
const ItemsCount = __webpack_require__(78372);
const Rubric = __webpack_require__(34187);
// FIXME: patterns shouldnt be importing compositions
const StoryAssurance = __webpack_require__(75013);
const Bylines = __webpack_require__(52540);
const InlineVideoItem = __webpack_require__(29697);
const ResponsiveAsset = __webpack_require__(73275);
const OverlaySummaryItem = __webpack_require__(18463);
const SummaryItemAsset = __webpack_require__(56816);
const SummaryItemByline = __webpack_require__(17035);
const SummaryItemHed = __webpack_require__(44553);
const SummaryItemReviewLabel = __webpack_require__(9486);
const SummaryItemBusinessProfileButton = __webpack_require__(56883);
const SummaryItemBusinessLocation = __webpack_require__(64273);
const SummaryItemBusinessCategory = __webpack_require__(75590);
const SummaryItemCTACard = __webpack_require__(99672);
const SummaryItemCTAPodcast = __webpack_require__(67709);
const SummaryItemAction = __webpack_require__(63902);
const SummaryItemProductOffers = __webpack_require__(75096);
const { LAYOUT_PLACEMENTS } = __webpack_require__(28197);
const { cutClearLink, getRecircId, hasFeatureVideo } = __webpack_require__(2953);
const { generateId } = __webpack_require__(54318);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const { SummaryItemBaseByline } = __webpack_require__(277);
const { handlSnowplowNavigationEvent } = __webpack_require__(55259);
const { SummaryItemContent, SummaryItemDek, SummaryItemDekReadMore, SummaryItemHedLink, SummaryItemAuthorTitle, SummaryItemMetadataPrimary, SummaryItemMetadataSecondary, SummaryItemRubric, SummaryItemRubricSeparator, SummaryItemRubricWrapper, SummaryItemStickyWrapper, SummaryItemWrapper, SummaryItemAssetContainer, SummaryItemContributorContent, SummaryItemContributorName, SummaryItemSignage, SummaryItemVenueDetails, SummaryItemContextualHeader, SummaryItemNowShopping, SummaryItemShopLink } = __webpack_require__(68116);
const SummaryItemSubHed = __webpack_require__(20267);
const SummaryItemContributor = __webpack_require__(79993);
const SummaryItemShopNowButton = __webpack_require__(50328);
const UtilityFeatures = __webpack_require__(23261);
const SummaryItemEventInfo = __webpack_require__(60572);
/**
 * SummaryItem component
 *
 * @param {object} props - React Props
 * @param {Function} [props.alternateClickHandlerStrategy] - called when user clicks anywhere on SummaryItem when defined, defaults to clickHandler
 * @param {object} [props.analyticsDataAttribute] - Optional data-section-title attribute for component level tracking
 * @param {string} [props.audioTagIconTitle] - Optional title for the headphone icon of the floating audio tag
 * @param {Array} [props.awards] - Optional awards array
 * @param {object} [props.business] - optional object that contains data for a business
 * @param {object} [props.businessInfo] - Optional object that contains data for business
 * @param {object} [props.buttonSize] - Optional string to set the button size
 * @param {string} [props.bylineVariation] - Optional variation of byline
 * @param {string} [props.className] - Optional top-level class to add
 * @param {Function} [props.clickHandler] - called when user clicks anywhere on non-bookmark SummaryItem
 * @param {Function} [props.clickHandlerContributors] - called when user clicks author
 * @param {Function} [props.clickHandlerHed] - called when user clicks hed
 * @param {Function} [props.clickHandlerRubric] - called when user clicks rubric
 * @param {string} [props.contentType] - Optional prop to generate classname to target items by contentType
 * @param {string} [props.contextualHeader] - Optional prop to generate contextualHeader for summaryItem
 * @param {object} [props.contributors] - Optional object containing data to create contributors bylines.
 * @param {string} [props.copilotID] - copilot id
 * @param {string} [props.dangerousDek] - Optional Parsed markdown (dangerously set) deck/sub-headline of content
 * @param {string} [props.dangerousHed] - Article Hed.
 * @param {string} [props.date] - Optional Publish Date.
 * @param {string} [props.defaultTypeForContributor] - Optional defaultTypeForContributor.
 * @param {string} [props.defaultContributorDetailField] - Optional defaultContributorDetailField.
 * @param {string} [props.eventDate] - Optional Event Date.
 * @param {object} [props.summaryItemMetaData] - Object containing SummaryItemMetaData information.
 * @param {string} [props.fullPageTheme] - Optional prop to apply an inverted (dark) theme to the entire page
 * @param {string} [props.generateIdFrom] - optional field to show the component id
 * @param {ResponsiveAsset.propTypes | InlineVideoItem.propTypes.image} [props.image] - Object containing sources for a
 *   ResponsiveAsset or Video
 * @param {boolean} [props.hasBorder] - Optional. default true
 * @param {boolean} [props.hasBorderOnLargeScreen] - Optional. default false
 * @param {boolean} [props.hasBorderOnMobileAndTabletOnly] - Optional. default false
 * @param {boolean} [props.hasBundleClass] - Optional. default true
 * @param {boolean} [props.hasBylineBeforeDek] - Optional. place the byline immediately after hed on mobile only.
 * @param {boolean} [props.hasCoverCollage] - Optional. default false
 * @param {boolean} [props.hasImageCenteredButtonInCarousel] - Optional. Whether to display carousel control at center of the image
 * @param {boolean} [props.hasListInDek] - Optional. Set `true` if there is a ul inside.
 * @param {boolean} [props.hasMetaWithoutMargin] - Optional. Set `true` to remove bottom margin from metadata
 * @param {boolean} [props.hasNoBottomMarginForCneVideo] -  Optional flag to remove bottom margin for cnevideo
 * @param {boolean} [props.hasNoBottomPaddingForCneVideo] -  Optional flag to remove bottom bottompadding for cnevideo
 * @param {boolean} [props.shouldUseFlexGrow] - Optional boolean to add flex grow styles
 *   default false
 * @param {boolean} [props.hasNoBottomPaddingContent] - Optional. Set `true` to remove bottom padding from summary content
 * @param {boolean} [props.hasMarginSpacing] - Optional. Set to `true` for margin spacing
 * @param {boolean} [props.hasModerateSpacing] - Optional. default false has moderate spacing
 * @param {boolean} [props.hasDefaultSpacingMarginBottom] - Optional flag to set the margin bottom to default value for summaryitemhed
 * @param {boolean} [props.hasRubricBelowHed] - Optional. Positions the rubric under Hed
 * @param {boolean} [props.hasRule] - Optional. Show or should hide the decrorative rule.
 * @param {boolean} [props.hasSummaryItemAction] - Show or hide SummaryItemAction
 * @param {boolean} [props.hideIssueDate] - Show or hide the issue date
 * @param {boolean} [props.isRecircListItem] - Indicates whether the component is used in a recirculation list
 * @param {string} [props.recircPlacement] - Flag that determines placement of recirc item
 * @param {boolean} [props.hideRuleFromMobile] - Optional. Show or should hide the decrorative rule from mobile.
 * @param {object} [props.hasSeriesData] - Optional boolean to display series data
 * @param {boolean} [props.hasSideBySideMobileOnlyImageRight] - Optional. Enable side by side image to right for mobile view only
 * @param {boolean} [props.hasSponsorByline] - Optional. Default false
 * @param {boolean} [props.hasStoryAssurance] -  Optional. to show story assurance based on word count, instead of rubric
 * @param {boolean} [props.hasSummaryItemAssetSpacing] - Optional. Adds space around summary item asset
 * @param {boolean} [props.hasTighterVerticalSpacing] - Optional. has tighter spacing for reduced white space
 * @param {boolean} [props.hasVerticalRule] - Optional. partial (60%) vertical rule on the right of item, desktop only.
 *   in a list, dont apply to last item to have vertical rules between items
 * @param {boolean} [props.hasWrapperButtonRole] - Optional Adds button role in the component wrapper
 * @param {string} [props.hedTag] - Option to override the default header html tag when nested whithin a higher level
 * @param {boolean} [props.hasNoHedTagMargin] - Optional flag, to avoid default H tag margin
 *   header
 * @param {boolean} [props.hasNoHedTagMarginTop] - Optional flag, to avoid default Hed tag top margin
 * @param {string} [props.hideBylinesUntil] - Option to hide bylines until a specified breakpoint. default 'sm'
 * which shows bylines across all breakpoints. Note: Use shouldHideBylines to show/hide bylines across all breakpoints
 * @param {boolean} [props.hideIssueDate] - Show or hide the issue date
 * @param {boolean} [props.hidePadding] - Show or hide the padding
 * @param {boolean} [props.hideRubricItemSummary] - [`bool`] Optional. Set `true` for hide rubrics, set `false` for
 *   show rubrics.
 * @param {boolean} [props.hideRubricLink] - [`bool`] Optional. Set `true` for hide rubrics link, set `false` for show rubrics link.
 * @param {Function} [props.iconButtonOnclickHandler] - called when user clicks on bookmark icon
 * @param {Function} [props.iconType] - Option value for which icon family to use
 * @param {boolean} [props.isRegistrationRequired] - Optional value to determine if registration is required to view the content
 * @param {string} [props.issueDate] - Issue Date of magazine
 * @param {boolean} [props.hasNoFollowOnSyndicated] - Optional if item is syndicated
 * @param {boolean} [props.hasSummaryItemExtraPadding] - Optional boolean to check for extra padding
 * @param {boolean} [props.hasUnderlineHed] - Optional boolean to enable or disable underline in hed (default to true)
 * @param {boolean} [props.isAudioArticle] - Optional defined if article is audio article, defined by tag name
 * @param {boolean} [props.isLazy] - Optional if assets are to be lazy-loaded
 * @param {boolean} [props.isLive] - Optional flag indicating we should show the LIVE status. Default: FALSE.
 * @param {boolean} [props.isSticky] - Optional flag to make SummaryItem card sticky only if it is wrapped in containers like SummaryCollageFive
 * @param {number} [props.itemIndex] - Optional itemIndex
 * @param {string} [props.itemInViewGAEventName] - Optional GA event name that triggers when item is in view
 * @param {boolean} [props.isSpecial] - Optional prop to check whether it is special theme or not
 * @param {boolean} [props.isSponsored] - Optional if content is sponsored
 * @param {object} [props.itemsCount] - Optional
 * @param {number} [props.maxContributors] - Maximum number of contributors to show
 * @param {number} [props.maxContributorsNames] - Optional maximum number of contributors names to be displayed
 * @param {number} [props.maxHedLines] - Optional maximum number of visual lines for the hed to occupy
 * @param {number} [props.maxDekLines] - Optional maximum number of visual lines for the dek to occupy
 * @param {number} [props.maxDekLinesInMobile] - Optional maximum number of visual lines for the dek to occupy in mobile screens
 * @param {number} [props.maxDekLinesInTablet] - Optional maximum number of visual lines for the dek to occupy in tablet screens
 * @param {number} [props.maxDekLinesInDesktop] - Optional maximum number of visual lines for the dek to occupy in desktop screens
 * @param {number} [props.maxDekLinesInLargeDesktop] - Optional maximum number of visual lines for the dek to occupy in large desktop screens
 * @param {number} [props.maxDekLinesInExtraLargeDesktop] - Optional maximum number of visual lines for the dek to occupy in extra large desktop screens
 * @param {object} [props.metadataVideo] - Optional CNE video metadata
 * @param {boolean} [props.isTruncateDek] - Optional bool to truncate Dek
 * @param {string} [props.metadataPrimary] - Optional line of metadata
 * @param {string} [props.metadataSecondary] - Optional second line of metadata
 * @param {boolean} [props.shouldOpenInternalLinksInNewTab] - Optional component config to open internal link in a new tab
 * @param {Array} [props.offers] - Optional array of offers
 * @param {string} [props.playIconStyle] - Optional choice of 'dark', or 'cne' for play icon
 * @param {string} [props.primaryCta] - Optional primaryCta for podcasts.
 * @param {object} [props.recircId] - Optional recircId for Sparrow tracking
 * @param {object} [props.recircRiver] - Optional recirc river for Sparrow tracking
 * @param {object} [props.rubric] - Optional rubric.
 * @param {string} [props.registrationGateCookie] - Optional name of cookie to bypass the registration gate
 * @param {string} [props.registrationGateURL] - Optional URL of the registration gate
 * @param {string} [props.rubricIconOverride] - Optional svg icon string to override the rubric icon
 * @param {string} [props.rubricVariation] - Optional rubric variation to use
 * @param {boolean} [props.shouldAlignDekAtBottom] - Optional prop to display dek at the bottom of the container
 * @param {string} [props.imageAlignment] - Optional prop to display dek at the bottom of the container
 * @param {string} [props.sectionTemplate] - The name of the used template. It is needed to be able to distinguish between the different representations of the SummaryItem.
 * @param {boolean} [props.shouldApplyImageBorderRadius] - Optional prop to apply border radius to image from BI
 * @param {boolean} [props.shouldDisplaySignage] - Optional boolean to display signage, defaults to false
 * @param {boolean} [props.shouldDisplaySignageInline] - Optional boolean to display signage inline with content
 * @param {boolean} [props.shouldDekHideOnMobileAndShowOnTablet] - Optional boolean to hide dangerousDek on mobile only i.e. < 768px
 * @param {boolean} [props.shouldEnableReviewFlag] - Optional boolean to enable best new music flag
 * @param {boolean} [props.shouldHandleOverlayForLongHed] - Optional boolean to set new styled to overlay item for long hed
 * @param {boolean} [props.shouldHaveBorderBottomOnItem] - Optional boolean to check whether we need border bottom or not
 * @param {boolean} [props.shouldHideBookmarkIcon] - Optional flag to hide bookmark icon
 * @param {boolean} [props.shouldHideBylines] - Optional boolean to hide bylines
 * Note: Use hideBylinesUntil to hide by lines until specific breakpoint.
 * @param {boolean} [props.shouldHideIcon] - Optional boolean to hide icons
 * @param {boolean} [props.shouldHideFinalBorder] - Optional flag to hide bottom border on the last Item in its section
 * @param {boolean} [props.shouldLinkByline] - Optional boolean to link bylines, default to true
 * @param {boolean} [props.shouldHideContributors] - Hide contributors in byline
 * @param {boolean} [props.shouldHideDangerousDek] - Optional flag to hide dangerousDek
 * @param {boolean} [props.shouldHideDangerousDekMobileOnly] - Optional flag to hide dangerousDek on mobile / tablet
 * with CSS (defaults to false). Note: shouldDekHideOnMobileAndShowOnTablet can be used if dek needs to be
 * shown in tablet and hidden in mobile devices
 * @param {boolean} [props.shouldHideDangerousHed] - Optional flag to hide dangerousHed (defaults to false)
 * @param {boolean} [props.shouldHideDekBottomMargin] - Optional flag to hide dek bottom margin (defaults to false)
 * @param {boolean} [props.shouldDekhaveExtraVerticalSpace] - Optional boolean to give dangerousDek extra bottom spacing
 * @param {boolean} [props.shouldHideEventDate] - Optional flag to hide Event Date (defaults to true)
 * @param {boolean} [props.shouldHideItemCount] - Optional flag to hide Item count and slide (defaults to true)
 * @param {boolean} [props.shouldHideMetadataSecondary] - Optional boolean to hide MetadataSecondary (default to false)
 * @param {boolean} [props.shouldHidePublishDate] - Optional flag to hide publish date
 * @param {Array<string>} [props.shouldHidePublishDateInTemplate] - Optional array of container.template names (sectionTemplate; from the parent component) where to hide publish date
 * @param {boolean} [props.shouldHideSubHed] - Optional flag to toggle display of subhed default true
 * @param {boolean} [props.shouldHideSubHedForTracks] - Optional flag to toggle display of subhed default true
 * @param {boolean} [props.shouldHideVideoDek] - Optional boolean to hide deks on videos
 * @param {boolean} [props.shouldPlaceVenueBelowDek] - Optional boolean to place venue detail below dek
 * @param {boolean} props.shouldPlayInline - Switch to enable inline video playback
 * @param {boolean} [props.shouldNotPreventPageRedirect] - will open link in new chrome tab
 * @param {boolean} props.shouldRemoveHorizontalPadding - Optional to remove side paddings and set top and bottom paddings to 16px.
 * @param {boolean} [props.shouldEnablePlayIcon] - Optional flag to display play icon for cne video content type
 * @param {boolean} [props.shouldHoldImageSpace] - Optional flag to tell item to hold image space
 * @param {boolean} [props.shouldTrackItemImpressionForSnowplow] - Optional flag to tell item impression event to be tracked for snowplow
 * @param {boolean} [props.shouldTriggerDynamicUKExperienceTracking] - Optional flag to trigger summary_collection instead of recirc_unit event
 * @param {string}  [props.placement] - Optional placement info of the item for Snowplow tracking
 * @param {boolean} [props.shouldAppendReadMoreLinkForDek] - Optional flag append a 'Read More' link in dangerousDek
 * @param {boolean} [props.shouldAutoPlay] - Optional boolean to start playing video clip once component is rendered
 * @param {boolean} [props.shouldShowAllContentWhenDense] - Optional. isDense floats the image right but also hides content
 * on some viewports. This shows it all, always.
 * @param {boolean} [props.shouldUseArrowIconInDek] - Optional boolean to add arrow icon in SummaryItemDek
 * @param {boolean} [props.shouldUseFeaturedFontWeight] - optional flag for featured font weight
 * @param {boolean} [props.shouldUseMediumBreakpoint] - Optional. Set to `true` will enable a third medium breakpoint on
 *   ResponsiveImage.js
 * @param {Array} [props.multiImages] - Optional Object containing multiple images for same item.
 * @param {boolean} [props.shouldUseSmallHed] - Optional flag to use a smaller font size for the hed
 * @param {boolean} [props.shouldUseSmallImageMobileOnly] - Optional. Set to `true` will render a small sized image for
 *   XS,S and M breakpoints
 * @param {boolean} [props.shouldVerticallyAlignHed] - Optional flag to remove the margin-bottom from the hed
 * @param {boolean} [props.showCommaAsideContributorName] - ooptional flag to override exisitng comma(,) with custom logic
 * @param {boolean} [props.showContributorDetail] - Optional. Set to `true` to render contributorDetail.
 *   to fix visual bug with long author name. see #8939 for details - defaults to false
 * @param {boolean} [props.shouldEmbedCneVideo] - EmbedVideoInGrid
 * @param {boolean} [props.showOffers] - Optional flag to show offers
 * @param {boolean} [props.showReviewLabel] - Optional. Set to `true` to render review label.
 * @param {boolean} [props.showShopNowButton] - Optional. Set to `true` to render shop now button.
 * @param {Array} [props.shouldLimitSavingToContentTypes] - flag to determine if saving should be enabled only on certain content types
 * @param {string} [props.sideBySideVerticalAlign] - [`center`, `top`] Vertical alignment of content when placed side by
 *   side. Defaults to `center`
 * @param {string} [props.signage] - Optional signage label to display on top of SummaryImage
 * @param {bool} [props.sparrowPattern] - Special sparrow pattern dimension that sends with event
 * @param {bool} [props.shouldUpdateVideoTitleOnVideoChange] - Optional flag, to update video title on video change
 * @param {object} [props.snowplowEvent] - Optional. Properties that can be passed to snowplow event navigation on click
 * @param {bool} [props.isAuthenticated] - represents if the user is currently authenticated.
 * @param {string} props.url - Url path to the content
 * @param {object} [props.variations] - Optional. Variation properties used in rendering the component.
 * @param {boolean} [props.variations.cardContentPaddingStyles] - Optional. Useful to add/remove card content padding styles
 * @param {boolean} [props.variations.circleImage] - [`bool`] Optional. Set to `true` if the image should be cropped to
 *   a circle.
 * @param {string} [props.variations.contentAlign] - [`center`, `left`] Optional. Sets the text alignment of textual
 * @param {string} [props.variations.contentAlignmentInMobile] - [`center`, `left`] Optional. by default do nothing. Sets the text alignment in mobile view.
 *   content block. Defaults to `left`
 * @param {boolean} [props.variations.hasAsset] - [`bool`] Optional
 * @param {boolean} [props.variations.hasCTA] - Optional, enables the Watch CTA
 * @param {boolean} [props.variations.hasLeftMargin] - Optional, used for marginal spacin for overlay
 * @param {boolean} props.variations.hasAudioTag - [`bool`] Optional to display the floating icon
 * @param {string} [props.variations.hasBookmarks] - Optional. Set to `true` for bookmark item display
 * @param {string} [props.variations.iconPosition] - Optional
 * @param {boolean} [props.variations.isCard] - [`bool`] Optional. Set to `true` if this will have a card background.
 * @param {boolean} [props.variations.isContributor] - Optional. Set to `true` to render contributor layout.
 * @param {boolean} [props.variations.showReadMore] - Optional. Set to `true` to render contributor readmore.
 * @param {bool} [props.variations.shouldAssetHaveNoBottomMargin] - Optional prop to hide bottom margin
 * @param {string} [props.variations.shouldDisplayLiveIndicator] - boolean, used to enable live indicator, default is false
 * @param {string} [props.variations.isDarkBackground] - [`text-below`, `text-below-desktop-only`, `side-by-side`,
 * @param {boolean} [props.variations.isContributorGridItem] - Optional, sets layout to ContributorGridItem
 * @param {boolean} [props.variations.isContributorImageTopAligned] - Optional. Set to `true` to render contributor image top aligned.
 *   `side-by-side-desktop-only`, `side-by-side-mobile-only`] Optional. Horizontal / Vertical placement of content Dark
 *   Background with Padding.
 * @param {string} [props.variations.isDarkBackgroundRight] - [`text-below`, `text-below-desktop-only`, `side-by-side`,
 *   `side-by-side-desktop-only`, `side-by-side-mobile-only`] Optional. Horizontal / Vertical placement of content Dark
 *   Background with Padding.
 * @param {boolean} [props.variations.isDense] - Changes the summary item to float structure instead of grid as
 *   summaryItem default is not grid. Instead set the asset to float right so that the content can be more condensed
 *   and text can wrap underneath it.
 * @param {boolean} [props.variations.hasHedCorePrimary] - Optional. Set to `true` to render hed-core-primary font.
 * @param {boolean} [props.variations.hasSecondaryCTA] -  Optional.will be false only for podcasts with variation 'PodcastsWithAppleEmbed'
 * @param {boolean} [props.variations.hasPrimaryCTA] -  Optional.will be true only for podcasts with variation 'PodcastsWithoutAppleEmbed'
 * @param {boolean} [props.variations.isHighDensity] - [`bool`] Optional. Set to `true` to render just the headline on
 *   mobile viewports
 * @param {string} [props.variations.layoutPlacement] - [`text-below`, `text-below-desktop-only`, `side-by-side`,
 *   `side-by-side-desktop-only`, `side-by-side-mobile-only`] Optional. Horizontal / Vertical placement of content.
 * @param {string} [props.variations.layoutPosition] - [`image-left`, `image-right`, ] Optional. Set which side the
 *   image is on in side by side layouts.
 * @param {boolean} [props.variations.imageWarp] - Optional. Set to `true` to warp the image around text.
 * @param {string} [props.variations.layoutProportions] - [`50-50`, `33-66`, `66-33`, `20-80`,`overlay`, `overlay-limited-height` ]
 *   Optional. Set the proportions for side by side layouts.
 * @param {boolean} [props.variations.hasUtilityFeatures] - enable the utility features like bookmark and comments count on the card
 * @param {string} [props.variations.primaryBlock] - display block for first row
 * @param {string} [props.variations.marginTop] - margin top for variation TextBelowDesktopOnlyThirdsImageRightThumbnailGrid
 * @param {number} [props.wordCount] - Optional, needed to get the story assurance
 * @param {string} [props.metadataSecondaryMessage] - Optional metadata secondary
 * @param {boolean} [props.shouldDisableGradientContentBlock] - Optional prop that can be used to remove gradient effect
 * @param {string} [props.showHeadTagAs] - Optional to replace h2 tags with h3 values
 * @param {string} [props.showHeadTagAsForRecirc] - Optional heading tag setting for recirc units
 * @param {string} [props.shouldCenterAlignContributorName] - Optional to algin contributor name center, when image is not present
 * @param {object} [props.subHed] - Optional to add sub hed below hed
 * @param {boolean} [props.showAuthorTitle] - Optional to display author title, default false
 * @param {boolean} [props.variations.shouldDisplayPremiereDate] - Optional to display premiere date
 * @param {boolean} [props.variations.shouldDisplayVideoTime] - Optional, used to show/hide video play time, default is false
 * @param {boolean} [props.variations.showOnHoverEffect] - set  to true, when needs some effects on hovering.
 * @param {boolean} [props.variations.showBusinessCategory] - Optional, used to show/hide a Business operational category
 * @param {boolean} [props.variations.showLocation] - Optional, used to show/hide a location hierarchy
 * @param {boolean} [props.variations.showProfileButton] - Optional, used to show/hide a "view profile" button
 * @param {boolean} [props.variations.isDenseDesktopStack] - Optional, used to trigger the image inset "dense" layout on mobile, and stack on desktop.
 * @param {boolean} [props.variations.isDenseDesktopThirds] - Optional, used to trigger the image inset "dense" layout on mobile, and sidebyside thirds on desktop
 * @param {boolean} [props.variations.shouldUseGridStyles] - Optional, used to apply the grid styles for the summary item in accounts page
 * @param {object} [props.ratingValue] - Optional to add rating
 * @param {string} [props.venueAwards] - Optional, used to show venue awards
 * @param {string} [props.venueDetails] - Optional to show venue details
 * @param {boolean} [props.isVenueCardItemContainer] - padding flag for new venuecard container
 * @param {string} [props.clampBreakpoint] - Optional string to set maximum screen breakpoint truncation can be executed
 * @param {string} [props.shouldUseRubricAsRole] - Optional boolean to set rubric as role
 * @param {boolean} [props.shouldDisplayImageCount] - Optional boolean to display image slide count in recirc unit (default to false)
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {boolean} [props.hasMediumMarginBottom] - Margin flag for medium bottom margin
 * @param {boolean} [props.hasNoBottomPaddingForGridContent] - optional flag to disable bottom padding for grid content
 * @param {boolean} [props.hasRoundedEdges] - - Optional, whether to show rounded image edges
 * @param {boolean} [props.isAlternateClickHandlerStrategy] - Optional flag to disable wrapper click
 * @param {boolean} [props.isCtaButtonClickable] - optional flag to enable CTA button click
 * @param {string} [props.ctaTextSource] - Optional string to read CTA text from source for externallinks
 * @param {boolean} [props.isPlpCurated] - Optional - to remove the padding bottom from carousel slider
 * @param {string} [props.primaryCTALabel] - Optional string to read primary CTA label text
 * @param {string} [props.secondaryCTALabel] - Optional string to read secondary CTA label text
 * @param {string} [props.responsiveCartoonVariation] - Responsive Cartoon variation
 * @param {Function} [props.clickItem] - Optional click item handler for call to action
 * @param {string} [props.layout] - prop for content items layout
 * @param {number} [props.totalItems] - prop that contains total number of items.
 * @param {number} [props.index] - prop for indexing items in the layout
 * @param {Array} [props.node] - Optional prop for node item
 * @param {boolean} [props.showReviewTitleForTracks] - Optional to use review title as hed
 * @param {object} [props.source] - Optional to get review title as hed
 * @param {boolean} [props.isSeriesNavigation] - Optional flag value is true if layout is SeriesNavigationCarousel
 * @param {object} [props.isCurrent] - Optional to to check whether the now shopping url
 * @param {string} [props.signalType] - Specifying the icon to be displayed in the actionBar
 * @param {object} [props.actionBarConfig] - config for the actionBar
 * @param {boolean} [props.isTextExternalLink] - Optional flag for external link with text
 * @param {boolean} [props.hasMultipleRubric] - - Optional, whether rubric has more than one item
 * @param {boolean} [props.shouldShowVenueDetails] - Optional flag to show venue details
 * @param {string} [props.mobileDenseItemClassCarousel] - Optional classname for Carousel component
 * @param {boolean} [props.shouldEnableCardLevelBookmark] - flag to show the utility bookmark option
 * @param {boolean} [props.shouldEnableCommentsCount] - flag to show the comments count
 * @param {boolean} [props.shouldUseBookmarkV3] - Feature flag to define whether to use bookmark v3
 * @param {boolean} [props.commentsCount] - total primary comments count added for the story
 * @param {boolean} [props.shouldHideCartoonCaption] - Optional hides the cartoon caption
 * @param {boolean} [props.shouldHideCartoonCredit] - Optional hides the cartoon credit
 * @param {boolean} [props.shouldEnableBookmarkDrawers] - flag to enable bookmark drawer functionality
 * @param {string} [props.sectionTitleLabel] - SectionTitle value
 * @param {string} [props.subjectVersion] - subject versions are `default/mobile_dense`. `default` is for Desktop
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @param {boolean} [props.shouldTrackItemEvents] - Optional prop to enable/disable tracking for item events
 * @param {object} [props.actionIdFlags] - Optional object to enable actionId for summary item
 *
 * @returns {ReactElement} <div>
 */
// eslint-disable-next-line complexity
const SummaryItem = (props) => {
    const { actionBarConfig, alternateClickHandlerStrategy = undefined, analyticsDataAttribute = {}, audioTagIconTitle, awards, business, businessInfo, buttonSize, bylineVariation, className, clampBreakpoint, clickHandler = () => { }, clickHandlerContributors, clickHandlerHed, clickHandlerRubric, clickItem = () => { }, commentsCount, contentType, contextualHeader, contributors, copilotID, ctaTextSource, dangerousDek, dangerousHed, contentId, date: publishDate, defaultTypeForContributor = 'author', defaultContributorDetailField = 'featuredBio', shouldEmbedCneVideo, eventDate, summaryItemMetaData = {}, shouldLimitSavingToContentTypes, fullPageTheme, generateIdFrom, hasBorder = true, hasBorderOnLargeScreen = false, hasBorderOnMobileAndTabletOnly = false, hasBorderSides, hasBundleClass = true, hasBylineBeforeDek = false, showReviewTitleForTracks, hasDefaultSpacingMarginBottom = false, responsiveCartoonVariation, hasImageCenteredButtonInCarousel = false, hasListInDek = false, hasMarginSpacing = false, hasMediumMarginBottom, hasMetaWithoutMargin = false, hasModerateSpacing = false, hasMultipleRubric = false, hasNoBottomMarginForCneVideo, hasNoBottomPaddingForCneVideo, hasNoBottomPaddingForGridContent, hasNoBottomPaddingContent = false, hasNoHedTagMargin, hasNoHedTagMarginTop = false, hasRubricBelowHed, hasRule = true, hasCoverCollage = false, hasSponsorByline = false, hasUnderlineHed = true, hasSideBySideMobileOnlyImageRight = false, hasStoryAssurance = false, hasSummaryItemAssetSpacing = false, hasTighterVerticalSpacing = false, hasVerticalRule = false, hedTag = 'h2', hideBylinesUntil = 'sm', hideIssueDate = true, hidePadding = false, hideRubricItemSummary = false, hideRubricLink = false, hideRuleFromMobile = false, isAlternateClickHandlerStrategy = false, isRecircListItem, recircPlacement, iconButtonOnclickHandler, isCategoryFeatureContainer, isCtaButtonClickable = false, iconType = 'thinner', image, isRegistrationRequired, isAudioArticle = false, isLazy = true, impressionHandler, isLive = false, isSponsored, isSpecial = false, isSticky = false, issueDate, hasNoFollowOnSyndicated, isVenueCardItemContainer = false, itemIndex, itemInViewGAEventName, itemsCount, totalItems, maxContributors, maxContributorsNames, maxDekLines, maxDekLinesInMobile, maxDekLinesInTablet, maxDekLinesInDesktop, maxDekLinesInLargeDesktop, maxDekLinesInExtraLargeDesktop, maxHedLines = Infinity, metadataPrimary, metadataVideo = {}, multiImages, metadataSecondaryMessage, offers, placement, playIconStyle, parentDangerousHed = '', ratingValue = {
        isBestNewReissue: false,
        isBestNewMusic: false,
        channelType: '',
        score: 0
    }, recircId, recircRiver, registrationGateCookie, registrationGateURL, rubric, rubricIconOverride, rubricVariation, hasRoundedEdges = false, hasSeriesData = false, hasSummaryItemAction, hasSummaryItemExtraPadding = false, hasWrapperButtonRole = true, shouldAlignDekAtBottom = false, shouldUseRubricAsRole = false, shouldHideContributorContent = false, shouldTrackItemImpressionForSnowplow, showContributorContentOnTop = false, hasBottomSpaceOnRubric = false, imageAlignment = 'default', primaryCta, sectionTemplate, shouldApplyImageBorderRadius = false, shouldAutoPlay, shouldDekHideOnMobileAndShowOnTablet = false, shouldDisableGradientContentBlock, shouldDisplaySignage = false, shouldDisplaySignageInline = false, shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark, shouldEnableCommentsCount, shouldUseBookmarkV3, shouldHideBookmarkIcon = true, shouldHideBylines = false, shouldHideDangerousDek = false, shouldHideDangerousDekMobileOnly = false, shouldHideDangerousHed, shouldDekhaveExtraVerticalSpace = false, shouldHandleOverlayForLongHed, shouldHaveBorderBottomOnItem = false, shouldHideEventDate = true, shouldHideFinalBorder = false, shouldHideIcon = false, shouldHideItemCount = false, shouldHideSubHed = true, shouldHideSubHedForTracks = false, shouldHideVideoDek = false, shouldLinkByline = false, shouldHideContributors = false, shouldHideDekBottomMargin = false, shouldHideMetadataSecondary = false, shouldHidePublishDate = true, shouldHidePublishDateInTemplate = [], shouldHoldImageSpace = true, shouldOpenInternalLinksInNewTab, shouldPlaceVenueBelowDek = false, shouldPlayInline = false, shouldNotPreventPageRedirect = true, shouldShowVenueDetails = true, shouldShowAllContentWhenDense = false, shouldRemoveHorizontalPadding = false, shouldRemoveSummaryItemBorder = false, shouldAppendReadMoreLinkForDek = false, shouldTriggerDynamicUKExperienceTracking = false, shouldUseArrowIconInDek, shouldUseFeaturedFontWeight, shouldUseFlexGrow = false, shouldUseMediumBreakpoint, shouldUseSmallHed, shouldUseSmallImageMobileOnly = false, shouldVerticallyAlignHed, showCommaAsideContributorName = false, showContributorDetail = false, showOffers = false, showReviewLabel = false, showShopNowButton = false, showHeadTagAs, showHeadTagAsForRecirc, sideBySideVerticalAlign = 'center', signage, signalType, snowplowEvent = {}, sparrowPattern = 'summary-item', subHed, isTruncateDek = false, isAuthenticated = false, url, shouldUpdateVideoTitleOnVideoChange = false, shouldEnablePlayIcon = false, shouldEnableReviewFlag = false, shouldCenterAlignContributorName = false, showAuthorTitle = false, shouldDisplayImageCount = false, source, subtype, variations = {
        cardContentPaddingStyles: true,
        circleImage: false,
        contentAlign: 'left',
        contentAlignmentInMobile: undefined,
        shouldDisplayLiveIndicator: false,
        hasAsset: true,
        hasAudioTag: false,
        hasBookmarks: false,
        hasCTA: false,
        hasLeftMargin: false,
        hasPrimaryCTA: false,
        hasSecondaryCTA: false,
        hasUtilityFeatures: false,
        iconPosition: 'left',
        isCard: false,
        isContributor: false,
        isContributorGridItem: false,
        isContributorImageTopAligned: false,
        isContributorThreeCol: false,
        isDarkBackground: false,
        isDarkBackgroundRight: false,
        isDense: false,
        isDenseDesktopStack: false,
        isDenseDesktopThirds: false,
        hasHedCorePrimary: false,
        isHighDensity: false,
        imageWarp: false,
        layoutPlacement: 'text-below',
        layoutPosition: 'image-left',
        layoutProportions: '50-50',
        primaryBlock: false,
        marginTop: false,
        shouldAssetHaveNoBottomMargin: false,
        shouldDisplayPremiereDate: false,
        shouldDisplayVideoTime: false,
        shouldUseGridStyles: false,
        showOnHoverEffect: true,
        showBusinessCategory: false,
        showLocation: false,
        showProfileButton: false,
        showReadMore: false
    }, venueAwards, venueDetails, venueName, wordCount, variationName, isPlpCurated, isSeriesNavigation, isCurrent, layout, index, primaryCTALabel, secondaryCTALabel, node, isTextExternalLink, mobileDenseItemClassCarousel, shouldHideCartoonCaption, shouldHideCartoonCredit, sectionTitleLabel, subjectVersion, shouldTrackItemEvents, actionIdFlags = {} } = props;
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'SummaryItem',
            variation: variationName
        });
    }, [variationName]);
    const { cardContentPaddingStyles, circleImage, contentAlign, contentAlignmentInMobile, shouldDisplayLiveIndicator, hasAsset, hasAudioTag, hasBookmarks, hasCTA, hasLeftMargin, hasPrimaryCTA, hasSecondaryCTA, hasUtilityFeatures, iconPosition, isCard, isContributor, isContributorGridItem, isContributorImageTopAligned, isContributorThreeCol, isDarkBackground, isDarkBackgroundRight, isDense, isDenseDesktopStack, isDenseDesktopThirds, hasHedCorePrimary, isHighDensity, layoutPlacement, layoutPosition, layoutProportions, primaryBlock, marginTop, shouldAssetHaveNoBottomMargin, shouldDisplayPremiereDate, shouldDisplayVideoTime, shouldUseGridStyles, showOnHoverEffect, showBusinessCategory, showLocation, showProfileButton, showReadMore, imageWarp } = variations;
    const hasGridOrCarouselLayout = layout === 'ContentCarousel' || layout === 'GridFourColumns';
    const contentData = useMemo(() => ({
        id: copilotID,
        title: dangerousHed,
        name: contentType,
        url,
        position: index,
        contentId
    }), [contentType, copilotID, dangerousHed, index, url, contentId]);
    const type = url?.split('/')[1];
    const isHotelType = type === 'hotels';
    React.useEffect(() => {
        if (isHotelType) {
            window.addEventListener('load', () => productImpressionTracking('ProductEmbed', document.getElementsByClassName('product-embed')));
            window.addEventListener('scroll', debounce(() => {
                productImpressionTracking('ProductEmbed', document.getElementsByClassName('product-embed'));
            }, 1000));
        }
    }, [isHotelType]);
    const productData = {
        dangerousHed,
        id: node?.id || copilotID,
        index: itemIndex,
        contentType: 'venue',
        offers,
        hotelLink: url,
        layout: layout || 'GridFourColumns'
    };
    const { ctaLabel, eventStatus } = summaryItemMetaData;
    const [isUrlDomainExternal, setIsUrlDomainExternal] = React.useState(false);
    React.useEffect(() => {
        if (true) {
            setIsUrlDomainExternal(isLinkExternal(url, window.location.hostname));
        }
    }, [url]);
    // Any external link content type should always open in a new tab
    const isExternalLink = contentType === 'externallink' && isUrlDomainExternal;
    const shouldOpenUrlInNewTab = isExternalLink || shouldOpenInternalLinksInNewTab;
    const completeRubric = hasMultipleRubric
        ? rubric
        : {
            ...rubric,
            ...(rubricIconOverride && { dangerousIcon: rubricIconOverride })
        };
    const isPublishDateHidden = shouldHidePublishDateInTemplate.includes(sectionTemplate)
        ? true
        : shouldHidePublishDate;
    const [redirectURL, setRedirectURL] = useState('');
    const [updateVideoTitle, setUpdateVideoTitle] = useState('');
    const [isGAFired, setGAFired] = useState(false);
    const [itemRef, itemInView] = useInView({
        threshold: 0.5,
        trackVisibility: true,
        delay: 100,
        triggerOnce: true
    });
    const { ref: recircItemRef, entry } = useInView({
        threshold: 0.1,
        trackVisibility: true,
        delay: 100,
        triggerOnce: true
    });
    // if registration is required and user has not yet registered, send user to registration page
    useEffect(() => {
        const registrationCookieExists = getCookie(registrationGateCookie);
        if (!isAuthenticated &&
            isRegistrationRequired &&
            !registrationCookieExists) {
            const newURL = `${registrationGateURL}?redirectURL=${url}`;
            setRedirectURL(newURL);
        }
    }, [
        isAuthenticated,
        registrationGateCookie,
        isRegistrationRequired,
        registrationGateURL,
        url
    ]);
    const recircItemClassName = isRecircListItem && `${recircPlacement}-${recircId}`;
    useEffect(() => {
        if (entry?.isIntersecting &&
            (isRecircListItem || shouldTriggerDynamicUKExperienceTracking)) {
            let eventData = {
                type: 'impression',
                label: sectionTitleLabel,
                subject: 'recirc_unit',
                strategy: extractStrategyFromURL(contentData.url),
                placement: recircPlacement,
                subject_version: subjectVersion,
                items: [
                    {
                        content_id: copilotID || contentData.contentId,
                        content_title: contentData.title,
                        content_type: contentData.name?.toLowerCase(),
                        content_url: contentData.url
                    }
                ],
                index: recircId - 1,
                total_index: totalItems
            };
            if (shouldTriggerDynamicUKExperienceTracking) {
                const { label, placement, strategy, ...restEventData } = eventData;
                eventData = Object.assign(restEventData, {
                    subject: 'summary_collection',
                    subject_version: 'version_uk'
                });
            }
            trackNavigationEvent(eventData);
        }
    }, [
        copilotID,
        contentData,
        dangerousHed,
        entry,
        isRecircListItem,
        parentDangerousHed,
        recircId,
        recircPlacement,
        sectionTitleLabel,
        subjectVersion,
        url,
        totalItems,
        shouldTriggerDynamicUKExperienceTracking
    ]);
    const searchItemClassName = (shouldTrackItemEvents || shouldTrackItemImpressionForSnowplow) &&
        `search_result_item-${copilotID}`;
    useViewportObserver(`.${searchItemClassName}`, undefined, (isInViewport, cleanup) => {
        if (isInViewport) {
            impressionHandler();
            // Call the cleanup function to stop observing this element
            // This prevents the callback from being called again
            cleanup();
        }
    });
    const summaryCollageItemClass = (shouldTrackItemEvents || shouldTrackItemImpressionForSnowplow) &&
        `${placement || snowplowEvent?.placement}_summary_item-${copilotID || index || itemIndex}`;
    useViewportObserver(`.${mobileDenseItemClassCarousel || summaryCollageItemClass}`, undefined, (isInViewport) => {
        if (isInViewport && typeof impressionHandler === 'function') {
            impressionHandler('impression', {
                dangerousHed,
                copilotID,
                contentType,
                url
            }, index || itemIndex || 0);
        }
    });
    if (!isGAFired && itemInView && itemInViewGAEventName) {
        setGAFired(true);
        const payload = {
            'profile-item-rank': (itemIndex + 1).toString().padStart(2, '0'),
            'profile-item-name': dangerousHed || ''
        };
        googleAnalytics.emitGoogleTrackingEvent(itemInViewGAEventName, payload);
    }
    const getHeadTagAs = () => {
        if (recircId) {
            return showHeadTagAsForRecirc || 'div';
        }
        else if (isTextExternalLink) {
            return 'h2';
        }
        return showHeadTagAs !== undefined ? showHeadTagAs : hedTag;
    };
    const onVideoChange = useCallback((video) => {
        if (shouldUpdateVideoTitleOnVideoChange) {
            setUpdateVideoTitle(video.title);
        }
    }, [shouldUpdateVideoTitleOnVideoChange]);
    const { formatMessage } = useIntl();
    const hedTagAs = getHeadTagAs();
    const seoAltText = getAltTextForSeo(dangerousHed) || image?.altText || '';
    if (image?.altText !== undefined) {
        image.altText = seoAltText;
    }
    // overlay gets special treatment, see README for details.
    if (layoutPlacement === 'overlay') {
        return (React.createElement(OverlaySummaryItem, { analyticsDataAttribute: analyticsDataAttribute, className: className, isRecircListItem: isRecircListItem, recircPlacement: recircPlacement, clickHandler: clickHandler, contentAlign: contentAlign, contributors: contributors, dangerousHed: dangerousHed, dangerousDek: dangerousDek, eventDate: eventDate, hasCTA: hasCTA, hasLeftMargin: hasLeftMargin, hideRubricItemSummary: hideRubricItemSummary, hasCoverCollage: hasCoverCollage, HedTag: hedTagAs, image: image, isLazy: isLazy, isLive: isLive, shouldDisableGradientContentBlock: shouldDisableGradientContentBlock, isContributor: isContributor, totalItems: totalItems, layoutProportions: layoutProportions, showOnHoverEffect: showOnHoverEffect, maxHedLines: maxHedLines, metadataPrimary: metadataPrimary, metadataVideo: metadataVideo, multiImages: multiImages, publishDate: publishDate, recircId: recircId, recircRiver: recircRiver, rubric: rubric, rubricVariation: rubricVariation, shouldAutoPlay: shouldAutoPlay, shouldHideEventDate: shouldHideEventDate, shouldHideItemCount: shouldHideItemCount, shouldHidePublishDate: isPublishDateHidden, shouldDisplayLiveIndicator: shouldDisplayLiveIndicator, shouldHandleOverlayForLongHed: shouldHandleOverlayForLongHed, sparrowPattern: sparrowPattern, url: url, contentType: contentType, contentId: copilotID || contentId, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, signage: signage, sectionTitleLabel: sectionTitleLabel, subjectVersion: subjectVersion }));
    }
    const hasMobileAndTabletOnlyBorder = shouldRemoveSummaryItemBorder
        ? false
        : hasBorderOnMobileAndTabletOnly;
    const classes = classnames('summary-item', {
        'summary-item--card': isCard,
        'summary-item--high-density': isHighDensity,
        'summary-item--circle-image': circleImage,
        'summary-item--no-asset': !hasAsset,
        'summary-item--has-bookmarks': hasBookmarks,
        'summary-item--has-margin-spacing': hasMarginSpacing,
        'summary-item--has-border': hasBorder,
        'summary-item--has-no-final-border': shouldHideFinalBorder,
        'summary-item--has-border-sides': hasBorderSides,
        'summary-item--has-mobile-border': hasMobileAndTabletOnlyBorder,
        'summary-item--has-large-screen-border': hasBorderOnLargeScreen,
        'summary-item--has-rule': hasRule,
        'summary-item--has-offers': showOffers && offers?.length,
        [`summary-item--${contentType}`]: contentType && hasBundleClass,
        'summary-item--has-tighter-spacing': hasTighterVerticalSpacing,
        'summary-item--has-vertical-rule': hasVerticalRule,
        'summary-item--is-contributor': isContributor,
        'summary-item--has-small-image-mobile-only': shouldUseSmallImageMobileOnly,
        'summary-item--is-contributor-three-col': isContributorThreeCol,
        'summary-item--is-dense': isDense,
        'summary-item--primary-block': primaryBlock,
        'summary-item--name-center': isContributor &&
            !contributors?.author?.items?.[0]?.photo &&
            shouldCenterAlignContributorName,
        'summary-item--show-read-more': showReadMore
    }, !hasMultipleRubric && rubric && rubric.dangerousIcon
        ? 'summary-item--has-icon'
        : 'summary-item--no-icon', `summary-item--text-align-${contentAlign}`, `summary-item--layout-placement-${layoutPlacement}`, `summary-item--layout-position-${layoutPosition}`, `summary-item--layout-proportions-${layoutProportions}`, `summary-item--side-by-side-align-${sideBySideVerticalAlign}`, `summary-item--side-by-side-image-right-mobile-${hasSideBySideMobileOnlyImageRight}`, {
        'summary-item--dark-background-right': isDarkBackgroundRight,
        'summary-item--dark-background': isDarkBackground
    }, `summary-item--${fullPageTheme}`, className, searchItemClassName, summaryCollageItemClass, mobileDenseItemClassCarousel);
    const RubricVariation = Rubric[rubricVariation || 'Item'];
    const themedBylineVariation = getThemedBylineVariation({
        bylineVariation,
        theme: fullPageTheme
    });
    const getDateValue = () => {
        if (!hideIssueDate && issueDate) {
            return issueDate;
        }
        else if (hasFeatureVideo(image)) {
            return image.publishDate;
        }
        return publishDate;
    };
    const bylineProps = {
        bylineVariation: themedBylineVariation,
        clickHandlerContributors,
        contentAlign,
        contributors,
        dateValue: getDateValue(),
        eventDate,
        hasBookmarks,
        hideBylinesUntil,
        iconButtonOnclickHandler,
        iconType,
        isVenueCardItemContainer,
        maxContributors,
        maxContributorsNames,
        shouldHideBookmarkIcon,
        shouldHideBylines,
        shouldHideContributors,
        shouldHideEventDate,
        shouldLink: shouldLinkByline,
        shouldHidePublishDate: isPublishDateHidden,
        shouldMoveBylineToBottom: shouldUseFlexGrow,
        showCommaAsideContributorName,
        shouldUseGridStyles,
        test: 'prop',
        venueAwards,
        isDenseDesktopStack,
        isDenseDesktopThirds
    };
    const goToLink = () => {
        if (isCategoryFeatureContainer) {
            const eventData = {
                type: 'click',
                label: parentDangerousHed,
                subject: 'category_feature',
                items: [
                    {
                        content_title: dangerousHed.replace(/<[^>]*>/g, ''),
                        content_type: contentType,
                        content_url: url,
                        content_id: copilotID
                    }
                ],
                index: itemIndex,
                total_index: totalItems
            };
            trackNavigationEvent(eventData);
        }
        googleAnalytics.emitGoogleTrackingEvent('gtm.linkClick', {
            'gtm.elementUrl': url,
            'gtm.triggers': ''
        });
        sparrow.trackSparrowEvent('content', 'click', {
            dim1: url,
            dim2: cutClearLink(url),
            dim3: 'recirc-river',
            dim4: getRecircId('wrapper', recircId),
            dim5: sparrowPattern
        });
        clickHandler(isSponsored);
        isLinkExternal(url, window.location.hostname) || shouldOpenUrlInNewTab
            ? window.open(url, '_blank')
            : (window.location = url);
        clickItem(null, null, copilotID, index || itemIndex, 'click_result', contentType, dangerousHed, url, true);
    };
    const handleKeys = (event) => {
        if (event.key === 'Enter') {
            alternateClickHandlerStrategy
                ? alternateClickHandlerStrategy(event)
                : goToLink();
        }
    };
    const clickProps = {
        onKeyDown: handleKeys,
        onClick: isAlternateClickHandlerStrategy
            ? () => { }
            : alternateClickHandlerStrategy || goToLink
    };
    const ctaClickHandler = isCtaButtonClickable
        ? (e) => {
            e.stopPropagation();
            shouldOpenUrlInNewTab
                ? window.open(url, '_blank')
                : (window.location.href = url);
        }
        : () => { };
    const hotelClickHandler = (position, event) => {
        formatGtmData({
            window,
            product: { ...productData },
            index: position,
            layout: 'ProductEmbed',
            event,
            layoutTitle: dangerousHed
        });
    };
    const linkClickHandler = (e, position) => {
        e.stopPropagation();
        if (clickHandlerHed)
            clickHandlerHed();
        if (!hasBookmarks)
            clickHandler(isSponsored, e);
        if (!isEmpty(snowplowEvent))
            handlSnowplowNavigationEvent(snowplowEvent);
        clickItem(null, null, copilotID, index || itemIndex, 'click_result', contentType, dangerousHed, url);
        if (isHotelType) {
            hotelClickHandler(position, e);
        }
    };
    const contributor = contributors?.[defaultTypeForContributor]?.items?.[0] || {};
    const contributorName = contributor.name;
    const contributorPhoto = contributor.photo;
    const contributorTitle = contributor.dangerousTitle;
    const contributorDetail = contributor[defaultContributorDetailField];
    const contributorURL = contributor.url;
    // hack to hide duplicate HED information; has to be removed as soon as the proper solution invented for "Travel Specialists" is available
    // https://cnissues.atlassian.net/browse/LS4-667
    const hideHed = shouldHideDangerousHed ||
        (contributorName && variationName === 'ContributorRiverItem');
    const hideMetaDataSecondary = shouldDisplayImageCount
        ? !(itemsCount?.count > 0)
        : shouldHideMetadataSecondary;
    let metadataSecondary;
    if (itemsCount && itemsCount.count > 0) {
        metadataSecondary = formatMessage(translations.slides, {
            slidesCount: itemsCount.count
        });
    }
    if (metadataSecondaryMessage) {
        metadataSecondary = metadataSecondaryMessage;
    }
    const hasRubricIcon = !!completeRubric?.dangerousIcon;
    const RubricComponent = (rubricProps) => (React.createElement(SummaryItemRubric, { as: RubricVariation, ...rubricProps, fullPageTheme: fullPageTheme, className: classnames('summary-item__rubric', {
            'summary-item__series-link': hasSeriesData,
            'summary-item__rubric--extra-margin-bottom': hasModerateSpacing
        }), hasSeriesData: hasSeriesData, clickHandler: clickHandlerRubric, contentAlign: contentAlign, hasBookmarks: hasBookmarks, hasIcon: hasRubricIcon, hasModerateSpacing: hasModerateSpacing, hasRubricBelowHed: hasRubricBelowHed, isContributor: isContributor, shouldUseRubricAsRole: shouldUseRubricAsRole, hasBottomSpaceOnRubric: hasBottomSpaceOnRubric, hideRubricLink: hideRubricLink, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds }));
    const renderMultipleRubric = (rubric) => {
        const rubricComponent = Array.isArray(rubric) ? (uniqBy(rubric, 'name').map((rubricData, i) => (React.createElement(React.Fragment, null,
            i > 0 && (React.createElement(SummaryItemRubricSeparator, null, "\u00A0/\u00A0")),
            React.createElement(RubricComponent, { ...rubricData }))))) : (React.createElement(RubricComponent, { ...rubric }));
        return rubricComponent;
    };
    const renderRubric = (React.createElement(SummaryItemRubricWrapper, null, renderMultipleRubric(completeRubric)));
    const shouldRenderStoryAssurance = !isDense &&
        !hideRubricItemSummary &&
        rubric &&
        !isContributor &&
        !isSponsored;
    const renderStoryAssurance = shouldRenderStoryAssurance && (React.createElement(StoryAssurance, { wordCount: wordCount, hasStoryAssurance: hasStoryAssurance, rubric: renderRubric }));
    const hideDangerousDek = isTextExternalLink
        ? !isTextExternalLink
        : (shouldHideDangerousDek && contentType !== 'fashionshow') ||
            (contentType === 'cnevideo' && shouldHideVideoDek);
    const hideIcon = shouldEnablePlayIcon && contentType === 'cnevideo'
        ? !shouldEnablePlayIcon
        : shouldHideIcon;
    let syndicatedRel = {};
    if (hasNoFollowOnSyndicated) {
        syndicatedRel = {
            rel: 'nofollow'
        };
    }
    const summaryItemImage = isContributor ? contributorPhoto : image;
    const readMoreMessage = showReadMore
        ? translations.readMore
        : translations.dekReadMoreText;
    const dekReadMoreLink = shouldAppendReadMoreLinkForDek ? (React.createElement(SummaryItemDekReadMore, { href: url, className: "summary-item__dek--readmore-link", isVenueCardItemContainer: isVenueCardItemContainer, onClick: isHotelType ? hotelClickHandler : () => { } }, formatMessage(readMoreMessage))) : null;
    const contributorReadMoreLink = showReadMore && contributorURL ? (React.createElement(React.Fragment, null,
        React.createElement(SummaryItemDekReadMore, { href: contributorURL, className: "summary-item__contributor--readmore-link", showReadMore: showReadMore, isVenueCardItemContainer: isVenueCardItemContainer }, formatMessage(translations.readMore)))) : null;
    const embedVideoForIndex = shouldEmbedCneVideo && itemIndex === 0;
    const isDekValidToTruncate = (maxDekLines > 0 && maxDekLines < Infinity) ||
        (maxDekLinesInMobile > 0 && maxDekLinesInMobile < Infinity) ||
        (maxDekLinesInTablet > 0 && maxDekLinesInTablet < Infinity) ||
        (maxDekLinesInDesktop > 0 && maxDekLinesInDesktop < Infinity) ||
        (maxDekLinesInLargeDesktop > 0 && maxDekLinesInLargeDesktop < Infinity) ||
        (maxDekLinesInExtraLargeDesktop > 0 &&
            maxDekLinesInExtraLargeDesktop < Infinity);
    const shouldUseClamp = isTruncateDek && isDekValidToTruncate && !isPlpCurated; // isPlpCurated is added here to avoid clamping in the PLP
    let summaryTitle = embedVideoForIndex && shouldUpdateVideoTitleOnVideoChange
        ? updateVideoTitle
        : dangerousHed;
    if (showReviewTitleForTracks &&
        ratingValue &&
        ratingValue.channelType === 'Tracks') {
        summaryTitle = source?.hed;
    }
    const shouldDekHaveExtraSpace = shouldDekhaveExtraVerticalSpace && !shouldAlignDekAtBottom;
    const bundleClass = contentType && hasBundleClass;
    const imageClickHandler = image && image.showImageWithoutLink && image.shouldImageHaveClickHandler
        ? (e) => {
            e.stopPropagation();
            window.open(url, '_blank');
        }
        : null;
    const shouldAddHover = image && image.showImageWithoutLink && image.shouldImageHaveClickHandler;
    const assetContainerClickProps = image && image.showImageWithoutLink && image.shouldImageHaveClickHandler
        ? { shouldAddHover, onClick: imageClickHandler }
        : {};
    const isCneVideo = contentType?.toLowerCase() === 'cnevideo';
    const SummaryItemAssetComponent = (React.createElement(SummaryItemAssetContainer, { className: "summary-item__asset-container", ...assetContainerClickProps, hasSummaryItemAssetSpacing: hasSummaryItemAssetSpacing, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, imageAlignment: imageAlignment, shouldHaveBorderBottomOnItem: shouldHaveBorderBottomOnItem, hasNoBottomMarginForCneVideo: hasNoBottomMarginForCneVideo, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds, hideDangerousDek: hideDangerousDek, shouldApplyImageBorderRadius: shouldApplyImageBorderRadius, onClick: isHotelType ? hotelClickHandler : () => { }, isTextExternalLink: isTextExternalLink },
        React.createElement(SummaryItemAsset, { audioTagIconTitle: audioTagIconTitle, awards: awards, clickHandlerHed: linkClickHandler, contentType: contentType, hasAsset: hasAsset, hasAudioTag: hasAudioTag || isAudioArticle, hasImageCenteredButtonInCarousel: hasImageCenteredButtonInCarousel, hasCircularImage: circleImage, hasNoBottomMarginForCneVideo: hasNoBottomMarginForCneVideo, hasReviewTag: shouldEnableReviewFlag &&
                (ratingValue
                    ? ratingValue.isBestNewMusic || ratingValue.isBestNewReissue
                    : false), hasRel: hasNoFollowOnSyndicated, hasRoundedEdges: hasRoundedEdges, iconPosition: iconPosition, image: summaryItemImage, isLazy: isLazy, isLive: isLive, layoutPlacement: layoutPlacement, metadataVideo: metadataVideo, multiImages: multiImages, onVideoChange: onVideoChange, playIconStyle: playIconStyle, recircId: recircId, recircRiver: recircRiver, shouldAutoPlay: shouldAutoPlay, shouldDisplayPremiereDate: shouldDisplayPremiereDate, shouldDisplaySignage: shouldDisplaySignage && !shouldDisplaySignageInline, shouldDisplayVideoTime: shouldDisplayVideoTime, shouldAssetHaveNoBottomMargin: shouldAssetHaveNoBottomMargin, shouldHideIcon: hideIcon, shouldHoldImageSpace: shouldHoldImageSpace, shouldPlayInline: shouldPlayInline, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, signage: signage, sparrowPattern: sparrowPattern, shouldEmbedCneVideo: embedVideoForIndex, url: redirectURL || url, shouldOpenUrlInNewTab: shouldOpenUrlInNewTab, responsiveCartoonVariation: responsiveCartoonVariation, signalType: signalType, actionBarConfig: actionBarConfig, shouldHideCartoonCaption: shouldHideCartoonCaption, shouldHideCartoonCredit: shouldHideCartoonCredit }),
        isContributor && !shouldHideContributorContent && (React.createElement(SummaryItemContributorContent, { layoutPosition: layoutPosition, shoulUseContributorRiverItemStyle: showContributorDetail, className: classnames({
                'summary-item--contributor-name-center': !summaryItemImage && shouldCenterAlignContributorName
            }) },
            React.createElement(SummaryItemContributor, { contributorName: contributorName, contributorDetail: contributorDetail, showContributorDetail: showContributorDetail, shouldUseRubricAsRole: shouldUseRubricAsRole, isSpecial: isSpecial }),
            !hideRubricItemSummary && rubric && renderRubric,
            contributorReadMoreLink,
            showAuthorTitle && contributorTitle && (React.createElement(SummaryItemAuthorTitle, { dangerouslySetInnerHTML: { __html: contributorTitle } }))))));
    const determineShopLayout = () => {
        if (isTextExternalLink) {
            return (React.createElement(SummaryItemShopLink, { href: url, className: "summary-item__shop-link" }, ctaTextSource));
        }
        else if (showShopNowButton) {
            return (React.createElement(SummaryItemShopNowButton, { url: url, dangerousHed: dangerousHed, buttonSize: buttonSize, buttonAlignment: contentAlign, buttonLabel: ctaTextSource }));
        }
        return false;
    };
    const SummaryItem = (React.createElement(React.Fragment, null,
        isDense &&
            !hideRubricItemSummary &&
            rubric &&
            !isContributor &&
            renderRubric,
        SummaryItemAssetComponent,
        React.createElement(SummaryItemContent, { className: classnames('summary-item__content', {
                'summary-item__content--minimal': hasTighterVerticalSpacing,
                'summary-item__content--no-padding': hasNoBottomPaddingContent,
                'summary-item__content--no-rubric': !hideRubricItemSummary && !rubric,
                'summary-item__content--margintop': marginTop,
                'summary-item__content--vertically-align': shouldVerticallyAlignHed,
                'summary-item__content--bottom-dek': shouldAlignDekAtBottom
            }), contentAlign: contentAlign, contentAlignmentInMobile: contentAlignmentInMobile, layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, layoutPosition: layoutPosition, hasMarginTop: marginTop, hasNoRubric: !hideRubricItemSummary && !rubric, hasNoBottomPaddingContent: hasNoBottomPaddingContent, hasNoBottomPaddingForGridContent: hasNoBottomPaddingForGridContent, hasNoBottomPaddingForCneVideo: hasNoBottomPaddingForCneVideo, hasTighterVerticalSpacing: hasTighterVerticalSpacing, shouldAlignDekAtBottom: shouldAlignDekAtBottom, shouldRemoveHorizontalPadding: shouldRemoveHorizontalPadding, shouldUseFlexGrow: shouldUseFlexGrow, shouldVerticallyAlignHed: shouldVerticallyAlignHed, hasBookmarks: hasBookmarks, hasAsset: hasAsset, hasHighDensity: isHighDensity, hasSummaryItemExtraPadding: hasSummaryItemExtraPadding, isContributor: isContributor, isContributorThreeCol: isContributorThreeCol, bundleClass: bundleClass, isVenueCardItemContainer: isVenueCardItemContainer, isSpecial: isSpecial, hasMediumMarginBottom: hasMediumMarginBottom, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds, shouldHidePublishDate: shouldHidePublishDate, isPlpCurated: isPlpCurated, isSeriesNavigation: isSeriesNavigation, isTextExternalLink: isTextExternalLink, shouldEnableCommentsCount: shouldEnableCommentsCount, commentsCount: commentsCount, shouldEnableBookmarkDrawers: shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark: shouldEnableCardLevelBookmark, shouldLimitSavingToContentTypes: shouldLimitSavingToContentTypes, isGridLayout: layout === 'GridFourColumns' },
            contextualHeader && (React.createElement(SummaryItemContextualHeader, null, contextualHeader)),
            !hasRubricBelowHed && renderStoryAssurance,
            (hasSponsorByline || isSponsored) && (React.createElement(SummaryItemBaseByline, { className: classnames({
                    'summary-item__byline': hasSponsorByline,
                    'summary-item__byline--sponsored': hasSponsorByline,
                    'summary-item__content--sponsored': isSponsored
                }, `summary-item__content--sponsored-${fullPageTheme}`), isSponsoredByline: hasSponsorByline, isSponsored: isSponsored, isSponsoredInverted: fullPageTheme === 'inverted' }, formatMessage(translations.sponsoredContent))),
            showContributorContentOnTop && (React.createElement(SummaryItemContributorName, null, contributorName)),
            showContributorContentOnTop &&
                !hideRubricItemSummary &&
                rubric &&
                renderRubric,
            (dangerousHed || hasFeatureVideo(image)) && !hideHed && (React.createElement(React.Fragment, null,
                React.createElement(SummaryItemHedLink, { className: classnames('summary-item-tracking__hed-link', 'summary-item__hed-link', {
                        'summary-item__hed-link--underline-disable': !hasUnderlineHed,
                        'summary-item__hed-link--heading-inline': contentType === 'heading-inline'
                    }, recircItemClassName), name: contentType === 'heading-inline' ? dangerousHed : undefined, contentAlign: contentAlign, "data-component-title": recircRiver, "data-component-type": "recirc-river", "data-recirc-id": getRecircId('hed', recircId), "data-recirc-pattern": sparrowPattern, hasRule: hasRule && hasUnderlineHed && !hasBookmarks, hideRuleFromMobile: hideRuleFromMobile, hasRuleOnlyMedium: layoutPlacement === 'side-by-side' ||
                        layoutPlacement === 'text-below-desktop-only', ...syndicatedRel, href: redirectURL || url, isContributor: isContributor, layoutPlacement: layoutPlacement, onClick: linkClickHandler, target: shouldNotPreventPageRedirect && shouldOpenUrlInNewTab
                        ? '_blank'
                        : '_self', hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds },
                    React.createElement(SummaryItemHed, { contentType: contentType, dangerousHed: hasFeatureVideo(image) ? image.dangerousHed : summaryTitle, hasFixedMarginBottom: isTextExternalLink || hasModerateSpacing, HedTag: hedTagAs, layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, maxHedLines: maxHedLines, hasHedCorePrimary: hasHedCorePrimary, shouldUseSmallHed: shouldUseSmallHed, isHighDensity: isHighDensity, isVenueCardItemContainer: isVenueCardItemContainer, hasNoHedTagMargin: hasNoHedTagMargin, hasNoHedTagMarginTop: hasNoHedTagMarginTop, shouldUseFeaturedFontWeight: shouldUseFeaturedFontWeight, breakpoint: clampBreakpoint, hasDefaultSpacingMarginBottom: hasDefaultSpacingMarginBottom, isTextExternalLink: isTextExternalLink })),
                isCurrent && isSeriesNavigation && (React.createElement(SummaryItemNowShopping, { isCurrent: isCurrent, isSeriesNavigation: isSeriesNavigation }, formatMessage(translations.NowShoppingLabel))),
                shouldHideSubHedForTracks &&
                    ratingValue.channelType === 'Tracks' ? null : (React.createElement(React.Fragment, null, !shouldHideSubHed && subHed && (React.createElement(SummaryItemSubHed, { contentType: contentType, subHed: subHed?.name, hasFixedMarginBottom: hasModerateSpacing, layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, maxHedLines: maxHedLines, hasHedCorePrimary: hasHedCorePrimary, shouldUseSmallHed: shouldUseSmallHed, isHighDensity: isHighDensity, hasNoHedTagMargin: hasNoHedTagMargin, shouldUseFeaturedFontWeight: shouldUseFeaturedFontWeight })))))),
            hasRubricBelowHed && renderStoryAssurance,
            !hasSponsorByline && hasBylineBeforeDek && (React.createElement(SummaryItemByline, { ...bylineProps, isBeforeDek: true, className: "summary-item__byline-date-icon--pre-dek" })),
            shouldEnableReviewFlag && ratingValue && showReviewLabel && (React.createElement(SummaryItemReviewLabel, { ratingValue: ratingValue })),
            shouldShowVenueDetails &&
                venueDetails &&
                !shouldPlaceVenueBelowDek && (React.createElement(SummaryItemVenueDetails, { as: Clamp, lines: 1, breakpoint: clampBreakpoint, isVenueCardItemContainer: isVenueCardItemContainer },
                React.createElement(SummaryItemVenueDetails, null, venueDetails))),
            (eventDate || venueName) && (React.createElement(SummaryItemEventInfo, { eventDate: eventDate, eventLocation: venueName })),
            dangerousDek &&
                !hideDangerousDek &&
                (shouldUseClamp ? (React.createElement(React.Fragment, null,
                    React.createElement(SummaryItemDek, { as: Clamp, lines: maxDekLines, linesInMobile: maxDekLinesInMobile, linesInTablet: maxDekLinesInTablet, linesInDesktop: maxDekLinesInDesktop, linesInLargeDesktop: maxDekLinesInLargeDesktop, linesInExtraLargeDesktop: maxDekLinesInExtraLargeDesktop, className: "summary-item__dek", hasMarginSpacing: hasMarginSpacing, breakpoint: clampBreakpoint, isVenueCardItemContainer: isVenueCardItemContainer, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds, shouldHideContributors: shouldHideContributors, shouldHideDekBottomMargin: shouldHideDekBottomMargin },
                        React.createElement(React.Fragment, null,
                            React.createElement(SummaryItemDek, { className: classnames('summary-item__dek', {
                                    'summary-item__dek--hide-mobile-show-tablet': shouldDekHideOnMobileAndShowOnTablet,
                                    'summary-item__dek--hidden-mobile': shouldHideDangerousDekMobileOnly,
                                    'summary-item__dek--extra-spacing': shouldDekhaveExtraVerticalSpace &&
                                        !shouldAlignDekAtBottom,
                                    'summary-item__dek--with-readmore': shouldAppendReadMoreLinkForDek,
                                    'summary-item__dek--bottom-align': shouldAlignDekAtBottom,
                                    'summary-item__dek--video-dek': shouldEmbedCneVideo,
                                    'summary-item__dek--isCneVideo': isCneVideo
                                }), hasMarginSpacing: hasMarginSpacing, hasExtraSpacing: shouldDekHaveExtraSpace, isInline: shouldAppendReadMoreLinkForDek, hasListInDek: hasListInDek, shouldHideOnMobileAndShowOnTablet: shouldDekHideOnMobileAndShowOnTablet, shouldHideOnMobile: shouldHideDangerousDekMobileOnly, verticalAlign: shouldAlignDekAtBottom ? 'bottom' : 'top', dangerouslySetInnerHTML: { __html: dangerousDek }, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds, shouldHideContributors: shouldHideContributors, shouldHideDekBottomMargin: shouldHideDekBottomMargin, isTextExternalLink: isTextExternalLink, as: isTextExternalLink ? 'p' : 'div' }))),
                    dekReadMoreLink)) : (React.createElement(React.Fragment, null,
                    isDenseDesktopStack || isDenseDesktopThirds || imageWarp
                        ? SummaryItemAssetComponent
                        : null,
                    React.createElement(SummaryItemDek, { className: classnames('summary-item__dek', {
                            'summary-item__dek--hide-mobile-show-tablet': shouldDekHideOnMobileAndShowOnTablet,
                            'summary-item__dek--hidden-mobile': shouldHideDangerousDekMobileOnly,
                            'summary-item__dek--extra-spacing': shouldDekhaveExtraVerticalSpace && !shouldAlignDekAtBottom,
                            'summary-item__dek--with-readmore': shouldAppendReadMoreLinkForDek,
                            'summary-item__dek--bottom-align': shouldAlignDekAtBottom,
                            'summary-item__dek--video-dek': shouldEmbedCneVideo,
                            'summary-item__dek--isCneVideo': isCneVideo
                        }), hasExtraSpacing: shouldDekHaveExtraSpace, hasMarginSpacing: hasMarginSpacing, isInline: shouldAppendReadMoreLinkForDek, hasListInDek: hasListInDek, shouldHideOnMobileAndShowOnTablet: shouldDekHideOnMobileAndShowOnTablet, shouldHideOnMobile: shouldHideDangerousDekMobileOnly, verticalAlign: shouldAlignDekAtBottom ? 'bottom' : 'top', dangerouslySetInnerHTML: {
                            __html: dangerousDek
                        }, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds, shouldHideContributors: shouldHideContributors, shouldHideDekBottomMargin: shouldHideDekBottomMargin, shouldUseArrowIconInDek: shouldUseArrowIconInDek, isTextExternalLink: isTextExternalLink, as: isTextExternalLink ? 'p' : 'div' }),
                    dekReadMoreLink))),
            shouldAppendReadMoreLinkForDek && hideDangerousDek && dekReadMoreLink,
            shouldDisplaySignageInline && signage && (React.createElement(SummaryItemSignage, null,
                " ",
                signage)),
            showLocation &&
                (businessInfo?.address?.state || businessInfo?.address?.city) && (React.createElement(SummaryItemBusinessLocation, { business: businessInfo })),
            showBusinessCategory && (React.createElement(React.Fragment, null,
                (businessInfo?.category?.name ||
                    businessInfo?.profession?.name) && (React.createElement(SummaryItemBusinessCategory, { business: businessInfo })),
                React.createElement(SummaryItemCTACard, { shouldUseFullWidthMobileOnly: true, clickHandlerCta: ctaClickHandler }, formatMessage(translations.BusinessProfileCTAText)))),
            (hasPrimaryCTA || hasSecondaryCTA) && (url || primaryCta) && (React.createElement(SummaryItemCTAPodcast, { hasPrimaryCTA: hasPrimaryCTA, hasSecondaryCTA: hasSecondaryCTA, primaryCta: primaryCta, secondaryCta: url, primaryCTALabel: primaryCTALabel, secondaryCTALabel: secondaryCTALabel })),
            metadataPrimary && (React.createElement(SummaryItemMetadataPrimary, { className: "summary-item__metadata-primary" }, metadataPrimary)),
            metadataSecondary && !hideMetaDataSecondary && (React.createElement(SummaryItemMetadataSecondary, { className: classnames('summary-item__metadata-secondary', {
                    'summary-item__metadata-secondary-without-mobile-margin': hasBylineBeforeDek,
                    'summary-item__metadata-secondary-without-margin': hasMetaWithoutMargin
                }), hasMobileSpacing: hasBylineBeforeDek, hasMarginSpacing: hasMarginSpacing, hasMetaWithoutMargin: hasMetaWithoutMargin }, metadataSecondary)),
            shouldShowVenueDetails && venueDetails && shouldPlaceVenueBelowDek && (React.createElement(SummaryItemVenueDetails, { as: Clamp, lines: 1, breakpoint: clampBreakpoint, isVenueCardItemContainer: isVenueCardItemContainer },
                React.createElement(SummaryItemVenueDetails, null, venueDetails))),
            !hasSponsorByline && !hasBylineBeforeDek && (React.createElement(SummaryItemByline, { ...bylineProps })),
            hasUtilityFeatures && (React.createElement(UtilityFeatures, { shouldLimitSavingToContentTypes: shouldLimitSavingToContentTypes, totalCommentsCount: commentsCount, urlToBookmark: url, copilotID: copilotID, contentType: contentType, subtype: subtype, isPageScoped: false, shouldEnableBookmarkDrawers: shouldEnableBookmarkDrawers, shouldEnableCardLevelBookmark: shouldEnableCardLevelBookmark, shouldEnableCommentsCount: shouldEnableCommentsCount, subject: "summary_item", shouldUseBookmarkV3: shouldUseBookmarkV3 })),
            showProfileButton && (React.createElement(SummaryItemBusinessProfileButton, { business: business })),
            showOffers && (React.createElement(SummaryItemProductOffers, { offers: offers, urlToBookmark: url, copilotID: copilotID, image: image, contentType: contentType, subtype: subtype, productData: productData, index: itemIndex, isHotelType: isHotelType, dangerousHed: dangerousHed, isActionIdEnabledForComponent: actionIdFlags?.enableActionIdForSummaryItem })),
            ctaTextSource && determineShopLayout(),
            hasSummaryItemAction && (React.createElement(SummaryItemAction, { ctaLabel: ctaLabel, eventStatus: eventStatus })))));
    const SummaryItemContainer = (isSticky) => isSticky ? (React.createElement(SummaryItemStickyWrapper, null, SummaryItem)) : (SummaryItem);
    const wrapperRef = () => {
        if (itemInViewGAEventName || hasGridOrCarouselLayout) {
            return { ref: itemRef };
        }
        else if (isRecircListItem || shouldTriggerDynamicUKExperienceTracking) {
            return { ref: recircItemRef };
        }
        return {};
    };
    return (React.createElement(SummaryItemWrapper, { ...wrapperRef(), ...(!hasBookmarks ? clickProps : {}), ...analyticsDataAttribute, cardContentPaddingStyles: cardContentPaddingStyles, className: isHotelType ? classnames('product-embed', classes) : classes, "data-item": JSON.stringify(productData), contentType: contentType, fullPageTheme: fullPageTheme, hasBorder: hasBorder, hasBorderOnLargeScreen: hasBorderOnLargeScreen, hasBorderSides: hasBorderSides, hasSummaryItemAction: hasSummaryItemAction, hasMarginSpacing: hasMarginSpacing, hasHiddenFinalBorder: shouldHideFinalBorder, hasMobileOnlyBorder: hasMobileAndTabletOnlyBorder, hasSmallImageMobileOnly: shouldUseSmallImageMobileOnly, hidePadding: hidePadding, isDarkBackgroundRight: isDarkBackgroundRight, hasBookmarks: hasBookmarks, bundleClass: bundleClass, hasDense: isDense, hasOffers: !!(showOffers && offers?.length), hasVerticalRule: hasVerticalRule, isPrimaryBlock: primaryBlock === 'primary-block', isCard: isCard, isContributor: isContributor, isContributorImageTopAligned: isContributorImageTopAligned, isContributorThreeCol: isContributorThreeCol, isDarkBackground: isDarkBackground, isPlpCurated: isPlpCurated, isSeriesNavigation: isSeriesNavigation, isHighDensity: isHighDensity, layoutPlacement: layoutPlacement, layoutPosition: layoutPosition, layoutProportions: layoutProportions, sideBySideVerticalPlacement: sideBySideVerticalAlign, hasSideBySideMobileOnlyImageRight: hasSideBySideMobileOnlyImageRight, shouldRemoveHorizontalPadding: shouldRemoveHorizontalPadding, shouldShowAllContentWhenDense: shouldShowAllContentWhenDense, shouldUseGridStyles: shouldUseGridStyles, shouldUseFlexGrow: shouldUseFlexGrow, verticalAlign: shouldAlignDekAtBottom ? 'bottom' : 'top', showReadMore: showReadMore, ...(hasWrapperButtonRole && {
            role: 'button',
            tabIndex: 0
        }), imageAlignment: imageAlignment, isSpecial: isSpecial, id: generateId(props, generateIdFrom), isAlternateClickHandlerStrategy: isAlternateClickHandlerStrategy, hasDenseDesktopStack: isDenseDesktopStack, hasDenseDesktopThirds: isDenseDesktopThirds, hideDangerousDek: hideDangerousDek, isTextExternalLink: isTextExternalLink, isContributorGridItem: isContributorGridItem }, SummaryItemContainer(isSticky)));
};
SummaryItem.propTypes = {
    actionBarConfig: PropTypes.object,
    actionIdFlags: PropTypes.object,
    alternateClickHandlerStrategy: PropTypes.func,
    analyticsDataAttribute: PropTypes.object,
    audioTagIconTitle: PropTypes.string,
    awards: PropTypes.array,
    business: PropTypes.object,
    businessInfo: PropTypes.object,
    buttonSize: PropTypes.oneOf(['default', 'small']),
    bylineVariation: PropTypes.string,
    clampBreakpoint: PropTypes.string,
    className: PropTypes.string,
    clickHandler: PropTypes.func,
    clickHandlerContributors: PropTypes.func,
    clickHandlerHed: PropTypes.func,
    clickHandlerRubric: PropTypes.func,
    clickItem: PropTypes.func,
    commentsCount: PropTypes.number,
    contentId: PropTypes.string,
    contentType: PropTypes.string,
    contextualHeader: PropTypes.string,
    contributors: PropTypes.shape(Bylines.propTypes.contributors),
    copilotID: PropTypes.string,
    ctaTextSource: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    date: PropTypes.string,
    defaultContributorDetailField: PropTypes.string,
    defaultTypeForContributor: PropTypes.string,
    eventDate: PropTypes.string,
    fullPageTheme: PropTypes.oneOf(['standard', 'inverted']),
    generateIdFrom: PropTypes.string,
    hasBorder: PropTypes.bool,
    hasBorderOnLargeScreen: PropTypes.bool,
    hasBorderOnMobileAndTabletOnly: PropTypes.bool,
    hasBorderSides: PropTypes.bool,
    hasBottomSpaceOnRubric: PropTypes.bool,
    hasBundleClass: PropTypes.bool,
    hasBylineBeforeDek: PropTypes.bool,
    hasCoverCollage: PropTypes.bool,
    hasDefaultSpacingMarginBottom: PropTypes.bool,
    hasImageCenteredButtonInCarousel: PropTypes.bool,
    hasListInDek: PropTypes.bool,
    hasMarginSpacing: PropTypes.bool,
    hasMediumMarginBottom: PropTypes.bool,
    hasMetaWithoutMargin: PropTypes.bool,
    hasModerateSpacing: PropTypes.bool,
    hasMultipleRubric: PropTypes.bool,
    hasNoBottomMarginForCneVideo: PropTypes.bool,
    hasNoBottomPaddingContent: PropTypes.bool,
    hasNoBottomPaddingForCneVideo: PropTypes.bool,
    hasNoBottomPaddingForGridContent: PropTypes.bool,
    hasNoFollowOnSyndicated: PropTypes.bool,
    hasNoHedTagMargin: PropTypes.bool,
    hasNoHedTagMarginTop: PropTypes.bool,
    hasRoundedEdges: PropTypes.bool,
    hasRubricBelowHed: PropTypes.bool,
    hasRule: PropTypes.bool,
    hasSeriesData: PropTypes.bool,
    hasSideBySideMobileOnlyImageRight: PropTypes.bool,
    hasSponsorByline: PropTypes.bool,
    hasStoryAssurance: PropTypes.bool,
    hasSummaryItemAction: PropTypes.bool,
    hasSummaryItemAssetSpacing: PropTypes.bool,
    hasSummaryItemExtraPadding: PropTypes.bool,
    hasTighterVerticalSpacing: PropTypes.bool,
    hasUnderlineHed: PropTypes.bool,
    hasVerticalRule: PropTypes.bool,
    hasWrapperButtonRole: PropTypes.bool,
    hedTag: PropTypes.oneOf(['div', 'h2', 'h3']),
    hideBylinesUntil: PropTypes.oneOf(Breakpoints.sizes),
    hideIssueDate: PropTypes.bool,
    hidePadding: PropTypes.bool,
    hideRubricItemSummary: PropTypes.bool,
    hideRubricLink: PropTypes.bool,
    hideRuleFromMobile: PropTypes.bool,
    iconButtonOnclickHandler: PropTypes.func,
    iconType: PropTypes.oneOf(['thin', 'thinner', 'standard']),
    image: PropTypes.oneOfType([
        PropTypes.shape(ResponsiveAsset.propTypes),
        PropTypes.shape(InlineVideoItem.propTypes)
    ]),
    imageAlignment: PropTypes.oneOf(['top', 'default', 'bottom']),
    impressionHandler: PropTypes.func,
    index: PropTypes.number,
    isAlternateClickHandlerStrategy: PropTypes.bool,
    isAudioArticle: PropTypes.bool,
    isAuthenticated: PropTypes.bool,
    isCategoryFeatureContainer: PropTypes.bool,
    isCtaButtonClickable: PropTypes.bool,
    isCurrent: PropTypes.bool,
    isHotelType: PropTypes.bool,
    isLazy: PropTypes.bool,
    isLive: PropTypes.bool,
    isPlpCurated: PropTypes.bool,
    isRecircListItem: PropTypes.bool,
    isRegistrationRequired: PropTypes.bool,
    isSeriesNavigation: PropTypes.bool,
    isSpecial: PropTypes.bool,
    isSponsored: PropTypes.bool,
    isSticky: PropTypes.bool,
    issueDate: PropTypes.string,
    isTextExternalLink: PropTypes.bool,
    isTruncateDek: PropTypes.bool,
    isVenueCardItemContainer: PropTypes.bool,
    itemIndex: PropTypes.number,
    itemInViewGAEventName: PropTypes.string,
    itemsCount: PropTypes.shape(ItemsCount.propTypes),
    layout: PropTypes.string,
    maxContributors: PropTypes.number,
    maxContributorsNames: PropTypes.number,
    maxDekLines: PropTypes.number,
    maxDekLinesInDesktop: PropTypes.number,
    maxDekLinesInExtraLargeDesktop: PropTypes.number,
    maxDekLinesInLargeDesktop: PropTypes.number,
    maxDekLinesInMobile: PropTypes.number,
    maxDekLinesInTablet: PropTypes.number,
    maxHedLines: PropTypes.number,
    metadataPrimary: PropTypes.string,
    metadataSecondaryMessage: PropTypes.string,
    metadataVideo: PropTypes.shape({
        isLive: PropTypes.bool,
        premiereDate: PropTypes.string,
        series: PropTypes.string,
        videoLength: PropTypes.number,
        premiereGap: PropTypes.number
    }),
    mobileDenseItemClassCarousel: PropTypes.string,
    multiImages: PropTypes.array,
    node: PropTypes.array,
    offers: PropTypes.array,
    parentDangerousHed: PropTypes.string,
    placement: PropTypes.string,
    playIconStyle: PropTypes.oneOf(['dark', 'white', 'cne']),
    primaryCta: PropTypes.string,
    primaryCTALabel: PropTypes.string,
    ratingValue: PropTypes.shape({
        isBestNewMusic: PropTypes.bool,
        isBestNewReissue: PropTypes.bool,
        channelType: PropTypes.string,
        score: PropTypes.number
    }),
    recircId: PropTypes.number,
    recircPlacement: PropTypes.string,
    recircRiver: PropTypes.string,
    registrationGateCookie: PropTypes.string,
    registrationGateURL: PropTypes.string,
    responsiveCartoonVariation: PropTypes.string,
    rubric: PropTypes.oneOfType([
        PropTypes.arrayOf(PropTypes.shape(Rubric.propTypes)),
        PropTypes.shape(Rubric.propTypes)
    ]),
    rubricIconOverride: PropTypes.string,
    rubricVariation: PropTypes.string,
    secondaryCTALabel: PropTypes.string,
    sectionTemplate: PropTypes.string,
    sectionTitleLabel: PropTypes.string,
    shouldAlignDekAtBottom: PropTypes.bool,
    shouldAppendReadMoreLinkForDek: PropTypes.bool,
    shouldApplyImageBorderRadius: PropTypes.bool,
    shouldAutoPlay: PropTypes.bool,
    shouldCenterAlignContributorName: PropTypes.bool,
    shouldDekhaveExtraVerticalSpace: PropTypes.bool,
    shouldDekHideOnMobileAndShowOnTablet: PropTypes.bool,
    shouldDisableGradientContentBlock: PropTypes.bool,
    shouldDisplayImageCount: PropTypes.bool,
    shouldDisplaySignage: PropTypes.bool,
    shouldDisplaySignageInline: PropTypes.bool,
    shouldEmbedCneVideo: PropTypes.bool,
    shouldEnableBookmarkDrawers: PropTypes.bool,
    shouldEnableCardLevelBookmark: PropTypes.bool,
    shouldEnableCommentsCount: PropTypes.bool,
    shouldEnablePlayIcon: PropTypes.bool,
    shouldEnableReviewFlag: PropTypes.bool,
    shouldHandleOverlayForLongHed: PropTypes.bool,
    shouldHaveBorderBottomOnItem: PropTypes.bool,
    shouldHideBookmarkIcon: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideCartoonCaption: PropTypes.bool,
    shouldHideCartoonCredit: PropTypes.bool,
    shouldHideContributorContent: PropTypes.bool,
    shouldHideContributors: PropTypes.bool,
    shouldHideDangerousDek: PropTypes.bool,
    shouldHideDangerousDekMobileOnly: PropTypes.bool,
    shouldHideDangerousHed: PropTypes.bool,
    shouldHideDekBottomMargin: PropTypes.bool,
    shouldHideEventDate: PropTypes.bool,
    shouldHideFinalBorder: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHideItemCount: PropTypes.bool,
    shouldHideMetadataSecondary: PropTypes.bool,
    shouldHidePublishDate: PropTypes.bool,
    shouldHidePublishDateInTemplate: PropTypes.array,
    shouldHideSubHed: PropTypes.bool,
    shouldHideSubHedForTracks: PropTypes.bool,
    shouldHideVideoDek: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldLimitSavingToContentTypes: PropTypes.array,
    shouldLinkByline: PropTypes.bool,
    shouldNotPreventPageRedirect: PropTypes.bool,
    shouldOpenInternalLinksInNewTab: PropTypes.bool,
    shouldPlaceVenueBelowDek: PropTypes.bool,
    shouldPlayInline: PropTypes.bool,
    shouldRemoveHorizontalPadding: PropTypes.bool,
    shouldRemoveSummaryItemBorder: PropTypes.bool,
    shouldShowAllContentWhenDense: PropTypes.bool,
    shouldShowVenueDetails: PropTypes.bool,
    shouldTrackItemEvents: PropTypes.bool,
    shouldTrackItemImpressionForSnowplow: PropTypes.bool,
    shouldTriggerDynamicUKExperienceTracking: PropTypes.bool,
    shouldUpdateVideoTitleOnVideoChange: PropTypes.bool,
    shouldUseArrowIconInDek: PropTypes.bool,
    shouldUseBookmarkV3: PropTypes.bool,
    shouldUseFeaturedFontWeight: PropTypes.bool,
    shouldUseFlexGrow: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    shouldUseRubricAsRole: PropTypes.bool,
    shouldUseSmallHed: PropTypes.bool,
    shouldUseSmallImageMobileOnly: PropTypes.bool,
    shouldVerticallyAlignHed: PropTypes.bool,
    showAuthorTitle: PropTypes.bool,
    showCommaAsideContributorName: PropTypes.bool,
    showContributorContentOnTop: PropTypes.bool,
    showContributorDetail: PropTypes.bool,
    showHeadTagAs: PropTypes.string,
    showHeadTagAsForRecirc: PropTypes.string,
    showOffers: PropTypes.bool,
    showReviewLabel: PropTypes.bool,
    showReviewTitleForTracks: PropTypes.bool,
    showShopNowButton: PropTypes.bool,
    sideBySideVerticalAlign: PropTypes.oneOf(['top', 'center']),
    signage: PropTypes.string,
    signalType: PropTypes.string,
    snowplowEvent: PropTypes.object,
    source: PropTypes.object,
    sparrowPattern: PropTypes.string,
    subHed: PropTypes.shape({
        name: PropTypes.string,
        url: PropTypes.string
    }),
    subjectVersion: PropTypes.string,
    subtype: PropTypes.string,
    summaryItemMetaData: PropTypes.object,
    totalItems: PropTypes.number,
    url: PropTypes.string.isRequired,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        circleImage: PropTypes.bool.isRequired,
        contentAlign: PropTypes.oneOf(['center', 'left']).isRequired,
        contentAlignmentInMobile: PropTypes.oneOf(['center', 'left']),
        hasAsset: PropTypes.bool.isRequired,
        hasAudioTag: PropTypes.bool,
        hasBookmarks: PropTypes.bool,
        iconPosition: PropTypes.oneOf(['right', 'left']),
        isCard: PropTypes.bool.isRequired,
        isContributor: PropTypes.bool,
        isContributorGridItem: PropTypes.bool,
        isContributorImageTopAligned: PropTypes.bool,
        isContributorThreeCol: PropTypes.bool,
        isDarkBackground: PropTypes.bool,
        isDarkBackgroundRight: PropTypes.bool,
        isDense: PropTypes.bool,
        isDenseDesktopStack: PropTypes.bool,
        isDenseDesktopThirds: PropTypes.bool,
        isHighDensity: PropTypes.bool,
        hasCTA: PropTypes.bool,
        hasLeftMargin: PropTypes.bool,
        hasHedCorePrimary: PropTypes.bool,
        hasPrimaryCTA: PropTypes.bool,
        hasSecondaryCTA: PropTypes.bool,
        hasUtilityFeatures: PropTypes.bool,
        imageWarp: PropTypes.bool,
        layoutPlacement: PropTypes.oneOf(LAYOUT_PLACEMENTS).isRequired,
        layoutPosition: PropTypes.oneOf([
            'image-left',
            'image-right',
            'image-overlay'
        ]).isRequired,
        layoutProportions: PropTypes.oneOf([
            '20-80',
            '50-50',
            '33-66',
            '66-33',
            'overlay',
            'overlay-limited-height'
        ]).isRequired,
        showOnHoverEffect: PropTypes.bool,
        primaryBlock: PropTypes.oneOf(['primary-block']),
        marginTop: PropTypes.string,
        cardContentPaddingStyles: PropTypes.bool,
        shouldAssetHaveNoBottomMargin: PropTypes.bool,
        shouldDisplayLiveIndicator: PropTypes.bool,
        shouldDisplayPremiereDate: PropTypes.bool,
        shouldDisplayVideoTime: PropTypes.bool,
        shouldUseGridStyles: PropTypes.bool,
        showBusinessCategory: PropTypes.bool,
        showLocation: PropTypes.bool,
        showProfileButton: PropTypes.bool,
        showReadMore: PropTypes.bool
    }),
    venueAwards: PropTypes.string,
    venueDetails: PropTypes.string,
    venueName: PropTypes.string,
    wordCount: PropTypes.number
};
SummaryItem.displayName = 'SummaryItem';
module.exports = asThemedComponent(asConfiguredComponent(SummaryItem, 'SummaryItem'));
//# sourceMappingURL=SummaryItem.js.map

/***/ }),

/***/ 28197:
/***/ ((module) => {

const LAYOUT_PLACEMENTS = [
    'text-below',
    'text-below-desktop-only',
    'text-below-desktop-only-thumbnail',
    'side-by-side',
    'side-by-side-desktop-only',
    'side-by-side-mobile-only',
    'overlay'
];
const LAYOUT_POSITIONS = ['image-left', 'image-right', 'image-overlay'];
const LAYOUT_PROPORTIONS = [
    '20-80',
    '50-50',
    '33-66',
    '66-33',
    'overlay',
    'overlay-limited-height'
];
module.exports = {
    LAYOUT_PLACEMENTS,
    LAYOUT_POSITIONS,
    LAYOUT_PROPORTIONS
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 74992:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(99156);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6528:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorStyles, getColorToken, maxScreen, minScreen, minMaxScreen } = __webpack_require__(26865);
const { cssVariablesGrid } = __webpack_require__(1123);
const applyGridMixin = () => {
    return `
    ${cssVariablesGrid()}

    align-items: center;
    display: grid;
    grid-column-gap: var(--grid-gap);
    grid-template-areas: 'image content';
    grid-template-columns: repeat(2, 1fr);

    &.summary-item--layout-position-image-right {
      grid-template-areas: 'content image';
    }

    &.summary-item--primary-block {
      ${minScreen(BREAKPOINTS.md)}{
        border-bottom: 0;
      }

      .summary-item__image-link {
        max-width: 100%;
      }
    }

    &.summary-item--primary-block:first-of-type {
      ${maxScreen(BREAKPOINTS.md)}{
        display: block;
      }
    }
    .summary-item__asset-container--align-top {
      align-self: start;
    }

    .summary-item__asset-container {
      grid-area: image;
    }

    .summary-item__content {
      grid-area: content;
      padding-top: 0;
    }

    &.summary-item--primary-block:first-of-type
      > .summary-item__content--margintop {
      padding-top: 0;
      margin-top: ${calculateSpacing(2)};
    }
  `;
};
const applyGridThirdsMixin = () => {
    return `
    && {
      grid-template-areas: 'image content content';
      grid-template-columns: repeat(3, 1fr);
  
      &.summary-item--layout-position-image-right {
        grid-template-areas: 'content content image';
      }
    }
  `;
};
const applyBorder = ({ hasBorder, hasHiddenFinalBorder, shouldRemoveHorizontalPadding, theme, isHighDensity }) => {
    if (hasBorder) {
        let highDensityDependentStyles = '';
        if (isHighDensity) {
            highDensityDependentStyles = `
        ${minMaxScreen(0, BREAKPOINTS.md)} {
          border-bottom: 1px solid;
          ${getColorStyles(theme, 'border-bottom-color', 'colors.discovery.body.light.border')};
        }
      `;
        }
        return `
      // this is added by the shouldHideFinalBorder prop for when we want
      // borders everywhere except the end of the section
      ${hasHiddenFinalBorder
            ? `
            &:last-of-type {
              border-bottom: none;
            }
          `
            : ''}

      border-bottom: var(--border-width, 1px) solid;
      ${getColorStyles(theme, 'border-bottom-color', 'colors.discovery.body.white.border')};
      padding-bottom: ${calculateSpacing(2)};
      ${shouldRemoveHorizontalPadding &&
            `
          ${minScreen(BREAKPOINTS.sm)} {
            padding-bottom: 0;
          }
          `}
      ${minScreen(BREAKPOINTS.md)} {
        padding-bottom: 0;
      }
      ${highDensityDependentStyles}
    `;
    }
    return '';
};
const applyBorderSides = ({ hasBorderSides, theme }) => {
    if (hasBorderSides) {
        return `
      &&&{
        border-right: 1px solid ${getColorToken(theme, 'colors.discovery.body.white.divider')};
      }

      &:last-of-type {
        border-right: none;
      }
    `;
    }
    return '';
};
const applyMobileOnlyBorder = ({ hasMobileOnlyBorder, theme }) => {
    if (hasMobileOnlyBorder) {
        return `
      ${maxScreen(BREAKPOINTS.md)} {
        border-bottom: 1px solid;
        ${getColorStyles(theme, 'border-bottom-color', 'colors.discovery.body.white.border')};
        padding-bottom: ${calculateSpacing(2)};
        padding-top: 0;
      }
    `;
    }
    return '';
};
const applyLargeScreenBorder = ({ hasBorderOnLargeScreen, theme }) => {
    if (hasBorderOnLargeScreen) {
        return `
      ${maxScreen(BREAKPOINTS.lg)} {
        border-bottom: 1px solid;
        ${getColorStyles(theme, 'border-bottom-color', 'colors.discovery.body.white.border')};
        padding-bottom: ${calculateSpacing(2)};
        padding-top: 0;
      }
    `;
    }
    return '';
};
const applyVerticalRule = ({ theme, hasVerticalRule }) => {
    if (hasVerticalRule) {
        return `
      ${minScreen(BREAKPOINTS.lg)} {
          position: relative;
          &::before {
            ${getColorStyles(theme, 'background', 'colors.consumption.lead.standard.divider')};
            position: absolute;
            top: 20%;
            right: ${calculateSpacing(-2)};
            width: 1px;
            height: 60%;
            content: '';
          }
        }
    `;
    }
    return '';
};
const applySideBySideVerticalAlign = ({ sideBySideVerticalPlacement, layoutPlacement }) => {
    const dependentLayoutPlacements = [
        'side-by-side',
        'side-by-side-desktop-only',
        'side-by-side-mobile-only',
        'text-below-desktop-only'
    ];
    if (sideBySideVerticalPlacement === 'top' &&
        dependentLayoutPlacements.includes(layoutPlacement)) {
        return `&& {
      align-items: flex-start;
    }`;
    }
    return '';
};
const applyhasSideBySideMobileOnlyImageRight = ({ hasSideBySideMobileOnlyImageRight, layoutPlacement }) => {
    const dependentLayoutPlacements = [
        'side-by-side',
        'side-by-side-desktop-only',
        'side-by-side-mobile-only',
        'text-below-desktop-only'
    ];
    if (hasSideBySideMobileOnlyImageRight &&
        dependentLayoutPlacements.includes(layoutPlacement)) {
        return `&& {
      @media (max-width: calc(${BREAKPOINTS.md} - 1px)) {
            ${applyGridMixin()}
            align-items: start;
            grid-template-columns: repeat(4, 1fr);
            grid-template-areas: 'content content content image';
      }
    }`;
    }
    return '';
};
const applySideBySideDesktopOnly = ({ layoutPlacement }) => {
    if (layoutPlacement === 'side-by-side-desktop-only') {
        return `
      ${minScreen(BREAKPOINTS.md)} {
        ${applyGridMixin()}
      }
    `;
    }
    return '';
};
const applyProportions3366 = ({ layoutProportions }) => {
    if (layoutProportions === '33-66') {
        return applyGridThirdsMixin();
    }
    return '';
};
const applySideBySideMobileOnly = ({ layoutPlacement }) => {
    if (layoutPlacement === 'side-by-side-mobile-only') {
        return `
      ${minMaxScreen(0, BREAKPOINTS.lg)} {
        && {
          ${applyGridMixin()}
        }
      }
    `;
    }
    return '';
};
// Another function name is welcome.
// FIX: these styles should be split across the independant values, not merged
// as one.
const applyIDontKnowHowToJustifyThis2 = ({ layoutPosition, layoutProportions }) => {
    if (layoutProportions === '66-33' && layoutPosition === 'image-left') {
        return `
      ${applyGridMixin()}

      align-items: start;
      grid-template-areas: 'image content';
      grid-template-columns: 2fr 1fr;
    `;
    }
    return '';
};
const applyTextBelowDesktopOnly = ({ layoutPlacement, isHighDensity }) => {
    if (layoutPlacement === 'text-below-desktop-only') {
        let highDensityDependentStyles = '';
        // Adding highDensity dependent styles here.
        if (isHighDensity) {
            highDensityDependentStyles = `
        ${minMaxScreen(0, BREAKPOINTS.md)} {
          grid-column-gap: var(--grid-gap);
        }
      `;
        }
        return `
      ${applyGridMixin()}
      ${applyGridThirdsMixin()}
      ${highDensityDependentStyles}
      ${minScreen(BREAKPOINTS.md)}{
        display: block;
      }
    `;
    }
    return '';
};
const applySqueezedItem = ({ layoutProportions }) => {
    if (layoutProportions === '20-80') {
        // Adding highDensity dependent styles here.
        return `
      &&& {
        .summary-item__asset-container {
          ${minScreen(BREAKPOINTS.lg)} {
            width: 80%;
          }
          margin: auto;
          padding: ${calculateSpacing(2)} 0;
        }
      }
    `;
    }
    return '';
};
module.exports = {
    applyGridMixin,
    applyGridThirdsMixin,
    applyBorder,
    applyBorderSides,
    applyMobileOnlyBorder,
    applyLargeScreenBorder,
    applyTextBelowDesktopOnly,
    applyIDontKnowHowToJustifyThis2,
    applySideBySideDesktopOnly,
    applyProportions3366,
    applySideBySideMobileOnly,
    applyVerticalRule,
    applySideBySideVerticalAlign,
    applyhasSideBySideMobileOnlyImageRight,
    applySqueezedItem
};
//# sourceMappingURL=styles-utils.js.map

/***/ }),

/***/ 68116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorStyles, getColorToken, getLinkStyles, getTypographyStyles, minScreen, clearFix, minMaxScreen, maxScreen, getDecoration } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(18730);
const { BaseLink } = __webpack_require__(60881);
const { resolveMenuKey } = __webpack_require__(70698);
const { RubricIcon, RubricWrapper, RubricLink } = __webpack_require__(6613);
const { BylinesWrapper } = __webpack_require__(15384);
const { applyGridMixin, applyGridThirdsMixin, applyBorder, applyBorderSides, applyMobileOnlyBorder, applyLargeScreenBorder, applyTextBelowDesktopOnly, applyIDontKnowHowToJustifyThis2, applySideBySideDesktopOnly, applyProportions3366, applySideBySideMobileOnly, applyVerticalRule, applySideBySideVerticalAlign, applyhasSideBySideMobileOnlyImageRight, applySqueezedItem } = __webpack_require__(6528);
const { ButtonWrapper } = __webpack_require__(18974);
const { maxThresholds, minThresholds } = __webpack_require__(99906);
const { SummaryItemImageLink, SummaryItemImageContent } = __webpack_require__(14207);
const { SummaryItemBylinePublishDate, SummaryItemBaseByline } = __webpack_require__(277);
const { SummaryItemHedBase } = __webpack_require__(36211);
const { BylineWrapper, BylineNamesWrapper } = __webpack_require__(74423);
const { ResponsiveImageContainer } = __webpack_require__(7228);
const { UtilityFeaturesWrapper } = __webpack_require__(27490);
const SummaryItemAssetContainer = styled.div.withConfig({
    displayName: 'SummaryItemAssetContainer'
}) `
  ${({ hasSummaryItemAssetSpacing }) => {
    if (hasSummaryItemAssetSpacing) {
        return `
        padding: 0 ${calculateSpacing(4)};
        ${maxScreen(BREAKPOINTS.lg)} {
          padding: 0 ${calculateSpacing(2)};
        }
      `;
    }
    return '';
}}

  ${({ shouldAddHover }) => {
    if (shouldAddHover) {
        return `
        &:hover {
            cursor : pointer;
          }
      `;
    }
    return '';
}}

  ${({ theme, shouldHaveBorderBottomOnItem }) => {
    if (shouldHaveBorderBottomOnItem) {
        return `
        border-bottom-style: solid;
        border-bottom-width: ${calculateSpacing(0.5)};
        ${getColorStyles(theme, 'border-bottom-color', 'colors.interactive.base.black')};
      `;
    }
    return '';
}}

  ${({ shouldUseMediumBreakpoint, imageAlignment }) => !shouldUseMediumBreakpoint &&
    imageAlignment === 'top' &&
    `
    ${maxScreen(`${maxThresholds.lg}px`)} {
      align-self: baseline;
    }
  `}
 
  img {
    ${({ shouldApplyImageBorderRadius, theme }) => shouldApplyImageBorderRadius &&
    `border-radius: ${getDecoration(theme, 'cardRadiusSm')};
      ${minScreen(BREAKPOINTS.md)} {
        border-radius: ${getDecoration(theme, 'cardRadiusMd')};
      }
      ${minScreen(BREAKPOINTS.lg)} {
        border-radius: ${getDecoration(theme, 'cardRadiusLg')};
      }`}
  }

  &&& {
    ${({ isTextExternalLink }) => {
    if (isTextExternalLink) {
        return `
        width: 0px;
      `;
    }
    return '';
}}
  }
`;
const SummaryItemContributorContent = styled.div.withConfig({
    displayName: 'SummaryItemContributorContent'
}) `
  /* To prevent a long rubric or contributor name from clipping */
  max-width: calc(100% - 44px);
  ${({ shoulUseContributorRiverItemStyle }) => {
    if (shoulUseContributorRiverItemStyle) {
        return `
      width: 80%;
      order: 1;
      padding-right: ${calculateSpacing(1)};
    `;
    }
    return '';
}}
  ${maxScreen(BREAKPOINTS.lg)} {
    max-width: calc(100% - 40px);
  }
  ${({ layoutPosition }) => layoutPosition === 'image-right' &&
    `
      order: 1;
      padding-right: ${calculateSpacing(1)};
    `}
`;
const SummaryItemDek = styled(BaseText).withConfig({
    displayName: 'SummaryItemDek'
}) `
  ${({ hasDenseDesktopStack, shouldHideContributors, theme }) => hasDenseDesktopStack
    ? css `
          ${maxScreen(BREAKPOINTS.sm)} {
            margin: 0;
            padding-bottom: ${shouldHideContributors
        ? 0
        : calculateSpacing(0.5)};

            &&& {
              margin-bottom: 0;
            }
          }

          ${minScreen(BREAKPOINTS.sm)} {
            margin: 0;
            padding-bottom: ${shouldHideContributors ? 0 : calculateSpacing(1)};
          }
          ${getColorStyles(theme, 'color', 'colors.discovery.body.white.description')}
        `
    : css `
          ${({ shouldHideDekBottomMargin, shouldHideContributors }) => {
        if (shouldHideDekBottomMargin) {
            return css `
                ${maxScreen(BREAKPOINTS.md)} {
                  &&& {
                    margin-bottom: ${shouldHideContributors && 0};
                  }
                }
              `;
        }
        return css `
              margin: 0 0 ${calculateSpacing(1)} 0;

              &&& {
                margin-bottom: ${({ hasExtraSpacing, hasMarginSpacing, verticalAlign, isVenueCardItemContainer }) => {
            let spacing = 1;
            if (hasExtraSpacing || hasMarginSpacing) {
                spacing = 2;
            }
            else if (verticalAlign === 'bottom') {
                spacing = 0;
            }
            else if (isVenueCardItemContainer) {
                spacing = 0.5;
            }
            return calculateSpacing(spacing);
        }};
              }
            `;
    }}
        `};

  .small {
    text-transform: lowercase;
    font-style: normal;
    font-variant: small-caps;
  }

  a {
    ${getColorStyles('color', 'colors.discovery.body.white.description')};
  }

  a:hover {
    ${getColorStyles('color', 'colors.discovery.body.white.heading')};
  }

  ${({ hasListInDek }) => {
    if (hasListInDek) {
        return `
        ul {
          padding-left: ${calculateSpacing(2)};
          & li {
            padding-bottom: 10px;
          }
          & li:last-child {
            padding-bottom: 0
          }
        }
      `;
    }
    return '';
}}

  ${({ isInline, shouldHideOnMobile, shouldHideOnMobileAndShowOnTablet }) => {
    if (isInline) {
        return 'display: inline;';
    }
    else if (shouldHideOnMobile) {
        return `
        display: none;
        ${minScreen(BREAKPOINTS.lg)} {
          display: block;
        }
      `;
    }
    else if (shouldHideOnMobileAndShowOnTablet) {
        return `
        display: none;
        ${minScreen(BREAKPOINTS.md)} {
          display: block;
        }
      `;
    }
    return '';
}}

  ${({ verticalAlign }) => verticalAlign === 'bottom'
    ? `
    ${minScreen(BREAKPOINTS.lg)}{
      bottom: 0;
      position: absolute;
    }
  `
    : ''}
  
  ${({ theme, shouldUseArrowIconInDek }) => shouldUseArrowIconInDek &&
    `
    font-weight:bold;
    text-align:center;
    &::after {
      content: '';
      margin-left: ${calculateSpacing(1)};
      ${getColorStyles(theme, 'color', 'colors.discovery.body.white.context-signature')};
    }
  `}
  
  ${({ isTextExternalLink }) => {
    return (isTextExternalLink &&
        css `
        &&&& {
          ${maxScreen(BREAKPOINTS.md)} {
            margin-bottom: ${calculateSpacing(3)};
          }
          ${getTypographyStyles(`typography.definitions.discovery.description-page`)};
          margin-bottom: ${calculateSpacing(4)};
        }
      `);
}}
`;
SummaryItemDek.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
const SummaryItemAuthorTitle = styled(BaseText).withConfig({
    displayName: 'SummaryItemAuthorTitle'
}) ``;
SummaryItemAuthorTitle.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
const applyDense = ({ hasDense, shouldShowAllContentWhenDense }) => {
    if (!hasDense)
        return '';
    const floatImageStyles = css `
    ${clearFix()}
    display: block;

    ${SummaryItemAssetContainer} {
      float: right;
      margin-top: 0;
      margin-bottom: ${calculateSpacing(1)};
      margin-left: ${calculateSpacing(2)};
      width: ${calculateSpacing(8)}; /* explicit width needed as the image is now floating */
    }
  `;
    return shouldShowAllContentWhenDense
        ? floatImageStyles
        : css `
        ${minScreen(BREAKPOINTS.xl)} {
          ${floatImageStyles}
        }

        ${maxScreen(BREAKPOINTS.lg)} {
          ${RubricWrapper} {
            display: none;
          }
        }

        ${minMaxScreen(BREAKPOINTS.lg, `${maxThresholds.xl - 1}px`)} {
          ${clearFix()}

          display: block;

          ${SummaryItemAssetContainer} {
            display: none;
          }
        }
      `;
};
const applyHighDensity = ({ isHighDensity }) => {
    if (!isHighDensity)
        return '';
    return `
    && {
      ${minScreen(BREAKPOINTS.md)} {
        border-bottom: none;
    
        /* hide summary items 5-10 on mobile+ viewports */
        &:nth-child(n + 6) {
          display: none;
        }
      }
    }
  `;
};
const applyBundle = () => `&.summary-item--bundle {
      grid-column-gap: 0;
      ${minScreen(BREAKPOINTS.lg)} {
        padding-bottom: ${calculateSpacing(6)};
      }

      ${SummaryItemHedBase} {
        margin-top: ${calculateSpacing(1)};
        margin-bottom: 0;
      }

      ${SummaryItemHedBase},
      ${SummaryItemBaseByline} {
        ${minScreen(BREAKPOINTS.md)} {
          margin-right: auto;
          margin-left: auto;
        }
      }
    
      ${minMaxScreen(BREAKPOINTS.md, `calc(${BREAKPOINTS.lg} - 1px)`)} {
        /* need to treat tablet like mobile but the 'side-by-side-desktop-only' breakpoints are based on bp--md which is tablet but not desktop */
        display: block;
        padding: 0;
    
        ${SummaryItemHedBase}, ${SummaryItemDek} {
          display: block;
          margin-top: ${calculateSpacing(4)};
        }

      }
  }`;
const applyMargin = ({ hasMarginSpacing, verticalAlign }) => {
    if (hasMarginSpacing && verticalAlign === 'bottom') {
        return `&&& {
    ${SummaryItemDek}{
    margin-bottom: 0;
  }}`;
    }
    return (hasMarginSpacing &&
        `&&& {
    ${SummaryItemDek}{
    margin-bottom: ${calculateSpacing(2)};
  }}`);
};
const applyPadding = ({ hidePadding }) => {
    if (hidePadding) {
        return `&&&.summary-item--bundle {
      ${minScreen(BREAKPOINTS.lg)} {
        padding-bottom: 0;
      }
    }`;
    }
    return '';
};
const applyImageonTop = ({ imageAlignment }) => {
    if (imageAlignment === 'top')
        return `
  && {
      ${minScreen(BREAKPOINTS.md)} {
        align-items: start;
      }

      ${SummaryItemAssetContainer} {
        ${minScreen(BREAKPOINTS.md)} {
          margin-top: ${calculateSpacing(0.5)};
        }
      }
    }
  `;
    return '';
};
const applyContributorGridItem = ({ theme, isContributorGridItem }) => {
    if (!isContributorGridItem)
        return '';
    return `
  max-width: ${calculateSpacing(20)};
  &&&&
  ${SummaryItemAssetContainer} {
    img {
      ${getColorStyles(theme, 'background-color', 'colors.discovery.lead.secondary.background')};
    }
  }`;
};
const applyContributor = ({ isContributor, theme, layoutPosition, isContributorThreeCol, isContributorImageTopAligned }) => {
    if (!isContributor)
        return '';
    let imageRightPositionStyles = '';
    if (layoutPosition === 'image-right') {
        imageRightPositionStyles = `
    && {
      ${SummaryItemImageLink},
      ${SummaryItemImageContent} {
        order: 2;
        margin-right: 0;
      }
    }
    `;
    }
    let imagePaddingContributorStyles = '';
    let imageContributorStyles = '';
    let imageContributorPositioning = '';
    if (isContributor && !isContributorThreeCol) {
        imagePaddingContributorStyles = `
    padding: ${calculateSpacing(3)} 0;
    ${minScreen(BREAKPOINTS.md)} {
      padding: ${calculateSpacing(1)} 0 ${calculateSpacing(3)} 0;
    }`;
        imageContributorStyles = `
    ${SummaryItemImageLink},
    ${SummaryItemImageContent} {
      position: absolute;
      top: -6px; /* image should always be fixed as per design */
      right: 0;
      margin-right: ${calculateSpacing(1)};
      width: 44px;
      height: 44px;

      ${maxScreen(BREAKPOINTS.lg)} {
        width: 40px;
        height: 40px;
      }

      img {
        ${getColorStyles(theme, 'background-color', 'colors.discovery.lead.secondary.background')};
      }
    }`;
    }
    else if (isContributorThreeCol) {
        imagePaddingContributorStyles = `
    padding: 0;
    ${minScreen(BREAKPOINTS.md)} {
      padding: 0;
    }`;
        imageContributorStyles = `
    ${SummaryItemImageLink} {
      position: relative;
      top: 0px; 
      margin-right: ${calculateSpacing(3)};
      width: 98px;
      height: 98px;

      ${maxScreen(BREAKPOINTS.lg)} {
        width: 70px;
        height: 70px;
      }

      img {
        ${getColorStyles(theme, 'background-color', 'colors.discovery.lead.secondary.background')};
      }
    }  `;
    }
    if (isContributorImageTopAligned) {
        imageContributorPositioning = `
    ${SummaryItemImageLink} {
      position: relative;
      top: 0; 
      margin-right: ${calculateSpacing(3)};
      width: ${calculateSpacing(15.5)};
      height: ${calculateSpacing(15.5)};
      align-self: baseline;

      ${maxScreen(BREAKPOINTS.lg)} {
        width: ${calculateSpacing(9)};
        height: ${calculateSpacing(9)};
      }
    } `;
    }
    return `
    &&& {
      ${imagePaddingContributorStyles}
      ${imageRightPositionStyles}

      ${imageContributorStyles}

      ${imageContributorPositioning}

      ${RubricWrapper} {
        margin-bottom: 0;
      }
    
      ${SummaryItemAssetContainer} {
        display: flex;
        position: relative;
        align-items: center;
        width: 100%;
      }

      ${SummaryItemHedBase} {
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-secondary')}
      }
    }
  `;
};
const SummaryItemMetadataPrimary = styled(BaseText).withConfig({
    displayName: 'SummaryItemMetadataPrimary'
}) `
  margin-bottom: ${calculateSpacing(0.5)};

  ${minScreen(BREAKPOINTS.md)} {
    margin-bottom: ${calculateSpacing(1)};
  }
`;
SummaryItemMetadataPrimary.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.accent',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
const SummaryItemMetadataSecondary = styled(BaseText).withConfig({
    displayName: 'SummaryItemMetadataSecondary'
}) `
  ${({ hasMobileSpacing, hasMarginSpacing, hasMetaWithoutMargin }) => {
    if (hasMobileSpacing) {
        return `
        margin-bottom: 0;
        ${minScreen(BREAKPOINTS.md)} {
          margin-bottom: ${hasMarginSpacing ? calculateSpacing(2) : calculateSpacing(4)};
        }
      `;
    }
    if (hasMarginSpacing)
        return `margin-bottom: ${calculateSpacing(2)}{

    }`;
    if (hasMetaWithoutMargin)
        return `margin-bottom: ${calculateSpacing(0)}{

    }`;
    return `margin-bottom: ${calculateSpacing(4)};`;
}}
`;
SummaryItemMetadataSecondary.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.globalEditorial.numerical-small'
};
const SummaryItemContent = styled.div.withConfig({
    displayName: 'SummaryItemContent'
}) `
  ${({ hasNoRubric, hasTighterVerticalSpacing, hasBookmarks, hasNoBottomPaddingContent, hasNoBottomPaddingForGridContent, hasNoBottomPaddingForCneVideo, isContributorThreeCol, isVenueCardItemContainer, hasMediumMarginBottom, isPlpCurated }) => {
    let paddingTop = 2;
    let paddingBottom = 4;
    if (hasNoBottomPaddingForCneVideo) {
        paddingTop = 2;
        paddingBottom = 0;
    }
    if (hasNoBottomPaddingForGridContent) {
        paddingTop = 2;
        paddingBottom = 0;
    }
    if (hasTighterVerticalSpacing) {
        paddingTop = 3;
        paddingBottom = 1;
    }
    if (hasNoRubric) {
        paddingTop = 2;
    }
    if (hasNoBottomPaddingContent) {
        paddingTop = 3;
        paddingBottom = 0;
    }
    if (hasBookmarks) {
        paddingBottom = 0;
    }
    if (isContributorThreeCol) {
        paddingTop = 0;
    }
    if (isVenueCardItemContainer) {
        paddingTop = 1;
    }
    if (hasMediumMarginBottom) {
        paddingBottom = 2;
    }
    if (isPlpCurated) {
        paddingBottom = 0;
    }
    return `padding: ${calculateSpacing(paddingTop)} 0 ${calculateSpacing(paddingBottom)};`;
}}

  &&&& {
    ${({ isTextExternalLink, isGridLayout }) => isTextExternalLink &&
    `text-align: left; 
     ${!isGridLayout &&
        `padding: 0 ${calculateSpacing(2)} 0 ${calculateSpacing(2)};
     ${maxScreen(BREAKPOINTS.md)} 
     {
        padding: 0 ${calculateSpacing(1)} 0 ${calculateSpacing(1)};
     }`}
    `}
  }

  ${({ isSeriesNavigation }) => isSeriesNavigation &&
    `
    display: -webkit-box;
     overflow: hidden;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
  `}

  ${minScreen(BREAKPOINTS.lg)} {
    ${({ hasTighterVerticalSpacing }) => hasTighterVerticalSpacing && `padding-bottom: ${calculateSpacing(5)};`}
  }

  ${({ contentAlign }) => contentAlign === 'center' ? 'text-align: center;' : ''}

  ${({ hasSummaryItemExtraPadding }) => hasSummaryItemExtraPadding &&
    `padding: ${calculateSpacing(2)} ${calculateSpacing(3)} ${calculateSpacing(3)} ${calculateSpacing(3)};`}

  ${({ contentAlignmentInMobile }) => contentAlignmentInMobile &&
    `${maxScreen(`${maxThresholds.lg}px`)} {
        text-align: ${contentAlignmentInMobile};
        }
    `}

  .summary-item--text-align-center & {
    ${BylineWrapper} {
      text-align: center;
    }
  }

  .summary-item--bundle & {
    ${minScreen(BREAKPOINTS.md)} {
      margin: 0 auto;
      width: ${calculateSpacing(56)};
    }
    ${maxScreen(BREAKPOINTS.md)} {
      padding-right: ${calculateSpacing(2)};
      padding-left: ${calculateSpacing(2)};
    }
  }

  /* update padding based on layout placement */
  ${({ layoutPlacement }) => layoutPlacement === 'text-below-desktop-only' &&
    `&&& {
      ${minScreen(BREAKPOINTS.md)}{
        padding-top: ${calculateSpacing(2)};
      }
    }`}

  ${({ hasAsset }) => {
    if (hasAsset)
        return '';
    return `
      &&& {
        grid-column: 1/-1;
        padding: 0;
      }
    `;
}}

  /* -> .summary-item--high-density */
  ${({ hasHighDensity }) => hasHighDensity &&
    `
    &&& {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
  
      ${minScreen(BREAKPOINTS.md)} {
        display: block;
        align-items: inherit;
        height: auto;
      }

      ${RubricWrapper},
      ${SummaryItemDek},
      ${SummaryItemMetadataPrimary},
      ${SummaryItemMetadataSecondary},
      ${SummaryItemBaseByline},
      ${SummaryItemBylinePublishDate} {
        display: none;
        ${minScreen(BREAKPOINTS.md)} {
          display: block;
        }
      }
    }
  `}

    ${({ hasDenseDesktopStack, shouldHidePublishDate, theme }) => hasDenseDesktopStack &&
    css `
      ${RubricWrapper} {
        margin-bottom: ${calculateSpacing(1)};
      }
      ${minMaxScreen(0, BREAKPOINTS.sm)} {
        margin-bottom: 0;
        padding-bottom: ${calculateSpacing(2)};
        ${SummaryItemBaseByline} {
          .bylines__byline {
            padding-bottom: ${shouldHidePublishDate
        ? 0
        : calculateSpacing(0.5)};
          }
        }
      }
      ${minMaxScreen(BREAKPOINTS.sm, `${maxThresholds.md}px`)} {
        align-self: start;
        margin-bottom: 0;
        padding-bottom: ${calculateSpacing(2)};
        ${SummaryItemBaseByline} {
          .bylines__byline {
            padding-bottom: ${shouldHidePublishDate ? 0 : calculateSpacing(1)};
          }
        }
      }

      ${maxScreen(`${maxThresholds.lg}px`)} {
        &&& {
          padding-top: 0;
        }
      }

      ${minScreen(`${minThresholds.lg}px`)} {
        margin-bottom: 0;
        padding-bottom: 0;

        ${SummaryItemBaseByline} {
          .bylines__byline {
            padding-bottom: ${shouldHidePublishDate ? 0 : calculateSpacing(1)};
          }
        }
      }

      ${SummaryItemBaseByline} {
        margin-bottom: 0;

        .bylines__byline {
          margin-top: 0;
        }
      }
      ${SummaryItemBylinePublishDate} {
        ${getColorStyles(theme, 'color', 'colors.discovery.body.white.context-tertiary')}
      }
    `};

  ${({ isContributor }) => isContributor &&
    `
    && {
      padding-top: ${calculateSpacing(2)};
      padding-bottom: 0;
    }
  `}

  ${({ shouldUseFlexGrow }) => shouldUseFlexGrow &&
    `display:flex;
  flex-grow:1;
  flex-direction:column;`}

  ${({ commentsCount, shouldEnableCommentsCount, shouldEnableCardLevelBookmark }) => (!shouldEnableCommentsCount || !commentsCount) &&
    shouldEnableCardLevelBookmark &&
    `
    position: relative;
    ${UtilityFeaturesWrapper} {
      position: absolute;
      bottom: 0;
      right: 0;
    }
  `}
`;
const applyContributorReadMore = ({ showReadMore }) => {
    if (showReadMore) {
        return `
      font-size: ${calculateSpacing(1.5)};
    `;
    }
    return '';
};
const SummaryItemDekReadMore = styled(BaseLink).withConfig({
    displayName: 'SummaryItemDekReadMore'
}) `
  ${({ isVenueCardItemContainer }) => isVenueCardItemContainer ? `margin-bottom: ${calculateSpacing(1.5)};` : ''}
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
  ${applyContributorReadMore}
  display: inherit;
`;
SummaryItemDekReadMore.defaultProps = {
    as: 'a',
    colorStaticLinkToken: 'colors.discovery.body.light.accent',
    colorToken: null,
    linkStyle: 'global',
    typeIdentity: 'typography.definitions.discovery.description-core'
};
const applyHedLinkRule = ({ hasRule }) => {
    if (!hasRule)
        return '';
    return `display: block;
    position: relative;

    &::after {
      display: block;
      content: '';
    }`;
};
const SummaryItemHedLink = styled.a.withConfig({
    displayName: 'SummaryItemHedLink'
}) `
  ${getLinkStyles('colors.discovery.body.white.heading', null, 'global')}

  &::after {
    margin-bottom: ${calculateSpacing(2)};
    border-bottom: 1px solid
      ${getColorToken('colors.discovery.body.white.accent')};
    width: ${calculateSpacing(10)};

    ${({ hasRuleOnlyMedium }) => hasRuleOnlyMedium &&
    `display: none;
    ${minScreen(BREAKPOINTS.md)}{
      display: block;
    }`}

    ${({ contentAlign }) => contentAlign === 'center' ? `margin-left: auto; margin-right: auto;` : ''}
  }
  ${applyHedLinkRule}

  ${({ hasRule, hideRuleFromMobile }) => hasRule &&
    hideRuleFromMobile &&
    `
    &::after {
      display: none;
      ${minScreen(BREAKPOINTS.md)}{
        display: block;
      }
    }
  `}
${({ hasDenseDesktopStack, theme }) => hasDenseDesktopStack
    ? css `
          ${minMaxScreen(BREAKPOINTS.sm, `${maxThresholds.lg}px`)} {
            padding-top: ${calculateSpacing(1)};
          }
          ${maxScreen(BREAKPOINTS.sm)} {
            padding-top: ${calculateSpacing(0.5)};

            &&& {
              ${SummaryItemHedBase} {
                margin-bottom: ${calculateSpacing(0.5)};
              }
            }
          }
          ${minScreen(BREAKPOINTS.md)} {
            &&& {
              ${SummaryItemHedBase} {
                margin-bottom: ${calculateSpacing(1)};
              }
            }
          }

          &&&& {
            .summary-item__hed {
              ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')}
            }
          }

          &::after {
            display: none;
          }
        `
    : ''}

  ${({ isContributor }) => isContributor &&
    `
      &:last-child {
        ${SummaryItemHedBase} {
          margin-bottom: 0;
        }
      }
   `}
`;
const SummaryItemNowShopping = styled(BaseText).withConfig({
    displayName: 'SummaryItemNowShopping'
}) `
  padding-top: ${calculateSpacing(1)};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-secondary')};

  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.feedback.invalid-primary')};
`;
const SummaryItemContributorName = styled.div.withConfig({
    displayName: 'SummaryItemContributorName'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')};
  text-transform: uppercase;
`;
const SummaryItemRubric = styled.div.withConfig({
    displayName: 'SummaryItemRubric'
}) `
  display: block;
  margin-bottom: ${({ hasBookmarks }) => hasBookmarks ? 0 : calculateSpacing(1)};
  max-width: max-content;

  ${({ shouldUseRubricAsRole, isContributor }) => shouldUseRubricAsRole &&
    isContributor &&
    css `
      ${getTypographyStyles('typography.definitions.globalEditorial.accreditation-core')}
    `}

  ${({ contentAlign }) => contentAlign === 'center'
    ? `
    margin-left: auto;
    margin-right: auto;
  `
    : ''}

  ${({ hasBottomSpaceOnRubric }) => hasBottomSpaceOnRubric &&
    ` && {
        padding-bottom: 8px
      }
      `}

  ${RubricIcon} {
    ${({ hasIcon, hasBookmarks }) => {
    let display = 'none';
    if (hasIcon || hasBookmarks)
        display = 'inline';
    return `display: ${display};`;
}}

    svg {
      max-width: ${calculateSpacing(2)};
      max-height: ${calculateSpacing(2)};
    }
  }

  ${({ hasSeriesData, theme }) => hasSeriesData &&
    `
    a {
      ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')}
    }
  `}

  ${({ hasRubricBelowHed }) => hasRubricBelowHed &&
    `
    margin-top: ${calculateSpacing(1)};
    margin-bottom: 0;
  `}
  

  ${({ hasDenseDesktopStack }) => hasDenseDesktopStack
    ? css `
          ${minMaxScreen(0, `${maxThresholds.lg}px`)} {
            margin-bottom: ${calculateSpacing(0)};
          }
        `
    : ''}

  ${minScreen(BREAKPOINTS.xl)} {
    ${({ hasBookmarks, hasModerateSpacing }) => hasModerateSpacing && !hasBookmarks
    ? `margin-bottom: ${calculateSpacing(2)};`
    : ''}
  }
`;
const SummaryItemRubricWrapper = styled.div.withConfig({
    displayName: 'SummaryItemRubricWrapper'
}) `
  display: flex;
  flex-wrap: wrap;
`;
const SummaryItemRubricSeparator = styled.div.withConfig({
    displayName: 'SummaryItemRubricSeparator'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')};
`;
const SummaryItemVenueDetails = styled(BaseText).withConfig({
    displayName: 'SummaryItemVenueDetails'
}) `
  ${({ isVenueCardItemContainer }) => isVenueCardItemContainer ? `margin-bottom: ${calculateSpacing(1.5)}` : ''}
`;
SummaryItemVenueDetails.defaultProps = {
    as: 'div',
    colorToken: 'colors.consumption.body.standard.body',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
const applyBookmarks = ({ hasBookmarks, shouldUseGridStyles, theme }) => {
    if (!hasBookmarks)
        return '';
    return `
    && {
      grid-template-columns: 2fr 4fr;
      align-items: start;
      margin-bottom: ${calculateSpacing(2)};
      padding-bottom: ${calculateSpacing(2)};

      ${minScreen(BREAKPOINTS.md)} {
        grid-template-columns: 1fr 5fr;
      }

      ${ButtonWrapper} {
        ${getColorStyles(theme, 'border', 'colors.discovery.body.white.accent')};
        ${shouldUseGridStyles
        ? `
            ${getColorStyles(theme, 'background-color', 'colors.background.white')};
            `
        : `
            ${getColorStyles(theme, 'background-color', 'colors.background.light')};
            `}
      }
    
      ${SummaryItemRubric} ${RubricLink} {
        text-decoration: none;
    
        &:hover {
          text-decoration: underline;
        }
      }
    
      .rubric--discovery.rubric--with-bg {
        ${getColorStyles(theme, 'background-color', 'colors.background.white')};
        display: block;
        margin-bottom: ${calculateSpacing(2)};
        padding: 0;
    
        a:link,
        a:visited {
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.standard.context-signature')};
        }
      }
    
      ${SummaryItemHedBase} {
        margin-bottom: ${calculateSpacing(2)};
    
       ${minScreen(BREAKPOINTS.md)} {
          ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')}
        }
      }
    }
  `;
};
const applyDarkBackgroundStyles = (theme) => `
  ${getColorStyles(theme, 'background-color', 'colors.discovery.body.dark.background')};

  ${minScreen(BREAKPOINTS.sm)}{ 
    ${SummaryItemContent} {
      padding: ${calculateSpacing(4)} ${calculateSpacing(3)} ${calculateSpacing(7)};
    }
  }

  ${RubricLink},
  ${SummaryItemRubric},
  .rubric--with-bg ${RubricLink} {
    ${getColorStyles(theme, 'color', 'colors.discovery.body.dark.context-signature')};
  }

  ${SummaryItemDek} {
    ${getColorStyles(theme, 'color', 'colors.discovery.body.dark.description')};
  }

  ${SummaryItemHedBase} {
    ${getColorStyles(theme, 'color', 'colors.discovery.body.dark.heading')};
  }
`;
const applyDarkBackground = ({ isDarkBackground, theme }) => {
    if (isDarkBackground) {
        return `
      ${applyDarkBackgroundStyles(theme)}
      .summary-item__hed--hed-core-primary {
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')}
      }

      ${SummaryItemHedBase} {
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-break-out')}
      }

      ${minScreen(BREAKPOINTS.md)}{
        ${SummaryItemContent} {
          padding: 0 ${calculateSpacing(2)} 0 0;
        }
      }

      ${minScreen(BREAKPOINTS.lg)}{
        ${SummaryItemContent} {
          padding-right: ${calculateSpacing(4)};
        }
      }
    `;
    }
    return '';
};
const applyDarkBackgroundRight = ({ isDarkBackgroundRight, theme }) => {
    if (isDarkBackgroundRight) {
        return `
      ${applyDarkBackgroundStyles(theme)}

      .summary-item__hed--hed-core-primary {
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-primary')}
        ${getColorStyles(theme, 'color', 'colors.discovery.body.dark.heading')};
      }
      ${minScreen(BREAKPOINTS.md)}{
        ${SummaryItemContent} {
          padding: 0;
        }
      }

      ${minScreen(BREAKPOINTS.lg)}{
        ${SummaryItemContent} {
          padding-right: 0;
        }
      }

      ${minScreen(BREAKPOINTS.xl)}{
        ${SummaryItemContent} {
          padding-right: 0;
        }
      }

      ${minScreen(BREAKPOINTS.xxl)}{
        ${SummaryItemContent} {
          padding-right: 0;
        }
      }
    `;
    }
    return '';
};
const applyOffers = ({ hasOffers, layoutPlacement }) => {
    const styles = `
    && {
      display: flex;
      position: relative;
      flex-direction: column;
      height: 100%;

       ${SummaryItemAssetContainer} {
        width: 100%;
      }

      ${SummaryItemContent} {
        display: flex;
        flex: 1 0 auto;
        flex-direction: column;
      }
    }
  `;
    if (!hasOffers)
        return '';
    const dependentLayoutPlacements = ['text-below-desktop-only', 'text-below'];
    if (dependentLayoutPlacements.includes(layoutPlacement)) {
        return styles;
    }
    return '';
};
// A new function name is welcome
// Not sure how the classes are been called so added !imporant to increase the specificity
const applyIDontKnowHowToJustifyThis = ({ layoutPlacement, layoutPosition, layoutProportions }) => {
    if (layoutPlacement === 'text-below-desktop-only-thumbnail' &&
        layoutProportions === '33-66' &&
        layoutPosition === 'image-right') {
        return `
      ${applyGridMixin()}
      align-items: start;

      ${minMaxScreen(0, BREAKPOINTS.md)} {
        &&{
          grid-template-areas: 'content image';
          grid-template-columns: 1fr ${calculateSpacing(9.375)};
        }

        ${SummaryItemImageLink} {
          max-width: ${calculateSpacing(9.375)};
          height: auto;
          float: right;
          width: 100%;
        }
      }

      ${minScreen(BREAKPOINTS.md)} {
        display: block;

        ${SummaryItemContent} {
          padding-top: ${calculateSpacing(2)};
        }
      }
    `;
    }
    else if (layoutProportions === '66-33' && layoutPosition === 'image-left') {
        return `
    &&& {
      grid-template-areas: 'image content';
      grid-template-columns: 2fr 1fr;
      align-items: start;
    }`;
    }
    return '';
};
const applyCard = ({ shouldRemoveHorizontalPadding, isCard, cardContentPaddingStyles, layoutPlacement, theme, isContributorThreeCol }) => {
    let summaryItemContentPaddingStyles = '';
    if (isContributorThreeCol) {
        summaryItemContentPaddingStyles = `
    ${SummaryItemContent} {
      padding: 0 ${calculateSpacing(3)};
    }
    `;
    }
    else if (shouldRemoveHorizontalPadding) {
        summaryItemContentPaddingStyles = `
  ${SummaryItemContent} {
    padding: ${calculateSpacing(2)} ${calculateSpacing(0)};
  }
  `;
    }
    else {
        summaryItemContentPaddingStyles = `
    ${SummaryItemContent} {
      padding: ${calculateSpacing(4)} ${calculateSpacing(3)};
    }
    `;
    }
    if (isCard) {
        return `
      ${getColorStyles(theme, 'background-color', 'colors.consumption.body.standard.bg-card')};

      ${cardContentPaddingStyles && summaryItemContentPaddingStyles} 

      ${SummaryItemMetadataSecondary},
      ${SummaryItemDek} {
        &:last-child {
          margin-bottom: 0;
        }
      }

      ${layoutPlacement === 'side-by-side-desktop-only'
            ? `
            ${minScreen(BREAKPOINTS.md)}{
              ${SummaryItemContent} {
                margin-right: var(--grid-gap);
                padding: ${calculateSpacing(1)} 0;
              }
            }
          `
            : ''}
    `;
    }
    return '';
};
const applySideBySide = ({ layoutProportions, layoutPlacement, theme }) => {
    if (layoutPlacement === 'side-by-side') {
        return `
        ${applyGridMixin()}
        ${layoutProportions === '33-66'
            ? `
              ${SummaryItemImageLink}{
                margin-bottom: auto;
              }
              
              ${SummaryItemImageContent},
              ${SummaryItemContent} {
                margin-bottom: auto;
                padding-bottom: ${calculateSpacing(1)};
              }

              .summary-item__content--vertically-align {
                margin-bottom: 0;
              }
            `
            : ''}

        ${minMaxScreen(0, BREAKPOINTS.md)}{
          ${applyGridThirdsMixin()}
        }

        ${minScreen(BREAKPOINTS.md)}{
          grid-column-gap: var(--grid-gap);
        }

        ${maxScreen(BREAKPOINTS.md)}{
          .rubric--discovery.rubric--with-bg {
            background-color: transparent;
            ${getColorStyles(theme, 'color', 'colors.discovery.body.white.context-signature')};
            padding: unset;

            a {
              ${getLinkStyles(theme, 'colors.discovery.body.white.context-signature')}
            }

            svg {
              ${getColorStyles(theme, 'fill', 'colors.discovery.body.white.context-signature')};
            }
          }
        }
    `;
    }
    return '';
};
const applyInvertedTheme = ({ fullPageTheme, theme }) => {
    if (fullPageTheme === 'inverted') {
        return `
      ${SummaryItemHedBase},
      ${SummaryItemDek} {
        ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')};
      }

      ${SummaryItemHedLink} {
        &:active,
        &:hover {
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')};
        }
      }
    `;
    }
    return `
    ${BylinesWrapper},
    .byline__preamble,
    .byline__name,
    .byline__social-link,
    .byline__name-link:link,
    .byline__name-link:visited {
      ${getColorStyles(theme, 'color', 'colors.discovery.body.white.accreditation')}
    }
  `;
};
const applySpecialTheme = ({ isSpecial, theme }) => {
    if (isSpecial) {
        return `
      ${SummaryItemHedBase},
      ${SummaryItemDek} {
        ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')};
      }

      ${SummaryItemHedLink} {
        &:active,
        &:hover {
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')};
        }
      }
      
      ${BylinesWrapper},
      ${BylineNamesWrapper},
        .byline__preamble,
        .byline__name,
        .byline__social-link,
        .byline__name-link:link,
        .byline__name-link:visited,
        .summary-item__publish-date {
          ${getColorStyles(theme, 'color', 'colors.consumption.lead.inverted.heading')}
        } 
    `;
    }
    return ``;
};
const applySideBySideSmallImageMobileOnly = ({ hasSmallImageMobileOnly, layoutPlacement }) => {
    if (hasSmallImageMobileOnly && layoutPlacement.startsWith('side-by-side')) {
        return `
      &&& {
        ${minMaxScreen(0, BREAKPOINTS.lg)}{
          grid-template-columns: 1fr 75px;
  
          ${SummaryItemContent} {
            padding-bottom: 0;
          }
  
          ${SummaryItemImageLink},
          ${SummaryItemImageContent} {
            max-width: 75px;
          }
        }
      }
    `;
    }
    return '';
};
const applyDenseDesktopStack = ({ hasDenseDesktopStack }) => {
    const floatImageStyles = css `
    ${clearFix()}
    display: block;
    ${SummaryItemAssetContainer} {
      float: right;
      margin-top: ${calculateSpacing(0.5)};
      margin-bottom: ${calculateSpacing(1)};
      margin-left: ${calculateSpacing(2)};
      width: ${calculateSpacing(14)};
    }
  `;
    return hasDenseDesktopStack
        ? css `
        align-items: flex-start;
        ${minMaxScreen(0, `${maxThresholds.md}px`)} {
          ${floatImageStyles}
          ${ResponsiveImageContainer} {
            max-height: ${calculateSpacing(10.5)};
            object-fit: contain;
            object-position: right;
          }
        }
        ${maxScreen(`${maxThresholds.md}px`)} {
          && > ${SummaryItemAssetContainer} {
            display: none;
          }
        }
        ${minScreen(`${minThresholds.lg}px`)} {
          && > ${SummaryItemAssetContainer} {
            display: block;
          }
          ${SummaryItemContent} ${SummaryItemAssetContainer} {
            display: none;
          }
        }
        ${minMaxScreen(`${minThresholds.lg}px`, `${maxThresholds.lg}px`)} {
          display: grid;
          padding-bottom: ${calculateSpacing(0)};
        }
        ${minMaxScreen(0, BREAKPOINTS.sm)} {
          padding-bottom: ${calculateSpacing(0)};
        }
      `
        : '';
};
const applyDenseDesktopThirds = ({ hasDenseDesktopThirds }) => {
    const floatImageStyles = css `
    ${clearFix()}
    display: block;
    ${SummaryItemAssetContainer} {
      float: right;
      margin-top: ${calculateSpacing(0.5)};
      margin-bottom: ${calculateSpacing(1)};
      margin-left: ${calculateSpacing(2)};
      width: ${calculateSpacing(14)};
    }
  `;
    return hasDenseDesktopThirds
        ? css `
        align-items: flex-start;
        ${minMaxScreen(0, BREAKPOINTS.md)} {
          ${floatImageStyles}
          ${ResponsiveImageContainer} {
            max-height: ${calculateSpacing(10.5)};
            object-fit: contain;
            object-position: right;
          }
        }
        ${maxScreen(`${maxThresholds.md}px`)} {
          && > ${SummaryItemAssetContainer} {
            display: none;
          }
        }
        ${minScreen(`${minThresholds.lg}px`)} {
          ${SummaryItemContent} ${SummaryItemAssetContainer} {
            display: none;
          }
        }
      `
        : '';
};
// must do remove the contentType check here
const applyBorderSidesWhenSummaryItemAction = ({ contentType, hasSummaryItemAction, theme }) => {
    if (hasSummaryItemAction && contentType === 'culturalevent') {
        return `
      &&& {
        .summary-item__content{
          padding: ${calculateSpacing(1.5)} ${calculateSpacing(1.5)} 0 ${calculateSpacing(1.5)};
        }
          display: block;
          padding-bottom: 0 !important;
          border-width: 1px;
          border-style: solid;
          ${getColorStyles(theme, 'border-color', 'colors.discovery.body.white.border')};
        .summary-item__hed, .summary-item__hed-link{
          &::after {
            border-bottom: none;
          }
          ${getTypographyStyles(theme, 'typography.definitions.utility.landing-subheading')}
        }
        .summary-item__hed {
          margin-bottom: unset;
        }
        .summary-item__dek{
          margin-bottom: ${calculateSpacing(1.5)};
          ${getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.description-embed')}
          
        }
        time, .summary-item__dek, ${SummaryItemVenueDetails}{
          ${getColorStyles(theme, 'color', 'colors.discovery.body.white.description')};
        }
        ${SummaryItemVenueDetails}{
          margin-bottom: ${calculateSpacing(0.25)};
          ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')}
        }
        height: fit-content;
      }
    `;
    }
    return '';
};
const applyHeadingInline = ({ contentType, theme }) => {
    if (contentType === 'heading-inline') {
        return `
      &&& {
        .summary-item__content{
          border-bottom: 1px solid;
          ${getColorStyles(theme, 'border-bottom-color', 'colors.discovery.body.white.border')};
          margin-bottom: ${calculateSpacing(2.5)};
        }
        .summary-item__hed-link--heading-inline {
          scroll-margin-top: ${calculateSpacing(8)};
          &:active,
          &:focus,
          &:hover {
            text-decoration: none
          };
        }
        ${SummaryItemHedBase} {
          ${getTypographyStyles(theme, 'typography.definitions.discovery.subhed-section-primary')};
          padding: ${calculateSpacing(2)} 0;
          text-align: center;
        }
      }
    `;
    }
    return '';
};
// NOTE: All of these styles cascade which causes things to constantly override
// each other. To put it politely, a fucking mess.
const SummaryItemWrapper = styled.div.withConfig({
    displayName: 'SummaryItemWrapper'
}) `
  ${({ isPlpCurated }) => isPlpCurated &&
    css `
      &:hover {
        a {
          text-decoration: underline;
        }
      }
    `}

  ${({ hasDenseDesktopStack, hideDangerousDek }) => hasDenseDesktopStack && !hideDangerousDek
    ? css `
          ${maxScreen(`${maxThresholds.md}px`)} {
            .summary-item__asset-container:first-child {
              display: none;
            }
          }
        `
    : ``}

  ${({ isAlternateClickHandlerStrategy }) => !isAlternateClickHandlerStrategy &&
    `
      cursor: pointer;
    `}

  ${applyBorderSidesWhenSummaryItemAction}
  ${applyBorderSides}
  ${applyBorder}
  ${applyMobileOnlyBorder}
  ${applyLargeScreenBorder}
  ${applyTextBelowDesktopOnly}
  ${applyIDontKnowHowToJustifyThis}
  ${applyIDontKnowHowToJustifyThis2}
  ${applyCard}
  ${applySideBySide}
  ${applyInvertedTheme}
  ${applySpecialTheme}
  ${applyDarkBackground}
  ${applyDarkBackgroundRight}
  ${applySideBySideSmallImageMobileOnly}
  ${applySideBySideDesktopOnly}
  ${applyProportions3366}
  ${applySideBySideMobileOnly}
  ${applyOffers}
  ${applyDense}
  ${applyBookmarks}
  ${applyVerticalRule}
  ${applyHighDensity}
  ${applySideBySideVerticalAlign}
  ${applyhasSideBySideMobileOnlyImageRight}
  ${applyContributor}
  ${applyContributorGridItem}
  ${applyBundle}
  ${applyImageonTop}
  ${applyMargin}
  ${applyPadding}
  ${applySqueezedItem}
  ${applyHeadingInline}
  ${applyDenseDesktopStack}
  ${applyDenseDesktopThirds}

  ${({ shouldUseFlexGrow }) => shouldUseFlexGrow &&
    `display: flex;
     flex-direction: column;`}

  &&& {
    ${({ isTextExternalLink }) => isTextExternalLink &&
    `
            &:hover,
            &:focus,
            &:visited {
              text-decoration: none;
              .summary-item__hed-link {
                text-decoration: none;
              }
          }
      `}
  }
`;
const SummaryItemContextualHeader = styled(BaseText).withConfig({
    displayName: 'SummaryItemContextualHeader'
}) `
  padding-bottom: 20px;
`;
SummaryItemContextualHeader.defaultProps = {
    as: 'div',
    colorToken: 'colors.discovery.body.white.description',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
const SummaryItemSignage = styled(SummaryItemDek).withConfig({
    displayName: 'SummaryItemSignage'
}) ``;
const SummaryItemStickyWrapper = styled.div.withConfig({
    displayName: 'SummaryItemStickyWrapper'
}) `
  position: sticky;
  /* override the top value in container components */
  top: 0;
`;
const SummaryItemShopLink = styled(BaseLink)
    .withConfig({
    displayName: 'SummaryItemShopLink'
})
    .attrs(({ theme }) => ({
    colorSecondaryLinkToken: resolveMenuKey(theme, 'colors.discovery.body.white.heading'),
    colorStaticLinkToken: resolveMenuKey(theme, 'colors.discovery.body.white.heading')
})) `
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-core')};
  text-transform: 'uppercase';
`;
SummaryItemDekReadMore.defaultProps = {
    as: 'a'
};
module.exports = {
    SummaryItemContent,
    SummaryItemDek,
    SummaryItemDekReadMore,
    SummaryItemHedLink,
    SummaryItemAuthorTitle,
    SummaryItemMetadataPrimary,
    SummaryItemMetadataSecondary,
    SummaryItemRubric,
    SummaryItemRubricSeparator,
    SummaryItemRubricWrapper,
    SummaryItemStickyWrapper,
    SummaryItemWrapper,
    SummaryItemAssetContainer,
    SummaryItemContributorName,
    SummaryItemContributorContent,
    SummaryItemVenueDetails,
    SummaryItemContextualHeader,
    SummaryItemSignage,
    SummaryItemNowShopping,
    SummaryItemShopLink
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 63902:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { SummaryItemActionWrapper, SummaryItemActionLabel, SummaryItemActionCtaLabel } = __webpack_require__(83762);
const Arrow = __webpack_require__(4262);
/**
 * SummaryItemAction component
 *
 * @param {object} props - React props
 * @param {string} [props.eventStatus] - status of event in summaryItemMetaData object
 * @param {string} [props.ctaLabel] - label on cta in summaryItemMetaData object
 * @returns {ReactElement} <label>
 */
const SummaryItemAction = ({ ctaLabel, eventStatus }) => {
    if (!eventStatus) {
        return null;
    }
    const buttonProps = {
        btnStyle: 'text',
        hasEnableIcon: true,
        label: ctaLabel,
        ButtonIcon: Arrow
    };
    return (React.createElement(SummaryItemActionWrapper, null,
        React.createElement(SummaryItemActionLabel, null, eventStatus),
        React.createElement(SummaryItemActionCtaLabel, { ...buttonProps })));
};
SummaryItemAction.propTypes = {
    ctaLabel: PropTypes.string,
    eventStatus: PropTypes.string
};
module.exports = SummaryItemAction;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 83762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const Button = __webpack_require__(73730);
const SummaryItemActionCtaLabel = styled(Button.Utility).withConfig({
    displayName: 'SummaryItemActionCtaLabel'
}) `
  justify-content: end;
  padding-right: ${calculateSpacing(1)};
  text-transform: capitalize;
  white-space: nowrap;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')}

  .button__icon-container {
    display: flex;
    flex: 0 0 auto;
    align-items: center;
    justify-content: center;
    margin-left: ${calculateSpacing(1)};
    border: 1px solid;
    border-radius: 100%;
    padding: 0;
    width: 2.25rem;
    height: 2.25rem;

    ${getColorStyles('border-color', 'colors.discovery.body.black.background')};

    ${getColorStyles('background-color', 'colors.interactive.base.brand-primary')};
    ${getColorStyles('border-color', 'colors.interactive.base.brand-primary')};

    svg {
      fill: white;
      width: unset;
      height: unset;
    }
  }
  ${getColorStyles('color', 'colors.discovery.body.black.background')};
`;
const SummaryItemActionWrapper = styled.div.withConfig({
    displayName: 'SummaryItemActionWrapper'
}) `
  display: grid;
  grid-template-columns: 3fr 3fr 0fr;
  align-items: center;
  margin-top: ${calculateSpacing(1.5)};
  border-top: 1px solid ${getColorToken('colors.discovery.body.white.border')};
  padding: ${calculateSpacing(1.5)} 0 ${calculateSpacing(1.5)} 0;

  @media (min-width: ${BREAKPOINTS.md}) {
    grid-template-columns: 3fr 6fr 0fr;
  }
`;
const SummaryItemActionLabel = styled.a.withConfig({
    displayName: 'SummaryItemActionLabel'
}) `
  grid-column: span 2;
  white-space: nowrap;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.assistive-text')};
  ${getColorStyles('color', 'colors.interactive.base.deemphasized')};
`;
module.exports = {
    SummaryItemActionCtaLabel,
    SummaryItemActionLabel,
    SummaryItemActionWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 56816:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const InlineVideoItem = __webpack_require__(29697);
const ResponsiveAsset = __webpack_require__(73275);
const { LAYOUT_PLACEMENTS } = __webpack_require__(28197);
const { hasFeatureVideo } = __webpack_require__(2953);
const SummaryItemImage = __webpack_require__(52413);
const { SummaryItemAssetInlineVideo } = __webpack_require__(88436);
const { inlineEmbedPosition } = __webpack_require__(62327);
/**
 * The asset (either video or image) for the summary item
 *
 * @param {object} props - React props
 * @param {string} [props.audioTagIconTitle] - Optional title for the headphone icon of the floating audio tag
 * @param {Array} [props.awards] - Optional awards array
 * @param {Function} [props.clickHandlerHed] - called when user clicks hed
 * @param {string} [props.contentType] - Optional prop to generate classname to target items by contentType
 * @param {bool} props.hasAsset - Whether to show the asset at all
 * @param {boolean} [props.hasNoBottomMarginForCneVideo] - whether to remove bottom-margin based on boolean value
 * @param {bool} [props.hasReviewTag] - Whether to display floating review icon or not
 * @param {bool} [props.hasAudioTag] - Whether to display floating icon or not
 * @param {bool} [props.hasImageCenteredButtonInCarousel] - Whether to display carousel control at center of the image
 * @param {bool} props.hasCircularImage - Whether to present the image as circular
 * @param {bool} props.hasRoundedEdges - Optional, whether to show rounded image edges
 * @param {boolean} [props.hasRel] - Optional. adds the rel= nofollow property if the content is syndicated.
 * @param {string} [props.iconPosition] - The position of the icon
 * @param {ResponsiveAsset.propTypes | InlineVideoItem.propTypes.image} [props.image] - Object containing sources for a
 *   ResponsiveAsset or Video
 * @param {boolean} [props.isLazy] - Optional if assets are to be lazy-loaded
 * @param {boolean} [props.isLive] - Optional flag indicating we should show the LIVE status. Default: FALSE.
 * @param {string} [props.layoutPlacement] - [`text-below`, `text-below-desktop-only`, `side-by-side`,
 *   `side-by-side-desktop-only`, `side-by-side-mobile-only`] Optional. Horizontal / Vertical placement of content.
 * @param {object} [props.metadataVideo] - Optional CNE video metadata
 * @param {Array} [props.multiImages] - Optional Object containing sources for a multiple ResponsiveAsset
 * @param {Function} [props.onVideoChange] - Optional function that gets called with video when video loads or changes.
 * @param {string} [props.playIconStyle] - Optional choice of 'dark', or 'cne' for play icon
 * @param {number} [props.recircId] - Optional recircId for Sparrow tracking
 * @param {string} [props.recircRiver] - Optional recirc river for Sparrow tracking
 * @param {bool} [props.shouldAssetHaveNoBottomMargin] - Optional prop to hide bottom margin
 * @param {boolean} [props.shouldAutoPlay] - Optional boolean to start playing video clip once component is rendered
 * @param {bool} [props.shouldDisplayPremiereDate] - Optional, used to display premiere date
 * @param {boolean} [props.shouldDisplaySignage] - Optional boolean to display signage, defaults to false
 * @param {boolean} [props.shouldHideIcon] - Should the icon be hidden?
 * @param {boolean} [props.shouldOpenUrlInNewTab] - Optional component config to open link in a new tab
 * @param {boolean} props.shouldPlayInline - Switch to enable inline video playback
 * @param {boolean} [props.shouldPlayVideoOnHover] - Optional flag to turn on Play on Hover behaviour for video clip
 * @param {boolean} [props.shouldHoldImageSpace] - Option to hold image space
 * @param {boolean} [props.shouldUseMediumBreakpoint] - Optional setting to enable medium breakpoint for image srcSet
 * @param {string} [props.signage] - Optional signage label to display on top of SummaryImage
 * @param {bool} [props.sparrowPattern] - Special sparrow pattern dimension that sends with event
 * @param {bool} [props.shouldEmbedCneVideo] - load cne video inline
 * @param {bool} [props.shouldDisplayVideoTime] - Optional, used to show/hide video play time, default is false
 * @param {string} props.url - Url path to the content
 * @param {string} [props.responsiveCartoonVariation] - Responsive Cartoon variation
 * @param {string} [props.signalType] - Specifying the icon to be displayed in the actionBar
 * @param {object} [props.actionBarConfig] - config for the actionBar
 * @param {boolean} [props.shouldHideCartoonCaption] - Optional hides the cartoon caption
 * @param {boolean} [props.shouldHideCartoonCredit] - Optional hides the cartoon credit
 *
 * @returns {ReactElement} React.Fragment - the asset
 */
const SummaryItemAsset = ({ audioTagIconTitle, awards, clickHandlerHed, contentType, hasAsset, hasAudioTag = false, hasImageCenteredButtonInCarousel, hasCircularImage = false, hasRoundedEdges = false, hasNoBottomMarginForCneVideo, hasReviewTag = false, hasRel = false, iconPosition, image, isLazy, isLive, layoutPlacement, metadataVideo, multiImages, onVideoChange = () => { }, playIconStyle, recircId, recircRiver, shouldAssetHaveNoBottomMargin, shouldAutoPlay, shouldDisplayPremiereDate, shouldDisplaySignage, shouldDisplayVideoTime, shouldHideIcon, shouldHoldImageSpace, shouldPlayInline, shouldPlayVideoOnHover, shouldUseMediumBreakpoint, signage, shouldEmbedCneVideo = false, sparrowPattern, url, shouldOpenUrlInNewTab, responsiveCartoonVariation, signalType, actionBarConfig, shouldHideCartoonCaption, shouldHideCartoonCredit }) => (React.createElement(React.Fragment, null,
    hasAsset && image && !hasFeatureVideo(image) && !shouldEmbedCneVideo && (React.createElement(SummaryItemImage, { audioTagIconTitle: audioTagIconTitle, awards: awards, clickHandlerHed: clickHandlerHed, contentType: contentType, hasAudioTag: hasAudioTag, hasReviewTag: hasReviewTag, hasRel: hasRel, hasCircularImage: hasCircularImage, hasImageCenteredButtonInCarousel: hasImageCenteredButtonInCarousel, hasRoundedEdges: hasRoundedEdges, iconPosition: iconPosition, image: image, isLazy: isLazy, isLive: isLive, layoutPlacement: layoutPlacement, metadataVideo: metadataVideo, multiImages: multiImages, playIconStyle: playIconStyle, recircId: recircId, recircRiver: recircRiver, shouldAutoPlay: shouldAutoPlay, shouldDisplayPremiereDate: shouldDisplayPremiereDate, shouldDisplaySignage: shouldDisplaySignage, shouldDisplayVideoTime: shouldDisplayVideoTime, shouldAssetHaveNoBottomMargin: shouldAssetHaveNoBottomMargin, shouldHideIcon: shouldHideIcon, shouldHoldImageSpace: shouldHoldImageSpace, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, shouldPlayVideoOnHover: shouldPlayVideoOnHover, signage: signage, sparrowPattern: sparrowPattern, url: url, shouldOpenUrlInNewTab: shouldOpenUrlInNewTab, responsiveCartoonVariation: responsiveCartoonVariation, signalType: signalType, actionBarConfig: actionBarConfig, shouldHideCartoonCaption: shouldHideCartoonCaption, shouldHideCartoonCredit: shouldHideCartoonCredit })),
    ((hasAsset && hasFeatureVideo(image)) || shouldEmbedCneVideo) && (React.createElement(SummaryItemAssetInlineVideo, { className: classnames('summary-item__inline-video', {
            'inline-cne-video': shouldEmbedCneVideo
        }), ...image, hasNoBottomMarginForCneVideo: hasNoBottomMarginForCneVideo, shouldEmbedCneVideo: shouldEmbedCneVideo, shouldPlayInline: shouldPlayInline, shouldAutoPlay: shouldAutoPlay, dangerousHed: null, onVideoChange: onVideoChange, playIconStyle: playIconStyle, publishDate: null, scriptUrl: image.scriptUrl, url: image.url ? image.url : image.scriptUrl, videoEmbedPosition: inlineEmbedPosition }))));
SummaryItemAsset.propTypes = {
    actionBarConfig: PropTypes.object,
    audioTagIconTitle: PropTypes.string,
    awards: PropTypes.array,
    clickHandlerHed: PropTypes.func,
    contentType: PropTypes.string,
    hasAsset: PropTypes.bool.isRequired,
    hasAudioTag: PropTypes.bool,
    hasCircularImage: PropTypes.bool,
    hasImageCenteredButtonInCarousel: PropTypes.bool,
    hasNoBottomMarginForCneVideo: PropTypes.bool,
    hasRel: PropTypes.bool,
    hasReviewTag: PropTypes.bool,
    hasRoundedEdges: PropTypes.bool,
    iconPosition: PropTypes.oneOf(['right', 'left']),
    image: PropTypes.oneOfType([
        PropTypes.shape(ResponsiveAsset.propTypes),
        PropTypes.shape(InlineVideoItem.propTypes)
    ]),
    isLazy: PropTypes.bool,
    isLive: PropTypes.bool,
    layoutPlacement: PropTypes.oneOf(LAYOUT_PLACEMENTS).isRequired,
    metadataVideo: PropTypes.shape({
        isLive: PropTypes.bool,
        premiereDate: PropTypes.string,
        series: PropTypes.string,
        videoLength: PropTypes.number,
        premiereGap: PropTypes.number
    }),
    multiImages: PropTypes.array,
    onVideoChange: PropTypes.func,
    playIconStyle: PropTypes.oneOf(['dark', 'white', 'cne']),
    recircId: PropTypes.number,
    recircRiver: PropTypes.string,
    responsiveCartoonVariation: PropTypes.string,
    shouldAssetHaveNoBottomMargin: PropTypes.bool,
    shouldAutoPlay: PropTypes.bool,
    shouldDisplayPremiereDate: PropTypes.bool,
    shouldDisplaySignage: PropTypes.bool,
    shouldDisplayVideoTime: PropTypes.bool,
    shouldEmbedCneVideo: PropTypes.bool,
    shouldHideCartoonCaption: PropTypes.bool,
    shouldHideCartoonCredit: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldOpenUrlInNewTab: PropTypes.bool,
    shouldPlayInline: PropTypes.bool,
    shouldPlayVideoOnHover: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    signage: PropTypes.string,
    signalType: PropTypes.string,
    sparrowPattern: PropTypes.string,
    url: PropTypes.string.isRequired
};
module.exports = SummaryItemAsset;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, minScreen } = __webpack_require__(26865);
const { InlineVideoItemCNEVideoEmbed, InlineVideoItemImageLink } = __webpack_require__(41803);
const InlineVideoItem = __webpack_require__(29697);
const SummaryItemAssetInlineVideo = styled(InlineVideoItem).withConfig({
    displayName: 'SummaryItemAssetInlineVideo'
}) `
  margin-bottom: ${calculateSpacing(3)};
  border-bottom: 0;
  padding-bottom: 0;

  ${InlineVideoItemCNEVideoEmbed},
  ${InlineVideoItemImageLink} {
    margin-bottom: 0;
  }

  ${({ shouldEmbedCneVideo }) => (shouldEmbedCneVideo ? 'margin: 0;' : '')}

  ${minScreen(BREAKPOINTS.md)} {
    ${({ shouldEmbedCneVideo, hasNoBottomMarginForCneVideo }) => {
    if (hasNoBottomMarginForCneVideo) {
        return css `
          margin-bottom: 0;
        `;
    }
    else if (shouldEmbedCneVideo) {
        return '';
    }
    return css `
        margin-bottom: ${calculateSpacing(5)};
      `;
}}
  }
`;
module.exports = { SummaryItemAssetInlineVideo };
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 75590:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { SummaryItemBusinessCategoryWrapper, SummaryItemBusinessCategoryList, SummaryItemBusinessCategoryListItem } = __webpack_require__(13626);
/**
 *
 * The Offers component for the summary item
 *
 * @param {object} props - React props
 * @param {object} [props.business] - Optional array of offer
 * @returns {ReactElement} SummaryItemBusinessCategory
 *
 */
const SummaryItemBusinessCategory = ({ business }) => {
    const { category, profession } = business;
    const businessHierarchy = [];
    if (category?.name && category.name !== '')
        businessHierarchy.push(category);
    if (profession?.name && profession.name !== '')
        businessHierarchy.push(profession);
    return businessHierarchy?.length > 0 ? (React.createElement(SummaryItemBusinessCategoryWrapper, null,
        React.createElement(SummaryItemBusinessCategoryList, null, Object.keys(businessHierarchy).map((key) => (React.createElement(SummaryItemBusinessCategoryListItem, { key: key }, businessHierarchy[key].name)))))) : null;
};
SummaryItemBusinessCategory.propTypes = {
    business: PropTypes.object
};
module.exports = SummaryItemBusinessCategory;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 13626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getTypographyStyles } = __webpack_require__(26865);
const SummaryItemBusinessCategoryWrapper = styled.div.withConfig({
    displayName: 'SummaryItemBusinessCategoryWrapper'
}) `
  display: flex;
  flex-wrap: wrap;
  align-items: baseline;
  margin-top: ${calculateSpacing(0.5)};
  margin-bottom: ${calculateSpacing(2.4)};
`;
const SummaryItemBusinessCategoryList = styled.ul.withConfig({
    displayName: 'SummaryItemBusinessCategoryList'
}) `
  margin: 0;
  padding: 0;
  line-height: 1;
`;
const SummaryItemBusinessCategoryListItem = styled.li.withConfig({
    displayName: 'SummaryItemBusinessCategoryListItem'
}) `
  display: inline-block;

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.numerical-small')};

  &:not(:last-child) {
    &::after {
      margin: 0 ${calculateSpacing(1)};
      color: ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.inverted.divider')};
      content: '|';
    }
  }
`;
module.exports = {
    SummaryItemBusinessCategoryWrapper,
    SummaryItemBusinessCategoryList,
    SummaryItemBusinessCategoryListItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 64273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const remove = __webpack_require__(14174);
const PropTypes = __webpack_require__(5556);
const { SummaryItemBusinessLocationWrapper, SummaryItemBusinessLocationList, CategoriesSummaryItemBusinessLocationListItem } = __webpack_require__(34075);
/**
 *
 * The Offers component for the summary item
 *
 * @param {object} props - React props
 * @param {object} [props.business] - Optional array of offer
 * @returns {ReactElement} SummaryItemBusinessLocation
 *
 */
const SummaryItemBusinessLocation = ({ business }) => {
    const { address } = business;
    const locations = Object.values(address).map((location) => location);
    remove(locations, (val) => val === '');
    return locations?.length > 0 ? (React.createElement(SummaryItemBusinessLocationWrapper, null,
        React.createElement(SummaryItemBusinessLocationList, null, locations.map((location) => (React.createElement(CategoriesSummaryItemBusinessLocationListItem, { key: location }, location)))))) : null;
};
SummaryItemBusinessLocation.propTypes = {
    business: PropTypes.object
};
module.exports = SummaryItemBusinessLocation;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 34075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getTypographyStyles } = __webpack_require__(26865);
const SummaryItemBusinessLocationWrapper = styled.div.withConfig({
    displayName: 'SummaryItemBusinessLocationWrapper'
}) `
  display: flex;
  flex-wrap: wrap;
  align-items: baseline;
  margin-top: ${calculateSpacing(0.5)};
  margin-bottom: ${calculateSpacing(0.5)};
`;
const SummaryItemBusinessLocationList = styled.ul.withConfig({
    displayName: 'SummaryItemBusinessLocationList'
}) `
  margin: 0;
  padding: 0;
  line-height: 1;
`;
const CategoriesSummaryItemBusinessLocationListItem = styled.li.withConfig({
    displayName: 'CategoriesSummaryItemBusinessLocationListItem'
}) `
  display: inline-block;

  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};

  &:not(:last-child) {
    &::after {
      margin: 0 ${calculateSpacing(1)};
      color: ${({ theme }) => getColorToken(theme, 'colors.consumption.lead.inverted.divider')};
      content: '|';
    }
  }
`;
module.exports = {
    SummaryItemBusinessLocationWrapper,
    SummaryItemBusinessLocationList,
    CategoriesSummaryItemBusinessLocationListItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 56883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const { googleAnalytics } = __webpack_require__(90090);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const { SummaryItemBusinessProfileButtonWrapper } = __webpack_require__(9789);
/**
 *
 * The Offers component for the summary item
 *
 * @param {object} props - React props
 * @param {object} [props.business] - Optional array of offer
 * @returns {ReactElement} SummaryItemBusinessProfileButton
 *
 */
const SummaryItemBusinessProfileButton = ({ business }) => {
    const { formatMessage } = useIntl();
    const onClickHandler = () => {
        googleAnalytics.emitGoogleTrackingEvent('summary-item-business-profile-button-click');
    };
    return business?.profileURL ? (React.createElement(SummaryItemBusinessProfileButtonWrapper, { btnStyle: "outlined", label: formatMessage(translations.BusinessProfileCTAText), dataAttrs: {
            'data-component-position': 'summary-item'
        }, defaultCTAText: formatMessage(translations.BusinessProfileCTAText), onClickHandler: onClickHandler, showOffersSeller: false })) : null;
};
SummaryItemBusinessProfileButton.propTypes = {
    business: PropTypes.object
};
module.exports = SummaryItemBusinessProfileButton;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing } = __webpack_require__(26865);
const { ButtonWrapper } = __webpack_require__(18974);
const Button = __webpack_require__(73730);
const SummaryItemBusinessProfileButtonWrapper = styled(Button.Utility).withConfig({
    displayName: 'SummaryItemBusinessProfileButtonWrapper'
}) `
  margin-top: ${calculateSpacing(2.4)};

  ${ButtonWrapper} {
    width: 100%;
    max-width: ${calculateSpacing(4.3)};
  }
`;
module.exports = {
    SummaryItemBusinessProfileButtonWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 17035:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const Breakpoints = __webpack_require__(99906);
const Viewport = __webpack_require__(52089);
const BookmarkActivatedThinIcon = __webpack_require__(52585);
const BookmarkActivatedThinIconnerIcon = __webpack_require__(64736);
const Button = __webpack_require__(73730);
const Bylines = __webpack_require__(52540);
const { SummaryItemBaseByline, SummaryItemByLineDekRewards, SummaryItemBylinePublishDate, SummaryItemBylineWrapper, SummaryItemBylineButtonWrapper } = __webpack_require__(277);
/**
 * The byline component for the summary item
 *
 * @param {string} [props.bylineVariation] - Optional variation of byline
 * @param {string} [props.className] - Optional top-level class to add to byline
 * @param {string} [props.contentAlign] - Alignment of bylines within SummaryItem
 * @param {object} [props.contributors] - Optional object containing data to create contributors bylines.
 * @param {Function} [props.clickHandlerContributors] - called when user clicks author
 * @param  {string} [props.dateValue] - the value for the date
 * @param {Function} [props.iconButtonOnclickHandler] - called when user clicks on bookmark icon
 * @param {Function} [props.iconType] - Option value for which icon family to use
 * @param {bool} [props.isVenueCardItemContainer] - Option value setting new venueCard specific padding
 * @param {number} [props.maxContributors] - Maximum number of contributors to show
 * @param {number} [props.maxContributorsNames] - Optional maximum number of contributors names of a single type to be
 *   displayed
 * @param {bool} [props.hasBookmarks] - Optional. Set to `true` for bookmark item display
 * @param {bool} [props.hideBylinesUntil] - Option to show/hide bylines until specific breakpoints
 * @param {bool} [props.shouldHideBookmarkIcon] - Optional flag to hide bookmark icon
 * @param {bool} [props.shouldHideBylines] - Optional boolean to hide bylines
 * @param {bool} [props.shouldHidePublishDate] - Optional boolean to hide publish date
 * @param {bool} [props.shouldMoveBylineToBottom] - Optional boolean to move bylines to bottom
 * @param {bool} [props.showCommaAsideContributorName] - optional flag to override exisitng comma(,) with custom logic
 *   to fix visual bug with long author name. see #8939 for details - defaults to false
 * @param {string} [props.venueAwards] - Optional. used to show venue awards
 * @param {string} [props.summaryItemVariation] - Optional prop to control summary item variation
 * @returns {ReactElement|null} <div>
 */
const SummaryItemByline = ({ bylineVariation, className, clickHandlerContributors, contentAlign = 'left', contributors, dateValue, hideBylinesUntil = 'sm', iconButtonOnclickHandler, iconType, isBeforeDek = false, isVenueCardItemContainer = false, maxContributors, maxContributorsNames, shouldHideBookmarkIcon, shouldHideBylines, shouldHideContributors = false, shouldHidePublishDate, shouldLink, shouldMoveBylineToBottom, showCommaAsideContributorName, hasBookmarks, venueAwards, shouldUseGridStyles }) => {
    if (shouldHideBylines) {
        return null;
    }
    const iconFamily = iconType === 'thin'
        ? BookmarkActivatedThinIcon
        : BookmarkActivatedThinIconnerIcon;
    const bylineBlocks = [];
    const hasContributors = contributors && Object.keys(contributors).length > 0;
    if (hasContributors && !shouldHideContributors) {
        bylineBlocks.push(React.createElement(SummaryItemBaseByline, { className: "summary-item__byline", key: "authors" },
            React.createElement("div", { className: "summary-item__byline__content" },
                React.createElement(Bylines, { contentAlign: contentAlign, bylineVariation: bylineVariation, clickHandler: clickHandlerContributors, contributors: contributors, maxContributors: maxContributors, maxContributorsNames: maxContributorsNames, shouldLink: shouldLink, showCommaAsideContributorName: showCommaAsideContributorName }))));
    }
    if (venueAwards) {
        bylineBlocks.push(React.createElement(SummaryItemByLineDekRewards, { className: "summary-item__dek-rewards", key: "venue-awards", dangerouslySetInnerHTML: { __html: venueAwards } }));
    }
    if (dateValue && !shouldHidePublishDate) {
        bylineBlocks.push(React.createElement(SummaryItemBylinePublishDate, { className: "summary-item__publish-date", key: "date" }, dateValue));
    }
    if (!shouldHideBookmarkIcon) {
        bylineBlocks.push(React.createElement(SummaryItemBylineButtonWrapper, { key: "bookmark", shouldUseGridStyles: shouldUseGridStyles },
            React.createElement(Button.Utility, { className: `summary-item__button-icon--${iconType}`, ButtonIcon: iconFamily, label: "icon", isIconButton: true, onClickHandler: iconButtonOnclickHandler })));
    }
    return (React.createElement(Viewport, { min: hideBylinesUntil }, (matches) => matches &&
        bylineBlocks.length > 0 && (React.createElement(SummaryItemBylineWrapper, { className: classnames('summary-item__byline-date-icon', { 'summary-item__byline-date-icon--no-author': !hasContributors }, className), isBeforeDek: isBeforeDek, hasBookmarks: hasBookmarks, shouldUseGridStyles: shouldUseGridStyles, isVenueCardItemContainer: isVenueCardItemContainer, shouldMoveBylineToBottom: shouldMoveBylineToBottom }, bylineBlocks))));
};
SummaryItemByline.propTypes = {
    bylineVariation: PropTypes.string,
    className: PropTypes.string,
    clickHandlerContributors: PropTypes.func,
    contentAlign: Bylines.propTypes.contentAlign,
    contributors: PropTypes.object,
    dateValue: PropTypes.string,
    hasBookmarks: PropTypes.bool,
    hideBylinesUntil: PropTypes.oneOf(Breakpoints.sizes),
    iconButtonOnclickHandler: PropTypes.func,
    iconType: PropTypes.oneOf(['thin', 'thinner', 'standard']),
    isBeforeDek: PropTypes.bool,
    isVenueCardItemContainer: PropTypes.bool,
    maxContributors: PropTypes.number,
    maxContributorsNames: PropTypes.number,
    shouldHideBookmarkIcon: PropTypes.bool,
    shouldHideBylines: PropTypes.bool,
    shouldHideContributors: PropTypes.bool,
    shouldHidePublishDate: PropTypes.bool,
    shouldLink: PropTypes.bool,
    shouldMoveBylineToBottom: PropTypes.bool,
    shouldUseGridStyles: PropTypes.bool,
    showCommaAsideContributorName: PropTypes.bool,
    venueAwards: PropTypes.string
};
module.exports = SummaryItemByline;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { ButtonWrapper } = __webpack_require__(18974);
const { calculateSpacing, minMaxScreen, minScreen, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(18730);
const { BREAKPOINTS } = __webpack_require__(96472);
const applySponsoredStyles = ({ isSponsored, isSponsoredByline, theme, isSponsoredInverted }) => {
    let marginBottom = 0;
    let colorToken = null;
    let display = null;
    if (isSponsoredByline) {
        marginBottom = 1;
        colorToken = 'colors.consumption.lead.special.context-signature';
    }
    if (isSponsored) {
        marginBottom = 2;
        colorToken = 'colors.discovery.body.white.context-signature';
    }
    if (isSponsoredInverted) {
        marginBottom = 2;
        display = 'block';
        colorToken = 'colors.consumption.body.inverted.accent';
    }
    if (isSponsoredByline || isSponsored) {
        return `
      ${display ? `display: ${display};` : ''}
      ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')}
      ${getColorStyles(theme, 'color', colorToken)};
      margin-bottom: ${calculateSpacing(marginBottom)};

      .byline,
      .byline__preamble,
      .byline__name,
      .byline__social-link {
        ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')}
        ${getColorStyles(theme, 'color', colorToken)};
      }
    `;
    }
    return '';
};
const SummaryItemBaseByline = styled.div.withConfig({
    displayName: 'SummaryItemBaseByline'
}) `
  margin-bottom: ${calculateSpacing(0.5)};

  .byline,
  .byline__preamble,
  .byline__name,
  .byline__social-link {
    ${getTypographyStyles('typography.definitions.globalEditorial.accreditation-core')};
  }

  .summary-item--bundle-endorsement & {
    .bylines__byline {
      span {
        ${getColorStyles('color', 'colors.discovery.body.white.accreditation')};
      }
    }
  }

  .bylines__byline {
    text-align: left;
  }

  ${applySponsoredStyles}
`;
const SummaryItemBylineEventDate = styled(BaseText).withConfig({
    displayName: 'SummaryItemBylineEventDate'
}) `
  display: block;
  align-self: center;
`;
SummaryItemBylineEventDate.defaultProps = {
    as: 'time',
    colorToken: 'colors.discovery.body.white.context-tertiary',
    typeIdentity: 'typography.definitions.globalEditorial.context-tertiary'
};
const SummaryItemBylinePublishDate = styled(BaseText).withConfig({
    displayName: 'SummaryItemBylinePublishDate'
}) `
  display: block;
  align-self: center;
`;
SummaryItemBylinePublishDate.defaultProps = {
    as: 'time',
    colorToken: 'colors.discovery.body.white.context-tertiary',
    typeIdentity: 'typography.definitions.globalEditorial.context-tertiary'
};
const SummaryItemBylineWrapper = styled.div.withConfig({
    displayName: 'SummaryItemBylineWrapper'
}) `
  ${({ isBeforeDek }) => isBeforeDek ? `margin: ${calculateSpacing(2)} 0;` : ''}
  ${({ hasBookmarks, shouldUseGridStyles, theme }) => hasBookmarks &&
    `
        position: relative;
        ${minScreen(BREAKPOINTS.md)} {
          align-items: baseline;

          ${!shouldUseGridStyles
        ? `
              &:not(.summary-item__byline-date-icon--no-author) {
                .summary-item__publish-date {
                  padding-top: ${calculateSpacing(0.5)};
                }
              }
              `
        : `
                display: grid;
                grid-template-columns: auto auto 2fr;
                
                &.summary-item__byline-date-icon--no-author {
                  grid-template-columns: auto 2fr;
                }

                &:not(.summary-item__byline-date-icon--no-author) {
                  .summary-item__publish-date {
                    padding-left: ${calculateSpacing(1)};
                  }
                }
              `}
          }

        ${SummaryItemBaseByline}{
            ${minScreen(BREAKPOINTS.lg)} {
              margin-bottom: 0;
            }
        }

        .icon-bookmark--activated-outline {
          ${getColorStyles(theme, 'fill', 'colors.interactive.base.brand-primary')};
        }

        .icon-bookmark--activated-checkmark-stroke {
          ${getColorStyles(theme, 'stroke', 'colors.interactive.base.white')};
        }

        .icon-bookmark--activated-checkmark {
          ${getColorStyles(theme, 'stroke', 'colors.interactive.base.black')};
        }

        .summary-item__button-icon--thin {
          stroke-width: 0;
          .icon {
            transform: scale(2);
          }
        }

        ${!shouldUseGridStyles
        ? `
          .summary-item__button-icon--thinner {
            stroke-width: 0;
            .icon {
              padding-left: 4px;
              width: ${calculateSpacing(3)};
              height: ${calculateSpacing(3)};
            }
          }
          `
        : `
            ${SummaryItemBylinePublishDate} {
              display: inline-block;
              align-self: unset;
              margin-bottom: 0;
              vertical-align: text-top;
            }
          `}
      `}
  ${({ shouldMoveBylineToBottom }) => shouldMoveBylineToBottom && `margin-top:auto;`}
`;
const SummaryItemBylineButtonWrapper = styled.div.withConfig({
    displayName: 'SummaryItemBylineButtonWrapper'
}) `
  align-self: center;
  margin-left: auto;
  padding: 0;

  ${({ shouldUseGridStyles }) => !shouldUseGridStyles &&
    `
    position: absolute; 
    right: 0px;
    bottom: 0px;
    `}

  ${minMaxScreen(0, BREAKPOINTS.lg)} {
    float: right;
  }

  ${minScreen(BREAKPOINTS.lg)} {
    display: inline-block;
    text-align: right;
  }

  ${ButtonWrapper},
  .button--icon-only {
    padding: 0;

    ${minScreen(BREAKPOINTS.lg)} {
      float: right;
    }
  }
`;
const SummaryItemByLineDekRewards = styled(BaseText).withConfig({
    displayName: 'SummaryItemByLineDekRewards'
}) `
  > img {
    margin-top: ${calculateSpacing(0.5)};
    margin-right: ${calculateSpacing(0.8)};

    &:first-of-type {
      margin-top: 0;
    }

    &:nth-of-type(3) {
      margin-left: ${calculateSpacing(0.8)};
    }
  }
  margin: 0 0 ${calculateSpacing(3)} 0;
`;
SummaryItemByLineDekRewards.defaultProps = {
    as: 'div',
    colorToken: 'colors.consumption.lead.standard.heading',
    typeIdentity: 'typography.definitions.globalEditorial.context-primary'
};
module.exports = {
    SummaryItemBaseByline,
    SummaryItemByLineDekRewards,
    SummaryItemBylineEventDate,
    SummaryItemBylinePublishDate,
    SummaryItemBylineWrapper,
    SummaryItemBylineButtonWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 99672:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { SummaryItemCTACardWrapper } = __webpack_require__(88828);
const SummaryItemCTACard = ({ children, shouldUseFullWidthMobileOnly = false, clickHandlerCta }) => {
    return (React.createElement(SummaryItemCTACardWrapper, { label: children, inputKind: "text", isDisabled: true, btnStyle: "filled", shouldUseFullWidthMobileOnly: shouldUseFullWidthMobileOnly, onClickHandler: clickHandlerCta }));
};
SummaryItemCTACard.propTypes = {
    children: PropTypes.node.isRequired,
    clickHandlerCta: PropTypes.func,
    shouldUseFullWidthMobileOnly: PropTypes.bool
};
module.exports = SummaryItemCTACard;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles, maxScreen } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const Button = __webpack_require__(73730);
const SummaryItemCTACardWrapper = styled(Button.UtilityInverted).withConfig({
    displayName: 'SummaryItemCTACard'
}) `
  align-items: center;
  margin-top: ${calculateSpacing(0.5)};
  border: 2px solid black;
  padding: 9px 9px;
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.utility.button-utility')};
  ${({ shouldUseFullWidthMobileOnly }) => shouldUseFullWidthMobileOnly &&
    `${maxScreen(`calc(${BREAKPOINTS.md} - 1px)`)} {
      width: 100%;
    }
  `}
`;
module.exports = {
    SummaryItemCTACardWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 67709:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const { SummaryItemCTAPodcastStartListeningNow, SummaryItemCTAPodcastWrapper, SummaryItemCTAPodcastMoreInfo } = __webpack_require__(30854);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const SummaryItemCTAPodcast = ({ hasPrimaryCTA, hasSecondaryCTA, primaryCta, secondaryCta, primaryCTALabel, secondaryCTALabel }) => {
    const { formatMessage } = useIntl();
    return (React.createElement(SummaryItemCTAPodcastWrapper, null,
        hasPrimaryCTA && primaryCta && (React.createElement(SummaryItemCTAPodcastStartListeningNow, { label: primaryCTALabel ||
                formatMessage(translations.StartListeningNowPodcastCTA), inputKind: "link", buttonVariation: "Primary", btnStyle: "filled", href: primaryCta })),
        hasSecondaryCTA && secondaryCta && (React.createElement(SummaryItemCTAPodcastMoreInfo, { label: secondaryCTALabel ||
                formatMessage(translations.MoreInfoAndEpisodesPodcastCTA), inputKind: "link", buttonVariation: "Primary", btnStyle: "outlined", href: secondaryCta }))));
};
SummaryItemCTAPodcast.propTypes = {
    hasPrimaryCTA: PropTypes.bool,
    hasSecondaryCTA: PropTypes.bool,
    primaryCta: PropTypes.string,
    primaryCTALabel: PropTypes.string,
    secondaryCta: PropTypes.string,
    secondaryCTALabel: PropTypes.string
};
module.exports = SummaryItemCTAPodcast;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 30854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing } = __webpack_require__(26865);
const Button = __webpack_require__(73730);
const SummaryItemCTAPodcastStartListeningNow = styled(Button.Primary).withConfig({
    displayName: 'SummaryItemCTAPodcastStartListeningNow'
}) `
  display: block;
  margin-top: 0.5rem;
  margin-bottom: ${calculateSpacing(2.4)};
  padding: 15px 9px;
  max-width: 100%;
  height: unset;
  text-align: center;

  &:active::before {
    top: 0;
    left: 0;
  }
`;
const SummaryItemCTAPodcastMoreInfo = styled(Button.Primary).withConfig({
    displayName: 'SummaryItemCTAPodcastMoreInfo'
}) `
  display: block;
  margin-top: 0.5rem;
  margin-bottom: ${calculateSpacing(2.4)};
  padding: 15px 9px;
  max-width: 100%;
  height: unset;
  text-align: center;

  &:active::before {
    top: 0;
    left: 0;
  }
`;
const SummaryItemCTAPodcastWrapper = styled.div.withConfig({
    displayName: 'SummaryItemCTAPodcastWrapper'
}) `
  margin-top: 1rem;
`;
module.exports = {
    SummaryItemCTAPodcastStartListeningNow,
    SummaryItemCTAPodcastWrapper,
    SummaryItemCTAPodcastMoreInfo
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 79993:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { SummaryItemContributorNameWrapper, SummaryItemContributorHedName, SummaryItemContributorDetail } = __webpack_require__(86723);
/**
 * The hed author name wrapper
 *
 * @param {string} props.contributorName - Optional Name of the author
 * @param {string} [props.contributorDetail] - Optional. contributor detail.
 * @param {boolean} [props.showContributorDetail] - Optional flag to feature detail
 * @param {boolean} [props.shouldUseRubricAsRole] - Optional flag to change color token
 * @returns {ReactElement} <HedTag>
 */
const SummaryItemContributor = ({ contributorName, contributorDetail, showContributorDetail, shouldUseRubricAsRole = false }) => {
    if (!contributorName) {
        return null;
    }
    if (showContributorDetail) {
        return (React.createElement(React.Fragment, null,
            React.createElement(SummaryItemContributorHedName, { "data-testid": "SummaryItemContributorHedName", shouldUseRubricAsRole: shouldUseRubricAsRole }, contributorName),
            React.createElement(SummaryItemContributorDetail, { "data-testid": "SummaryItemContributor-contributor-detail", dangerouslySetInnerHTML: { __html: contributorDetail } })));
    }
    return (React.createElement(SummaryItemContributorNameWrapper, { "data-testid": "SummaryItemContributor-name", shouldUseRubricAsRole: shouldUseRubricAsRole }, contributorName));
};
SummaryItemContributor.propTypes = {
    contributorDetail: PropTypes.string,
    contributorName: PropTypes.string,
    shouldUseRubricAsRole: PropTypes.bool,
    showContributorDetail: PropTypes.bool
};
module.exports = SummaryItemContributor;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 86723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { calculateSpacing, getTypographyStyles } = __webpack_require__(26865);
const SummaryItemContributorNameWrapper = styled.div.withConfig({
    displayName: 'SummaryItemContributorNameWrapper'
}) `
  ${({ shouldUseRubricAsRole }) => shouldUseRubricAsRole
    ? css `
          ${getTypographyStyles('typography.definitions.discovery.hed-bulletin-primary')}
        `
    : css `
          ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
        `}

  margin-bottom: ${calculateSpacing(0.5)};
`;
const SummaryItemContributorHedName = styled.div.withConfig({
    displayName: 'SummaryItemContributorHedName'
}) `
  ${({ shouldUseRubricAsRole }) => shouldUseRubricAsRole
    ? css `
          ${getTypographyStyles('typography.definitions.discovery.hed-bulletin-primary')}
        `
    : css `
          ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
        `}
  margin-bottom: ${calculateSpacing(0.5)};
  font-size: 17px;
  font-weight: 700;
`;
const SummaryItemContributorDetail = styled.div.withConfig({
    displayName: 'SummaryItemContributorDetail'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
  margin-bottom: ${calculateSpacing(0.5)};
  font-size: 17px;
  font-weight: 200;
`;
module.exports = {
    SummaryItemContributorNameWrapper,
    SummaryItemContributorHedName,
    SummaryItemContributorDetail
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 60572:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { SummaryItemEventInfoItem, SummaryItemEventInfoWrapper } = __webpack_require__(49592);
/**
 * The event info component for the summary item
 *
 * @param {string} [props.eventDate] - Optional event date
 * @param {string} [props.eventLocation] - Optional event location (venue location)
 * @returns {ReactElement|null} <div>
 */
const SummaryItemEventInfo = ({ eventDate, eventLocation }) => {
    return (React.createElement(SummaryItemEventInfoWrapper, null,
        eventLocation && (React.createElement(SummaryItemEventInfoItem, null, eventLocation)),
        eventDate && (React.createElement(SummaryItemEventInfoItem, { as: "time" }, eventDate))));
};
SummaryItemEventInfo.propTypes = {
    eventDate: PropTypes.string,
    eventLocation: PropTypes.string
};
module.exports = SummaryItemEventInfo;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 49592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BaseText } = __webpack_require__(18730);
const { calculateSpacing } = __webpack_require__(26865);
const SummaryItemEventInfoItem = styled(BaseText).withConfig({
    displayName: 'SummaryItemEventInfoItem'
}) `
  display: inline;

  & + &::before {
    padding: 0 ${calculateSpacing(1)};
    content: '';
  }
`;
SummaryItemEventInfoItem.defaultProps = {
    as: 'span',
    colorToken: 'colors.consumption.body.standard.body',
    typeIdentity: 'typography.definitions.consumptionEditorial.description-embed'
};
const SummaryItemEventInfoWrapper = styled.div.withConfig({
    displayName: 'SummaryItemEventInfoWrapper'
}) ``;
module.exports = {
    SummaryItemEventInfoItem,
    SummaryItemEventInfoWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 44553:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const Clamp = __webpack_require__(48286);
const { LAYOUT_PLACEMENTS, LAYOUT_PROPORTIONS } = __webpack_require__(28197);
const { SummaryItemHedBase, SummaryItemHedTag } = __webpack_require__(36211);
/**
 * The hed with optional clamping
 *
 * @param {string} props.dangerousHed - The dangerous hed
 * @param {boolean} [props.hasTighterVerticalSpacing] - Optional. has tighter spacing for reduced white space
 * @param {boolean} [props.hasFixedMarginBottom] - Optional. used to give fixed margin bottom across screen sizes
 * @param {boolean} [props.hasNoHedTagMargin] - Optional flag, to avoid default H tag margin
 * @param {boolean} [props.hasNoHedTagMarginTop] - Optional flag, to avoid default hed tag margin top
 * @param {string} props.HedTag - The component to use
 * @param {number} [props.maxHedLines] - maximum lines in the hed
 * @param {bool} [props.shouldUseFeaturedFontWeight] - optional flag for font weight
 * @param {boolean} [props.shouldUseSmallHed] - Optional flag to use a smaller font size for the hed
 * @param {boolean} [props.isHighDensity] - [`bool`] Optional. Set to `true` to render just the headline on
 * @param {string} [props.breakpoint] - Optional string to set maximum screen breakpoint truncation can be executed
 * @param {boolean} [props.isVenueCardItemContainer] - bool to set the venueCard specific design
 * @param {boolean} [props.hasDefaultSpacingMarginBottom] - optional. bool to set the margin bottom to default value
 * @returns {ReactElement} <HedTag>
 */
const SummaryItemHed = ({ breakpoint, dangerousHed, HedTag, hasDefaultSpacingMarginBottom, hasTighterVerticalSpacing, hasFixedMarginBottom, layoutPlacement, layoutProportions, maxHedLines, hasHedCorePrimary, hasNoHedTagMargin, hasNoHedTagMarginTop, shouldUseFeaturedFontWeight, shouldUseSmallHed, isHighDensity, isVenueCardItemContainer, isTextExternalLink }) => {
    const shouldClamp = maxHedLines > 0 && maxHedLines < Infinity;
    const shouldRenderSummaryItemHed = !shouldClamp && !hasHedCorePrimary;
    const HedComponent = shouldRenderSummaryItemHed
        ? SummaryItemHedBase
        : SummaryItemHedTag;
    const hed = (React.createElement(HedComponent, { as: HedTag, className: classnames({
            'summary-item__hed': shouldRenderSummaryItemHed,
            'summary-item__hed--hed-core-primary': hasHedCorePrimary,
            'summary-item__hed--no-margin-bottom': hasTighterVerticalSpacing,
            'summary-item__hed--fixed-margin-bottom': hasFixedMarginBottom,
            'summary-item__hed--small': shouldUseSmallHed
        }), "data-testid": "SummaryItemHed", dangerouslySetInnerHTML: { __html: dangerousHed }, hasFixedMarginBottom: hasFixedMarginBottom, isSmall: shouldUseSmallHed, layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, isHighDensity: isHighDensity, hasNoHedTagMargin: hasNoHedTagMargin, hasNoHedTagMarginTop: hasNoHedTagMarginTop, shouldUseFeaturedFontWeight: shouldUseFeaturedFontWeight, hasDefaultSpacingMarginBottom: hasDefaultSpacingMarginBottom, isTextExternalLink: isTextExternalLink }));
    if (shouldClamp) {
        return (React.createElement(SummaryItemHedBase, { as: Clamp, className: "summary-item__hed", layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, lines: maxHedLines, isHighDensity: isHighDensity, breakpoint: breakpoint, isVenueCardItemContainer: isVenueCardItemContainer }, hed));
    }
    return hed;
};
SummaryItemHed.propTypes = {
    breakpoint: PropTypes.string,
    dangerousHed: PropTypes.string.isRequired,
    hasDefaultSpacingMarginBottom: PropTypes.bool,
    hasFixedMarginBottom: PropTypes.bool,
    hasHedCorePrimary: PropTypes.bool,
    hasNoHedTagMargin: PropTypes.bool,
    hasNoHedTagMarginTop: PropTypes.bool,
    hasTighterVerticalSpacing: PropTypes.bool,
    HedTag: PropTypes.oneOf(['div', 'h2', 'h3']),
    isHighDensity: PropTypes.bool,
    isTextExternalLink: PropTypes.bool,
    isVenueCardItemContainer: PropTypes.bool,
    layoutPlacement: PropTypes.oneOf(LAYOUT_PLACEMENTS),
    layoutProportions: PropTypes.oneOf(LAYOUT_PROPORTIONS),
    maxHedLines: PropTypes.number,
    shouldUseFeaturedFontWeight: PropTypes.bool,
    shouldUseSmallHed: PropTypes.bool
};
module.exports = SummaryItemHed;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 36211:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getTypographyStyles, maxScreen, minScreen } = __webpack_require__(26865);
const applyHedTypographyChanges = ({ isSmall, layoutPlacement, layoutProportions, theme, isHighDensity }) => {
    if (isSmall ||
        isHighDensity ||
        layoutPlacement === 'side-by-side-mobile-only') {
        return css `
      ${maxScreen(`calc(${BREAKPOINTS.lg} - 1px)`)} {
        &&& {
          ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-primary')}
        }
      }
    `;
    }
    else if (layoutPlacement === 'side-by-side' ||
        layoutPlacement === 'text-below-desktop-only' ||
        layoutProportions === '33-66') {
        return css `
      ${maxScreen(BREAKPOINTS.md)} {
        ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-core-secondary')}
      }
    `;
    }
    return '';
};
const SummaryItemHedBase = styled.div.withConfig({
    displayName: 'SummaryItemHedBase'
}) `
  ${getTypographyStyles('typography.definitions.discovery.hed-core-primary')}
  ${applyHedTypographyChanges}
  margin-top: 0;
  ${({ hasFixedMarginBottom, isSmall, layoutPlacement, theme, isVenueCardItemContainer }) => {
    let marginBottom = 1;
    if (isSmall) {
        return css `
        &&& {
          ${getTypographyStyles(theme, 'typography.definitions.discovery.hed-bulletin-primary')}
          margin-bottom: 0;
        }
      `;
    }
    else if (hasFixedMarginBottom && layoutPlacement !== 'side-by-side') {
        marginBottom = 1.5;
    }
    else if (isVenueCardItemContainer) {
        marginBottom = 0.5;
    }
    return css `
      &&& {
        margin-bottom: ${calculateSpacing(marginBottom)};
      }
    `;
}}

  p {
    margin: 0;
  }

  .small {
    text-transform: lowercase;
    font-style: normal;
    font-variant: small-caps;
  }

  ${maxScreen(BREAKPOINTS.md)} {
    margin-bottom: ${calculateSpacing(1)};
  }

  ${minScreen(BREAKPOINTS.md)} {
    ${({ hasFixedMarginBottom, isSmall, hasDefaultSpacingMarginBottom }) => !hasFixedMarginBottom && !isSmall && !hasDefaultSpacingMarginBottom
    ? `&&& {
          margin-bottom: ${calculateSpacing(2)};
        }`
    : ''}
    ${({ isVenueCardItemContainer }) => isVenueCardItemContainer
    ? `&&& {
            margin-bottom: ${calculateSpacing(1)};
        }`
    : ''}
  }

  &&&& {
    ${({ isTextExternalLink, theme }) => isTextExternalLink &&
    `
    ${getTypographyStyles(theme, 'typography.definitions.consumptionEditorial.subhed-break-secondary')}
      margin-bottom: ${calculateSpacing(1)};
      `}
  }
`;
const SummaryItemHedTag = styled.div.withConfig({
    displayName: 'SummaryItemHedTag'
}) `
  ${({ hasNoHedTagMargin }) => hasNoHedTagMargin && `margin: 0;`}
  ${({ shouldUseFeaturedFontWeight }) => shouldUseFeaturedFontWeight && 'font-weight:400;'}
  ${({ hasNoHedTagMarginTop }) => hasNoHedTagMarginTop && `&& { margin-top: 0; }`}
`;
module.exports = { SummaryItemHedBase, SummaryItemHedTag };
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 1780:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const GalleryIcon = __webpack_require__(39336);
const PlayIcon = __webpack_require__(11118);
const SUPPORTED_ICONS = {
    gallery: GalleryIcon,
    video: PlayIcon,
    cnevideo: PlayIcon
};
// exlude icons on these layout placements
const ICON_EXCLUSIONS = ['side-by-side'];
module.exports = { ICON_EXCLUSIONS, SUPPORTED_ICONS };
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 52413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const { useIntl } = __webpack_require__(46984);
const moment = __webpack_require__(95093);
const Carousel = __webpack_require__(30830);
const ResponsiveAsset = __webpack_require__(73275);
const { LAYOUT_PLACEMENTS } = __webpack_require__(28197);
const { getRecircId } = __webpack_require__(2953);
const { getIconComponent } = __webpack_require__(77000);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const SummaryPremiere = __webpack_require__(96591);
const { SummaryItemImageAwards, SummaryItemImageContent, SummaryItemImageLink, SummaryItemResponsiveAsset, SummaryItemImageSignage, SummaryItemVideoTime, SummaryItemImageIcon, SummaryItemFloatingIcon, SummaryItemFloatingReviewIcon, SummaryItemPremiereWrapper } = __webpack_require__(14207);
const HeadphoneIcon = __webpack_require__(77818);
const ReviewIcon = __webpack_require__(43018);
/**
 * The image asset and its overlays
 *
 * @param {object} props - React props
 * @param {string} [props.audioTagIconTitle] - Optional title for the headphone icon of the floating audio tag
 * @param {Array} [props.awards] - Optional awards array
 * @param {Function} [props.clickHandlerHed] - called when user clicks hed
 * @param {string} [props.contentType] - Optional prop to generate classname to target items by contentType
 * @param {bool} props.hasCircularImage - Whether to present the image as circular
 * @param {bool} [props.hasAudioTag] - Whether to display floating icon or not
 * @param {bool} [props.hasRel] - Whether to display nofollow rel for syndicated content
 * @param {bool} [props.hasReviewTag] - Whether to display floating icon or not
 * @param {bool} [props.hasRoundedEdges] - Optional, whether to show rounded image edges
 * @param {bool} [props.hasImageCenteredButtonInCarousel] - Whether to display carousel control at center of the image
 * @param {string} [props.iconPosition] - The icon position
 * @param {ResponsiveAsset.propTypes} props.image - Object containing sources for a ResponsiveAsset
 * @param {boolean} [props.isLazy] - Optional if assets are to be lazy-loaded
 * @param {string} [props.layoutPlacement] - [`text-below`, `text-below-desktop-only`, `side-by-side`,
 *   `side-by-side-desktop-only`, `side-by-side-mobile-only`] Optional. Horizontal / Vertical placement of content.
 * @param {object} [props.metadataVideo] - Optional CNE video metadata
 * @param {bool} [props.metadataVideo.isLive] - Optional CNE video isLive prop
 * @param {string} [props.metadataVideo.premiereDate] - CNE video premiere date
 * @param {number} [props.metadataVideo.videoLength] - length of video
 * @param {number} [props.metadataVideo.premiereGap] - difference in days wrt to current date, will be negative for future premiered date
 * @param {Array} [props.multiImages] - Optional Object containing sources for a multiple ResponsiveAsset
 * @param {string} [props.playIconStyle] - Optional choice of 'dark', or 'cne' for play icon
 * @param {number} [props.recircId] - Optional recircId for Sparrow tracking
 * @param {string} [props.recircRiver] - Optional recirc river for Sparrow tracking
 * @param {bool} [props.shouldAssetHaveNoBottomMargin] - Optional prop to hide bottom margin
 * @param {boolean} [props.shouldAutoPlay] - Optional boolean to start playing video clip once component is rendered
 * @param {bool} [props.shouldDisplayPremiereDate] - Optional, used to display premiere date
 * @param {bool} [props.shouldDisplaySignage] - Optional boolean to display signage, defaults to false
 * @param {boolean} [props.shouldHideIcon] - Option to hide the icon
 * @param {boolean} [props.shouldHoldImageSpace] - Option to hold image space
 * @param {boolean} [props.shouldOpenUrlInNewTab] - Optional component config to open link in a new tab
 * @param {boolean} [props.shouldUseMediumBreakpoint] - Optional setting to enable medium breakpoint for image srcSet
 * @param {string} [props.signage] - Optional signage label to display on top of SummaryImage
 * @param {string} [props.sparrowPattern] - The sparrow pattern name
 * @param {bool} [props.shouldDisplayVideoTime] - Optional, used to show/hide video play time, default is false
 * @param {string} props.url - the url to link to
 * @param {string} [props.responsiveCartoonVariation] - Responsive cartoon variation
 * @param {string} [props.signalType] - Specifying the icon to be displayed in the actionBar
 * @param {object} [props.actionBarConfig] - config for the actionBar
 * @param {boolean} [props.shouldHideCartoonCaption] - Optional hides the cartoon caption
 * @param {boolean} [props.shouldHideCartoonCredit] - Optional hides the cartoon credit
 *
 * @returns {ReactElement} <a>
 */
// eslint-disable-next-line complexity
const SummaryItemImage = ({ audioTagIconTitle, awards, clickHandlerHed, contentType, hasCircularImage = false, hasAudioTag = false, hasImageCenteredButtonInCarousel, hasRel = false, hasReviewTag = false, hasRoundedEdges = false, iconPosition, image, isLazy, layoutPlacement, metadataVideo: { isLive, videoLength, premiereDate, premiereGap } = {}, multiImages, playIconStyle, recircId, recircRiver, responsiveCartoonVariation, shouldAssetHaveNoBottomMargin, shouldAutoPlay, shouldDisplayPremiereDate, shouldDisplaySignage, shouldDisplayVideoTime, shouldHideIcon, shouldHoldImageSpace, shouldUseMediumBreakpoint, signage, sparrowPattern, url, shouldOpenUrlInNewTab, signalType, actionBarConfig, shouldHideCartoonCaption, shouldHideCartoonCredit }) => {
    const Icon = getIconComponent(contentType, layoutPlacement);
    const { formatMessage } = useIntl();
    const { showImageWithoutLink } = image;
    const showImageOnly = contentType === 'cartoon' || showImageWithoutLink || multiImages?.length;
    let syndicatedRel = {};
    if (hasRel) {
        syndicatedRel = {
            rel: 'nofollow'
        };
    }
    const sharedAssetProps = {
        tabIndex: '-1',
        'data-component-title': recircRiver,
        'data-component-type': 'recirc-river',
        'data-recirc-id': getRecircId('image', recircId),
        'data-recirc-pattern': sparrowPattern
    };
    const videoDuration = videoLength && moment.utc(videoLength * 1000).format('mm:ss');
    const isVideoNotPremiered = shouldDisplayPremiereDate && premiereGap <= 0;
    const autoPlay = isVideoNotPremiered ? false : shouldAutoPlay;
    const videoBadge = () => {
        if (shouldDisplayVideoTime) {
            if (isLive) {
                return (React.createElement(SummaryItemVideoTime, { name: formatMessage(translations.liveVideo) }));
            }
            else if (videoDuration) {
                return React.createElement(SummaryItemVideoTime, { name: videoDuration });
            }
        }
        return null;
    };
    const imageContent = (React.createElement(React.Fragment, null,
        awards && React.createElement(SummaryItemImageAwards, { awards: awards }),
        multiImages?.length > 1 ? (React.createElement(Carousel, { hasControls: true, paginationStyle: "slider", controlPosition: "center", controlPlacement: "space-between", hasImageCenteredButton: hasImageCenteredButtonInCarousel, hasModerateSpacing: true, hasNoHorizontalScrollCarousel: true, hasPagination: true, hideHeaderBorder: true, onForwardClick: (e) => e.stopPropagation(), onBackClick: (e) => e.stopPropagation() }, multiImages.map((item, index) => (React.createElement(Carousel.CarouselItem, { key: index, spacing: "0", width: "100%" },
            React.createElement(ResponsiveAsset, { ...item, isLazy: isLazy, shouldAutoPlay: autoPlay, shouldHoldImageSpace: shouldHoldImageSpace, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, className: "summary-item__image" })))))) : (React.createElement(SummaryItemResponsiveAsset, { ...image, hasCircularImage: hasCircularImage, hasRoundedEdges: hasRoundedEdges, isLazy: isLazy, shouldAutoPlay: autoPlay, shouldHoldImageSpace: shouldHoldImageSpace, shouldUseMediumBreakpoint: shouldUseMediumBreakpoint, className: "summary-item__image", shouldAssetHaveNoBottomMargin: shouldAssetHaveNoBottomMargin, responsiveCartoonVariation: responsiveCartoonVariation, signalType: signalType, actionBarConfig: actionBarConfig, shouldHideCartoonCaption: shouldHideCartoonCaption, shouldHideCartoonCredit: shouldHideCartoonCredit })),
        Icon && !shouldHideIcon && (React.createElement(SummaryItemImageIcon, { className: classnames('summary-item__icon-button', {
                [`summary-item__icon-button--icon-${iconPosition}`]: iconPosition,
                [`summary-item__icon-button--${playIconStyle}`]: playIconStyle
            }), ButtonIcon: Icon, iconStyle: playIconStyle, inputKind: "text", isIconButton: true, label: "icon", position: iconPosition })),
        hasAudioTag && (React.createElement(SummaryItemFloatingIcon, { className: "summary-item__icon-floating" },
            React.createElement(HeadphoneIcon, { headphoneIconTitle: audioTagIconTitle }))),
        hasReviewTag && (React.createElement(SummaryItemFloatingReviewIcon, { className: "summary-item__icon-review-floating" },
            React.createElement(ReviewIcon, null))),
        signage && shouldDisplaySignage && (React.createElement(SummaryItemImageSignage, { name: signage })),
        videoBadge(),
        isVideoNotPremiered && (React.createElement(SummaryItemPremiereWrapper, null,
            React.createElement(SummaryPremiere, { shouldDisplayPremiereDate: shouldDisplayPremiereDate, premiereDate: premiereDate, premiereGap: premiereGap })))));
    return (React.createElement(React.Fragment, null,
        showImageOnly && (React.createElement(SummaryItemImageContent, { ...sharedAssetProps }, imageContent)),
        !showImageOnly && (React.createElement(SummaryItemImageLink, { className: classnames('summary-item__image-link', 'summary-item-tracking__image-link'), href: url, ...syndicatedRel, "aria-hidden": "true", onClick: clickHandlerHed, layoutPlacement: layoutPlacement, ...sharedAssetProps, target: shouldOpenUrlInNewTab ? '_blank' : '_self' }, imageContent))));
};
SummaryItemImage.propTypes = {
    actionBarConfig: PropTypes.object,
    audioTagIconTitle: PropTypes.string,
    awards: PropTypes.array,
    clickHandlerHed: PropTypes.func,
    contentType: PropTypes.string,
    hasAudioTag: PropTypes.bool,
    hasCircularImage: PropTypes.bool,
    hasImageCenteredButtonInCarousel: PropTypes.bool,
    hasRel: PropTypes.bool,
    hasReviewTag: PropTypes.bool,
    hasRoundedEdges: PropTypes.bool,
    iconPosition: PropTypes.oneOf(['right', 'left']),
    image: PropTypes.shape(ResponsiveAsset.propTypes),
    isLazy: PropTypes.bool,
    isLive: PropTypes.bool,
    layoutPlacement: PropTypes.oneOf(LAYOUT_PLACEMENTS).isRequired,
    metadataVideo: PropTypes.shape({
        isLive: PropTypes.bool,
        premiereDate: PropTypes.string,
        series: PropTypes.string,
        videoLength: PropTypes.number,
        premiereGap: PropTypes.number
    }),
    multiImages: PropTypes.array,
    playIconStyle: PropTypes.oneOf(['dark', 'white', 'cne']),
    recircId: PropTypes.number,
    recircRiver: PropTypes.string,
    responsiveCartoonVariation: PropTypes.string,
    shouldAssetHaveNoBottomMargin: PropTypes.bool,
    shouldAutoPlay: PropTypes.bool,
    shouldDisplayPremiereDate: PropTypes.bool,
    shouldDisplaySignage: PropTypes.bool,
    shouldDisplayVideoTime: PropTypes.bool,
    shouldHideCartoonCaption: PropTypes.bool,
    shouldHideCartoonCredit: PropTypes.bool,
    shouldHideIcon: PropTypes.bool,
    shouldHoldImageSpace: PropTypes.bool,
    shouldOpenUrlInNewTab: PropTypes.bool,
    shouldUseMediumBreakpoint: PropTypes.bool,
    signage: PropTypes.string,
    signalType: PropTypes.string,
    sparrowPattern: PropTypes.string,
    url: PropTypes.string.isRequired
};
module.exports = SummaryItemImage;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 14207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getColorStyles, getTypographyStyles, minMaxScreen, minScreen } = __webpack_require__(26865);
const Rubric = __webpack_require__(34187);
const { ResponsiveClipWrapper } = __webpack_require__(91783);
const { ResponsiveImageContainer } = __webpack_require__(7228);
const ResponsiveAsset = __webpack_require__(73275);
const Awards = __webpack_require__(866);
const { InlineVideoItemIconButton } = __webpack_require__(41803);
const SummaryItemImageAwards = styled(Awards).withConfig({
    displayName: 'SummaryItemImageAwards'
}) `
  position: absolute;
  top: 0;
  z-index: 1;
  height: ${calculateSpacing(6.25)};
  text-align: right;
`;
const SummaryItemResponsiveAsset = styled(ResponsiveAsset).withConfig({
    displayName: 'SummaryItemResponsiveAsset'
}) `
  display: block;

  ${ResponsiveImageContainer} {
    width: 100%;

    ${({ hasCircularImage }) => (hasCircularImage ? 'border-radius: 50%' : '')}
    ${({ hasRoundedEdges }) => hasRoundedEdges ? `border-radius: ${calculateSpacing(1)}` : ''}
  }

  ${minMaxScreen(0, BREAKPOINTS.md)} {
    ${ResponsiveImageContainer} {
      ${({ hasRoundedEdges }) => hasRoundedEdges ? `border-radius: ${calculateSpacing(1)}` : ''}
    }
  }

  ${ResponsiveClipWrapper} {
    ${({ shouldAssetHaveNoBottomMargin }) => shouldAssetHaveNoBottomMargin
    ? 'margin-bottom: 0'
    : `margin-bottom: ${calculateSpacing(3)}`}
  }

  ${minScreen(BREAKPOINTS.md)} {
    ${ResponsiveClipWrapper} {
      ${({ shouldAssetHaveNoBottomMargin }) => shouldAssetHaveNoBottomMargin
    ? 'margin-bottom: 0'
    : `margin-bottom:${calculateSpacing(5)}`}
    }
  }
`;
const SummaryItemImageContent = styled.span.withConfig({
    displayName: 'SummaryItemImageContent'
}) `
  display: block;
  position: relative;

  ${minMaxScreen(0, BREAKPOINTS.md)} {
    .summary-item--layout-placement-text-below-desktop-only & {
      margin: 0;
    }
  }
`;
const SummaryItemImageLink = styled.a.withConfig({
    displayName: 'SummaryItemImageLink'
}) `
  display: block;
  position: relative;

  ${minMaxScreen(0, BREAKPOINTS.md)} {
    ${({ layoutPlacement }) => layoutPlacement === 'text-below-desktop-only' && `margin: 0;`}
  }
`;
const SummaryItemVideoTime = styled(Rubric.Card).withConfig({
    displayName: 'SummaryItemVideoTime'
}) `
  position: absolute;
  bottom: ${calculateSpacing(1)};
  left: ${calculateSpacing(1)};
  padding: ${calculateSpacing(0.75)} ${calculateSpacing(0.5)}
    ${calculateSpacing(0.5)} ${calculateSpacing(0.75)};
`;
const SummaryItemPremiereWrapper = styled.div.withConfig({
    displayName: 'SummaryItemPremiereWrapper'
}) `
  position: absolute;
  top: 0;
  z-index: 2;
  width: 100%;
  height: 100%;
  min-height: ${calculateSpacing(4)};
  ${getColorStyles('background', 'colors.discovery.body.black.background')};
`;
const SummaryItemImageSignage = styled(Rubric.Card).withConfig({
    displayName: 'SummaryItemImageSignage'
}) `
  ${getColorStyles('background-color', 'colors.consumption.lead.standard.context-signature')};
  ${getColorStyles('color', 'colors.consumption.lead.standard.context-texture')};
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
  position: absolute;
  top: ${calculateSpacing(2)};
`;
const SummaryItemImageIcon = styled(InlineVideoItemIconButton).withConfig({
    displayName: 'SummaryItemImageIcon'
}) `
  .summary-item--layout-placement-side-by-side & {
    display: none;
  }

  ${minScreen(BREAKPOINTS.md)} {
    .summary-item--layout-placement-side-by-side & {
      display: inline-flex;
    }
  }
`;
const SummaryItemFloatingIcon = styled.div.withConfig({
    displayName: 'SummaryItemFloatingIcon'
}) `
  ${getColorStyles('background-color', 'colors.discovery.body.brand.accreditation')};

  ${getColorStyles('border-color', 'colors.discovery.body.black.border')};

  display: flex;
  position: absolute;
  right: 2px;
  bottom: 2px;
  align-items: center;
  justify-content: center;
  width: 22px;
  height: 22px;

  svg {
    ${getColorStyles('fill', 'colors.interactive.base.white')};
    align-self: center;
    width: 11px;
    height: 11px;
  }

  @media (min-width: ${BREAKPOINTS.lg}) {
    right: 8px;
    bottom: 8px;
    width: 32px;
    height: 32px;

    svg {
      width: 16px;
      height: 16px;
    }
  }
`;
const SummaryItemFloatingReviewIcon = styled.div.withConfig({
    displayName: 'SummaryItemFloatingReviewIcon'
}) `
  position: absolute;
  top: ${calculateSpacing(-0.3)};
  right: 2.6px;
  transform: rotate(45deg);
  z-index: 1;

  svg {
    top: 0;
    right: 0;
    align-self: center;
    transform: rotate(-45deg);
    z-index: 2;
    width: 3rem;
    height: 3rem;
    fill: #ff0000;
  }

  @media (max-width: ${BREAKPOINTS.md}) {
    top: ${calculateSpacing(-0.25)};

    svg {
      width: 2rem;
      height: 2rem;
    }
  }
`;
module.exports = {
    SummaryItemImageAwards,
    SummaryItemImageIcon,
    SummaryItemImageContent,
    SummaryItemImageLink,
    SummaryItemImageSignage,
    SummaryItemVideoTime,
    SummaryItemResponsiveAsset,
    SummaryItemFloatingIcon,
    SummaryItemFloatingReviewIcon,
    SummaryItemPremiereWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 77000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { ICON_EXCLUSIONS, SUPPORTED_ICONS } = __webpack_require__(1780);
/**
 * Based on the content type and placement, get the icon component
 *
 * @param  {string} contentType - the content type of the article
 * @param  {string} layoutPlacement - the layout placement variation
 * @returns {ReactComponent|null} the icon component
 */
const getIconComponent = (contentType, layoutPlacement) => {
    if (ICON_EXCLUSIONS.indexOf(layoutPlacement) === -1 &&
        SUPPORTED_ICONS[contentType]) {
        return SUPPORTED_ICONS[contentType];
    }
    return null;
};
module.exports = { getIconComponent };
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 96591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const Timestamp = __webpack_require__(92566);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const { SummaryItemAssetPremier, AssetPremierLabel } = __webpack_require__(75761);
/**
 * Premiere date display
 *
 * @param {object} props - React props
 * @param {string} [props.containerTheme] - theme for component
 * @param {bool} [props.hideTimeStampIcon] - Optional flag to show/hide time stamp icon
 * @param {string} [props.premiereDate] - Optional, date of article/video
 * @param {number} [props.premiereGap] - difference in days wrt to current date, will be negative for future premiered date
 * @returns {ReactElement}
 */
const SummaryPremiere = ({ premiereDate, premiereGap, containerTheme = 'inverted', hideTimeStampIcon = false }) => {
    const { formatMessage } = useIntl();
    let premiereLabel = null;
    if (premiereDate) {
        if (premiereGap === 0) {
            premiereLabel = `${formatMessage(translations.futurePremiereLabel)} ${formatMessage(translations.todayLabel)}`;
        }
        else if (premiereGap < 0) {
            premiereLabel = `${formatMessage(translations.futurePremiereLabel)} ${premiereDate}`;
        }
        else if (premiereGap > 0) {
            premiereLabel = `${formatMessage(translations.pastPremiereLabel)} ${premiereDate}`;
        }
    }
    return premiereLabel ? (React.createElement(SummaryItemAssetPremier, { containerTheme: containerTheme },
        !hideTimeStampIcon && React.createElement(Timestamp, null),
        React.createElement(AssetPremierLabel, null, premiereLabel))) : null;
};
SummaryPremiere.propTypes = {
    containerTheme: PropTypes.string,
    hideTimeStampIcon: PropTypes.bool,
    premiereDate: PropTypes.string,
    premiereGap: PropTypes.number
};
module.exports = SummaryPremiere;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 75761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { getColorToken, getTypographyStyles, calculateSpacing, minMaxScreen } = __webpack_require__(26865);
const { maxThresholds } = __webpack_require__(99906);
const { BREAKPOINTS } = __webpack_require__(96472);
const SummaryItemAssetPremier = styled.div.withConfig({
    displayName: 'SummaryItemAssetPremier'
}) `
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  ${({ theme, containerTheme }) => {
    if (containerTheme === 'inverted') {
        return css `
        border: 1px solid
          ${getColorToken(theme, 'colors.discovery.body.black.accent')};
        color: ${getColorToken(theme, 'colors.discovery.body.black.description')};
        ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.numerical-small')};

        & .icon path {
          fill: ${getColorToken(theme, 'colors.discovery.body.black.description')};
        }
      `;
    }
    else if (containerTheme === 'standard' || containerTheme === 'special') {
        return css `
        border: 1px solid
          ${getColorToken(theme, 'colors.discovery.body.black.accent')};
        color: ${getColorToken(theme, 'colors.discovery.body.white.description')};
        ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.numerical-small')};

        & .icon path {
          fill: ${getColorToken(theme, 'colors.discovery.body.black.description')};
        }
      `;
    }
    return '';
}}
`;
const AssetPremierLabel = styled.div.withConfig({
    displayName: 'AssetPremierLabel'
}) `
  ${minMaxScreen(BREAKPOINTS.md, `${maxThresholds.lg + 80}px`)} {
    font-size: 9px;
  }

  ${minMaxScreen(BREAKPOINTS.sm, `${maxThresholds.sm + 120}px`)} {
    font-size: 9px;
  }

  margin-top: ${calculateSpacing(0.5)};
  ${({ theme }) => {
    return css `
      ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.numerical-small')};
    `;
}}
`;
module.exports = {
    SummaryItemAssetPremier,
    AssetPremierLabel
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 75096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const { googleAnalytics } = __webpack_require__(90090);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const { SummaryItemProductOffersWrapper } = __webpack_require__(18396);
const { formatGtmData } = __webpack_require__(60162);
/**
 *
 * The Offers component for the summary item
 *
 * @param {object} props - React props
 * @param {string} [props.copilotID]  - Optional copilot id of the item
 * @param {Array} [props.offers] - Optional array of offer
 * @param {string} [props.urlToBookmark] - optional url string for bookmark button
 * @param {object} [props.productData] - optional prop for gtm productData
 * @param {number} [props.index] - optional prop for item index
 * @param {string} [props.dangerousHed] - optional prop to dangerousHed
 * @param {object} [props.image] - image object for collection drawer
 * @param {boolean} [props.isHotelType] - optional flag for hotel contentype
 * @param {string} [props.contentType] - Optional prop to target items by contentType
 * @param {string} [props.subtype] - describes the subtype under Venue types.
 * @param {boolean} [props.isActionIdEnabledForComponent] - optional flag to enable actionId for component
 *
 * @returns {ReactElement} ProductOfferList
 *
 */
const SummaryItemProductOffers = ({ copilotID, offers, image, contentType, subtype, urlToBookmark, productData, index, isHotelType, dangerousHed, isActionIdEnabledForComponent }) => {
    const { formatMessage } = useIntl();
    const onClickHandler = ({ event, actionId }) => {
        googleAnalytics.emitGoogleTrackingEvent('summary-item-offers-button-click');
        if (isHotelType) {
            formatGtmData({
                window,
                product: { ...productData },
                index,
                layout: 'ProductEmbed',
                event,
                layoutTitle: dangerousHed,
                actionId
            });
        }
    };
    return offers?.length ? (React.createElement(SummaryItemProductOffersWrapper, { buttonVariation: "Primary", btnStyle: "filled", copilotID: copilotID, dataAttrs: {
            'data-component-position': 'summary-item'
        }, image: image, contentType: contentType, contentTitle: dangerousHed, defaultCTAText: formatMessage(translations.productOfferCTAText), offers: offers, onClickHandler: onClickHandler, showOffersSeller: true, urlToBookmark: urlToBookmark, subtype: subtype, venueSellerPreviewText: formatMessage(translations.venueSellerPreviewText), isActionIdEnabledForComponent: isActionIdEnabledForComponent })) : null;
};
SummaryItemProductOffers.propTypes = {
    contentType: PropTypes.string,
    copilotID: PropTypes.string,
    dangerousHed: PropTypes.string,
    image: PropTypes.object,
    index: PropTypes.number,
    isActionIdEnabledForComponent: PropTypes.bool,
    isHotelType: PropTypes.bool,
    offers: PropTypes.array,
    productData: PropTypes.object,
    subtype: PropTypes.string,
    urlToBookmark: PropTypes.string
};
module.exports = SummaryItemProductOffers;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18396:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { ButtonWrapper } = __webpack_require__(18974);
const ProductOfferList = __webpack_require__(18059);
const SummaryItemProductOffersWrapper = styled(ProductOfferList).withConfig({
    displayName: 'SummaryItemProductOffersWrapper'
}) `
  margin-top: auto;
  width: 100%;

  ${ButtonWrapper} {
    width: 100%;
  }
`;
module.exports = {
    SummaryItemProductOffersWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 9486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { SummaryItemReviewLabelWrapper } = __webpack_require__(50082);
/**
 * The hed author name wrapper
 *
 * @param {string} props.ratingValue - rating value
 * @returns {ReactElement} <HedTag>
 */
const SummaryItemReviewLabel = ({ ratingValue }) => {
    const ChannelLabel = ratingValue.channelType
        ? ratingValue.channelType.replace(/s$/, '')
        : 'Music';
    if (!ratingValue) {
        return null;
    }
    if (ratingValue.isBestNewReissue) {
        return (React.createElement(SummaryItemReviewLabelWrapper, null, "Best New Reissue"));
    }
    if (ratingValue.isBestNewMusic) {
        return (React.createElement(SummaryItemReviewLabelWrapper, null,
            "Best New ",
            ChannelLabel));
    }
    return null;
};
SummaryItemReviewLabel.propTypes = {
    ratingValue: PropTypes.object
};
module.exports = SummaryItemReviewLabel;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 50082:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getTypographyStyles } = __webpack_require__(26865);
const SummaryItemReviewLabelWrapper = styled.div.withConfig({
    displayName: 'SummaryItemReviewLabelWrapper'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.context-primary')}
  margin-bottom: ${calculateSpacing(0.5)};
  color: ${getColorToken('colors.consumption.lead.standard.accent')};
`;
module.exports = {
    SummaryItemReviewLabelWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 50328:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { useIntl } = __webpack_require__(46984);
const { googleAnalytics } = __webpack_require__(90090);
const translations = (__webpack_require__(82942)/* ["default"] */ .A);
const { SummaryItemShopNowButtonWrapper } = __webpack_require__(94620);
/**
 *
 * The shop now component for the summary item
 *
 * @param {object} props - React props
 * @param {object} [props.buttonAligment] - shop now button alignment
 * @param {object} [props.buttonSize] - shop now button size
 * @param {object} [props.dangerousHed] - item dangerousHed
 * @param {object} [props.url] - shop now url
 * @param {string} [props.buttonAlignment] - shop now button alignment
 * @param {string} [props.buttonLabel] - Button label text from source
 * @param {string} [props.buttonSize] - shop now button size
 * @param {string} [props.dangerousHed] - item dangerousHed
 * @param {string} [props.url] - shop now url
 * @returns {ReactElement} SummaryItemShopNowButton
 *
 */
const SummaryItemShopNowButton = ({ buttonAlignment, buttonLabel, buttonSize, dangerousHed, url }) => {
    const { formatMessage } = useIntl();
    const onClickHandler = (uri) => {
        googleAnalytics.emitGoogleTrackingEvent('summary-item-shop-now-button-click');
        // Open links in new tab on click of button
        if (uri) {
            window.open(uri, '_blank');
        }
    };
    return (React.createElement(SummaryItemShopNowButtonWrapper, { btnStyle: "outlined", label: buttonLabel, dataAttrs: {
            'data-component-position': 'summary-item'
        }, defaultCTAText: formatMessage(translations.ShopNowCTA), onClickHandler: () => onClickHandler(url), dangerousHed: dangerousHed, size: buttonSize, buttonAlignment: buttonAlignment }));
};
SummaryItemShopNowButton.propTypes = {
    buttonAlignment: PropTypes.oneOf(['center', 'left']),
    buttonLabel: PropTypes.string,
    buttonSize: PropTypes.oneOf(['default', 'small']),
    dangerousHed: PropTypes.string,
    url: PropTypes.string
};
module.exports = SummaryItemShopNowButton;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94620:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { calculateSpacing } = __webpack_require__(26865);
const { ButtonWrapper } = __webpack_require__(18974);
const Button = __webpack_require__(73730);
const SummaryItemShopNowButtonWrapper = styled(Button.Utility).withConfig({
    displayName: 'SummaryItemShopNowButtonWrapper'
}) `
  ${({ dangerousHed, buttonAlignment }) => (dangerousHed === '' || buttonAlignment === 'center') && `margin: auto;`}
  margin-top: ${calculateSpacing(2)};
  ${ButtonWrapper} {
    width: 100%;
    max-width: ${calculateSpacing(4.3)};
  }

  span {
    margin: auto;
  }
`;
module.exports = {
    SummaryItemShopNowButtonWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 20267:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const Clamp = __webpack_require__(48286);
const { LAYOUT_PLACEMENTS, LAYOUT_PROPORTIONS } = __webpack_require__(28197);
const { SummaryItemSubHedBase, SummaryItemSubHedTag } = __webpack_require__(76053);
/**
 * The hed with optional clamping
 *
 * @param {boolean} [props.hasTighterVerticalSpacing] - Optional. has tighter spacing for reduced white space
 * @param {boolean} [props.hasFixedMarginBottom] - Optional. used to give fixed margin bottom across screen sizes
 * @param {boolean} [props.hasNoHedTagMargin] - Optional flag, to avoid default H tag margin
 * @param {string} props.HedTag - The component to use
 * @param {number} [props.maxHedLines] - maximum lines in the hed
 * @param {boolean} [props.shouldUseSmallHed] - Optional flag to use a smaller font size for the hed
 * @param {boolean} [props.isHighDensity] - [`bool`] Optional. Set to `true` to render just the headline on
 * @param {string} props.subHed - The sub hed
 * @returns {ReactElement} <HedTag>
 */
const SummaryItemSubHed = ({ hasTighterVerticalSpacing, hasFixedMarginBottom, layoutPlacement, layoutProportions, maxHedLines, HedTag, hasHedCorePrimary, hasNoHedTagMargin, shouldUseSmallHed, isHighDensity, subHed }) => {
    const shouldClamp = maxHedLines > 0 && maxHedLines < Infinity;
    const shouldRenderSummaryItemHed = !shouldClamp && !hasHedCorePrimary;
    const HedComponent = shouldRenderSummaryItemHed
        ? SummaryItemSubHedBase
        : SummaryItemSubHedTag;
    const hed = (React.createElement(HedComponent, { as: HedTag, className: classnames({
            'summary-item__sub-hed': shouldRenderSummaryItemHed,
            'summary-item__sub-hed--hed-core-primary': hasHedCorePrimary,
            'summary-item__sub-hed--no-margin-bottom': hasTighterVerticalSpacing,
            'summary-item__sub-hed--fixed-margin-bottom': hasFixedMarginBottom,
            'summary-item__sub-hed--small': shouldUseSmallHed
        }), "data-testid": "SummaryItemHed", dangerouslySetInnerHTML: { __html: subHed }, hasFixedMarginBottom: hasFixedMarginBottom, isSmall: shouldUseSmallHed, layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, isHighDensity: isHighDensity, hasNoHedTagMargin: hasNoHedTagMargin }));
    if (shouldClamp) {
        return (React.createElement(SummaryItemSubHedBase, { as: Clamp, className: "summary-item__sub-hed", layoutPlacement: layoutPlacement, layoutProportions: layoutProportions, lines: maxHedLines, isHighDensity: isHighDensity }, hed));
    }
    return hed;
};
SummaryItemSubHed.propTypes = {
    hasFixedMarginBottom: PropTypes.bool,
    hasHedCorePrimary: PropTypes.bool,
    hasNoHedTagMargin: PropTypes.bool,
    hasTighterVerticalSpacing: PropTypes.bool,
    HedTag: PropTypes.oneOf(['div', 'h2', 'h3', 'h4']),
    isHighDensity: PropTypes.bool,
    layoutPlacement: PropTypes.oneOf(LAYOUT_PLACEMENTS),
    layoutProportions: PropTypes.oneOf(LAYOUT_PROPORTIONS),
    maxHedLines: PropTypes.number,
    shouldUseSmallHed: PropTypes.bool,
    subHed: PropTypes.string
};
module.exports = SummaryItemSubHed;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 76053:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { calculateSpacing, getTypographyStyles, maxScreen, minScreen } = __webpack_require__(26865);
const applyHedTypographyChanges = ({ isSmall, layoutPlacement, layoutProportions, theme, isHighDensity }) => {
    if (isSmall ||
        isHighDensity ||
        layoutPlacement === 'side-by-side-mobile-only') {
        return `
    ${maxScreen(`calc(${BREAKPOINTS.lg} - 1px)`)} {
      &&& {
        ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-feature')}
      }
    }
    `;
    }
    else if (layoutPlacement === 'side-by-side' ||
        layoutPlacement === 'text-below-desktop-only' ||
        layoutProportions === '33-66') {
        return `
      ${maxScreen(BREAKPOINTS.md)}{
        ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-feature')}
      }
    `;
    }
    return '';
};
const SummaryItemSubHedBase = styled.div.withConfig({
    displayName: 'SummaryItemSubHedBase'
}) `
  ${getTypographyStyles('typography.definitions.globalEditorial.accreditation-feature')}
  ${applyHedTypographyChanges}
  margin-top: 0;
  ${({ hasFixedMarginBottom, isSmall, layoutPlacement, theme }) => {
    let marginBottom = 1;
    if (isSmall) {
        return `&&& {
        ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.accreditation-feature')}
          margin-bottom: 0;
      }`;
    }
    else if (hasFixedMarginBottom && layoutPlacement !== 'side-by-side') {
        marginBottom = 1.5;
    }
    return `&&& { margin-bottom: ${calculateSpacing(marginBottom)};} `;
}}

  p {
    margin: 0;
  }

  .small {
    text-transform: lowercase;
    font-style: normal;
    font-variant: small-caps;
  }

  ${maxScreen(BREAKPOINTS.md)} {
    margin-bottom: ${calculateSpacing(1)};
  }

  ${minScreen(BREAKPOINTS.md)} {
    ${({ hasFixedMarginBottom, isSmall }) => !hasFixedMarginBottom && !isSmall
    ? `&&& {
          margin-bottom: ${calculateSpacing(2)};
        }`
    : ''}
  }
`;
const SummaryItemSubHedTag = styled.div.withConfig({
    displayName: 'SummaryItemSubHedTag'
}) `
  ${({ hasNoHedTagMargin }) => hasNoHedTagMargin && `margin: 0`}
`;
module.exports = { SummaryItemSubHedBase, SummaryItemSubHedTag };
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 55259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handlSnowplowNavigationEvent = void 0;
const { trackNavigationEvent } = __webpack_require__(14307);
const handlSnowplowNavigationEvent = (itemData = {}) => {
    trackNavigationEvent(itemData);
};
exports.handlSnowplowNavigationEvent = handlSnowplowNavigationEvent;
//# sourceMappingURL=tracking.js.map

/***/ }),

/***/ 82942:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    dekReadMoreText: {
        id: 'SummaryItem.DekReadMoreText',
        defaultMessage: 'Read full review',
        description: 'Appended text for SummaryItem dek'
    },
    readMore: {
        id: 'SummaryItem.ReadMore',
        defaultMessage: 'Read More',
        description: 'Call to action for user to...read more'
    },
    sponsoredContent: {
        id: 'SummaryItem.SponsoredContent',
        defaultMessage: 'Sponsored Content',
        description: 'SummaryItem component sponsored content text'
    },
    slides: {
        id: 'SummaryItem.Slides',
        defaultMessage: '{slidesCount, plural, one {# slide} other {# slides}}',
        description: 'SummaryItem component meta data secondary slide text'
    },
    venueSellerPreviewText: {
        id: 'SummaryItem.VenueSellerPreviewText',
        defaultMessage: 'Powered By:',
        description: 'Seller preview'
    },
    productOfferCTAText: {
        id: 'SummaryItem.DefaultCTAText',
        defaultMessage: 'Book Now',
        description: 'Cta text for product offer list'
    },
    liveVideo: {
        id: 'SummaryItem.LiveVideoLabel',
        defaultMessage: 'live',
        description: 'Live video label'
    },
    futurePremiereLabel: {
        id: 'SummaryItem.FuturePremiereLabel',
        defaultMessage: 'PREMIERES',
        description: 'premier label for future date'
    },
    todayLabel: {
        id: 'SummaryItem.TodayLabel',
        defaultMessage: 'TODAY',
        description: 'premiere label for today'
    },
    pastPremiereLabel: {
        id: 'SummaryItem.PastPremiereLabel',
        defaultMessage: 'PREMIERED',
        description: 'premiere label for past date'
    },
    BusinessProfileCTAText: {
        id: 'SummaryItem.BusinessProfileCTAText',
        defaultMessage: 'View Profile',
        description: 'Cta text for Business profile button'
    },
    StartListeningNowPodcastCTA: {
        id: 'SummaryItem.StartListeningNowPodcastCTA',
        defaultMessage: 'Start Listening Now',
        description: 'Cta text for Start Listening Now button'
    },
    MoreInfoAndEpisodesPodcastCTA: {
        id: 'SummaryItem.MoreInfoAndEpisodesPodcastCTA',
        defaultMessage: 'More Info and Episodes',
        description: 'Cta text for More Info and Episodes button'
    },
    NowShoppingLabel: {
        id: 'SummaryItem.NowShoppingLabel',
        defaultMessage: 'Now Shopping',
        description: 'Now shopping text for the external links in the series navigation carousel'
    },
    ShopNowCTA: {
        id: 'SummaryItem.ShopNowCTA',
        defaultMessage: 'Shop Now',
        description: 'Cta text for Shop Now button'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 2953:
/***/ ((module) => {

const cutClearLink = (url) => {
    const paramsIndex = url.search(/[?|#]/);
    return paramsIndex > 0 ? url.substring(0, paramsIndex) : url;
};
const getRecircId = (component, recircId) => recircId ? `item-${component}-${recircId}` : null;
const hasFeatureVideo = (image) => image && image.url;
module.exports = {
    cutClearLink,
    getRecircId,
    hasFeatureVideo
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 99156:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const SummaryItem = __webpack_require__(67619);
SummaryItem.TextBelowLeft = asVariation(SummaryItem, 'TextBelowLeft', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50',
    shouldAssetHaveNoBottomMargin: true
});
SummaryItem.TextBelowLeftSponsored = asVariation(SummaryItem, 'TextBelowLeftSponsored', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    hideRubricItemSummary: true,
    hasSponsorByline: true
});
SummaryItem.TextBelowLeftIconRight = asVariation(SummaryItem, 'TextBelowLeftIconRight', {
    iconPosition: 'right',
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.TextBelowCenter = asVariation(SummaryItem, 'TextBelowCenter', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.TextBelowLeftCard = asVariation(SummaryItem, 'TextBelowLeftCard', {
    isCard: true,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, { hasBorder: false });
SummaryItem.TextBelowCenterCard = asVariation(SummaryItem, 'TextBelowCenterCard', {
    isCard: true,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, { hasBorder: false });
SummaryItem.CircularImage = asVariation(SummaryItem, 'CircularImage', {
    isCard: false,
    circleImage: true,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.TextBelowDesktopOnly = asVariation(SummaryItem, 'TextBelowDesktopOnly', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.TextBelowDesktopOnlyImageRight = asVariation(SummaryItem, 'TextBelowDesktopOnlyImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '50-50'
});
SummaryItem.TextBelowDesktopOnlyThirds = asVariation(SummaryItem, 'TextBelowDesktopOnlyThirds', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
});
SummaryItem.TextBelowDesktopOnlyThirdsImageRight = asVariation(SummaryItem, 'TextBelowDesktopOnlyThirdsImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
});
SummaryItem.TextBelowDesktopOnlyNoAsset = asVariation(SummaryItem, 'TextBelowDesktopOnlyNoAsset', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: false,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
});
SummaryItem.TextBelowDesktopOnlyThirdsImageRightThumbnail = asVariation(SummaryItem, 'TextBelowDesktopOnlyThirdsImageRightThumbnail', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only-thumbnail',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    shouldAssetHaveNoBottomMargin: true
});
SummaryItem.TextBelowDesktopOnlyThirdsImageRightThumbnailGrid = asVariation(SummaryItem, 'TextBelowDesktopOnlyThirdsImageRightThumbnailGrid', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only-thumbnail',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    primaryBlock: 'primary-block',
    marginTop: 'margintop'
});
SummaryItem.SideBySide = asVariation(SummaryItem, 'SideBySide', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.SideBySideCenterImageLeft = asVariation(SummaryItem, 'SideBySideCenterImageLeft', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    hasRule: false
});
SummaryItem.SideBySideImageRight = asVariation(SummaryItem, 'SideBySideImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '50-50'
});
SummaryItem.SideBySideImageWarp = asVariation(SummaryItem, 'SideBySideImageWarp', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '50-50',
    imageWarp: true
});
SummaryItem.SideBySideCenterImageRight = asVariation(SummaryItem, 'SideBySideCenterImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '50-50'
}, {
    hasRule: false
});
SummaryItem.SideBySideThirds = asVariation(SummaryItem, 'SideBySideThirds', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideThirdsWithUtilityFeatures = asVariation(SummaryItem, 'SideBySideThirdsWithUtilityFeatures', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66',
    hasUtilityFeatures: true
});
SummaryItem.SideBySideThirdsCard = asVariation(SummaryItem, 'SideBySideThirdsCard', {
    isCard: true,
    cardContentPaddingStyles: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
}, {
    hasBorder: false
});
SummaryItem.HighDensity = asVariation(SummaryItem, 'HighDensity', {
    isCard: false,
    isHighDensity: true,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideThirdsImageRight = asVariation(SummaryItem, 'SideBySideThirdsImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideThirdsImageRightTextCenter = asVariation(SummaryItem, 'SideBySideThirdsImageRightTextCenter', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideTwoThirdsImageLeft = asVariation(SummaryItem, 'SideBySideTwoThirdsImageLeft', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '66-33'
});
SummaryItem.SideBySideDense = asVariation(SummaryItem, 'SideBySideDense', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    isDense: true
});
SummaryItem.SideBySideDenseNoAsset = asVariation(SummaryItem, 'SideBySideDenseNoAsset', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: false,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    isDense: true
});
SummaryItem.SideBySideDenseNoAssetNoRubric = asVariation(SummaryItem, 'SideBySideDenseNoAssetNoRubric', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: false,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    isDense: true
}, {
    hideRubricItemSummary: true,
    shouldHidePublishDate: true
});
SummaryItem.SideBySideDesktopOnly = asVariation(SummaryItem, 'SideBySideDesktopOnly', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.SideBySideDesktopOnlyImageRight = asVariation(SummaryItem, 'SideBySideDesktopOnlyImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '50-50'
});
SummaryItem.SideBySideDesktopOnlyThirds = asVariation(SummaryItem, 'SideBySideDesktopOnlyThirds', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideDesktopOnlyThirdsCard = asVariation(SummaryItem, 'SideBySideDesktopOnlyThirdsCard', {
    isCard: true,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
}, {
    hasBorder: false
});
SummaryItem.SideBySideDesktopOnlyThirdsSponsored = asVariation(SummaryItem, 'SideBySideDesktopOnlyThirdsSponsored', {
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
}, {
    hideRubricItemSummary: true,
    hasSponsorByline: true
});
SummaryItem.SideBySideDesktopOnlySponsored = asVariation(SummaryItem, 'SideBySideDesktopOnlySponsored', {
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    hideRubricItemSummary: true,
    hasSponsorByline: true
});
SummaryItem.Bookmarks = asVariation(SummaryItem, 'Bookmarks', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    hasBookmarks: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66',
    shouldUseGridStyles: true
}, {
    shouldHideDangerousDek: true
});
SummaryItem.TextBelowImageWithSavedBookmarks = asVariation(SummaryItem, 'TextBelowImageWithSavedBookmarks', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    hasBookmarks: true,
    shouldUseGridStyles: false,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideBylines: false,
    shouldHideDangerousDek: false,
    shouldHidePublishDate: false,
    hasBorder: false,
    shouldVerticallyAlignHed: true,
    shouldUseSmallHed: true
});
SummaryItem.SideBySideDesktopOnlyThirdsIconRight = asVariation(SummaryItem, 'SideBySideDesktopOnlyThirdsIconRight', {
    iconPosition: 'right',
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideDesktopOnlyThirdsImageRight = asVariation(SummaryItem, 'SideBySideDesktopOnlyThirdsImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
});
SummaryItem.PodcastsSideBySideDesktopOnlyThirdsImageRight = asVariation(SummaryItem, 'PodcastsSideBySideDesktopOnlyThirdsImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    hasPrimaryCTA: true,
    hasSecondaryCTA: true
});
SummaryItem.SideBySideMobileOnlyThirdsImageRight = asVariation(SummaryItem, 'SideBySideMobileOnlyThirdsImageRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-mobile-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
}, {
    shouldHideDangerousDekMobileOnly: true,
    shouldUseSmallImageMobileOnly: true
});
SummaryItem.SideBySideDesktopOnlyThirdsCircularImage = asVariation(SummaryItem, 'SideBySideDesktopOnlyThirdsCircularImage', {
    isCard: false,
    circleImage: true,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
});
SummaryItem.SideBySideDarkBackground = asVariation(SummaryItem, 'SideBySideDarkBackground', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50',
    isDarkBackground: true,
    hasDesktopTitleBlockDivider: true,
    hasHedCorePrimary: false
}, {
    shouldHideBylines: true,
    shouldHideDangerousDek: false,
    hasRule: true,
    hasBorder: true
});
SummaryItem.SideBySideDarkBackgroundWithBylines = asVariation(SummaryItem, 'SideBySideDarkBackgroundWithBylines', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50',
    isDarkBackground: true,
    hasDesktopTitleBlockDivider: true,
    hasHedCorePrimary: false
}, {
    shouldHideBylines: false,
    shouldHideDangerousDek: false,
    hasRule: true,
    hasBorder: true,
    shouldHidePublishDate: false
});
SummaryItem.SideBySideDarkBackgroundRight = asVariation(SummaryItem, 'SideBySideDarkBackgroundRight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '50-50',
    isDarkBackgroundRight: true,
    hasDesktopTitleBlockDivider: true,
    hasHedCorePrimary: true
}, {
    shouldHideBylines: true,
    shouldHideDangerousDek: false,
    hasRule: true,
    hasBorder: true
});
SummaryItem.NoAssetTextCenter = asVariation(SummaryItem, 'NoAssetTextCenter', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: false,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.OverlayCenter = asVariation(SummaryItem, 'OverlayCenter', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'overlay',
    layoutPosition: 'image-overlay',
    layoutProportions: 'overlay'
});
SummaryItem.OverlayWithVideoDetails = asVariation(SummaryItem, 'OverlayWithVideoDetails', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'overlay',
    layoutPosition: 'image-overlay',
    layoutProportions: 'overlay',
    showOnHoverEffect: false,
    isContributor: false,
    shouldDisplayLiveIndicator: true,
    hasCTA: true,
    hasLeftMargin: true
});
SummaryItem.OverlayCenterLimitedHeight = asVariation(SummaryItem, 'OverlayCenterLimitedHeight', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    hasAsset: true,
    layoutPlacement: 'overlay',
    layoutPosition: 'image-overlay',
    layoutProportions: 'overlay-limited-height'
});
SummaryItem.TextOnlyBrandLogoPersonalized = asVariation(SummaryItem, 'TextOnlyBrandLogoPersonalized', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: false,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.WithVideoDetails = asVariation(SummaryItem, 'WithVideoDetails', {
    hasAsset: true,
    shouldDisplayPremiereDate: true,
    shouldDisplayVideoTime: true,
    layoutPlacement: 'text-below',
    shouldAssetHaveNoBottomMargin: true,
    circleImage: false,
    contentAlign: 'left',
    isCard: false,
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    rubricIconOverride: '<svg class="icon icon-play-outlined" focusable="false" viewBox="5 8 20 20" width="32" height="32" xmlns="http://www.w3.org/2000/svg"><title>PlayOutlined</title><path d="M13 20.554L20.969 16 13 11.446v9.108zM11 8l14 8-14 8V8z" fill-rule="nonzero"></path></svg>'
});
SummaryItem.Contributor = asVariation(SummaryItem, 'Contributor', {
    isCard: false,
    circleImage: true,
    contentAlign: 'left',
    hasAsset: true,
    layoutPosition: 'image-right',
    layoutPlacement: 'text-below',
    layoutProportions: '50-50',
    isContributor: true
}, {
    shouldHideBylines: true,
    shouldHideDangerousDek: true,
    hasRule: false,
    hasBorder: true
});
SummaryItem.ContributorImageAtLeft = asVariation(SummaryItem, 'ContributorImageAtLeft', {
    isCard: false,
    circleImage: true,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66',
    isContributor: true,
    isContributorThreeCol: true
}, {
    hasRule: false,
    hasBorder: true,
    hideRubricItemSummary: false,
    shouldHideBylines: true,
    shouldHideDangerousDek: true,
    shouldHideContributorContent: true,
    showContributorContentOnTop: true,
    rubricVariation: 'DiscoveryItem',
    hasBottomSpaceOnRubric: true
});
SummaryItem.Business = asVariation(SummaryItem, 'Business', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPosition: 'image-left',
    layoutPlacement: 'side-by-side-desktop-only',
    layoutProportions: '33-66',
    isBusiness: true,
    showLocation: true,
    showProfileButton: true,
    showBusinessCategory: true
}, {
    hasRule: false,
    hideRubricItemSummary: true,
    shouldHideBylines: true,
    shouldHideMetadataSecondary: true
});
SummaryItem.ContributorAsCard = asVariation(SummaryItem, 'ContributorAsCard', {
    isCard: true,
    circleImage: false,
    hasAsset: true,
    layoutPosition: 'image-left',
    layoutPlacement: 'text-below',
    layoutProportions: 'overlay-limited-height',
    isContributor: true,
    contentAlign: 'left',
    isContributorThreeCol: true
}, {
    hasRule: false,
    hasBorder: false,
    hideRubricItemSummary: false,
    shouldHideBylines: true,
    shouldHideDangerousDek: true
});
SummaryItem.ContributorGridItem = asVariation(SummaryItem, 'ContributorGridItem', {
    isCard: false,
    circleImage: true,
    contentAlign: 'center',
    hasAsset: true,
    isContributorGridItem: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideBylines: true,
    shouldHideDangerousDek: true
});
SummaryItem.ContributorRiverItem = asVariation(SummaryItem, 'ContributorRiverItem', {
    isCard: false,
    circleImage: false,
    hasAsset: true,
    layoutPosition: 'image-left',
    layoutPlacement: 'text-below',
    layoutProportions: '20-80',
    isContributor: true,
    contentAlign: 'left',
    isContributorImageTopAligned: true,
    isContributorThreeCol: true,
    showReadMore: true
}, {
    hasRule: false,
    hasBorder: false,
    hideRubricItemSummary: true,
    shouldHideBylines: true,
    shouldHideDangerousDek: true
});
SummaryItem.TextBelowImageLeftHasRuleNoDek = asVariation(SummaryItem, 'TextBelowImageLeftHasRuleNoDek', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasRule: true,
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideDangerousDek: true
});
SummaryItem.TextBelowImageLeftHasRuleWithDek = asVariation(SummaryItem, 'TextBelowImageLeftHasRuleWithDek', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasRule: true,
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideDangerousDek: false
});
SummaryItem.SideBySideThirdsImageRightNoDeck = asVariation(SummaryItem, 'SideBySideThirdsImageRightNoDeck', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
}, {
    shouldHideDangerousDek: true
});
SummaryItem.SideBySideThirdsImageRightHedOnly = asVariation(SummaryItem, 'SideBySideThirdsImageRightHedOnly', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
}, {
    hasBorder: false,
    hasBorderSides: true,
    hideRubricItemSummary: false,
    shouldHideBylines: true,
    shouldHideDangerousDek: true,
    shouldVerticallyAlignHed: true,
    shouldUseSmallHed: true
});
SummaryItem.SideBySideThirdsImageLeftWithDek = asVariation(SummaryItem, 'SideBySideThirdsImageLeftWithDek', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
}, {
    shouldHideDangerousDek: false
});
SummaryItem.SideBySideThirdsImageLeftWithNoDekNoBorder = asVariation(SummaryItem, 'SideBySideThirdsImageLeftWithNoDekNoBorder', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-left',
    layoutProportions: '33-66'
}, {
    hasBorder: false,
    hasBorderSides: false,
    hideRubricItemSummary: true,
    shouldHideBylines: false,
    shouldHideDangerousDek: true,
    shouldUseSmallHed: true,
    shouldHidePublishDate: false
});
SummaryItem.TextBelowImageLeftHedOnly = asVariation(SummaryItem, 'TextBelowImageLeftHedOnly', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasRule: true,
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideDangerousDek: true,
    shouldHideBylines: true
});
SummaryItem.TextBelowImageLeftHedAndDek = asVariation(SummaryItem, 'TextBelowImageLeftHedAndDek', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasRule: true,
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideDangerousDek: false,
    shouldHideBylines: true
});
SummaryItem.TextBelowImageLeftHedDekAndByLines = asVariation(SummaryItem, 'TextBelowImageLeftHedDekAndByLines', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasRule: true,
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
}, {
    shouldHideDangerousDek: false,
    shouldHideBylines: false
});
SummaryItem.TextBelowImageWithUtilityFeatures = asVariation(SummaryItem, 'TextBelowImageWithUtilityFeatures', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasRule: true,
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50',
    hasUtilityFeatures: true
}, {
    shouldHideDangerousDek: false,
    shouldHideBylines: false
});
SummaryItem.WithIcon = asVariation(SummaryItem, 'WithIcon', {
    hasAudioTag: true,
    iconPosition: 'right',
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-mobile-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66'
}, {
    isDense: true,
    shouldUseSmallImageMobileOnly: true,
    hasBorderOnMobileAndTabletOnly: true,
    shouldHideDangerousDekMobileOnly: true
});
SummaryItem.TextBelowCenterWithIcon = asVariation(SummaryItem, 'TextBelowCenterWithIcon', {
    isCard: false,
    circleImage: false,
    contentAlign: 'center',
    contentAlignmentInMobile: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50'
});
SummaryItem.PodcastsWithoutAppleEmbed = asVariation(SummaryItem, 'PodcastsWithoutAppleEmbed', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '50-50',
    hasPrimaryCTA: true,
    hasSecondaryCTA: true
});
SummaryItem.PodcastRecirc = asVariation(SummaryItem, 'PodcastRecirc', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    hasPrimaryCTA: false,
    hasSecondaryCTA: true
});
SummaryItem.EventEmbed = asVariation(SummaryItem, 'EventEmbed', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side-desktop-only',
    layoutPosition: 'image-left',
    layoutProportions: '33-66',
    hasPrimaryCTA: true,
    hasSecondaryCTA: false
});
SummaryItem.DenseDesktopStack = asVariation(SummaryItem, 'DenseDesktopStack', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'text-below-desktop-only',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    isDenseDesktopStack: true
}, {
    shouldHideMetadataSecondary: true
});
SummaryItem.ContributorBundleItem = asVariation(SummaryItem, 'ContributorBundleItem', {
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    hasSummaryItemAction: true,
    isCard: false,
    layoutPlacement: 'text-below',
    layoutPosition: 'image-left',
    layoutProportions: '50-50',
    shouldAssetHaveNoBottomMargin: true,
    showReadMore: true
});
SummaryItem.DenseDesktopThirds = asVariation(SummaryItem, 'DenseDesktopThirds', {
    isCard: false,
    circleImage: false,
    contentAlign: 'left',
    hasAsset: true,
    layoutPlacement: 'side-by-side',
    layoutPosition: 'image-right',
    layoutProportions: '33-66',
    isDenseDesktopThirds: true
}, {
    shouldHideMetadataSecondary: true
});
module.exports = SummaryItem;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 2547:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { useEffect } = __webpack_require__(96540);
const { useIntl } = __webpack_require__(46984);
const { TrackComponentChannel } = __webpack_require__(78788);
const Button = __webpack_require__(73730);
const ItemsCount = __webpack_require__(78372);
const translations = (__webpack_require__(31492)/* ["default"] */ .A);
const { TextFieldWrapper, TextFieldLabel, TextFieldLabelText, TextFieldInputContainer, TextFieldControlInput, TextFieldControlTextarea, TextFieldIcon, TextFieldDataList, TextFieldDataListOption, TextFieldButton, TextFieldAssistiveText, TextFieldErrorText, TextFieldErrorSuggestion } = __webpack_require__(60434);
/**
 * TextField component
 *
 * @param {object} props - React props
 *
 * @param {number} [props.defaultCharCount] - something
 * @param {boolean} [props.shouldEnableErrorSuggestions] - something
 * @param {string} [props.errorPosition] - something
 * @param {boolean} [props.hasLabelCount] - something
 * @param {any} [props.marketingPermissions] - something
 * @param {boolean} [props.shouldDisableTypingAtMaxChar] - something
 *
 * @param {string} [props.ariaDescribedBy] - Optional aria-describedby value for input
 * @param {string} [props.assistiveSubtext] - Optional assistive text giving context to input
 * @param {string} [props.autoComplete] - Optional autoComplete input property
 * @param {string} [props.buttonAriaLabel] - Optional aria label for button
 * @param {string} [props.buttonInputKind] - Optional html button type attribute: ['button', 'link', 'submit', 'reset']. Provides context for which HTML tag to use.
 * @param {string} [props.buttonInverted] - Optional styling change
 * @param {string} [props.buttonVariation] - Optional button variation
 * @param {string} [props.buttonLabel] - Optional label for button
 * @param {Function} [props.charCountHandler] - Optional, returns character count
 * @param {string} [props.className] - Optional top-level class to add
 * @param {number} [props.customHeightMultiplier] - Optional passes multiplier to set custom height
 * @param {boolean} [props.isCommaSeperated] - Optional charCount reflects comma if it is more than 4 digits
 * @param {string} [props.defaultValue] - Optional default value
 * @param {string} [props.errorText] - Optional error text rendered with error state
 * @param {string} props.formName - Parent form name
 * @param {boolean} [props.hasAttachedButton] - Whether input has a visually attached button
 * @param {boolean} [props.hasAttachedButtonForMobile] - Whether input has a visually attached button for mobile view
 * @param {boolean} [props.hasAutoFocus] - Whether input has a autofocus as in account forms cases
 * @param {number} [props.hasBoxShadow] - Optional to add box-shadow property
 * @param {boolean} [props.hasInlineLabel] - Whether input label is within the input area
 * @param {boolean} [props.hasDynamicTextArea] - Whether the textarea shoud dynamically increase height based on placeholder
 * @param {boolean} [props.hasRoundedEdges] - Optional, whether to show rounded input edges
 * @param {boolean} [props.hasTextCounter] - Whether input label has text counter or not
 * @param {boolean} [props.hideButtonInMobile] - Show or hide button in mobile.
 * @param {boolean} [props.hideLabel] - Show or hide label. If hide, label will be added to 'aria-label'.
 * @param {object} [props.inputRef] - Optional node ref object
 * @param {object} [props.inputAttributes] - Optional attributes to add on element
 * @param {Map} [props.invalidElements] - Optional Map of invalid element ids from parent form. Will set invalid state if ID matches.
 * @param {boolean} [props.isAlwaysStacked] - Whether connected input is always stacked
 * @param {boolean} [props.isDisabled] - Whether input is disabled
 * @param {boolean} props.isInvalid - Whether input has error. Defaults to true when errorText is supplied. Adds an error state to the field without an error text.
 * @param {boolean} [props.isNeverStacked] - Whether connected input is ever stacked
 * @param {boolean} [props.isRequired] - Whether input is required
 * @param {string} props.label - Input label
 * @param {Function} [props.LeadingIcon] - Optional leading icon component
 * @param {string[]} [props.list] - Optional list of valid values to suggest
 * @param {number} [props.max] - Optional max validation
 * @param {number} [props.min] - Optional min validation
 * @param {string} props.name - Unique input name
 * @param {string} [props.placeholder] - Optional input placeholder
 * @param {boolean} [props.shouldUseAlternativeStyle] - Whether component has alternative styles
 * @param {boolean} [props.shouldUseUppercase] - Enable or disable uppercase for input value.
 * @param {number} [props.step] - Optional step validation
 * @param {Function} [props.TrailingIcon] - Optional trailing icon component
 * @param {string} [props.type] - Optional input type
 * @param {string} [props.onClickHandler] - Optional click handler function
 * @param {string} [props.onInputBlur] - Optional on input blur handler function
 * @param {string} [props.onInputChange] - Optional on input change handler function
 * @param {string} [props.onInputFocus] - Optional on input focus handler function
 * @param {string} [props.tabIndex] - Optional tab index
 * @param {object} [props.variations] - Optional variations
 * @param {string} [props.variations.inputType] - Optional input type ['single-line', 'multi-line']
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.buttonClassName] - passing a new classname for button
 *
 * @returns {ReactElement} <label>
 */
// eslint-disable-next-line complexity
const TextField = ({ shouldUseUppercase = false, ariaDescribedBy, assistiveSubtext, autoComplete, buttonAriaLabel, buttonInputKind, buttonInverted = 'standard', buttonLabel, buttonVariation = 'Utility', charCountHandler, className, defaultCharCount = 0, defaultValue, shouldEnableErrorSuggestions = false, errorPosition = 'belowButton', errorText, formName, hasAttachedButton, hasAttachedButtonForMobile, hasAutoFocus, hasBoxShadow = false, hasLabelCount = false, hasDynamicTextArea = false, hasInlineLabel, hasRoundedEdges = false, hasTextCounter = false, hideButtonInMobile = false, hideLabel = false, inputAttributes, inputRef, invalidElements, isAlwaysStacked = false, isDisabled, isInvalid, isNeverStacked = false, isRequired, label, labelCountValue, LeadingIcon, list, marketingPermissions: MarketingPermissions, max, min, name, onInputBlur, onInputChange, onInputFocus, onClickHandler, placeholder, shouldUseAlternativeStyle = false, step, TrailingIcon, type, variations = {
    inputType: 'single-line'
}, tabIndex, customHeightMultiplier, variationName, isCommaSeperated = false, shouldDisableTypingAtMaxChar, buttonClassName = '' }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'TextField',
            variation: variationName
        });
    }, [variationName]);
    const [isActivated, setIsActivated] = React.useState(false);
    const [isFocused, setIsFocused] = React.useState(false);
    const [charCount, setCharCount] = React.useState(defaultCharCount);
    const [isCharCountError, setCharCountError] = React.useState(false);
    const [errorTextState, setErrorTextState] = React.useState('');
    const input = React.useRef(null);
    const { formatMessage } = useIntl();
    React.useEffect(() => {
        if (!defaultCharCount) {
            setCharCountError(false);
            setErrorTextState('');
        }
        setCharCount(defaultCharCount);
    }, [defaultCharCount]);
    /**
     * Handle onchange of input to input area
     * Set isActivated to true if input field has a value
     * Used to add a classname to the dropdown
     *
     * @param {object} event - the event object
     * @returns {undefined} undefined
     */
    function calculateHeight(element) {
        element.style.height = `${element.scrollHeight / 16}rem`;
    }
    useEffect(() => {
        if (hasDynamicTextArea && inputRef.current)
            calculateHeight(inputRef.current);
    });
    const handleInput = (event) => {
        const ref = inputRef ?? input;
        const { value } = ref.current;
        if (shouldDisableTypingAtMaxChar && value.length >= max) {
            ref.current.value = value.slice(0, max);
            setCharCount(max);
        }
        else {
            setCharCount(value.length);
        }
        charCountHandler && charCountHandler(value.trim().length);
        setIsActivated(value && value.length > 0);
        if (shouldUseUppercase) {
            ref.current.value = ref.current.value.toUpperCase();
        }
        if (onInputChange) {
            onInputChange(event, value);
        }
    };
    /**
     * Handles onFocus of the input. Sets isFocused to true.
     *
     * @returns {undefined} undefined
     */
    const handleOnFocus = () => {
        setIsFocused(true);
        if (onInputFocus) {
            onInputFocus();
        }
    };
    /**
     * Handles the off-focus of the input. Sets isFocused to false.
     *
     * @param {object} event - the event object
     * @returns {undefined} undefined
     */
    const handleOnBlur = (event) => {
        setIsFocused(false);
        if (charCount < min || charCount > max) {
            setCharCountError(true);
            setErrorTextState(min
                ? formatMessage(translations.multiLineErrorText)
                    .replace('_MIN_', min)
                    .replace('_MAX_', max)
                : formatMessage(translations.multiLineUpperLimitErrorText).replace('_MAX_', max));
        }
        else {
            setCharCountError(false);
            setErrorTextState('');
        }
        if (onInputBlur) {
            onInputBlur(event);
        }
    };
    const id = `${formName}-text-field-${name}`;
    const errorTextId = `${formName}-text-field-error-${name}`;
    const IconComponent = LeadingIcon || TrailingIcon;
    const hasDatalist = list && !!list.length;
    const formHasFoundInvalid = invalidElements && invalidElements.has(id);
    const hasErrorState = isInvalid || errorText || formHasFoundInvalid || isCharCountError;
    const { inputType, itemType, messageType } = variations;
    const invalidElementsId = invalidElements && invalidElements.get(id);
    const SubmitButton = Button[buttonVariation];
    const commonProps = {
        ...inputAttributes,
        'aria-describedby': classnames({
            [ariaDescribedBy]: ariaDescribedBy,
            [errorTextId]: errorText,
            [invalidElementsId]: formHasFoundInvalid
        }),
        'aria-invalid': hasErrorState,
        autoComplete,
        autoFocus: hasAutoFocus,
        defaultValue,
        disabled: isDisabled,
        errorPosition,
        id,
        ref: inputRef ?? input,
        required: isRequired,
        name,
        placeholder,
        tabIndex
    };
    const getCommonProps = () => {
        return hideLabel ? { ...commonProps, 'aria-label': label } : commonProps;
    };
    const applySuggestion = (event, itemText = '') => {
        event.stopPropagation();
        const ref = inputRef ?? input;
        ref.current.value = itemText;
        if (onInputChange) {
            onInputChange();
        }
    };
    const implementErrorSuggestion = (itemChild, containerKey) => (React.createElement(TextFieldErrorSuggestion, { key: containerKey, "data-testid": "TextField__error-suggestion", className: "error-suggestion", onClick: (event) => {
            applySuggestion(event, itemChild);
        }, onKeyUp: (event) => {
            applySuggestion(event, itemChild);
        } }, itemChild));
    const getErrorComponent = () => {
        if (shouldEnableErrorSuggestions && errorText) {
            const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/i;
            return (React.createElement(TextFieldErrorText, { id: errorTextId, tabIndex: "-1" }, errorText.split(' ').map((collectionItem, index, { length }) => {
                const isLastItem = length - 1 === index;
                const itemText = isLastItem ? collectionItem : `${collectionItem} `;
                return emailRegex.test(collectionItem)
                    ? implementErrorSuggestion(collectionItem, index, isLastItem)
                    : itemText;
            })));
        }
        return (React.createElement(TextFieldErrorText, { id: errorTextId, tabIndex: "-1" }, errorText || errorTextState));
    };
    return (React.createElement(TextFieldWrapper, { className: classnames('text-field', className, {
            'text-field--activated': isActivated,
            'text-field--focused': isFocused,
            'text-field--error': hasErrorState,
            'alternative-style': shouldUseAlternativeStyle
        }), hasAttachedButton: hasAttachedButton, hasAttachedButtonForMobile: hasAttachedButtonForMobile, isAlwaysStacked: !isNeverStacked && isAlwaysStacked, isNeverStacked: isNeverStacked && !isAlwaysStacked, isActivated: isActivated, isFocused: isFocused, hasErrorState: hasErrorState, shouldUseAlternativeStyle: shouldUseAlternativeStyle, "data-testid": `TextFieldWrapper__${name}` },
        React.createElement(TextFieldLabel, { className: classnames('text-field__label', `text-field__label--${inputType}`, {
                'text-field__label--activated': isActivated
            }), isActivated: isActivated, isDisabled: isDisabled, hasInlineLabel: hasInlineLabel, htmlFor: id, "data-testid": `TextFieldLabel__${name}` },
            !hideLabel && React.createElement(TextFieldLabelText, null, label),
            React.createElement(TextFieldInputContainer, null,
                inputType === 'single-line' && (React.createElement(TextFieldControlInput, { ...getCommonProps(), className: classnames('text-field__control text-field__control--input', className), list: hasDatalist ? `${id}-datalist` : undefined, max: max, min: min, onInput: handleInput, onFocus: handleOnFocus, hasLeadingIcon: !!LeadingIcon, hasTrailingIcon: !!TrailingIcon, onBlur: handleOnBlur, step: step, type: type, "data-testid": `TextFieldInput__${name}` })),
                inputType === 'multi-line' && (React.createElement(React.Fragment, null,
                    React.createElement(TextFieldControlTextarea, { ...getCommonProps(), className: "text-field__control text-field__control--textarea", onInput: handleInput, onBlur: handleOnBlur, "data-testid": `TextFieldTextarea__${name}`, customHeightMultiplier: customHeightMultiplier, hasBoxShadow: hasBoxShadow, hasDynamicTextArea: hasDynamicTextArea, hasRoundedEdges: hasRoundedEdges }),
                    hasTextCounter && (React.createElement(ItemsCount, { count: max, hasTextCounter: true, itemType: itemType, minCount: min, messageType: messageType, preTextCount: isCommaSeperated ? charCount.toLocaleString() : charCount, showIcon: false })))),
                IconComponent && (React.createElement(TextFieldIcon, { as: IconComponent, LeadingIcon: LeadingIcon, TrailingIcon: TrailingIcon }))),
            hasDatalist && (React.createElement(TextFieldDataList, { id: `${id}-datalist` }, list.map((option) => (React.createElement(TextFieldDataListOption, { key: option.value, value: option.value }, option.label)))))),
        ((errorPosition === 'belowTextField' && errorText) || errorTextState) &&
            getErrorComponent(),
        MarketingPermissions && React.createElement(MarketingPermissions, null),
        hasAttachedButton && (React.createElement(TextFieldButton, { as: SubmitButton, ariaLabel: buttonAriaLabel, inputKind: buttonInputKind, isDisabled: isDisabled, label: buttonLabel, countValue: labelCountValue, hasLabelCount: hasLabelCount, onClickHandler: onClickHandler, isInverted: buttonInverted === 'inverted', hideButtonInMobile: hideButtonInMobile, className: buttonClassName })),
        assistiveSubtext && (React.createElement(TextFieldAssistiveText, { dangerouslySetInnerHTML: { __html: assistiveSubtext } })),
        ((errorPosition === 'belowButton' && errorText) || errorTextState) &&
            getErrorComponent()));
};
TextField.propTypes = {
    ariaDescribedBy: PropTypes.string,
    assistiveSubtext: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    autoComplete: PropTypes.string,
    buttonAriaLabel: PropTypes.string,
    buttonClassName: PropTypes.string,
    buttonInputKind: Button.propTypes.inputKind,
    buttonInverted: PropTypes.string,
    buttonLabel: PropTypes.string,
    buttonVariation: PropTypes.string,
    charCountHandler: PropTypes.func,
    className: PropTypes.string,
    customHeightMultiplier: PropTypes.number,
    defaultCharCount: PropTypes.number,
    defaultValue: PropTypes.string,
    errorPosition: PropTypes.oneOf(['belowButton', 'belowTextField']),
    errorText: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
    formName: PropTypes.string.isRequired,
    hasAttachedButton: PropTypes.bool,
    hasAttachedButtonForMobile: PropTypes.bool,
    hasAutoFocus: PropTypes.bool,
    hasBoxShadow: PropTypes.bool,
    hasDynamicTextArea: PropTypes.bool,
    hasInlineLabel: PropTypes.bool,
    hasLabelCount: PropTypes.bool,
    hasRoundedEdges: PropTypes.bool,
    hasTextCounter: PropTypes.bool,
    hideButtonInMobile: PropTypes.bool,
    hideLabel: PropTypes.bool,
    inputAttributes: PropTypes.object,
    inputRef: PropTypes.object,
    invalidElements: PropTypes.instanceOf(Map),
    isAlwaysStacked: PropTypes.bool,
    isCommaSeperated: PropTypes.bool,
    isDisabled: PropTypes.bool,
    isInvalid: PropTypes.bool,
    isNeverStacked: PropTypes.bool,
    isRequired: PropTypes.bool,
    label: PropTypes.string.isRequired,
    labelCountValue: PropTypes.number,
    LeadingIcon: PropTypes.func,
    list: PropTypes.arrayOf(PropTypes.object),
    marketingPermissions: PropTypes.any,
    max: PropTypes.number,
    min: PropTypes.number,
    name: PropTypes.string.isRequired,
    onClickHandler: PropTypes.func,
    onInputBlur: PropTypes.func,
    onInputChange: PropTypes.func,
    onInputFocus: PropTypes.func,
    placeholder: PropTypes.string,
    shouldDisableTypingAtMaxChar: PropTypes.bool,
    shouldEnableErrorSuggestions: PropTypes.bool,
    shouldUseAlternateStyleForError: PropTypes.bool,
    shouldUseAlternativeStyle: PropTypes.bool,
    shouldUseUppercase: PropTypes.bool,
    step: PropTypes.number,
    tabIndex: PropTypes.string,
    TrailingIcon: PropTypes.func,
    type: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        inputType: PropTypes.oneOf(['single-line', 'multi-line']),
        itemType: PropTypes.oneOf(['character']),
        messageType: PropTypes.oneOf(['withMinCountLimit', 'default'])
    })
};
module.exports = TextField;
//# sourceMappingURL=TextField.js.map

/***/ }),

/***/ 89662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(13510);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 60434:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const { BaseText, BaseInput, BaseTextarea, BaseLink } = __webpack_require__(76955);
const { calculateSpacing, minScreen, getColorStyles, getTypographyStyles, getInputFieldStyles, styledProperty, minMaxScreen, maxScreen } = __webpack_require__(26865);
const Button = __webpack_require__(73730);
const { BREAKPOINTS, INTERACTIVE } = __webpack_require__(96472);
const { maxThresholds } = __webpack_require__(99906);
const TextFieldLabelText = styled.div.withConfig({
    displayName: 'TextFieldLabelText'
}) `
  ${getTypographyStyles('typography.definitions.utility.label')};
  transition: color ${INTERACTIVE.timingButtonDefault} ease-in;
`;
const TextFieldIcon = styled.div.withConfig({
    displayName: 'TextFieldIcon'
}) `
  svg {
    ${({ theme }) => getInputFieldStyles(theme, 'normal', 'icon')}
  }

  .icon-search {
    margin-top: 8px;
    margin-left: 9px;
  }

  &:active,
  &:focus {
    svg {
      ${({ theme }) => getInputFieldStyles(theme, 'active', 'icon')}
    }
  }
  position: absolute;
  top: -5%;
  transform: translateY(calc(50% + ${calculateSpacing(1)}));
  transition: fill ${INTERACTIVE.timingButtonDefault} ease-in;
  width: ${calculateSpacing(3)};
  height: 1.7rem;

  /* leading */
  ${({ LeadingIcon }) => LeadingIcon && `left: ${calculateSpacing(1)};`}

  /* trailing */
  ${({ TrailingIcon }) => TrailingIcon && `right: ${calculateSpacing(1)};`}
`;
const textFieldControlStyles = css `
  ${getTypographyStyles('typography.definitions.utility.input-core')};
  margin-top: ${calculateSpacing(1)};
  padding: ${calculateSpacing(1)} ${calculateSpacing(1.5)};
  width: 100%;
  text-transform: none;
  transition-property: color, background, border;
  transition-duration: ${INTERACTIVE.timingButtonDefault};
  transition-timing-function: ease-in;

  ${({ theme }) => getInputFieldStyles(theme, 'normal', 'background')}
  ${({ theme }) => getInputFieldStyles(theme, 'normal', 'text')}
  ${({ theme }) => getInputFieldStyles(theme, 'normal', 'border')}

  &:focus {
    outline: 0;
    + ${TextFieldIcon} {
      svg {
        ${({ theme }) => getInputFieldStyles(theme, 'valid', 'icon')}
      }
    }
  }

  &:active,
  &:focus {
    ${({ theme }) => getInputFieldStyles(theme, 'active', 'background')}
    ${({ theme }) => getInputFieldStyles(theme, 'active', 'text')}
    ${({ theme }) => getInputFieldStyles(theme, 'active', 'border')}
  }

  &[disabled] {
    ${({ theme }) => getInputFieldStyles(theme, 'disabled', 'background')}
    ${({ theme }) => getInputFieldStyles(theme, 'disabled', 'text')}
    ${({ theme }) => getInputFieldStyles(theme, 'disabled', 'border')}
  }
`;
const TextFieldControlInput = styled(BaseInput).withConfig({
    displayName: 'TextFieldControlInput'
}) `
  ${textFieldControlStyles}
  border-radius: 0;
  height: ${calculateSpacing(6)};
  appearance: none;
  ${styledProperty('hasLeadingIcon', true, `padding-left: ${calculateSpacing(6.25)};`)}

  ${styledProperty('hasTrailingIcon', true, `padding-right: ${calculateSpacing(6)};`)}
`;
const TextFieldControlTextarea = styled(BaseTextarea).withConfig({
    displayName: 'TextFieldControlTextarea'
}) `
  ${textFieldControlStyles}
  max-width: 100%;

  resize: none;
  ${({ customHeightMultiplier }) => customHeightMultiplier
    ? `  
      height:${calculateSpacing(customHeightMultiplier)};
    `
    : `
     height:${calculateSpacing(19)};
    `}
  ${({ hasBoxShadow }) => hasBoxShadow &&
    `
    box-shadow: -2px 2px 5px rgba(0, 0, 0, 0.1);
  `}
   ${({ hasRoundedEdges }) => hasRoundedEdges &&
    `
    border-radius: 999px;
  `}
`;
const textFieldLabelActivatedStyles = css `
  ${TextFieldControlInput}, ${TextFieldControlTextarea} {
    ${({ theme }) => getInputFieldStyles(theme, 'valid', 'background')}
    ${({ theme }) => getInputFieldStyles(theme, 'valid', 'text')}
    ${({ theme }) => getInputFieldStyles(theme, 'valid', 'border')}
  }

  ${TextFieldIcon} {
    svg {
      ${({ theme }) => getInputFieldStyles(theme, 'valid', 'icon')}
    }
  }
`;
const TextFieldAssistiveText = styled.div.withConfig({
    displayName: 'TextFieldAssistiveText'
}) `
  ${getTypographyStyles('typography.definitions.utility.assistive-text')}

  grid-column: -1 / 1;
  transition: color ${INTERACTIVE.timingButtonDefault} ease-in;
  margin-top: ${calculateSpacing(1)};

  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.dark')};
`;
const TextFieldLabel = styled(BaseText).withConfig({
    displayName: 'TextFieldLabel'
}) `
  /* disabled */
  ${TextFieldLabelText}, ${TextFieldAssistiveText} {
    ${({ isDisabled, theme }) => isDisabled &&
    getColorStyles(theme, 'color', 'colors.interactive.base.dark')}
  }

  ${TextFieldIcon} {
    svg {
      ${({ theme }) => getInputFieldStyles(theme, 'disabled', 'icon')}
    }
  }

  /* leading-icon */
  ${TextFieldControlInput}, ${TextFieldControlTextarea} {
    ${styledProperty('hasInlineLabel', true, css `
        margin-top: 0;
        padding-top: ${calculateSpacing(3)};
      `)}
  }

  /* inline */
  ${TextFieldLabelText} {
    ${styledProperty('hasInlineLabel', true, css `
        ${getTypographyStyles('typography.definitions.utility.assistive-text')};
        position: absolute;
        z-index: 1;
        margin-left: 1px; /* to match the 1px left border of the input area */
        padding: ${calculateSpacing(1)} ${calculateSpacing(1)} 0;
      `)}
  }

  ${styledProperty('isActivated', true, textFieldLabelActivatedStyles)}
`;
TextFieldLabel.defaultProps = {
    as: 'label'
};
const TextFieldInputContainer = styled.div.withConfig({
    /* this helps to avoid styled-cc componentId collision */
    displayName: 'TextFieldInputContainer'
}) `
  position: relative;
  grid-column: 1;

  input[type='search'] {
    appearance: none;
  }
`;
const TextFieldDataList = styled.datalist.withConfig({
    displayName: 'TextFieldDataList'
}) ``;
const TextFieldDataListOption = styled.option.withConfig({
    displayName: 'TextFieldDataListOption'
}) ``;
const TextFieldButton = styled(Button).withConfig({
    displayName: 'TextFieldButton'
}) `
  height: 48px;
  ${minMaxScreen(0, BREAKPOINTS.md)} {
    margin-top: ${calculateSpacing(1)};
  }

  /* mobile-hide */
  ${({ hideButtonInMobile }) => hideButtonInMobile &&
    `
    ${minMaxScreen(0, `${maxThresholds.md}px`)} {
      position: absolute;
      visibility: hidden;
    }
  `}

  ${({ theme, isInverted }) => isInverted &&
    `
      border-radius: 3px;
      ${getColorStyles(theme, 'background-color', 'colors.interactive.base.brand-secondary')};
      
      ${minScreen(BREAKPOINTS.md)} {
        margin-left: ${calculateSpacing(1)};
      }

  `}
`;
const TextFieldErrorText = styled(BaseText).withConfig({
    displayName: 'TextFieldErrorText'
}) `
  grid-column: -1 / 1;
`;
TextFieldErrorText.defaultProps = {
    as: 'div',
    colorToken: 'colors.interactive.feedback.invalid-primary',
    topSpacing: 1,
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
const textFieldErrorStateStyles = css `
  ${TextFieldControlInput}, ${TextFieldControlTextarea} {
    ${({ theme }) => getInputFieldStyles(theme, 'invalid', 'background')}
    ${({ theme }) => getInputFieldStyles(theme, 'invalid', 'text')}
    ${({ theme }) => getInputFieldStyles(theme, 'invalid', 'border')}
  }

  ${TextFieldIcon} {
    svg {
      ${({ theme }) => getInputFieldStyles(theme, 'invalid', 'icon')}
    }
  }

  ${({ hasAttachedButton, isAlwaysStacked }) => hasAttachedButton &&
    !isAlwaysStacked &&
    `
    ${minScreen(BREAKPOINTS.md)} {
      grid-column: 1 / span 2;
    }
  `}
`;
const textFieldAttachedButtonStyles = css `
  ${minMaxScreen(0, BREAKPOINTS.md)} {
    grid-template-columns: auto ${calculateSpacing(14)};
    align-items: end;
  }

  ${TextFieldButton} {
    margin-top: 0;
    ${minMaxScreen(0, BREAKPOINTS.md)} {
      min-width: unset;
    }
  }
`;
const TextFieldWrapper = styled.span.withConfig({
    displayName: 'TextFieldWrapper'
}) `
  display: grid;
  margin-bottom: ${calculateSpacing(2)};

  ${minScreen(BREAKPOINTS.md)} {
    ${({ shouldUseAlternativeStyle }) => shouldUseAlternativeStyle && `margin-bottom: ${calculateSpacing(3)};`}
  }

  /* hasAttachedButton */
  ${({ hasAttachedButton, isAlwaysStacked }) => !isAlwaysStacked && hasAttachedButton
    ? `
    ${minScreen(BREAKPOINTS.md)} {
      grid-template-columns: 1fr auto;
      align-items: end;
    }
  `
    : ''}
  ${({ hasAttachedButtonForMobile }) => hasAttachedButtonForMobile &&
    `
    ${maxScreen(BREAKPOINTS.md)} {
      grid-template-columns: 1fr auto;
      align-items: end;
    }`}

  ::placeholder {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.dark')};
  }

  ${({ hasAttachedButton, isNeverStacked }) => hasAttachedButton && isNeverStacked ? textFieldAttachedButtonStyles : ''};

  /* error */
  ${styledProperty('hasErrorState', true, textFieldErrorStateStyles)}
  /* alternative-style */

  ${TextFieldLabelText} {
    ${({ hasAttachedButton, isAlwaysStacked }) => !isAlwaysStacked && hasAttachedButton
    ? `
      ${minScreen(BREAKPOINTS.md)} {
          grid-column: span 2;
      }
    `
    : ''}
  }

  ${TextFieldErrorText} {
    ${({ hasAttachedButton, isAlwaysStacked }) => !isAlwaysStacked && hasAttachedButton
    ? `
      ${minScreen(BREAKPOINTS.md)} {
        grid-column: 1 / span 2;
      }
    `
    : ''}
  }
`;
const TextFieldErrorSuggestion = styled(BaseLink).withConfig({
    displayName: 'TextFieldErrorSuggestion'
}) `
  text-decoration: underline;

  :hover {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.feedback.invalid-primary')};
  }
`;
TextFieldErrorSuggestion.defaultProps = {
    colorToken: 'colors.interactive.feedback.invalid-primary',
    typeIdentity: 'typography.definitions.utility.assistive-text'
};
module.exports = {
    TextFieldWrapper,
    TextFieldLabel,
    TextFieldLabelText,
    TextFieldInputContainer,
    TextFieldControlInput,
    TextFieldControlTextarea,
    TextFieldIcon,
    TextFieldDataList,
    TextFieldDataListOption,
    TextFieldButton,
    TextFieldAssistiveText,
    TextFieldErrorText,
    TextFieldErrorSuggestion
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 31492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    multiLineErrorText: {
        id: 'TextField.MultiLineErrorText',
        defaultMessage: 'Use at least _MIN_ characters and a maximum of _MAX_.',
        description: 'Text error for multiline'
    },
    multiLineUpperLimitErrorText: {
        id: 'TextField.multiLineUpperLimitErrorText',
        defaultMessage: 'Use maximum of _MAX_ characters only',
        description: 'Text error for multiline if only max limit is provided'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 13510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const withInvalidElementMapping = __webpack_require__(63050);
const TextField = __webpack_require__(2547);
const TextFieldWithInvalidElements = withInvalidElementMapping(TextField);
TextField.SingleLine = asVariation(TextFieldWithInvalidElements, 'SingleLine', {
    inputType: 'single-line'
});
TextField.MultiLine = asVariation(TextFieldWithInvalidElements, 'MultiLine', {
    inputType: 'multi-line'
});
TextField.MultiLineWithCharacterDefault = asVariation(TextFieldWithInvalidElements, 'MultiLineWithCharacterDefault', {
    inputType: 'multi-line',
    itemType: 'character',
    messageType: 'default'
});
TextField.MultiLineWithCharacterMinCount = asVariation(TextFieldWithInvalidElements, 'MultiLineWithCharacterMinCount', {
    inputType: 'multi-line',
    itemType: 'character',
    messageType: 'withMinCountLimit'
});
module.exports = TextField;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 15956:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseText } = __webpack_require__(76955);
const { BREAKPOINTS } = __webpack_require__(96472);
const { getTypographyStyles, calculateSpacing, getColorStyles, maxScreen } = __webpack_require__(26865);
const { maxThresholds } = __webpack_require__(99906);
const Button = __webpack_require__(73730);
const getBaseFlexSettings = () => `
display: flex;
flex-direction: column;
align-items: start;
justify-content: space-between;
  @media (min-width: ${BREAKPOINTS.md}) {
    flex-direction: column;
  }
`;
const getBaseFlexSettingsforWrapper = () => `
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;

  @media (min-width: ${BREAKPOINTS.md}) {
    flex-direction: row;
  }
`;
const ToutWrapper = styled.section.withConfig({
    displayName: 'ToutWrapper'
}) `
  ${getBaseFlexSettingsforWrapper()}

  margin-top: ${calculateSpacing(4)};
`;
const ToutText = styled.span.withConfig({ displayName: 'ToutText' }) `
  ${getBaseFlexSettings()}
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.foundation.link-primary')}
  margin-right: ${calculateSpacing(3)};
`;
const ToutHed = styled(BaseText).withConfig({ displayName: 'ToutHed' }) `
  padding-top: ${calculateSpacing(2)};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.globalEditorial.context-primary')};
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.context-tertiary')};
  @media (min-width: ${BREAKPOINTS.md}) {
    padding-top: ${calculateSpacing(2)};
  }
`;
const ToutDek = styled.div.withConfig({ displayName: 'ToutDek' }) `
  margin-top: ${calculateSpacing(1)};
  ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.description-core')};
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.context-tertiary')};
  @media (min-width: ${BREAKPOINTS.md}) {
    margin-top: ${calculateSpacing(1)};
  }

  p {
    margin-top: 0;
  }
`;
const ToutButton = styled(Button).withConfig({ displayName: 'ToutButton' }) `
  margin-top: ${calculateSpacing(2)};
  margin-bottom: ${calculateSpacing(2)};
  ${maxScreen(`${maxThresholds.md}px`)} {
    width: 100%;
  }
`;
module.exports = {
    ToutHed,
    ToutDek,
    ToutText,
    ToutWrapper,
    ToutButton
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 5344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const isEmpty = __webpack_require__(62193);
const { extractConsentGroups, hasTargetConsentFromCookie } = __webpack_require__(14307);
const { encodeAffiliateLink, extractTrackingParameters } = __webpack_require__(25203);
const { getCookie } = __webpack_require__(56892);
const XID_COOKIE_KEY = 'CN_xid';
const AMG_UUID_KEY = 'amg_user_partner';
/**
 * Resolves seller name information and determines Amazon-specific behavior
 * @param {string|null|undefined} sellerName - The seller name to analyze
 * @returns {object} Object containing seller analysis results
 * @returns {boolean} returns.isAmazonSeller - Whether the seller is Amazon
 * @returns {boolean} returns.showAmazonDiscount - Whether to show Amazon discount (same as isAmazonSeller)
 *
 * @example
 * resolveSellerName('Amazon.com') // { isAmazonSeller: true, showAmazonDiscount: true }
 * resolveSellerName('Best Buy') // { isAmazonSeller: false, showAmazonDiscount: false }
 * resolveSellerName(null) // { isAmazonSeller: false, showAmazonDiscount: false }
 */
const resolveSellerName = (sellerName) => {
    const normalizedSellerName = sellerName?.toLowerCase() || '';
    const isAmazonSeller = normalizedSellerName.includes('amazon');
    return {
        isAmazonSeller,
        showAmazonDiscount: isAmazonSeller
    };
};
const currencySymbols = {
    USD: '$',
    EUR: '',
    GBP: '',
    INR: '',
    JPY: '',
    TWD: 'NT$',
    PHP: '',
    PLN: 'z',
    KRW: '',
    UAH: '',
    VND: '',
    MXN: 'Mex$'
};
const escapeRegExp = (string) => typeof string === 'string'
    ? string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    : '';
/**
 * Normalize currency display if price already contains a currency symbol.
 *
 * @param {string} currency - The currency code (e.g., "USD", "INR").
 * @param {string|number} price - The price (can be string or number).
 * @returns {string} - Returns '' if symbol is in price, otherwise returns currency code.
 */
const normalizeOfferCurrency = (currency, price) => {
    if (typeof currency !== 'string')
        return '';
    const trimmedCurrency = currency.trim().toUpperCase();
    const symbol = currencySymbols[trimmedCurrency];
    // Safely convert price to string, or fallback to empty string
    let priceStr = '';
    if (typeof price === 'string') {
        priceStr = price.trim();
    }
    else if (typeof price === 'number') {
        priceStr = String(price);
    }
    if (!priceStr || !symbol) {
        return trimmedCurrency;
    }
    const safeRegex = new RegExp(`^\\s*${escapeRegExp(symbol)}`);
    if (safeRegex.test(priceStr)) {
        return '';
    }
    return trimmedCurrency;
};
const validateAndTransformOffers = (url, offers = []) => {
    const offerArr = [];
    const offerObj = {
        comparisonPrice: null,
        currency: 'USD',
        price: null,
        purchaseUri: url,
        sellerName: '',
        shortUrl: ''
    };
    if (offers.length > 0) {
        offers.forEach((offer) => {
            const offerObj = {
                comparisonPrice: 'comparisonPrice' in offer ? offer.comparisonPrice : null,
                currency: 'currency' in offer ? offer.currency : 'USD',
                price: 'price' in offer ? offer.price : null,
                purchaseUri: 'purchaseUri' in offer && offer.purchaseUri.length > 0
                    ? offer.purchaseUri
                    : url,
                sellerName: 'sellerName' in offer ? offer.sellerName : '',
                shortUrl: 'shortUrl' in offer ? offer.shortUrl : ''
            };
            if ('offerUrl' in offer) {
                offerObj.shortUrl = offerObj.purchaseUri;
                offerObj.purchaseUri = offer.offerUrl;
            }
            const transformedOffer = { ...offer, ...offerObj };
            // Normalize currency if price already contains currency symbol
            if (transformedOffer.price && transformedOffer.currency) {
                transformedOffer.currency = normalizeOfferCurrency(transformedOffer.currency, transformedOffer.price.toString());
            }
            const { showAmazonDiscount } = resolveSellerName(transformedOffer.sellerName);
            transformedOffer.showAmazonDiscount = showAmazonDiscount;
            return offerArr.push(transformedOffer);
        });
    }
    else {
        offerArr.push(offerObj);
    }
    return offerArr;
};
// eslint-disable-next-line complexity
const getAffiliateData = ({ dropShipData, offer, type = 'embed' }) => {
    const { isDropshipProduct, dropShipSellers, data_item, contentId, showOfferUrl } = dropShipData;
    let isAffiliateProduct = true;
    let target = '_blank';
    let rel = 'noreferrer noopener sponsored';
    // For commerce products
    if (offer?.offerType === 'Dropship') {
        isAffiliateProduct = false;
    }
    else if (isDropshipProduct && dropShipSellers?.length) {
        isAffiliateProduct = dropShipSellers?.some((seller) => !offer.purchaseUri?.toLowerCase().includes(seller));
    }
    const cid = !isAffiliateProduct
        ? data_item.id || data_item.variantKey
        : contentId;
    // for usa brands we will be passing shortUrl for non-usa brands we will be using purchaseUri
    const offerUrlParams = `cid=${cid}`;
    let offerUrl = showOfferUrl ? offer.purchaseUri : offer.shortUrl;
    const encodeParams = { offerUrl: offer.purchaseUri };
    if (cid && !showOfferUrl) {
        encodeParams.origin = cid;
    }
    if (offerUrl?.indexOf('cna.st') > 0) {
        if (offer.xid)
            encodeParams.xid = offer.xid;
        if (offer.amguuid)
            encodeParams.amguuid = offer.amguuid;
    }
    // Extract tracking parameters for client-side encoding
    if (!isEmpty(encodeParams) && !showOfferUrl) {
        const trackingParams = extractTrackingParameters();
        encodeParams.extractedParams = trackingParams;
        offerUrl = encodeAffiliateLink(offerUrl, encodeParams);
    }
    if (offerUrl?.indexOf('?') > 0) {
        offerUrl = `${offerUrl}&${offerUrlParams}`;
    }
    else {
        offerUrl = !isAffiliateProduct
            ? `${offerUrl}#${offerUrlParams}`
            : `${offerUrl}?${offerUrlParams}`;
    }
    if (type === 'embed') {
        offerUrl = showOfferUrl ? offer.purchaseUri : offer.shortUrl;
        if (offerUrl?.indexOf('cna.st') > 0 &&
            !showOfferUrl &&
            !isEmpty(encodeParams)) {
            offerUrl = encodeAffiliateLink(offerUrl, encodeParams);
        }
    }
    if (!isAffiliateProduct) {
        target = '_self';
        rel = 'noopener';
    }
    return {
        offerUrl,
        target,
        rel,
        isAffiliateProduct
    };
};
const isEllipsisActive = (e) => e?.offsetWidth < e?.scrollWidth;
const getValueWithCurrency = (currency, value) => `${currencySymbols[currency]}${value}`;
const getXidAndAmguuid = () => {
    const cnXid = getCookie(XID_COOKIE_KEY);
    const amgUUID = getCookie(AMG_UUID_KEY);
    const cookieIds = {};
    if (extractConsentGroups() || (window && window.OnetrustActiveGroups)) {
        // check if user provides consent id C0004
        const hasConsent = hasTargetConsentFromCookie() ||
            window.OnetrustActiveGroups?.split(',').includes('C0004');
        if (hasConsent && cnXid) {
            cookieIds.xid = cnXid;
        }
        if (hasConsent && amgUUID) {
            cookieIds.amguuid = amgUUID;
        }
    }
    return cookieIds;
};
const checkImageCreditText = (images) => {
    return Array.isArray(images) && images.length > 0
        ? images.some((image) => image.credit !== '')
        : images?.credit && images?.credit !== '';
};
/**
 * Calculates metrics for a clip element including dimensions and visibility
 * @param {HTMLElement} clipElement - The DOM element containing the clip
 * @returns {object} Object containing width, height, progress_percent (scroll progress),
 *                   inview_percent (percentage of element visible in viewport),
 *                   and current_time (playback position of media)
 */
const getClipMetrics = (clipElement) => {
    try {
        const rect = clipElement.getBoundingClientRect();
        const width = rect.width || 0;
        const height = rect.height || 0;
        const windowHeight = window.innerHeight;
        const visibleTop = Math.max(rect.top, 0);
        const visibleBottom = Math.min(rect.bottom, windowHeight);
        const visibleHeight = Math.max(visibleBottom - visibleTop, 0);
        const inviewPercent = rect.height ? (visibleHeight / rect.height) * 100 : 0;
        const scrollProgress = windowHeight - rect.top;
        const totalScrollable = windowHeight + rect.height;
        const progressPercent = totalScrollable
            ? (scrollProgress / totalScrollable) * 100
            : 0;
        let currentTime = null;
        const media = clipElement.querySelector('video');
        if (media) {
            ({ currentTime } = media);
        }
        return {
            width,
            height,
            progressPercent,
            inviewPercent,
            currentTime
        };
    }
    catch (error) {
        return {
            width: 0,
            height: 0,
            progressPercent: 0,
            inviewPercent: 0,
            currentTime: null
        };
    }
};
module.exports = {
    resolveSellerName,
    validateAndTransformOffers,
    currencySymbols,
    getAffiliateData,
    isEllipsisActive,
    getValueWithCurrency,
    getXidAndAmguuid,
    checkImageCreditText,
    getClipMetrics,
    normalizeOfferCurrency,
    escapeRegExp
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 43651:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { UtilityCardContent, UtilityCardWrapper, UtilityCardDek, UtilityCardHed } = __webpack_require__(99411);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * UtilityCard component
 *
 * @param {object} props - React props
 * @param {ReactElement} [props.children] - Optional React children
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dangerousDek] - Optional card dangerousDek
 * @param {string} [props.dangerousHed] - Optional card dangerousHed
 * @param {boolean} [props.shouldUseAlternateProfilePageStyle] - Whether component has alternate profile page styles
 * @param {boolean} [props.shouldUseAlternativeStyle] - Whether component has alternative styles
 * @param {boolean}[props.hasTopPadding] - optional style
 * @param {object} [props.variations] - Optional variations object
 * @param {string} [props.variations.contentAlign] - Optional content alignment ['left', 'right', 'center']
 * @param {string} [props.variations.hasBorder] - Optional border [true, false]
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 *
 * @returns {ReactElement} <div>
 */
const UtilityCard = ({ children, className, dangerousDek, dangerousHed, shouldUseAlternateProfilePageStyle, shouldUseAlternativeStyle = false, hasTopPadding, variations = {
    contentAlign: 'center',
    hasBorder: false
}, variationName }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'UtilityCard',
            variation: variationName
        });
    }, [variationName]);
    return (React.createElement(UtilityCardWrapper, { "data-testid": "UtilityCardWrapper", className: classnames('utility-card', className), hasBorder: variations.hasBorder, contentAlign: variations.contentAlign, shouldUseAlternativeStyle: shouldUseAlternativeStyle, hasTopPadding: hasTopPadding },
        dangerousHed && (React.createElement(UtilityCardHed, { className: "utility-card__hed", dangerouslySetInnerHTML: { __html: dangerousHed } })),
        dangerousDek && (React.createElement(UtilityCardDek, { className: "utility-card__dek", dangerouslySetInnerHTML: { __html: dangerousDek } })),
        React.createElement(UtilityCardContent, { className: "utility-card__content", shouldUseAlternateProfilePageStyle: shouldUseAlternateProfilePageStyle }, children)));
};
UtilityCard.propTypes = {
    children: PropTypes.node,
    className: PropTypes.string,
    dangerousDek: PropTypes.string,
    dangerousHed: PropTypes.string,
    hasTopPadding: PropTypes.bool,
    shouldUseAlternateProfilePageStyle: PropTypes.bool,
    shouldUseAlternativeStyle: PropTypes.bool,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        contentAlign: PropTypes.oneOf(['center', 'left', 'right']),
        hasBorder: PropTypes.oneOf([true, false])
    })
};
UtilityCard.displayName = 'UtilityCard';
module.exports = UtilityCard;
//# sourceMappingURL=UtilityCard.js.map

/***/ }),

/***/ 60521:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(93015);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99411:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { DiscoverySelectionControlHed } = __webpack_require__(69741);
const { BaseText, BaseWrap } = __webpack_require__(76955);
const { calculateSpacing, getColorStyles, getTypographyStyles } = __webpack_require__(26865);
const utilityCardBorder = `1px solid`;
const UtilityCardContent = styled.div.withConfig({
    displayName: 'UtilityCardContent'
}) `
  ${(props) => props.shouldUseAlternateProfilePageStyle &&
    `
      width: 100%;
    `}
`;
const UtilityCardDek = styled(BaseWrap).withConfig({
    displayName: 'UtilityCardDek'
}) `
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.description')};

  p {
    ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.description-feature')};
  }

  a {
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.discovery.body.white.accent')};
  }
`;
UtilityCardDek.defaultProps = {
    as: 'div',
    bottomSpacing: calculateSpacing(2),
    topSpacing: calculateSpacing(2)
};
const UtilityCardHed = styled(BaseText).withConfig({
    displayName: 'UtilityCardHed'
}) `
  margin: 0 0 ${calculateSpacing(2)};
`;
UtilityCardHed.defaultProps = {
    as: 'h2',
    colorToken: 'colors.discovery.body.white.heading',
    typeIdentity: 'typography.definitions.discovery.subhed-section-secondary'
};
const contentAlignStyles = (contentAlign) => `
  ${UtilityCardDek}, ${UtilityCardHed} {
    text-align: ${contentAlign}
  }
`;
const alternativeStyles = () => `
  &:not(.account-subscription-box) {
    background: transparent;
    padding: ${calculateSpacing(6)} 0 0;

    > ${UtilityCardContent} {
      .account-newsletter-check-boxes {
        ${UtilityCardDek} {
          display: none;
        }

        ${DiscoverySelectionControlHed} {
          ${({ theme }) => getTypographyStyles(theme, 'typography.definitions.discovery.description-feature')};
        }
      }
    }
`;
const UtilityCardWrapper = styled(BaseWrap).withConfig({
    displayName: 'UtilityCardWrapper'
}) `
  ${({ theme }) => getColorStyles(theme, 'background', 'colors.discovery.body.white.background')};
  padding: ${calculateSpacing(4)};

  ${({ shouldUseAlternativeStyle }) => shouldUseAlternativeStyle && alternativeStyles()};

  ${({ contentAlign }) => contentAlignStyles(contentAlign)};

  ${({ theme, hasBorder }) => hasBorder
    ? `
        border-top: ${utilityCardBorder};
        ${getColorStyles(theme, 'border-color', 'colors.discovery.body.white.accent')}`
    : 'none'};
  ${({ hasTopPadding }) => hasTopPadding === true &&
    `
      padding-top: ${calculateSpacing(3, 'px')};
    `}
`;
module.exports = {
    UtilityCardContent,
    UtilityCardWrapper,
    UtilityCardDek,
    UtilityCardHed
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 93015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const UtilityCard = __webpack_require__(43651);
UtilityCard.HasBorder = asVariation(UtilityCard, 'HasBorder', {
    hasBorder: true
});
UtilityCard.ContentLeft = asVariation(UtilityCard, 'ContentLeft', {
    contentAlign: 'left'
});
module.exports = UtilityCard;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 36857:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsentProvider = exports.ConsentConsumer = exports.ConsentContext = void 0;
const react_1 = __importStar(__webpack_require__(96540));
const prop_types_1 = __importDefault(__webpack_require__(5556));
const cn_snowplow_web_1 = __webpack_require__(43954);
const findLast_1 = __importDefault(__webpack_require__(20681));
const utils_1 = __webpack_require__(64687);
const snowplow_tracking_1 = __webpack_require__(14307);
const fidesFunctions_1 = __webpack_require__(65592);
const tools_1 = __webpack_require__(34854);
const { getCookie } = __webpack_require__(56892);
exports.ConsentContext = react_1.default.createContext(utils_1.CONSENT_FALSE);
exports.ConsentConsumer = exports.ConsentContext.Consumer;
const useFidesCnBusBridge = () => {
    (0, react_1.useEffect)(() => {
        const emitCnConsentUpdated = () => {
            window.cnBus?.emit('consent.updated');
        };
        window.addEventListener('FidesInitialized', emitCnConsentUpdated);
        window.addEventListener('FidesUpdated', emitCnConsentUpdated);
        if (window.Fides?.initialized) {
            emitCnConsentUpdated();
        }
        return () => {
            window.removeEventListener('FidesInitialized', emitCnConsentUpdated);
            window.removeEventListener('FidesUpdated', emitCnConsentUpdated);
        };
    }, []);
};
const ConsentProvider = ({ children, isEnabled = true }) => {
    const [cmpLoaded, setCmpLoaded] = (0, react_1.useState)(false);
    const [updatedGroups, setUpdatedGroups] = (0, react_1.useState)(null);
    const [preservedGroups, setPreservedGroups] = (0, react_1.useState)(null);
    const enhancedConsentTracker = (optanonAction, activeGroups, optanonLabel) => {
        const label = optanonLabel
            ? `${optanonAction}: ${optanonLabel}`
            : optanonAction;
        const clickInfoEntity = [
            {
                schema: 'iglu:com.condenast/click_info/jsonschema/2-0-0',
                data: {
                    click_text: label
                }
            }
        ];
        switch (optanonAction) {
            case 'Banner Accept Cookies':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentAllow', activeGroups, clickInfoEntity);
                break;
            case 'Banner Reject All':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentDeny', activeGroups, clickInfoEntity);
                break;
            case 'Preferences Allow All':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentAllow', activeGroups, clickInfoEntity);
                break;
            case 'Preferences Reject All':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentDeny', activeGroups, clickInfoEntity);
                break;
            case 'Banner - Continue without Accepting':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentDeny', activeGroups, clickInfoEntity);
                break;
            case 'Preferences Save Settings':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentSelected', activeGroups, clickInfoEntity);
                break;
            case 'withdrawn':
                (0, cn_snowplow_web_1.callEnhancedConsent)('trackConsentWithdrawn', activeGroups, clickInfoEntity);
                break;
            default:
                break;
        }
    };
    (0, react_1.useEffect)(() => {
        if (cmpLoaded) {
            window.cnBus?.emit('user.context.oneTrustLoaded');
            if (window.Fides) {
                const bannerShownEvents = (window.dataLayer ?? []).filter((event) => (0, tools_1.wasFidesBannerShownGtmEvent)(event));
                if (bannerShownEvents.length > 0) {
                    (0, cn_snowplow_web_1.callSnowplow)('trackCmpVisible', {
                        elapsedTime: bannerShownEvents[0].Fides.timestamp
                    });
                }
            }
            else {
                (0, cn_snowplow_web_1.callSnowplow)('trackCmpVisible', {
                    elapsedTime: performance.now()
                });
            }
        }
    }, [cmpLoaded]);
    useFidesCnBusBridge();
    (0, react_1.useEffect)(() => {
        const olderGroups = (0, snowplow_tracking_1.getConsentGroups)();
        setPreservedGroups(olderGroups);
    }, []); /* eslint-disable-line react-hooks/exhaustive-deps */
    (0, react_1.useEffect)(() => {
        if (updatedGroups) {
            const { dataLayer, Fides } = window;
            if (Fides) {
                (0, fidesFunctions_1.sendUpdateToEnhancedConsentTracker)(dataLayer, preservedGroups, updatedGroups, enhancedConsentTracker, setPreservedGroups);
            }
            else {
                const optEvent = (0, findLast_1.default)(dataLayer, (event) => event?.[2]?.optanonAction || event?.optanonAction);
                if (preservedGroups) {
                    const groupRevoked = preservedGroups.some((preservedGroup) => updatedGroups.indexOf(preservedGroup) <= -1);
                    const otAction = optEvent?.[2]?.optanonAction || optEvent?.optanonAction;
                    const otLabel = optEvent?.[2]?.optanonLabel || optEvent?.optanonLabel;
                    if (groupRevoked &&
                        otAction &&
                        !otAction.toLowerCase().includes('reject')) {
                        enhancedConsentTracker('withdrawn', updatedGroups, otAction);
                    }
                    else {
                        enhancedConsentTracker(otAction, updatedGroups, otLabel);
                    }
                    setPreservedGroups(updatedGroups);
                }
            }
        }
    }, [updatedGroups]); /* eslint-disable-line react-hooks/exhaustive-deps */
    const handleDataLayerPush = (0, react_1.useCallback)((event) => {
        setTimeout(() => {
            if (window.Fides) {
                (0, fidesFunctions_1.sendFidesEventToSnowplow)(event, setUpdatedGroups);
                const dataLayerHasBannerShownEvent = () => window.dataLayer.filter((event) => (0, tools_1.wasFidesBannerShownGtmEvent)(event))
                    .length > 0;
                setCmpLoaded((0, tools_1.wasFidesBannerShownGtmEvent)(event) || dataLayerHasBannerShownEvent());
            }
            else {
                const otActiveGroups = (0, snowplow_tracking_1.extractConsentGroups)()?.split(',') ||
                    window.OnetrustActiveGroups?.split(',')?.slice(1, -1);
                // OT Behavior
                const optanonAction = event[2]?.optanonAction || event?.optanonAction;
                const optanonLabel = event[2]?.optanonLabel || event?.optanonLabel;
                // tracking cmp_visible event
                if (!getCookie('OptanonAlertBoxClosed') &&
                    window.OneTrust &&
                    window.OneTrust.GetDomainData) {
                    const { IsBannerLoaded, ShowAlertNotice } = window.OneTrust.GetDomainData();
                    if (!optanonAction &&
                        !cmpLoaded &&
                        IsBannerLoaded &&
                        ShowAlertNotice) {
                        setCmpLoaded(true);
                    }
                }
                // tracking consent preferences event
                if (event.event === 'OneTrustGroupsUpdated' &&
                    event.OnetrustActiveGroups) {
                    setUpdatedGroups(otActiveGroups);
                }
                if (optanonAction) {
                    const label = optanonLabel
                        ? `${optanonAction}: ${optanonLabel}`
                        : optanonAction;
                    (0, snowplow_tracking_1.trackCookiesEvent)(label);
                    (0, snowplow_tracking_1.nonURLClickEvent)(label, null, 'click', 'consent_preferences');
                }
            }
        }, 1);
    }, []); /* eslint-disable-line react-hooks/exhaustive-deps */
    (0, react_1.useEffect)(() => {
        if (Array.isArray(window.dataLayer)) {
            window.dataLayer.push = function (...event) {
                Array.prototype.push.apply(this, event);
                handleDataLayerPush.apply(this, event);
            };
        }
    }, [handleDataLayerPush]);
    let defaultConsentState;
    if (isEnabled) {
        // window not available yet, so we can't determine if Fides is cmp on window.
        // But it will fail to find Onetrust if Fides is present, and will return false, as desired
        defaultConsentState = (0, utils_1.getConsentStateFromCookie)();
    }
    else {
        // If consent has been disabled, we want to pretend that the user has
        // consented to everything.
        defaultConsentState = { ...utils_1.CONSENT_TRUE };
    }
    // Fides if window.Fides exists, otherwise oneTrust
    const [consentState, setConsentState] = (0, react_1.useState)(defaultConsentState);
    const useFidesConsentContextOnInit = () => {
        (0, react_1.useEffect)(() => {
            const updateWithFidesConsent = () => {
                if (window.Fides) {
                    // Map Fides keys to existing OneTrust keys for consuming child components and applications
                    const fidesConsent = (0, utils_1.transformFidesValues)(window.Fides.consent, (consentKey) => utils_1.FIDES_TO_ONETRUST_MAPPING[consentKey]) || defaultConsentState;
                    setConsentState({ ...defaultConsentState, ...fidesConsent });
                }
            };
            window.addEventListener('FidesInitialized', updateWithFidesConsent);
            if (window.Fides?.initialized) {
                updateWithFidesConsent();
            }
            return () => {
                window.removeEventListener('FidesInitialized', updateWithFidesConsent);
            };
        }, []);
    };
    useFidesConsentContextOnInit();
    const onConsentCallback = (0, react_1.useCallback)((event) => {
        if (isEnabled) {
            // I don't trust OneTrust to not change this to be something else
            if (Array.isArray(event?.detail) || event?.detail?.consent) {
                // If Fides, pass Fides flag to get correct consent and map appropriately
                setConsentState({
                    ...defaultConsentState,
                    ...(0, utils_1.getConsentStateFromList)(event.detail, window?.Fides && utils_1.FIDES_IDENTIFIER)
                });
                // setLastConsentEvent(transformConsentEvent(event, window?.Fides && FIDES_IDENTIFIER))
            }
            else {
                // No consent informatiom in event, check cookies.
                // If Fides, pass Fides flag to query for Fides cookie
                setConsentState({
                    ...defaultConsentState,
                    ...(0, utils_1.getConsentStateFromCookie)(window?.Fides && utils_1.FIDES_IDENTIFIER)
                });
            }
        }
    }, [isEnabled, defaultConsentState]);
    (0, utils_1.useConsentUpdatedCallback)(onConsentCallback);
    return (react_1.default.createElement(exports.ConsentContext.Provider, { value: consentState }, children));
};
exports.ConsentProvider = ConsentProvider;
exports.ConsentProvider.displayName = 'ConsentProvider';
exports.ConsentProvider.propTypes = {
    children: prop_types_1.default.node.isRequired,
    isEnabled: prop_types_1.default.bool
};
//# sourceMappingURL=ConsentProvider.js.map

/***/ }),

/***/ 65592:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendUpdateToEnhancedConsentTracker = exports.sendFidesEventToSnowplow = void 0;
const findLast_1 = __importDefault(__webpack_require__(20681));
const snowplow_tracking_1 = __webpack_require__(14307);
const tools_1 = __webpack_require__(34854);
const sharedToggleFormat = [
    'tcf_special_feature',
    'tcf_purpose_consent',
    'tcf_purpose_legitimate_interest',
    'tcf_vendor_legitimate_interest',
    'tcf_vendor_consent'
];
const sendFidesEventToSnowplow = (event, setUpdatedGroups) => {
    if (event.event === 'FidesUpdated') {
        const lastFidesUIShownEvent = (0, findLast_1.default)(window.dataLayer, (event) => event.event === 'FidesUIShown');
        let methodMap = {};
        if (lastFidesUIShownEvent?.Fides?.extraDetails?.servingComponent?.endsWith('banner') ??
            false) {
            methodMap = {
                reject: 'Banner Reject All',
                accept: 'Banner Accept Cookies',
                dismiss: 'Banner - Continue without Accepting'
            };
        }
        else {
            methodMap = {
                reject: 'Preferences Reject All',
                save: 'Preferences Save Settings',
                accept: 'Preferences Allow All'
            };
        }
        const consentMethod = event?.Fides?.extraDetails?.consentMethod;
        const eventLabel = methodMap[consentMethod] || null;
        setUpdatedGroups((0, snowplow_tracking_1.extractConsentGroups)()?.split(','));
        if (eventLabel) {
            (0, snowplow_tracking_1.trackCookiesEvent)(eventLabel);
            (0, snowplow_tracking_1.nonURLClickEvent)(eventLabel, null, 'click', 'consent_preferences');
        }
    }
    if (event.event === 'FidesUIChanged' && event.Fides.extraDetails?.trigger) {
        const { trigger, preference } = event.Fides.extraDetails;
        if (trigger.type !== 'toggle') {
            return;
        }
        let eventLabel = `Toggle ${trigger.checked ? 'On' : 'Off'}`;
        if (preference.type === 'notice') {
            let noticeKey = preference.key;
            if ((preference.key ?? '').startsWith('pri_')) {
                const privacyNoticesRelatedToToggle = window.Fides.experience.privacy_notices.filter((notice) => notice.id === preference.key) ?? [];
                const notice = privacyNoticesRelatedToToggle[0];
                noticeKey = notice?.notice_key ?? noticeKey;
            }
            const otCategory = tools_1.fidesToOtKeyMap[noticeKey];
            eventLabel = `Preferences ${eventLabel}: ${trigger.label}: ${otCategory}`;
        }
        else if (sharedToggleFormat.includes(preference.type)) {
            eventLabel = `Preferences ${eventLabel}: ${trigger.label} ${preference.type} ${preference.key}`;
        }
        (0, snowplow_tracking_1.trackCookiesEvent)(eventLabel);
        (0, snowplow_tracking_1.nonURLClickEvent)(eventLabel, null, 'click', 'consent_preferences');
    }
};
exports.sendFidesEventToSnowplow = sendFidesEventToSnowplow;
const sendUpdateToEnhancedConsentTracker = (dataLayer, preservedGroups, updatedGroups, enhancedConsentTracker, setPreservedGroups) => {
    const lastFidesUpdatedEvent = (0, findLast_1.default)(dataLayer, (event) => event.event === 'FidesUpdated');
    // This lookup could be removed. If the UI
    // serving component was on the FidesUpdat(ed|ing) event
    const lastFidesUIShownEvent = (0, findLast_1.default)(dataLayer, (event) => event.event === 'FidesUIShown');
    if (preservedGroups) {
        const groupRevoked = preservedGroups.some((preservedGroup) => updatedGroups.indexOf(preservedGroup) <= -1);
        const consentMethod = lastFidesUpdatedEvent?.Fides?.extraDetails?.consentMethod ??
            'NO_CONSENT_METHOD';
        if (groupRevoked && consentMethod !== 'reject') {
            enhancedConsentTracker('withdrawn', updatedGroups, consentMethod); // We really want this event to be what button it was.
        }
        else {
            let convertedMethod = consentMethod;
            if (lastFidesUIShownEvent.Fides.extraDetails?.servingComponent?.endsWith('banner') ??
                false) {
                const methodMap = {
                    reject: 'Banner Reject All',
                    accept: 'Banner Accept Cookies',
                    dismiss: 'Banner - Continue without Accepting'
                };
                convertedMethod = methodMap[consentMethod];
            }
            else {
                const methodMap = {
                    reject: 'Preferences Reject All',
                    save: 'Preferences Save Settings',
                    accept: 'Preferences Allow All'
                };
                convertedMethod = methodMap[consentMethod];
            }
            enhancedConsentTracker(convertedMethod, updatedGroups); // Fides still needs to forward a label here potentially.
        }
        setPreservedGroups(updatedGroups);
    }
};
exports.sendUpdateToEnhancedConsentTracker = sendUpdateToEnhancedConsentTracker;
//# sourceMappingURL=fidesFunctions.js.map

/***/ }),

/***/ 85438:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsentProvider = exports.ConsentConsumer = exports.ConsentContext = void 0;
var ConsentProvider_1 = __webpack_require__(36857);
Object.defineProperty(exports, "ConsentContext", ({ enumerable: true, get: function () { return ConsentProvider_1.ConsentContext; } }));
Object.defineProperty(exports, "ConsentConsumer", ({ enumerable: true, get: function () { return ConsentProvider_1.ConsentConsumer; } }));
Object.defineProperty(exports, "ConsentProvider", ({ enumerable: true, get: function () { return ConsentProvider_1.ConsentProvider; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 64687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { useEffect, useRef } = __webpack_require__(96540);
const { getCookie } = __webpack_require__(56892);
// "Legacy" consent was using 1:1 whereas newer consent is using C0001:1. Using
// the legacy approach will cover both cases.
const ONETRUST_GROUPING = {
    STRICTLY_NECESSARY: '1:1',
    PERFORMANCE: '2:1',
    FUNCTIONAL: '3:1',
    TARGETING: '4:1',
    SOCIAL_MEDIA: '5:1',
    AUDIENCE_MEASUREMENT: '9:1'
};
const ONETRUST_CONSENT_MAP = {
    C0001: 'strictlyNecessary',
    C0002: 'performance',
    C0003: 'functional',
    C0004: 'targeting',
    C0005: 'socialMedia',
    C0009: 'audienceMeasurement'
};
const FIDES_TO_ONETRUST_MAPPING = {
    analytics: 'performance',
    audience_measurement: 'audienceMeasurement',
    essential: 'strictlyNecessary',
    functional: 'functional',
    sales_sharing_targeted_advertising: 'targeting',
    social_media: 'socialMedia'
};
const CONSENT_FALSE = {
    strictlyNecessary: false,
    performance: false,
    functional: false,
    targeting: false,
    socialMedia: false,
    audienceMeasurement: false
};
const CONSENT_TRUE = {
    strictlyNecessary: true,
    performance: true,
    functional: true,
    targeting: true,
    socialMedia: true,
    audienceMeasurement: true
};
const ONETRUST_COOKIE = 'OptanonConsent';
const FIDES_COOKIE = 'fides_consent';
const FIDES_IDENTIFIER = 'fides';
function transformFidesValues(consentValues, transformFn) {
    if (!consentValues) {
        return null;
    }
    return Object.keys(consentValues).reduce((acc, key) => {
        acc[transformFn(key)] = consentValues[key];
        return acc;
    }, {});
}
function hasFidesConsent(consentType) {
    const cookieValue = getCookie(FIDES_COOKIE);
    if (cookieValue === '') {
        return typeof document === 'undefined'; // returning true in case of server rendering to make items crawable, matching hasOneTrustConsent function
    }
    const re = new RegExp(`"consent":\\s*\\{[^}]*"${consentType}":\\s*(true|false)`, 'gi');
    const match = re.exec(cookieValue);
    return match ? match[1] === 'true' : null; // Returns true, false, or null if not found
}
function hasOnetrustConsent(consentType) {
    if (!Object.hasOwnProperty.call(ONETRUST_GROUPING, consentType))
        return false;
    const cookieValue = getCookie(ONETRUST_COOKIE);
    if (cookieValue === '') {
        return typeof document === 'undefined'; // returning true in case of server rendering to make items crawable
    }
    const onetrustCode = ONETRUST_GROUPING[consentType];
    const re = new RegExp(`groups=[^=]*${onetrustCode}`, 'gi');
    return re.test(cookieValue);
}
function hasStrictlyNecessaryConsent(cmp) {
    return cmp === FIDES_IDENTIFIER
        ? hasFidesConsent('essential')
        : hasOnetrustConsent('STRICTLY_NECESSARY');
}
function hasPerformanceConsent(cmp) {
    return cmp === FIDES_IDENTIFIER
        ? hasFidesConsent('analytics')
        : hasOnetrustConsent('PERFORMANCE');
}
function hasFunctionalConsent(cmp) {
    return cmp === FIDES_IDENTIFIER
        ? hasFidesConsent('functional')
        : hasOnetrustConsent('FUNCTIONAL');
}
function hasTargetingConsent(cmp) {
    return cmp === FIDES_IDENTIFIER
        ? hasFidesConsent('sales_sharing_targeted_advertising')
        : hasOnetrustConsent('TARGETING');
}
function hasSocialMediaConsent(cmp) {
    return cmp === FIDES_IDENTIFIER
        ? hasFidesConsent('social_media')
        : hasOnetrustConsent('SOCIAL_MEDIA');
}
function hasAudienceMeasurement(cmp) {
    return cmp === FIDES_IDENTIFIER
        ? hasFidesConsent('audience_measurement')
        : hasOnetrustConsent('AUDIENCE_MEASUREMENT');
}
function useConsentUpdatedCallback(handler) {
    const cachedHandler = useRef();
    useEffect(() => {
        cachedHandler.current = handler;
    }, [handler]);
    useEffect(() => {
        const onChange = (event) => {
            cachedHandler.current(event);
        };
        // This event fires for some sites
        window.addEventListener('optanonUpdated', onChange);
        window.addEventListener('FidesUpdated', onChange);
        // And this event fires for some others. Consistency is not one of
        // Onetrusts strengths.
        window.addEventListener('OneTrustGroupsUpdated', onChange);
        return () => {
            window.removeEventListener('optanonUpdated', onChange);
            window.removeEventListener('OneTrustGroupsUpdated', onChange);
            window.removeEventListener('FidesUpdated', onChange);
        };
    }, []);
}
function getConsentStateFromCookie(cmp) {
    return {
        strictlyNecessary: hasStrictlyNecessaryConsent(cmp),
        performance: hasPerformanceConsent(cmp),
        functional: hasFunctionalConsent(cmp),
        targeting: hasTargetingConsent(cmp),
        socialMedia: hasSocialMediaConsent(cmp),
        audienceMeasurement: hasAudienceMeasurement(cmp)
    };
}
function getConsentStateFromList(consentList, cmp) {
    let updatedConsentList = consentList;
    let state = { ...CONSENT_FALSE };
    if (cmp === FIDES_IDENTIFIER) {
        // Fides nests consent data inside of consent object - i.e. consent: { analytics: true, audience_measurement: true, ...}
        updatedConsentList = consentList.consent;
        state = transformFidesValues(updatedConsentList, (consentKey) => FIDES_TO_ONETRUST_MAPPING[consentKey]);
    }
    else {
        updatedConsentList.forEach((consent) => {
            if (Object.prototype.hasOwnProperty.call(ONETRUST_CONSENT_MAP, consent)) {
                state[ONETRUST_CONSENT_MAP[consent]] = true;
            }
        });
    }
    return state;
}
module.exports = {
    CONSENT_FALSE,
    CONSENT_TRUE,
    ONETRUST_GROUPING,
    FIDES_IDENTIFIER,
    FIDES_TO_ONETRUST_MAPPING,
    getConsentStateFromCookie,
    getConsentStateFromList,
    hasOnetrustConsent,
    hasStrictlyNecessaryConsent,
    hasPerformanceConsent,
    hasFunctionalConsent,
    hasTargetingConsent,
    hasSocialMediaConsent,
    transformFidesValues,
    useConsentUpdatedCallback
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 96461:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasScrolledProvider = exports.HasScrolledContext = void 0;
const prop_types_1 = __importDefault(__webpack_require__(5556));
const react_1 = __importStar(__webpack_require__(96540));
exports.HasScrolledContext = react_1.default.createContext(false);
const HasScrolledProvider = ({ children }) => {
    const [hasScrolled, setHasScrolled] = (0, react_1.useState)(false);
    (0, react_1.useEffect)(() => {
        let handleScroll = () => null;
        if (true) {
            handleScroll = () => {
                setHasScrolled(true);
                window.removeEventListener('scroll', handleScroll);
            };
            window.addEventListener('scroll', handleScroll, { passive: true });
        }
        return () => {
            if (true) {
                window.removeEventListener('scroll', handleScroll);
            }
        };
    }, []);
    return (react_1.default.createElement(exports.HasScrolledContext.Provider, { value: hasScrolled }, children));
};
exports.HasScrolledProvider = HasScrolledProvider;
exports.HasScrolledProvider.propTypes = {
    children: prop_types_1.default.node
};
exports.HasScrolledProvider.displayName = 'HasScrolledProvider';
//# sourceMappingURL=HasScrolledProvider.js.map

/***/ }),

/***/ 52064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HasScrolledProvider = exports.HasScrolledContext = exports.useHasScrolled = void 0;
var useHasScrolled_1 = __webpack_require__(35363);
Object.defineProperty(exports, "useHasScrolled", ({ enumerable: true, get: function () { return useHasScrolled_1.useHasScrolled; } }));
var HasScrolledProvider_1 = __webpack_require__(96461);
Object.defineProperty(exports, "HasScrolledContext", ({ enumerable: true, get: function () { return HasScrolledProvider_1.HasScrolledContext; } }));
Object.defineProperty(exports, "HasScrolledProvider", ({ enumerable: true, get: function () { return HasScrolledProvider_1.HasScrolledProvider; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 35363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useHasScrolled = void 0;
const react_1 = __webpack_require__(96540);
const HasScrolledProvider_1 = __webpack_require__(96461);
const useHasScrolled = () => (0, react_1.useContext)(HasScrolledProvider_1.HasScrolledContext);
exports.useHasScrolled = useHasScrolled;
//# sourceMappingURL=useHasScrolled.js.map

/***/ }),

/***/ 49235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { ThemeProvider } = __webpack_require__(92168);
// styled-components ThemeProviders can be nested, which allows us to use the PaletteProvider as a nested ThemeProvider
// that only overwrites theme palette value. The rest of the theme continues to be passed on from the
// parent ThemeProvider.
const PaletteProvider = ({ palette, children }) => (React.createElement(ThemeProvider, { theme: { palette } }, children));
PaletteProvider.propTypes = {
    children: PropTypes.node.isRequired,
    palette: PropTypes.oneOf(['standard', 'inverted', 'special', 'transparent'])
        .isRequired
};
module.exports = PaletteProvider;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 78020:
/***/ ((module) => {

/**
 * This higher order function returns a theme function for style component theme provider
 * which does the following
 * - Override theme with provided themeOverride
 * - Adds stylePools intended for Smart component elements to theme object
 *
 * @param {object} themeOverride - theme to override default
 * @param {object} themeExtensions - extensions to add to theme object
 * @returns {Function} - theme function for styled component theme provider
 */
function getThemeFunction(themeOverride, themeExtensions = {}) {
    const { componentStylePools: stylePoolsFromParent } = themeExtensions;
    return ({ componentStylePools = {}, ...theme } = {}) => {
        if (stylePoolsFromParent) {
            Object.entries(stylePoolsFromParent).forEach(([key, value]) => {
                if (key in componentStylePools) {
                    componentStylePools[key].push(value);
                }
                else {
                    componentStylePools[key] = [value];
                }
            });
        }
        return {
            ...theme,
            ...themeOverride,
            componentStylePools
        };
    };
}
module.exports = {
    getThemeFunction
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 6009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const { ThemeProvider: PresetThemeProvider } = __webpack_require__(92168);
const { connector } = __webpack_require__(57744);
const PaletteProvider = __webpack_require__(49235);
const { getThemeFunction } = __webpack_require__(78020);
const PresetContext = React.createContext({});
/**
 * PresetProvider component
 *
 * @param {object} props - Props to the PresetProvider
 * @param {string} [props.children] - Children to pass down within the clamped content
 * @param {string} props.id - The id of the container to extract the layout config
 * @param {boolean} [props.layoutConfigs] - Layout config from the redux store
 * @param {object} [props.themeExtensions] - Extensions to add to theme object
 *
 * @returns {component} children with PresetProvider
 */
const PresetProvider = ({ children, id, layoutConfigs = {}, themeExtensions = {} }) => {
    const { theme = {}, palette, ...config } = layoutConfigs[id] || {};
    return (React.createElement(PresetContext.Provider, { value: config },
        React.createElement(PresetThemeProvider, { "data-testid": "PresetThemeProvider", theme: getThemeFunction(theme, themeExtensions) },
            React.createElement(PaletteProvider, { palette: palette ?? 'standard' }, children))));
};
PresetProvider.propTypes = {
    children: PropTypes.node.isRequired,
    id: PropTypes.string.isRequired,
    layoutConfigs: PropTypes.object,
    themeExtensions: PropTypes.shape({
        componentStylePools: PropTypes.objectOf(PropTypes.objectOf(PropTypes.func))
    })
};
module.exports = {
    PresetConsumer: PresetContext.Consumer,
    PresetContext,
    PresetProvider: connector(PresetProvider, {
        keysToPluck: ['layoutConfigs']
    })
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 76700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StylesProvider = void 0;
const react_1 = __importDefault(__webpack_require__(96540));
const prop_types_1 = __importDefault(__webpack_require__(5556));
const styled_components_1 = __webpack_require__(92168);
const styled_components_v6_1 = __webpack_require__(50435);
const styles_1 = __webpack_require__(35695);
function StylesProvider({ theme, children }) {
    return (react_1.default.createElement(styled_components_1.ThemeProvider, { theme: { palette: 'standard', ...theme } },
        react_1.default.createElement(styled_components_v6_1.ThemeProvider, { theme: { palette: 'standard', ...theme } },
            react_1.default.createElement(react_1.default.Fragment, null,
                react_1.default.createElement(styles_1.GlobalStyles, null),
                children))));
}
exports.StylesProvider = StylesProvider;
StylesProvider.propTypes = {
    children: prop_types_1.default.node.isRequired,
    theme: prop_types_1.default.object
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 80481:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
const { calculateSpacing, getColorToken, getTypographyStyles, minScreen, maxScreen, getZIndex } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { ButtonIconWrapper } = __webpack_require__(18974);
const getStickyHeroWrapper = () => css `
  &.ad-stickyhero-issticky {
    position: sticky;
    top: var(--header-height, ${calculateSpacing(8, 'px')});
    z-index: 400;
  }

  &.ad-stickyhero-sticky-animating {
    transition: 0.5s ease;
  }

  &.ad-stickyhero-sticky-visible {
    transform: translateY(0);
  }

  &.ad-stickyhero-sticky-50 {
    transform: translateY(-160px); /* 50 * 2 + 60 */
  }

  &.ad-stickyhero-sticky-90 {
    transform: translateY(-240px); /* 90 * 2 + 60 */
  }

  &.ad-stickyhero-sticky-250 {
    transform: translateY(-560px); /* 250 * 2 + 60 */
  }
`;
const styles = ({ theme }) => css `
  .cns-ads-slot-state-empty {
    display: none;
  }

  .cns-ads-slot-state-filled.cns-ads-slot-type-hero,
  .ad-height-hold,
  .ad-stickyhero {
    .cns-ads-slot-size-970x250 {
      top: 0;
    }
    ${minScreen(BREAKPOINTS.sm)} {
      background-color: ${getColorToken(theme, 'colors.background.adContainer.standard')};
    }
    ${minScreen(BREAKPOINTS.md)} {
      background-color: ${getColorToken(theme, 'colors.background.adContainer.standard')};
    }
  }

  .ad-stickyhero-issticky {
    background-color: ${getColorToken(theme, 'colors.background.adContainer.sticky')};
  }

  .page-theme-inverted {
    .ad-height-hold,
    .ad__slot--hero,
    .ad--hero,
    .ad-stickyhero,
    .cns-ads-slot-state-filled.cns-ads-slot-type-hero,
    .notificationBanner-portal {
      background-color: ${getColorToken(theme, 'colors.consumption.lead.inverted.background')};
    }
  }

  .page-theme-special {
    .ad-height-hold,
    .ad__slot--hero,
    .ad--hero,
    .ad-stickyhero,
    .cns-ads-slot-state-filled.cns-ads-slot-type-hero {
      background-color: ${getColorToken(theme, 'colors.consumption.lead.special.background')};
    }
  }

  .page .cns-ads-slot-type-footer {
    padding: ${calculateSpacing(5)} 0;
  }

  .ad--footer {
    background-color: ${getColorToken(theme, 'colors.background.adContainer.standard')};
  }

  /* Article page inline mid-content ads */
  .ad--mid-content {
    position: relative;

    /* 9xX ad sizes are full width */
    .cns-ads-slot-size-2x1,
    .cns-ads-slot-size-4x1,
    .cns-ads-slot-size-9x1,
    .cns-ads-slot-size-9x2 {
      z-index: ${getZIndex('navFixed')};
    }

    .ad-label {
      ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.ad-label')}
      display: block;
      text-align: center;
      text-transform: uppercase;
      color: ${getColorToken(theme, 'colors.consumption.body.standard.adlabel')};
    }

    .ad__slot {
      background-color: ${getColorToken(theme, 'colors.background.adContainer.standard')};
    }
  }

  .ad-label {
    ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.ad-label')}
    display: block;
    top: ${calculateSpacing(-3)};
    padding-top: 1.5em;
    text-align: center;
    text-transform: uppercase;
    color: ${getColorToken(theme, 'colors.consumption.body.standard.adlabel')};
  }

  .ad--in-content {
    display: flex;
    flex-direction: column;
    align-items: center;

    .ad__slot {
      width: 85%;
      max-width: 575px;
    }

    .ad-label {
      ${getTypographyStyles(theme, 'typography.definitions.globalEditorial.ad-label')}
      display: block;
      top: ${calculateSpacing(-3)};
      padding-top: 1.5em;
      text-align: center;
      text-transform: uppercase;
      color: ${getColorToken(theme, 'colors.consumption.body.standard.adlabel')};
    }
  }

  /*
    TODO: replace '.grid +' with '{Grid} +'
    once Grid moved to Styled Components

    Article page inline mid-content ads- remove
    extra space between grid containers and full-bleed ads
  */
  .grid + .row-mid-content-ad {
    .ad--mid-content {
      z-index: calc(${getZIndex('persistentAsideLayer')} - 1);
      margin-top: ${calculateSpacing(-1)};
      margin-bottom: ${calculateSpacing(4)};
    }
  }

  .ad-stickyhero {
    top: 0;
    z-index: ${getZIndex('persistentAsideLayer')};

    &.ad-stickyhero-enable-mobile {
      ${getStickyHeroWrapper()}
    }

    &.ad-stickyhero-disable-mobile {
      ${minScreen(BREAKPOINTS.md)} {
        ${getStickyHeroWrapper()}
      }
    }

    .ad-stickyhero-button {
      position: absolute;
      right: 0;
      z-index: 100;
      margin: 0 ${calculateSpacing(1.5)} 0 auto;
      border: 0;
      background-color: transparent;
      padding: 0;
      width: ${calculateSpacing(3)};

      ${minScreen(BREAKPOINTS.sm)} {
        display: none;
      }

      ${minScreen(BREAKPOINTS.md)} {
        display: block;
        margin: 0 ${calculateSpacing(1.25)} 0 ${calculateSpacing(2)};
      }

      &:hover,
      &:focus {
        border: 0;
        background-color: transparent;

        svg path {
          fill: ${getColorToken(theme, 'colors.interactive.base.brand-primary')};
        }
      }

      ${ButtonIconWrapper} {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: ${calculateSpacing(2.8)};
        height: 100%;
      }

      svg path {
        fill: ${getColorToken(theme, 'colors.interactive.base.black')};
      }
    }
  }

  .page-theme-inverted .ad-stickyhero .ad-stickyhero-button {
    svg path {
      fill: ${getColorToken(theme, 'colors.interactive.base.white')};
    }
  }

  /*
  Default positioning for ad-stickymidcontent
  */
  .ad-stickymidcontent {
    .ad.ad--mid-content {
      ${maxScreen(BREAKPOINTS.md)} {
        position: sticky;
        top: 5px;
      }
    }
  }

  /*
  Stacked Nav Variations & ad-Stickymidcontent
  */
  .stackednavigation-site-navigation & {
    @media (max-width: ${BREAKPOINTS.md}) {
      .ad-stickyhero-button {
        display: none;
      }
    }
  }
  /*
  Stacked Nav Link-banner-link-list
  */
  &.link-banner-visual-link-banner,
  &.link-banner-link-list {
    .button.ad-stickyhero-button {
      position: relative;
      float: right;
      @media (max-width: ${BREAKPOINTS.md}) {
        position: relative;
        float: right;
      }
    }
  }

  /*
  Stacked Nav Mid mid-content
  */
  .ad-stickymidcontent {
    .ad.ad--mid-content {
      @media (max-width: ${BREAKPOINTS.md}) {
        top: ${calculateSpacing(8.75, 'px')};
      }
    }
  }
  /*
  Standard Nav with Logo ad-stickymidcontent- 
  */
  .logo-left-with-search-nav-variation & {
    .ad-stickymidcontent {
      .ad.ad--mid-content {
        @media (max-width: ${BREAKPOINTS.md}) {
          top: ${calculateSpacing(8.75, 'px')};
        }
      }
    }
  }
  /*
  Standard Nav ad-stickymidcontent
  */
  .standardnavigation-site-navigation & {
    .ad-stickymidcontent {
      .ad.ad--mid-content {
        @media (max-width: ${BREAKPOINTS.md}) {
          top: ${calculateSpacing(8.2, 'px')};
        }
      }
    }
  }

  @media print {
    .ad {
      display: none;
    }
  }
`;
module.exports = styles;
//# sourceMappingURL=ads.js.map

/***/ }),

/***/ 54431:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
const { BREAKPOINTS } = __webpack_require__(96472);
const { applyDefaultPagePadding } = __webpack_require__(1123);
const { calculateSpacing, getColorToken, getTypographyStyles, minScreen, maxScreen } = __webpack_require__(26865);
const body = css `
  * {
    box-sizing: border-box;
  }

  html {
    height: 100%;
    font-size: 16px;

    ${maxScreen(BREAKPOINTS.md)} {
      overflow-x: clip;
    }
  }

  body {
    margin: 0;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  body {
    ${getTypographyStyles('typography.definitions.consumptionEditorial.body-core')}
    height: 100%;
    min-height: 100%;
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased;
  }

  .page {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  .dynamic-page {
    display: flex;
    flex-direction: column;
    padding-top: 0;
    min-height: 100vh; /* stylelint-disable-line */
    min-height: 100dvh; /* stylelint-disable-line */
    :has(.persistent-top) {
      ${applyDefaultPagePadding()}
    }
  }

  .fides-overlay-modal-link-shown {
    .consent-privacy-icon {
      display: inline-block;
    }
  }

  .fides-overlay-modal-link-shown {
    .consent_btn:not(:first-child)::before {
      margin-right: 5px;
      color: ${getColorToken('colors.foundation.footer.links.secondary')};
      content: '|';
    }
  }

  .stackednavigation-site-navigation {
    &.fixed-header-x-large-logo-with-mega-menu-nav-variation {
      &.link-banner-link-list {
        .page:not(.dynamic-page) {
          ${applyDefaultPagePadding()}
        }

        .dynamic-page:has(.persistent-top) {
          ${applyDefaultPagePadding()}
        }
      }
    }

    && {
      .page.legal-banner-visible {
        padding-top: ${calculateSpacing(12.5)};
        @media (max-width: 768px) {
          padding-top: ${calculateSpacing(13)};
        }
        @media (max-width: 425px) {
          padding-top: ${calculateSpacing(16)};
        }
        @media (max-width: 375px) {
          padding-top: ${calculateSpacing(18)};
        }
      }
    }
  }

  .siteheader-site-navigation {
    .page {
      padding-top: 0;

      .grid-layout__aside {
        .sticky-box {
          ${minScreen(BREAKPOINTS.lg)} {
            top: ${calculateSpacing(16)};
          }
        }
      }
    }
  }
`;
module.exports = body;
//# sourceMappingURL=body.js.map

/***/ }),

/***/ 21976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
const { getColorToken, getColorStyles } = __webpack_require__(26865);
const { linkClean } = __webpack_require__(15737);
const mixinButton = () => css `
  ${linkClean()}
  display: inline-block;
  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.light')};
  text-align: center;
  text-decoration: none;
`;
const buttons = css `
  input[type='submit'],
  button {
    ${mixinButton()}
    border: 0;
  }
`;
const mixinInvalidDefaults = () => css `
  border: 1px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.feedback.invalid-primary')};
  background-color: rgba(
    ${getColorToken('colors.interactive.feedback.invalid-secondary', {
    rgbOnly: true
})},
    0.15
  );
`;
const mixinFieldHover = () => css `
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.black')};
`;
const mixinDefaultsFieldCheckboxesRadios = () => `
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  visibility: initial;
  opacity: 0;
  margin: 0;
  cursor: inherit;
  padding: 0;
  width: 100%;
  height: 100%;
`;
const mixinCheckboxArrow = (show = true) => {
    if (show) {
        return 'opacity: 1;';
    }
    return `
    top: 0.9em;
    left: 0.75em;
    transform: translateX(-50%) translateY(-50%);
    opacity: 0;
    content: '';
  `;
};
const mixinCheckboxBoxReplacement = (toggleSwitch = false) => {
    return css `
    margin-right: 0.5em;
    border-width: 1px;
    border-style: solid;
    height: 1.5em;
    ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.black')};
    ${toggleSwitch ? 'border-radius: 1em; width: 3em;' : 'width: 1.5em;'}
  `;
};
const mixinPseudoElement = (position = 'relative') => `
  display: block;
  position: ${position};
  content: '';
`;
const mixinCheckboxRadioLabel = () => `
  display: flex;
  position: relative;
  align-items: center;
`;
const mixinCheckboxRadioDisabled = () => `opacity: 0.5;`;
const mixinCheckboxRadioInvalidLabel = () => css `
  ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.black')};
`;
const mixinCheckboxSwitchDot = () => css `
  top: 0.87em;
  left: 0.75em;
  transform: translateX(-50%) translateY(-50%);
  opacity: 1;
  border: 0;
  border-radius: 50%;
  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.light')};
  width: 0.999em;
  height: 0.999em;
  transition-property: background-color, transform;
  transition-duration: 0.3s;
  transition-timing-function: ease-in-out;
`;
const mixinCheckboxSwitchDotActive = () => css `
  transform: translateX(1.1em) translateY(-50%);
  opacity: 1;
  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
`;
const mixinRadioCircleReplacement = () => css `
  margin-right: 0.5em;
  border: 1px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.dark')};
  border-radius: 50%;
  ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
  width: 1.5em;
  height: 1.5em;
`;
const mixinRadioActiveReplacement = (show = true) => {
    if (show) {
        return 'opacity: 1;';
    }
    return css `
    top: 0.87em;
    left: 0.795em;
    transform: translateX(-50%) translateY(-50%);
    opacity: 0;
    border-radius: 50%;
    ${({ theme }) => getColorStyles(theme, 'background-color', 'colors.interactive.base.white')};
    width: 0.999em;
    height: 0.999em;
  `;
};
const checkbox = css `
  input[type='checkbox'] {
    &:checked {
      + label {
        &::after {
          ${mixinCheckboxArrow()}
        }
      }
    }

    &:disabled {
      + label {
        ${mixinCheckboxRadioDisabled()}
      }
    }

    &.checkbox__invalid,
    &:invalid {
      + label {
        ${mixinCheckboxRadioInvalidLabel()}

        &::before {
          ${mixinInvalidDefaults()}
        }

        &::after {
          ${mixinCheckboxArrow()}
        }
      }
    }

    + label {
      ${mixinCheckboxRadioLabel()}

      &:hover,
      &:focus {
        &::before {
          ${mixinFieldHover()}
        }
      }

      &::before {
        ${mixinPseudoElement()}
        ${mixinCheckboxBoxReplacement()}
      }

      &::after {
        ${mixinPseudoElement('absolute')}
        ${mixinCheckboxArrow(false)}
        transition-property: all;
        transition-duration: 0.25s;
        transition-timing-function: ease-in-out;
      }
    }

    /* toggle-switch checkboxes */
    &.checkbox--switch {
      &:checked {
        + label::after {
          ${mixinCheckboxSwitchDotActive()}
        }
      }

      + label {
        &:hover::before,
        &:focus::before {
          ${mixinFieldHover()}
        }

        &::before {
          ${mixinCheckboxBoxReplacement(true)}
        }

        &::after {
          ${mixinPseudoElement('absolute')}
          ${mixinCheckboxSwitchDot()}
        }
      }
    }
  }
`;
const radioButton = css `
  input[type='radio'] {
    &:checked {
      + label {
        &::after {
          ${mixinRadioActiveReplacement()}
        }
      }
    }

    &:disabled {
      + label {
        ${mixinCheckboxRadioDisabled()}
      }
    }

    + label {
      ${mixinCheckboxRadioLabel()}

      &:hover,
      &:focus {
        &::before {
          ${mixinFieldHover()}
        }
      }

      &::before {
        ${mixinPseudoElement()}
        ${mixinRadioCircleReplacement()}
      }

      &::after {
        ${mixinPseudoElement('absolute')}
        ${mixinRadioActiveReplacement(false)}
        transition-property: all;
        transition-duration: 0.25s;
        transition-timing-function: ease-in-out;
      }
    }
  }
`;
const fieldset = `
  fieldset {
    margin: 0;
    border: 0;
    padding: 0;
  }
`;
const mixinDefaultsField = () => css `
  border: 1px solid;
  ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.interactive.base.black')};
  padding: 0.125em 0.5rem;
`;
const input = css `
  input {
    ${mixinDefaultsField()}

    &[disabled] {
      pointer-events: none;
    }

    &[type='checkbox'],
    &[type='radio'] {
      ${mixinDefaultsFieldCheckboxesRadios()}
    }

    &[type='submit'] {
      ${mixinButton()}
    }

    &[type='reset'] {
      cursor: pointer;
    }

    &[type='number']::-webkit-inner-spin-button,
    &[type='number']::-webkit-outer-spin-button {
      height: auto;
    }

    &[type='search'] {
      box-sizing: border-box;
    }
  }
`;
const mixinDefaultsFieldSelect = () => css `
  ${mixinDefaultsField()}
  width: auto;
`;
const select = css `
  select {
    ${mixinDefaultsFieldSelect()}
  }
`;
const textarea = css `
  textarea {
    ${mixinDefaultsField()}
    display: block;
    width: 100%;
    max-width: 25em;
  }
`;
const styles = css `
  ${buttons}
  ${checkbox}
  ${radioButton}
  ${fieldset}
  ${input}
  ${select}
  ${textarea}
`;
module.exports = styles;
//# sourceMappingURL=forms.js.map

/***/ }),

/***/ 73354:
/***/ ((module) => {

const image = `
  img {
    max-width: 100%;
    height: auto;
    vertical-align: bottom;
  }
`;
module.exports = image;
//# sourceMappingURL=image.js.map

/***/ }),

/***/ 35695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createGlobalStyle } = __webpack_require__(92168);
const AdsGlobalStyles = __webpack_require__(80481);
const FormGlobalStyles = __webpack_require__(21976);
const BodyGlobalStyles = __webpack_require__(54431);
const NormalizeGlobalStyles = __webpack_require__(71276);
const ImageGlobalStyles = __webpack_require__(73354);
const LinkGlobalStyles = __webpack_require__(50315);
const TableGlobalStyles = __webpack_require__(84919);
const GlobalStyles = createGlobalStyle `
  ${NormalizeGlobalStyles}
  ${BodyGlobalStyles}
  ${AdsGlobalStyles}
  ${FormGlobalStyles}
  ${ImageGlobalStyles}
  ${LinkGlobalStyles}
  ${TableGlobalStyles}
`;
module.exports = {
    GlobalStyles
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 50315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
const { getColorStyles } = __webpack_require__(26865);
const link = css `
  a {
    cursor: pointer;
    ${({ theme }) => getColorStyles(theme, 'color', 'colors.interactive.base.light')};
    transition-property: color, background, text-shadow;
    transition-duration: 0.2s;
    transition-timing-function: ease-in-out;
  }
`;
module.exports = link;
//# sourceMappingURL=link.js.map

/***/ }),

/***/ 71276:
/***/ ((module) => {

const normalize = `
  /*! normalize.scss v0.1.0 | MIT License | based on git.io/normalize */

  /**
   * 1. Set default font family to sans-serif.
   * 2. Prevent iOS text size adjust after orientation change, without disabling
   *    user zoom.
   */

  html {
    font-family: sans-serif; /* 1 */
    -ms-text-size-adjust: 100%; /* 2 */
    -webkit-text-size-adjust: 100%; /* 2 */
  }

  /**
   * Remove default margin.
   */

  body {
    margin: 0;
  }

  /* HTML5 display definitions
     ========================================================================== */

  /**
   * Correct \`block\` display not defined for any HTML5 element in IE 8/9.
   * Correct \`block\` display not defined for \`details\` or \`summary\` in IE 10/11
   * and Firefox.
   * Correct \`block\` display not defined for \`main\` in IE 11.
   */

  article,
  aside,
  details,
  figcaption,
  figure,
  footer,
  header,
  hgroup,
  main,
  menu,
  nav,
  section,
  summary {
    display: block;
  }

  /**
   * 1. Correct \`inline-block\` display not defined in IE 8/9.
   * 2. Normalize vertical alignment of \`progress\` in Chrome, Firefox, and Opera.
   */

  audio,
  canvas,
  progress,
  video {
    display: inline-block; /* 1 */
    vertical-align: baseline; /* 2 */
  }

  /**
   * Prevent modern browsers from displaying \`audio\` without controls.
   * Remove excess height in iOS 5 devices.
   */

  audio:not([controls]) {
    display: none;
    height: 0;
  }

  /**
   * Address \`[hidden]\` styling not present in IE 8/9/10.
   * Hide the \`template\` element in IE 8/9/11, Safari, and Firefox < 22.
   */

  [hidden],
  template {
    display: none;
  }

  /* Links
     ========================================================================== */

  /**
   * Remove the gray background color from active links in IE 10.
   */

  a {
    background-color: transparent;
  }

  /**
   * Improve readability when focused and also mouse hovered in all browsers.
   */

  a:active,
  a:hover {
    outline: 0;
  }

  /* Text-level semantics
     ========================================================================== */

  /**
   * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
   */

  abbr[title] {
    border-bottom: 1px dotted;
  }

  /**
   * Address style set to \`bolder\` in Firefox 4+, Safari, and Chrome.
   */

  b,
  strong {
    font-weight: bold;
  }

  /**
   * Address styling not present in Safari and Chrome.
   */

  dfn {
    font-style: italic;
  }

  /**
   * Address variable \`h1\` font-size and margin within \`section\` and \`article\`
   * contexts in Firefox 4+, Safari, and Chrome.
   */

  h1 {
    font-size: 2em;
    margin: 0.67em 0;
  }

  /**
   * Address styling not present in IE 8/9.
   */

  mark {
    background: #ff0;
    color: #000;
  }

  /**
   * Address inconsistent and variable font size in all browsers.
   */

  small {
    font-size: 80%;
  }

  /**
   * Prevent \`sub\` and \`sup\` affecting \`line-height\` in all browsers.
   */

  sub,
  sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }

  sup {
    top: -0.5em;
  }

  sub {
    bottom: -0.25em;
  }

  /* Embedded content
     ========================================================================== */

  /**
   * Remove border when inside \`a\` element in IE 8/9/10.
   */

  img {
    border: 0;
  }

  /**
   * Correct overflow not hidden in IE 9/10/11.
   */

  svg:not(:root) {
    overflow: hidden;
  }

  /* Grouping content
     ========================================================================== */

  /**
   * Address margin not present in IE 8/9 and Safari.
   */

  figure {
    margin: 1em 40px;
  }

  /**
   * Address differences between Firefox and other browsers.
   */

  hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
  }

  /**
   * Contain overflow in all browsers.
   */

  pre {
    overflow: auto;
  }

  /**
   * Address odd \`em\`-unit font size rendering in all browsers.
   */

  code,
  kbd,
  pre,
  samp {
    font-family: monospace, monospace;
    font-size: 1em;
  }

  /* Forms
     ========================================================================== */

  /**
   * Known limitation: by default, Chrome and Safari on OS X allow very limited
   * styling of \`select\`, unless a \`border\` property is set.
   */

  /**
   * 1. Correct color not being inherited.
   *    Known issue: affects color of disabled elements.
   * 2. Correct font properties not being inherited.
   * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
   */

  button,
  input,
  optgroup,
  select,
  textarea {
    color: inherit; /* 1 */
    font: inherit; /* 2 */
    margin: 0; /* 3 */
  }

  /**
   * Address \`overflow\` set to \`hidden\` in IE 8/9/10/11.
   */

  button {
    overflow: visible;
  }

  /**
   * Address inconsistent \`text-transform\` inheritance for \`button\` and \`select\`.
   * All other form control elements do not inherit \`text-transform\` values.
   * Correct \`button\` style inheritance in Firefox, IE 8/9/10/11, and Opera.
   * Correct \`select\` style inheritance in Firefox.
   */

  button,
  select {
    text-transform: none;
  }

  /**
   * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native \`audio\`
   *    and \`video\` controls.
   * 2. Correct inability to style clickable \`input\` types in iOS.
   * 3. Improve usability and consistency of cursor style between image-type
   *    \`input\` and others.
   */

  button,
  html input[type="button"], /* 1 */
  input[type="reset"],
  input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
  }

  /**
   * Re-set default cursor for disabled elements.
   */

  button[disabled],
  html input[disabled] {
    cursor: default;
  }

  /**
   * Remove inner padding and border in Firefox 4+.
   */

  button::-moz-focus-inner,
  input::-moz-focus-inner {
    border: 0;
    padding: 0;
  }

  /**
   * Address Firefox 4+ setting \`line-height\` on \`input\` using \`!important\` in
   * the UA stylesheet.
   */

  input {
    line-height: normal;
  }

  /**
   * It's recommended that you don't attempt to style these elements.
   * Firefox's implementation doesn't respect box-sizing, padding, or width.
   *
   * 1. Address box sizing set to \`content-box\` in IE 8/9/10.
   * 2. Remove excess padding in IE 8/9/10.
   */

  input[type="checkbox"],
  input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
  }

  /**
   * Resets the Hotjar widget style's for radio inputs.
   */

  ._hj-widget-container input[type="radio"] {
    inset: initial;
    height: initial;
    width: initial;
  }

  /**
   * Fix the cursor style for Chrome's increment/decrement buttons. For certain
   * \`font-size\` values of the \`input\`, it causes the cursor style of the
   * decrement button to change from \`default\` to \`text\`.
   */

  input[type="number"]::-webkit-inner-spin-button,
  input[type="number"]::-webkit-outer-spin-button {
    height: auto;
  }

  /**
   * 1. Address \`appearance\` set to \`searchfield\` in Safari and Chrome.
   * 2. Address \`box-sizing\` set to \`border-box\` in Safari and Chrome
   *    (include \`-moz\` to future-proof).
   */

  input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
  }

  /**
   * Remove inner padding and search cancel button in Safari and Chrome on OS X.
   * Safari (but not Chrome) clips the cancel button when the search input has
   * padding (and \`textfield\` appearance).
   */

  input[type="search"]::-webkit-search-cancel-button,
  input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
  }

  /**
   * Define consistent border, margin, and padding.
   */

  fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
  }

  /**
   * 1. Correct \`color\` not being inherited in IE 8/9/10/11.
   * 2. Remove padding so people aren't caught out if they zero out fieldsets.
   */

  legend {
    border: 0; /* 1 */
    padding: 0; /* 2 */
  }

  /**
   * Remove default vertical scrollbar in IE 8/9/10/11.
   */

  textarea {
    overflow: auto;
  }

  /**
   * Don't inherit the \`font-weight\` (applied by a rule above).
   * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
   */

  optgroup {
    font-weight: bold;
  }

  /* Tables
     ========================================================================== */

  /**
   * Remove most spacing between table cells.
   */

  table {
    border-collapse: collapse;
    border-spacing: 0;
  }

  td,
  th {
    padding: 0;
  }

`;
module.exports = normalize;
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ 84919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
const { getColorStyles, getColorToken } = __webpack_require__(26865);
const mixinTableCellDefaults = () => `
  padding: 0.5em;
  vertical-align: bottom;
  text-align: left;
`;
const table = css `
  table {
    width: 100%;
  }

  td {
    ${mixinTableCellDefaults()}
    vertical-align: baseline;
  }

  th {
    ${mixinTableCellDefaults()}
    vertical-align: bottom;
  }

  thead {
    ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};
    border-width: 0 0 2px 0;
    border-style: solid;
  }

  tfoot {
    ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};
    border-width: 2px 0 0 0;
    border-style: solid;
  }

  tbody {
    tr {
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};
      border-width: 0 0 1px 0;
      border-style: solid;

      &:nth-of-type(even) {
        background-color: rgba(
          ${getColorToken('colors.foundation.menu.dividers', {
    rgbOnly: true
})},
          0.5
        );
      }
    }

    td {
      ${({ theme }) => getColorStyles(theme, 'border-color', 'colors.foundation.menu.dividers')};
      border-width: 1px 0 0 0;
      border-style: solid;

      &:last-of-type {
        border-right: 0;
      }
    }
  }
`;
module.exports = table;
//# sourceMappingURL=table.js.map

/***/ }),

/***/ 98010:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var process = __webpack_require__(65606);

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.I18nProvider = void 0;
const react_1 = __importDefault(__webpack_require__(96540));
const prop_types_1 = __importDefault(__webpack_require__(5556));
const react_intl_1 = __webpack_require__(46984);
const i18n_1 = __webpack_require__(18106);
const intlError = (error) => {
    if (process.env.BUILD_ENV === 'dev' && process.env.DEBUG?.includes('i18n')) {
        console.error(error);
    }
};
// TODO: Handle content lang provider/context/consumer in here
const I18nProvider = ({ children, locale, translations }) => {
    return (react_1.default.createElement(react_intl_1.IntlProvider, { defaultLocale: i18n_1.DEFAULT_LANG, locale: locale, messages: translations, onError: intlError }, children));
};
exports.I18nProvider = I18nProvider;
exports.I18nProvider.propTypes = {
    children: prop_types_1.default.node.isRequired,
    locale: prop_types_1.default.oneOf(i18n_1.LOCALES),
    translations: prop_types_1.default.object
};
exports.I18nProvider.displayName = 'I18nProvider';
//# sourceMappingURL=I18nProvider.js.map

/***/ }),

/***/ 20539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.I18nProvider = void 0;
var I18nProvider_1 = __webpack_require__(98010);
Object.defineProperty(exports, "I18nProvider", ({ enumerable: true, get: function () { return I18nProvider_1.I18nProvider; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const classnames = __webpack_require__(32485);
const { injectIntl } = __webpack_require__(46984);
const googleAnalytics = __webpack_require__(37402);
const translations = (__webpack_require__(52036)/* ["default"] */ .A);
const helpers = __webpack_require__(98335);
const Button = __webpack_require__(73730);
const ChevronIcon = __webpack_require__(69880);
const { ClampContent, ClampWrapper } = __webpack_require__(68370);
const { TrackComponentChannel } = __webpack_require__(78788);
const { WindowEventChannel } = __webpack_require__(51735);
/**
 * Clamp component
 *
 * @param {object} props - React props
 * @param {string} [props.breakpoint] - Optional breakpoint at which the excess content should truncate
 * @param {number} props.children - React children
 * @param {string} [props.className] - Optional class name on the header
 * @param {number} [props.lines] - number of lines to clamp to
 * @param {number} [props.linesInMobile] - number of lines to clamp in mobile
 * @param {number} [props.linesInTablet] - number of lines to clamp in Tablet
 * @param {number} [props.linesInDesktop] - number of lines to clamp in Desktop
 * @param {number} [props.linesInLargeDesktop] - number of lines to clamp in Large Desktop
 * @param {number} [props.linesInExtraLargeDesktop] - number of lines to clamp in Extra Large Desktop
 * @param {bool} props.isCollapsible - whether the clamp can be controlled by a user
 * @param {string} [props.analyticsEvent] - google analytics event name to be triggered
 * @param {bool} props.isClampGalleryVariation - to update style for clamp in gallery component
 * @param {func} props.onTextClick - optional prop to track product description data on click
 * @param {string} [props.showClampedProductDescription] - optional to get clamped data inside product card
 *
 * @returns {ReactElement} <div>
 */
class Clamp extends React.Component {
    constructor(props) {
        super(props);
        /**
         * Gets the wrapper ref, allowing us to query the DOM and set the
         * correct line-height.
         *
         * @param {HTMLElement} wrapperNode - the wrapper element
         * @returns {undefined} undefined
         */
        this.onRef = (wrapperNode) => {
            if (this.clampRef || !wrapperNode) {
                return;
            }
            this.clampRef = wrapperNode.firstElementChild;
            this.calcLineHeights();
        };
        this.calcLineHeights = () => {
            setTimeout(() => {
                const clientLineHeight = helpers.getClientLineHeight(this.clampRef);
                const { fontSize, paddingBottom, paddingTop } = window.getComputedStyle(this.clampRef);
                const lineHeightRatio = clientLineHeight / parseFloat(fontSize);
                let padding = 0;
                if (paddingTop)
                    padding += Number(paddingTop.replace('px', ''));
                if (paddingBottom)
                    padding += Number(paddingBottom.replace('px', ''));
                this.setState({
                    clientLineHeight,
                    lineHeightRatio,
                    topAndBottomPadding: padding
                });
                this.buttonVisibilityCheck(clientLineHeight, this.props.offset);
            }, 0);
        };
        this.buttonVisibilityCheck = (clientLineHeight, offset = 0) => {
            const { scrollHeight } = this.clampRef;
            const shouldTruncate = scrollHeight >
                this.props.lines * Number(clientLineHeight) +
                    this.state.topAndBottomPadding +
                    offset;
            this.setState({ showButton: shouldTruncate });
        };
        this.dataLayerTracking = (eventTracking) => {
            if ( true && window.dataLayer) {
                window.dataLayer.push({
                    event: eventTracking
                });
            }
        };
        this.handleCollapse = (e) => {
            if (this.state.collapsed && this.props.analyticsEvent) {
                googleAnalytics.emitGoogleTrackingEvent(this.props.analyticsEvent);
            }
            if (this.state.collapsed) {
                this.dataLayerTracking('read more');
            }
            if (!this.state.collapsed) {
                this.dataLayerTracking('read less');
            }
            this.setState({ collapsed: !this.state.collapsed });
            e.preventDefault();
        };
        this.clampRef = null;
        this.state = {
            clientLineHeight: null,
            collapsed: true,
            showButton: false,
            topAndBottomPadding: 0 // top and bottom padding require to get the exact height of clampRef component
        };
    }
    componentDidMount() {
        this.subscription = window.Kendra.WINDOW_EVENT.on([WindowEventChannel.LOAD_DEBOUNCE, WindowEventChannel.RESIZE_DEBOUNCE], this.calcLineHeights);
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Clamp'
        });
    }
    componentWillUnmount() {
        this.clampRef = null;
        if (this.subscription) {
            this.subscription.off();
        }
    }
    render() {
        const { children, lines = 3, linesInMobile = 0, linesInTablet = 0, linesInDesktop = 0, linesInLargeDesktop = 0, linesInExtraLargeDesktop = 0, isCollapsible = false, className, intl, breakpoint = 'xxl', isClampGalleryVariation, clampReadMoreText, clampReadLessText, onTextClick, showClampedProductDescription } = this.props;
        const { clientLineHeight, lineHeightRatio, showButton, collapsed } = this.state;
        const childStyle = {};
        if (!helpers.checkNativeClampSupport() && clientLineHeight) {
            childStyle.height = `${lines * clientLineHeight}px`;
        }
        // -webkit-line-clamp doesn't work well with lineheights less than 1
        if (helpers.checkNativeClampSupport() && lineHeightRatio < 1) {
            childStyle.lineHeight = 1;
        }
        let buttonText = '';
        if (collapsed) {
            buttonText =
                clampReadMoreText ?? intl.formatMessage(translations.clampReadMore);
        }
        else {
            buttonText =
                clampReadLessText ?? intl.formatMessage(translations.clampReadLess);
        }
        return (React.createElement(ClampWrapper, { "data-testid": "ClampWrapper", className: classnames('clamp', className), isClampGalleryVariation: isClampGalleryVariation },
            React.createElement(ClampContent, { ref: this.onRef, isCollapsed: collapsed, lines: lines, linesInMobile: linesInMobile, linesInTablet: linesInTablet, linesInDesktop: linesInDesktop, linesInLargeDesktop: linesInLargeDesktop, linesInExtraLargeDesktop: linesInExtraLargeDesktop, breakpoint: breakpoint, isClampGalleryVariation: isClampGalleryVariation, showButton: showButton, showClampedProductDescription: showClampedProductDescription }, React.Children.map(children, (child) => {
                return React.cloneElement(child, { style: childStyle });
            })),
            isCollapsible && showButton && (React.createElement(Button.Utility, { btnStyle: "text", ButtonIcon: ChevronIcon, className: classnames('button--collapse', collapsed
                    ? 'button__icon--chevron-down'
                    : 'button__icon--chevron-up'), label: buttonText, hasEnableIcon: true, variation: { isIconButton: true }, onClickHandler: (e) => {
                    this.handleCollapse(e);
                    showClampedProductDescription && onTextClick();
                } }, buttonText))));
    }
}
Clamp.propTypes = {
    analyticsEvent: PropTypes.string,
    breakpoint: PropTypes.string,
    children: PropTypes.element.isRequired,
    clampReadLessText: PropTypes.string,
    clampReadMoreText: PropTypes.string,
    className: PropTypes.string,
    intl: PropTypes.object,
    isClampGalleryVariation: PropTypes.bool,
    isCollapsible: PropTypes.bool,
    lines: PropTypes.number,
    linesInDesktop: PropTypes.number,
    linesInExtraLargeDesktop: PropTypes.number,
    linesInLargeDesktop: PropTypes.number,
    linesInMobile: PropTypes.number,
    linesInTablet: PropTypes.number,
    offset: PropTypes.number,
    onTextClick: PropTypes.func,
    showClampedProductDescription: PropTypes.bool
};
module.exports = injectIntl(Clamp);
//# sourceMappingURL=Clamp.js.map

/***/ }),

/***/ 98335:
/***/ ((module) => {

/**
 * Verifies whether the JavaScript environment supports native
 * CSS line clamping. Defaults to FALSE.
 *
 * @returns {boolean} whether clamping is supported.
 */
function checkNativeClampSupport() {
    try {
        const el = document.createElement('div');
        return typeof el.style.webkitLineClamp !== 'undefined';
    }
    catch (e) {
        return false;
    }
}
/**
 * Retrieves the calculated pixel line-height for a DOM node, by mocking the same.
 * This method is not super-reliable; could be subject to padding etc., or CSS selectors
 * missing the test element. However, it's a good approximation.
 *
 * @param {HTMLElement} element - the element to test
 * @returns {number} line height in pixels
 */
function getClientLineHeight(element) {
    const { nodeName, parentNode } = element;
    const { fontSize, fontFamily, lineHeight } = window.getComputedStyle(element);
    const testEl = document.createElement(nodeName);
    testEl.setAttribute('class', element.getAttribute('class'));
    testEl.setAttribute('style', `position:absolute;top:0;opacity:0;margin:0px;padding:0px;font-family:${fontFamily};font-size:${fontSize};line-height:${lineHeight}`);
    testEl.innerHTML = 'A';
    parentNode.appendChild(testEl);
    const computedLineHeight = testEl.clientHeight;
    parentNode.removeChild(testEl);
    return computedLineHeight;
}
module.exports = {
    checkNativeClampSupport,
    getClientLineHeight
};
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ 48286:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(94337);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 68370:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const { minThresholds, maxThresholds } = __webpack_require__(99906);
const { calculateSpacing, getColorToken, maxScreen, minScreen, minMaxScreen } = __webpack_require__(26865);
const { ButtonIcon } = __webpack_require__(18974);
const { BaseButton } = __webpack_require__(63825);
const ClampWrapper = styled.div.withConfig({
    displayName: 'ClampWrapper'
}) `
  .button--collapse {
    margin: 0 auto;
    ${({ isClampGalleryVariation }) => isClampGalleryVariation &&
    `
    margin-bottom:  ${calculateSpacing(2.5)};  
    `}
  }

  ${BaseButton} {
    ${ButtonIcon} {
      width: ${calculateSpacing(2)};
    }
  }
`;
const ClampContent = styled.div.withConfig({
    displayName: 'ClampContent'
}) `
  ${({ isCollapsed }) => isCollapsed
    ? `
      /* stylelint-disable-next-line value-no-vendor-prefix */
      display: -webkit-box;
      overflow: hidden;
      text-overflow: ellipsis;
     -webkit-box-orient: vertical;
     `
    : `
     overflow: hidden;
    `}

  ${({ showClampedProductDescription, showButton, isCollapsed }) => showClampedProductDescription &&
    showButton &&
    isCollapsed &&
    `
      p {
        display: inline;
      }
      
      p::after {
        content: '${'\\A'}';
        white-space: pre;
      }
      `}

  ${({ isCollapsed, lines, linesInMobile, linesInTablet, linesInDesktop, linesInLargeDesktop, linesInExtraLargeDesktop, breakpoint = 'xxl' }) => {
    let clampCss = '';
    if (isCollapsed && lines) {
        if (lines) {
            // condition to show lines in specific breakpoint
            clampCss +=
                breakpoint === 'xxxl'
                    ? `-webkit-line-clamp: ${lines};`
                    : `
              ${maxScreen(`${maxThresholds[breakpoint]}px`)} {
                -webkit-line-clamp: ${lines};
              }
            `;
        }
        if (linesInMobile) {
            // lines to show in screen size upto 767px
            clampCss += `${maxScreen(`${maxThresholds.md}px`)} {
          -webkit-line-clamp: ${linesInMobile};
        }`;
        }
        if (linesInTablet) {
            // lines to show in screen size from 768px to 1023px
            clampCss += `${minMaxScreen(`${minThresholds.lg}px`, `${maxThresholds.lg}px`)} {
          -webkit-line-clamp: ${linesInTablet};
        }`;
        }
        if (linesInDesktop) {
            // lines to show in screen size from 1024px to 1279px
            clampCss += `${minMaxScreen(`${minThresholds.xl}px`, `${maxThresholds.xl}px`)} {
          -webkit-line-clamp: ${linesInDesktop};
        }`;
        }
        if (linesInLargeDesktop) {
            // lines to show in screen size from 1280px to 1599px
            clampCss += `${minMaxScreen(`${minThresholds.xxl}px`, `${maxThresholds.xxl}px`)} {
          -webkit-line-clamp: ${linesInLargeDesktop};
        }`;
        }
        if (linesInExtraLargeDesktop) {
            // lines to show in screen size above 1600px
            clampCss += `${minScreen(`${minThresholds.xxxl}px`)} {
          -webkit-line-clamp: ${linesInExtraLargeDesktop};
        }`;
        }
    }
    return clampCss;
}}

  > * {
    overflow: -moz-hidden-unscrollable;
  }

  > * {
    overflow: -webkit-paged-x;
  }

  ${({ isClampGalleryVariation, theme }) => isClampGalleryVariation &&
    `color: ${getColorToken(theme, 'colors.consumption.body.standard.body')}`};
`;
module.exports = {
    ClampWrapper,
    ClampContent
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 52036:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    clampReadMore: {
        id: 'Clamp.ReadMore',
        defaultMessage: 'Read more',
        description: 'button text when content is shrinked'
    },
    clampReadLess: {
        id: 'Clamp.ReadLess',
        defaultMessage: 'Read less',
        description: 'button text when content is expanded'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 59319:
/***/ ((module) => {

const modalActions = (dispatch) => {
    const openModal = (value) => {
        dispatch({
            type: 'SET_KEY',
            key: 'isModalOpen',
            value
        });
    };
    return {
        openModal
    };
};
module.exports = modalActions;
//# sourceMappingURL=actions.js.map

/***/ }),

/***/ 74479:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const PropTypes = __webpack_require__(5556);
const classnames = __webpack_require__(32485);
const GridContext = __webpack_require__(66552);
const { GridWrapper, GridItem } = __webpack_require__(40653);
const { TrackComponentChannel } = __webpack_require__(78788);
const NewsletterPLP = __webpack_require__(69275);
// Newsletter state management using module-level variables
const newsletterState = {
    isRendered: false,
    isRendering: false
};
const ITEMS_PER_ROW = 3;
/**
 * Grid component
 *
 * @param {object} props - React props
 * @param {Element} props.children - Required contents (patterns or components) to be rendered inside of the Row
 * @param {string} [props.className] - Optional top-level class to add
 * @param {string} [props.dataTestId] - Optional html attr value for data-testid (used for cypress testing)
 * @param {object} [props.variations] - Optional variations properties used in rendering the component.
 * @param {object} [variations.gridColumns] - Optional start and end values for grid columns
 * @param {bool} [props.variations.hasGutters] - Optional boolean to determine if grid has gutters
 * @param {bool} [props.variations.hasMargin] - Optional boolean to determine grid margins
 * @param {bool} [props.variations.hasMarginMobile] - Optional boolean to determine grid margins for mobile
 * @param {bool} [props.variations.isAdrail] - Optional boolean to determine if grid item is Ad Rail
 * @param {bool} [props.variations.adRailType] - Optional value ('normal', 'narrow', 'narrowWithNarrowContent') to determine which adrail layout to use
 * @param {bool} [props.variations.isEven] - Optional boolean to determine if grid items are centered
 * @param {bool} [props.variations.isFullBleed] - Optional boolean to determine if grid is full bleed.Grid
 * @param {bool} [props.variations.isMobileUp] - Optional boolean to always use vertical stack on small devices
 * @param {bool} [props.variations.isDynamicGridItemLayout] - Optional boolean to use dynamic grid item inside grid
 * @param {bool} [props.variations.shouldDisplayDenseGrid] - Optional boolean to show grid without empty slots
 * @param {string} [props.variationName] - Component variation name used for Component Tracking
 * @param {string} [props.containerIndex] - optional to store container index
 * @returns {ReactElement} <div>
 */
const Grid = ({ children, className, dataTestId, variations = {
    adRailType: 'normal',
    hasMargin: false,
    hasMarginMobile: false,
    isMarginOnly: false
}, variationName, containerIndex }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Grid',
            variation: variationName
        });
    }, [variationName]);
    const { adRailType = 'normal', childColumns = [], gridColumns = {}, hasMargin, hasMarginMobile, isAdrail = false, isEven, isFullBleed, isMarginOnly = false, isMobileUp = false, hasGutters = true, isDynamicGridItemLayout, shouldDisplayDenseGrid } = variations;
    const { startColumn, endColumn } = gridColumns;
    const isEvenAny = isEven && childColumns.length === 0;
    // NOTE: Remove any classes that are not being used as integration happens
    const classes = classnames('grid', { 'grid-margins': hasMargin }, { 'grid-margin-only': isMarginOnly }, { 'grid-even': isEven && childColumns.length >= 1 }, { 'grid-even-any': isEven && childColumns.length === 0 }, `grid-items-${childColumns.length}`, { 'grid-full-bleed': isFullBleed }, { 'grid-no-gap': !hasGutters }, { 'grid-mobile-up': isMobileUp }, className);
    // Track if we should render the newsletter in this grid instance
    const [shouldRenderNewsletter, setShouldRenderNewsletter] = React.useState(false);
    // Check if we should render the newsletter
    React.useEffect(() => {
        // Only set to true for the first grid with containerIndex 0
        if (containerIndex === 0 &&
            !newsletterState.isRendered &&
            !newsletterState.isRendering) {
            setShouldRenderNewsletter(true);
            newsletterState.isRendering = true;
        }
    }, [containerIndex]);
    // Callback when newsletter is actually rendered
    const onNewsletterRendered = React.useCallback(() => {
        newsletterState.isRendered = true;
        newsletterState.isRendering = false;
    }, []);
    return (React.createElement(GridWrapper, { childColumnsLength: childColumns.length, className: classes, "data-testid": dataTestId, hasMargin: hasMargin, hasMarginMobile: hasMarginMobile, hasGutters: hasGutters, isAdrail: isAdrail, adRailType: adRailType, isEven: isEven, isEvenAny: isEvenAny, isFullBleed: isFullBleed, isMarginOnly: isMarginOnly, isMobileUp: isMobileUp, isDynamicGridItemLayout: isDynamicGridItemLayout, shouldDisplayDenseGrid: shouldDisplayDenseGrid }, React.Children.map(children, (child, index) => {
        const column = childColumns[index] || {};
        let gridItemColSpan;
        if (isDynamicGridItemLayout &&
            child?.props?.children?.props?.gridItemColSpan) {
            gridItemColSpan = child?.props?.children?.props?.gridItemColSpan;
        }
        // Calculate current row based on index
        const currentRow = Math.floor(index / ITEMS_PER_ROW) + 1;
        // Determine if we should render newsletter after this item
        const isLastItemInThirdRow = currentRow === 3 && (index + 1) % ITEMS_PER_ROW === 0;
        return (React.createElement(React.Fragment, null,
            child && (React.createElement(GridContext.Provider, { value: { columnSpan: column.columnSpan, isFullBleed } },
                React.createElement(GridItem, { adRailType: adRailType, className: classnames('grid--item', {
                        [`grid-columns--start-${startColumn}-end-${endColumn}`]: startColumn && endColumn
                    }, column.className), endColumn: endColumn, isAdrail: isAdrail, isFullBleed: isFullBleed, layoutValue: column.layoutValue, spanValue: column.spanValue, startColumn: startColumn, isEvenGrid: isEven, gridItemColSpan: gridItemColSpan, isDynamicGridItemLayout: isDynamicGridItemLayout }, React.cloneElement(child)))),
            shouldRenderNewsletter && isLastItemInThirdRow && (React.createElement("div", { className: "newsletter-plp-full-bleed" },
                React.createElement(NewsletterPLP, { onRendered: onNewsletterRendered })))));
    })));
};
Grid.propTypes = {
    children: PropTypes.node.isRequired,
    className: PropTypes.string,
    containerIndex: PropTypes.number,
    dataTestId: PropTypes.string,
    variationName: PropTypes.string,
    variations: PropTypes.shape({
        adRailType: PropTypes.oneOf([
            'normal',
            'narrow',
            'narrowAdsLeft',
            'narrowWithNarrowContent',
            'persistent'
        ]),
        childColumns: PropTypes.arrayOf(PropTypes.shape({
            columnSpan: PropTypes.shape({
                sm: PropTypes.string,
                md: PropTypes.string,
                lg: PropTypes.string,
                xl: PropTypes.string,
                xxl: PropTypes.string,
                xxxl: PropTypes.string
            }),
            layoutValue: PropTypes.oneOf(['content', 'aside']),
            spanValue: PropTypes.oneOf([4, 6])
        })),
        gridColumns: PropTypes.shape({
            startColumn: PropTypes.number,
            endColumn: PropTypes.number
        }),
        hasGutters: PropTypes.bool,
        hasMargin: PropTypes.bool,
        hasMarginMobile: PropTypes.bool,
        isAdrail: PropTypes.bool,
        isEven: PropTypes.bool,
        isFullBleed: PropTypes.bool,
        isMarginOnly: PropTypes.bool,
        isMobileUp: PropTypes.bool,
        isDynamicGridItemLayout: PropTypes.bool,
        shouldDisplayDenseGrid: PropTypes.bool
    })
};
module.exports = Grid;
//# sourceMappingURL=Grid.js.map

/***/ }),

/***/ 7009:
/***/ ((module) => {

const columnSpanPresets = {
    mobile100Desktop33: {
        sm: '4/4',
        md: '4/4',
        lg: '4/4',
        xl: '4/12',
        xxl: '4/12',
        xxxl: '4/12'
    },
    mobile100Desktop25: {
        sm: '4/4',
        md: '4/4',
        lg: '4/4',
        xl: '3/12',
        xxl: '3/12',
        xxxl: '3/12'
    },
    mobile100Desktop50: {
        sm: '4/4',
        md: '4/4',
        lg: '4/4',
        xl: '6/12',
        xxl: '6/12',
        xxxl: '6/12'
    },
    mobile100Desktop75: {
        sm: '4/4',
        md: '4/4',
        lg: '4/4',
        xl: '9/12',
        xxl: '9/12',
        xxxl: '9/12'
    },
    mobile100Tablet50Desktop25: {
        sm: '4/4',
        md: '2/4',
        lg: '3/12',
        xl: '3/12',
        xxl: '3/12',
        xxxl: '3/12'
    },
    mobile50Desktop20: {
        sm: '2/4',
        md: '2/4',
        lg: '2/4',
        xl: '2/10',
        xxl: '2/10',
        xxxl: '2/10'
    },
    mobile50Desktop25: {
        sm: '2/4',
        md: '2/4',
        lg: '2/4',
        xl: '3/12',
        xxl: '3/12',
        xxxl: '3/12'
    },
    mobile50Desktop33: {
        sm: '2/4',
        md: '2/4',
        lg: '2/4',
        xl: '4/12',
        xxl: '4/12',
        xxxl: '4/12'
    },
    mobile50Desktop50: {
        sm: '2/4',
        md: '2/4',
        lg: '2/4',
        xl: '6/12',
        xxl: '6/12',
        xxxl: '6/12'
    }
};
module.exports = { columnSpanPresets };
//# sourceMappingURL=columnSpanPresets.js.map

/***/ }),

/***/ 66552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createContext } = __webpack_require__(96540);
const GridContext = createContext();
module.exports = GridContext;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 86659:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(9413);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 40653:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BREAKPOINTS } = __webpack_require__(96472);
const { applyGridSpacing, cssVariablesGrid } = __webpack_require__(1123);
const isColumnsTwoThreeFourOrFive = (childColumnsLength) => [2, 3, 4, 5, 6].includes(childColumnsLength);
const getAdRailStyleByTypeAndLayoutContent = (adRailType) => {
    switch (adRailType) {
        case 'normal':
            return `
            @media (min-width: ${BREAKPOINTS.lg}) {
              grid-column: span 8;
            }
        
            @media (min-width: ${BREAKPOINTS.xl}) {
              grid-column: span 9;
            }
          `;
        case 'narrow':
        case 'persistent':
        case 'narrowWithNarrowContent':
            return `
            @media (min-width: ${BREAKPOINTS.lg}) {
              grid-column: 2 / span 6;
            }
          `;
        case 'narrowAdsLeft':
            return `
            @media (min-width: ${BREAKPOINTS.md}) {
              grid-column: 3 / -3;
            }
            @media (min-width: ${BREAKPOINTS.lg}) {
              grid-column: 6 / -2;
            }
            @media (min-width: ${BREAKPOINTS.xl}) {
              grid-column: 6 / -2;
            }
          `;
        default:
            return '';
    }
};
const getAdRailStyleByTypeAndLayoutAside = (adRailType) => {
    switch (adRailType) {
        case 'normal':
            return `
        @media (min-width: ${BREAKPOINTS.lg}) {
          grid-column: 9 / -1;
        }
        @media (min-width: ${BREAKPOINTS.xl}) {
          grid-column: 10 / -1;
        }
      `;
        case 'narrow':
            return `
        @media (min-width: ${BREAKPOINTS.lg}) {
          grid-column: 8 / -2;
        }
        @media (min-width: ${BREAKPOINTS.xl}) {
          grid-column: 9 / -2;
        }
      `;
        case 'persistent':
            return `
        @media (min-width: ${BREAKPOINTS.lg}) {
          grid-column: 8 / -1;
          min-width: 300px;
          display: block;
        }
        @media (min-width: ${BREAKPOINTS.xl}) {
          grid-column: 9 / -1;
          min-width: 360px;
          display: block;
        }
        display: block;
        grid-column: 1 / -1;
      `;
        case 'narrowWithNarrowContent':
            return `
        @media (min-width: ${BREAKPOINTS.xl}) {
          grid-column: 9 / -2;
        }
        @media (min-width: ${BREAKPOINTS.lg}) {
          grid-column: 9 / -2;
        }
      `;
        case 'narrowAdsLeft':
            return `
        &&{
          justify-self: stretch;
        }
        display: block;
        grid-column: 1 / -1;
        @media (min-width: ${BREAKPOINTS.md}) {
          grid-column: 3 / -3;
        } 
        @media (min-width: ${BREAKPOINTS.lg}) {
          grid-column: 2 / 5;
        }
      `;
        default:
            return '';
    }
};
const getGridTemplateStyleByChildColumnsLength = (childColumnsLength) => {
    if (childColumnsLength === 2) {
        return `
      @media (min-width: ${BREAKPOINTS.md}) {
        grid-template-columns: repeat(2, 1fr);
      }
    `;
    }
    else if (childColumnsLength === 3) {
        return `
      @media (min-width: ${BREAKPOINTS.lg}) {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    `;
    }
    else if (childColumnsLength === 4) {
        return `
      @media (min-width: ${BREAKPOINTS.xl}) {
        grid-template-columns: repeat(4, minmax(0, 1fr));
      }
    `;
    }
    else if (childColumnsLength === 5) {
        return `
      @media (min-width: ${BREAKPOINTS.md}) {
        grid-template-columns: repeat(5, minmax(0, 1fr));
      }
    `;
    }
    else if (childColumnsLength === 6) {
        return `
      @media (min-width: ${BREAKPOINTS.md}) {
        grid-template-columns: repeat(6, minmax(0, 1fr));
      }
    `;
    }
    return '';
};
const getAdRailStyle = (adRailType) => {
    switch (adRailType) {
        case 'normal':
            return `
        @media (min-width: ${BREAKPOINTS.lg}) and (max-width: 1045px) {
          grid-template-columns: repeat(8, 1fr) minmax(300px, 4fr);
        }
        @media (min-width: ${BREAKPOINTS.xl}) and (max-width: 1393px) {
          grid-template-columns: repeat(9, 1fr) minmax(300px, 3fr);
        }
      `;
        case 'narrow':
            return `
        @media (min-width: ${BREAKPOINTS.lg}) and (max-width: 1045px) {
          grid-template-columns: repeat(7, 1fr) minmax(300px, 4fr) 1fr;
        }
        @media (min-width: ${BREAKPOINTS.xl}) and (max-width: 1393px) {
          grid-template-columns: repeat(8, 1fr) minmax(300px, 3fr) 1fr;
        }
      `;
        case 'persistent':
            return `
          @media (min-width: ${BREAKPOINTS.lg}) and (max-width: 1045px) {
            grid-template-columns: repeat(7, 1fr) minmax(300px, 4fr) 1fr;
          }
          @media (min-width: ${BREAKPOINTS.xl}) and (max-width: 1393px) {
            grid-template-columns: repeat(8, 1fr) minmax(360px, 3fr) 1fr;
          }
        `;
        case 'narrowWithNarrowContent':
            return `
        @media (min-width: ${BREAKPOINTS.lg}) and (max-width: 1190px) {
          grid-template-columns: repeat(8, 1fr) minmax(300px, 4fr);
        }
      `;
        default:
            return '';
    }
};
const GridWrapper = styled.div.withConfig({
    displayName: 'GridWrapper'
}) `
  && {
    ${cssVariablesGrid()}

    ${({ isMarginOnly }) => !isMarginOnly &&
    `
    display: grid;
    grid-template-columns: repeat(4, 1fr);
  `}

  .newsletter-plp-full-bleed {
      display: grid;
      grid-column: 1/-1;
    }

    gap: ${({ hasGutters }) => (hasGutters ? `var(--grid-gap)` : 0)};

    ${({ hasMargin }) => hasMargin && applyGridSpacing('padding')}
    @media (max-width: ${BREAKPOINTS.lg}) {
      ${({ hasMarginMobile }) => hasMarginMobile && applyGridSpacing('padding')}
    }

    margin: 0 auto;
    width: 100%;
    max-width: ${({ isFullBleed }) => (isFullBleed ? `none` : BREAKPOINTS.xxl)};

    ${({ isEvenAny }) => !isEvenAny &&
    `
    @media (min-width: ${BREAKPOINTS.md}) {
      grid-template-columns: repeat(12, 1fr);
    }
  `}

    ${({ isEven, isEvenAny, childColumnsLength }) => isEven &&
    !isEvenAny &&
    `
    grid-template-columns: 1fr;

    ${isColumnsTwoThreeFourOrFive(childColumnsLength) &&
        `grid-template-columns: repeat(2, minmax(0,1fr));`};

    ${getGridTemplateStyleByChildColumnsLength(childColumnsLength)}
  `}
  
    ${({ isEvenAny }) => isEvenAny &&
    `
      grid-auto-columns: 1fr;
      grid-template-columns: initial;
    @media (min-width: ${BREAKPOINTS.md}) {
      grid-auto-flow: column;
    }
  `}

    ${({ isMarginOnly }) => isMarginOnly &&
    `
      &&{
      display: block;
      grid-template-columns: unset;
      }
  `}

  ${({ isAdrail, adRailType }) => isAdrail && getAdRailStyle(adRailType)}

  ${({ isMobileUp }) => isMobileUp &&
    `
    @media (max-width: ${BREAKPOINTS.md}) {
      grid-template-columns: 1fr;
    }
  `}

${({ isDynamicGridItemLayout, shouldDisplayDenseGrid }) => isDynamicGridItemLayout &&
    shouldDisplayDenseGrid &&
    `{
      grid-auto-flow: dense;
     }   
  `}
  }
`;
const GridItem = styled.div.withConfig({ displayName: 'GridItem' }) `
  ${({ spanValue }) => spanValue &&
    `
    grid-column: 1/-1;
    @media (min-width: ${BREAKPOINTS.md}) {
      grid-column: span ${spanValue};
    }
  `}

  ${({ layoutValue, adRailType }) => layoutValue === 'content' &&
    `
    &{
    grid-column: 1 / -1;
    ${getAdRailStyleByTypeAndLayoutContent(adRailType)}
    }
  `}

  ${({ layoutValue, adRailType }) => layoutValue === 'aside' &&
    `
    display: none;

    @media (min-width: ${BREAKPOINTS.lg}) {
      display: block;
      justify-self: start;
    }
    @media (min-width: ${BREAKPOINTS.xl}) {
      display: block;
      .ad--rail {
        max-width: 300px;
      }
    }
    ${getAdRailStyleByTypeAndLayoutAside(adRailType)}
  `}

  ${({ startColumn, endColumn }) => startColumn &&
    endColumn &&
    `
    grid-column-start: ${startColumn};
    grid-column-end: ${endColumn};
  `}

  ${({ startColumn, endColumn }) => startColumn === 2 &&
    endColumn === 12 &&
    `
      grid-column: 1 / 12;

      @media (min-width: ${BREAKPOINTS.lg}) {
        grid-column: 2 / 12;
      }
  `}

  ${({ isEvenGrid }) => isEvenGrid &&
    `
    grid-column-end: auto;
    grid-column-start: auto;
  `}
    ${({ gridItemColSpan, isDynamicGridItemLayout }) => isDynamicGridItemLayout &&
    gridItemColSpan &&
    `grid-column-end:span ${gridItemColSpan};
  `}
`;
module.exports = {
    GridWrapper,
    GridItem
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 9413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { asVariation } = __webpack_require__(81372);
const { columnSpanPresets } = __webpack_require__(7009);
const Grid = __webpack_require__(74479);
Grid.WithMargins = asVariation(Grid, 'WithMargins', {
    hasMargin: true
});
Grid.MarginsOnly = asVariation(Grid, 'MarginsOnly', {
    hasMargin: true,
    isMarginOnly: true
});
Grid.NoMargins = asVariation(Grid, 'NoMargins', {
    hasMargin: false
});
Grid.NoMarginsTwoUp = asVariation(Grid, 'NoMarginsTwoUp', {
    childColumns: [
        {
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        }
    ],
    hasMargin: false
});
Grid.ContentWithAdRail = asVariation(Grid, 'ContentWithAdRail', {
    childColumns: [
        {
            layoutValue: 'content',
            className: 'grid-layout__content',
            columnSpan: columnSpanPresets.mobile100Desktop75
        },
        {
            layoutValue: 'aside',
            className: 'grid-layout__aside',
            columnSpan: columnSpanPresets.mobile100Desktop25
        }
    ],
    adRailType: 'normal',
    hasMargin: true,
    isAdrail: true
}, { className: 'grid-layout--adrail' });
const ContentWithAdRailNarrowProps = {
    childColumns: [
        {
            layoutValue: 'content',
            className: 'grid-layout__content',
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            layoutValue: 'aside',
            className: 'grid-layout__aside',
            columnSpan: columnSpanPresets.mobile100Desktop25
        }
    ],
    adRailType: 'narrow',
    hasMargin: true,
    isAdrail: true
};
Grid.ContentWithAdRailNarrow = asVariation(Grid, 'ContentWithAdRailNarrow', ContentWithAdRailNarrowProps, { className: 'grid-layout--adrail narrow' });
Grid.ContentWithAdRailNarrowNoMargin = asVariation(Grid, 'ContentWithAdRailNarrow', {
    ...ContentWithAdRailNarrowProps,
    hasMargin: false,
    hasMarginMobile: true
}, { className: 'grid-layout--adrail narrow' });
Grid.ContentRightWithAdRailNarrow = asVariation(Grid, 'ContentRightWithAdRailNarrow', {
    childColumns: [
        {
            layoutValue: 'aside',
            className: 'grid-layout__aside',
            columnSpan: columnSpanPresets.mobile50Desktop20
        },
        {
            layoutValue: 'content',
            className: 'grid-layout__content',
            columnSpan: columnSpanPresets.mobile100Desktop75
        }
    ],
    adRailType: 'narrowAdsLeft',
    hasMargin: true,
    isAdrail: true
}, { className: 'narrow' });
Grid.ContentWithAdRailPersistent = asVariation(Grid, 'ContentWithAdRailPersistent', {
    childColumns: [
        {
            layoutValue: 'content',
            className: 'grid-layout__content',
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            layoutValue: 'aside',
            className: 'grid-layout__aside',
            columnSpan: columnSpanPresets.mobile100Desktop25
        }
    ],
    adRailType: 'persistent',
    hasMargin: true,
    isAdrail: true
}, { className: 'grid-layout--adrail persistent' });
Grid.NarrowContentWithWideAdRail = asVariation(Grid, 'NarrowContentWithWideAdRail', {
    childColumns: [
        {
            layoutValue: 'content',
            className: 'grid-layout__content',
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            layoutValue: 'aside',
            className: 'grid-layout__aside',
            columnSpan: columnSpanPresets.mobile100Desktop25
        }
    ],
    adRailType: 'narrowWithNarrowContent',
    hasMargin: true,
    isAdrail: true
}, { className: 'grid-layout--adrail narrow wide-adrail' });
Grid.TwoUp = asVariation(Grid, 'TwoUp', {
    childColumns: [
        {
            className: 'grid_content_columnOne',
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            className: 'grid_content_columnTwo',
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        }
    ],
    hasMargin: true
}, { className: 'grid-layout-twoColumns' });
Grid.ThreeUp = asVariation(Grid, 'ThreeUp', {
    childColumns: [
        {
            spanValue: 4,
            columnSpan: columnSpanPresets.mobile100Desktop33
        },
        {
            spanValue: 4,
            columnSpan: columnSpanPresets.mobile100Desktop33
        },
        {
            spanValue: 4,
            columnSpan: columnSpanPresets.mobile100Desktop33
        }
    ],
    hasMargin: true
});
Grid.EvenAny = asVariation(Grid, 'EvenAny', {
    hasMargin: false,
    isEven: true
});
Grid.EvenTwo = asVariation(Grid, 'EvenTwo', {
    childColumns: [
        {
            columnSpan: columnSpanPresets.mobile50Desktop50
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop50
        }
    ],
    hasMargin: false,
    isEven: true
});
Grid.EvenThree = asVariation(Grid, 'EvenThree', {
    childColumns: [
        {
            columnSpan: columnSpanPresets.mobile50Desktop33
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop33
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop33
        }
    ],
    hasMargin: false,
    isEven: true
});
Grid.EvenFour = asVariation(Grid, 'EvenFour', {
    childColumns: [
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        }
    ],
    hasMargin: false,
    isEven: true
});
Grid.EvenFourMobileUp = asVariation(Grid, 'EvenFourMobileUp', {
    childColumns: [
        {
            columnSpan: columnSpanPresets.mobile100Tablet50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile100Tablet50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile100Tablet50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile100Tablet50Desktop25
        }
    ],
    hasMargin: false,
    isEven: true,
    isMobileUp: true
});
Grid.EvenFive = asVariation(Grid, 'EvenFive', {
    childColumns: [
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 }
    ],
    hasMargin: false,
    isEven: true
});
Grid.EvenSix = asVariation(Grid, 'EvenSix', {
    childColumns: [
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 },
        { columnSpan: columnSpanPresets.mobile50Desktop20 }
    ],
    hasMargin: false,
    isEven: true
});
Grid.TwoUpFullBleedNoGap = asVariation(Grid, 'TwoUpFullBleedNoGap', {
    childColumns: [
        {
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        }
    ],
    hasMargin: false,
    isFullBleed: true,
    hasGutters: false
});
Grid.DynamicGrid = ({ startColumn, endColumn }) => asVariation(Grid, 'DynamicGrid', {
    hasMargin: true,
    gridColumns: {
        startColumn,
        endColumn
    }
});
Grid.WithMarginsFullBleed = asVariation(Grid, 'WithMarginsFullBleed', {
    childColumns: [
        {
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        },
        {
            spanValue: 6,
            columnSpan: columnSpanPresets.mobile100Desktop50
        }
    ],
    hasMargin: true,
    isFullBleed: true
});
Grid.DynamicGridItemLayout = asVariation(Grid, 'DynamicGridItemLayout', {
    isDynamicGridItemLayout: true,
    shouldDisplayDenseGrid: true,
    childColumns: [
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        },
        {
            columnSpan: columnSpanPresets.mobile50Desktop25
        }
    ],
    hasMargin: false,
    isEven: true
});
Grid.NoMarginsFullBleed = asVariation(Grid, 'NoMarginsFullBleed', {
    hasMargin: false,
    isFullBleed: true
});
module.exports = Grid;
//# sourceMappingURL=variations.js.map

/***/ }),

/***/ 82185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const LightboxContext = React.createContext();
module.exports = LightboxContext;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 47350:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { PersistentBottomWrapper } = __webpack_require__(31006);
const { TrackComponentChannel } = __webpack_require__(78788);
// Note: Do NOT remove the persistent-bottom class until working with the paywall
// team to replace.
const PersistentBottom = ({ children }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'PersistentBottom'
        });
    }, []);
    return (React.createElement(PersistentBottomWrapper, { className: "persistent-bottom", "data-journey-hook": "persistent-bottom" }, children));
};
PersistentBottom.propTypes = {
    children: PropTypes.node
};
module.exports = PersistentBottom;
//# sourceMappingURL=PersistentBottom.js.map

/***/ }),

/***/ 23074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(47350);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 31006:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { ZINDEX_MAP } = __webpack_require__(96472);
const PersistentBottomWrapper = styled.div.withConfig({
    displayName: 'PersistentBottomWrapper'
}) `
  position: fixed;
  right: 0;
  bottom: 0;
  left: 0;
  z-index: ${ZINDEX_MAP.persistentBottomLayer};

  @media print {
    display: none;
  }
`;
module.exports = {
    PersistentBottomWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 23656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { PersistentTopWrapper } = __webpack_require__(43068);
const { TrackComponentChannel } = __webpack_require__(78788);
// Note: Do NOT remove the persistent-top class until working with the paywall
// team to replace.
const PersistentTop = ({ children }) => {
    const [unStick, setUnSticky] = React.useState(false);
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'PersistentTop'
        });
    }, []);
    React.useEffect(() => {
        function getSizes() {
            if (Math.round((window.devicePixelRatio * 100) / 2) >= 400) {
                setUnSticky(true);
            }
            else {
                setUnSticky(false);
            }
        }
        window.addEventListener('resize', getSizes, false);
    }, []);
    return (React.createElement(PersistentTopWrapper, { className: "persistent-top", "data-testid": "PersistentTop", "data-journey-hook": "persistent-top", unStickHeader: unStick }, children));
};
PersistentTop.propTypes = {
    children: PropTypes.node
};
module.exports = PersistentTop;
//# sourceMappingURL=PersistentTop.js.map

/***/ }),

/***/ 26392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(23656);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 43068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { getColorToken, isInverted } = __webpack_require__(26865);
const { ZINDEX_MAP } = __webpack_require__(96472);
const PersistentTopWrapper = styled.div.withConfig({
    displayName: 'PersistentTopWrapper'
}) `
  position: fixed;
  top: 0;
  right: 0;
  left: 0;
  z-index: ${ZINDEX_MAP.persistentTopLayer};
  max-height: 50px;

  ${({ unStickHeader }) => unStickHeader &&
    `
      position: absolute;
  `};

  @media print {
    display: none;
  }

  /* This is done to add proper color to Close icon in Utility Navigation in Site Header */
  .icon-close > g {
    stroke: ${({ theme }) => getColorToken(theme, `colors.interactive.base.${isInverted(theme) ? 'light' : 'black'}`)};
  }
`;
module.exports = {
    PersistentTopWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 92881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { RowWrapper } = __webpack_require__(20139);
const { TrackComponentChannel } = __webpack_require__(78788);
const Row = ({ backgroundColor = null, bottomSpacing, children, className, id, topSpacing, dataJourneyHook, rowRef }) => {
    React.useEffect(() => {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Row'
        });
    }, []);
    return (React.createElement(RowWrapper, { "data-testid": "RowWrapper", id: id || undefined, "data-journey-hook": dataJourneyHook, className: className, backgroundColor: backgroundColor, bottomSpacing: bottomSpacing, topSpacing: topSpacing, ref: rowRef }, children));
};
Row.propTypes = {
    backgroundColor: PropTypes.oneOf([
        null,
        'light',
        'dark',
        'white',
        'black',
        'brand'
    ]),
    bottomSpacing: PropTypes.number,
    children: PropTypes.node.isRequired,
    className: PropTypes.string,
    dataJourneyHook: PropTypes.string,
    id: PropTypes.string,
    rowRef: PropTypes.shape({ current: PropTypes.object }),
    topSpacing: PropTypes.number
};
module.exports = Row;
//# sourceMappingURL=Row.js.map

/***/ }),

/***/ 66657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(92881);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const { BaseWrap } = __webpack_require__(76955);
const { getColorToken } = __webpack_require__(26865);
const RowWrapper = styled(BaseWrap).withConfig({ displayName: 'RowWrapper' }) `
  display: block;
  width: 100%;

  ${({ theme, backgroundColor }) => backgroundColor
    ? `background-color: ${getColorToken(theme, `colors.discovery.body.${backgroundColor}.background`)}`
    : ''};
`;
module.exports = {
    RowWrapper
};
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ 84234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const classnames = __webpack_require__(32485);
const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * ViewportMonitor component
 *
 * @param {object} props - React props
 * @param {ReactElement} [props.children] - The children of this element
 * @param {number} [props.observerOptions] - Threshold to be used for the intersection observer
 * @param {string} [props.onIntersectionViewport] - callback to run when viewport status changes
 *
 * @returns {ReactElement} <div>
 */
class ViewportMonitor extends React.Component {
    constructor() {
        super(...arguments);
        this.cleanup = () => {
            this.observer.unobserve(this.anchor);
        };
        this.handleRef = (node) => {
            this.anchor = node;
        };
    }
    async componentDidMount() {
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'ViewportMonitor'
        });
        this.setUpIntersectionObserver();
    }
    componentWillUnmount() {
        this.observer && this.observer.disconnect();
    }
    setUpIntersectionObserver() {
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0,
            ...this.props.observerOptions
        };
        const { analyticsData = {}, onIntersectionViewport = () => { } } = this.props;
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                // Call onIntersectionViewport passed in and give it a function to stop observing
                onIntersectionViewport(entry.isIntersecting, this.cleanup, analyticsData);
            });
        }, observerOptions);
        // Set up by ref property in div in render
        this.observer.observe(this.anchor);
    }
    render() {
        const { className, children, dataAttrKey = '' } = this.props;
        return (React.createElement("div", { "data-attr-viewport-monitor": dataAttrKey, className: classnames(className, 'viewport-monitor-anchor'), ref: this.handleRef }, children));
    }
}
ViewportMonitor.propTypes = {
    analyticsData: PropTypes.object,
    children: PropTypes.node,
    className: PropTypes.string,
    dataAttrKey: PropTypes.string,
    observerOptions: PropTypes.object,
    onIntersectionViewport: PropTypes.func
};
module.exports = ViewportMonitor;
//# sourceMappingURL=ViewportMonitor.js.map

/***/ }),

/***/ 3990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(84234);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 87755:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const PropTypes = __webpack_require__(5556);
const React = __webpack_require__(96540);
const Media = __webpack_require__(57770);
const Breakpoints = __webpack_require__(99906);
const { TrackComponentChannel } = __webpack_require__(78788);
/**
 * Viewport component
 *
 * @param {Function|ReactElement} children - Function that takes a boolean `match` to conditionally render contents, or an element that renders only when the query matches. See `react-media`'s explanation on why you may not want to use an element [here](https://github.com/ReactTraining/react-media/#usage).
 * @param {string} max - Breakpoint edge selector to set max width to, inclusive of edge (i.e. 'md' sets max width to 1023). Must be one of 'sm', 'md', 'lg', 'xl', 'xxl'.
 * @param {string} min - Breakpoint edge selector to set min width to, inclusive of edge (i.e. 'md' sets min width to 768). Must be one of 'sm', 'md', 'lg', 'xl', 'xxl'.
 * @param {boolean} [shouldMatchOnServer] - Optional setting to determine what value the component should return when no window is available (defaults to true).
 *
 * @returns {ReactElement} null
 */
class Viewport extends React.Component {
    constructor() {
        super(...arguments);
        this.state = { isClient: false };
    }
    componentDidMount() {
        this.setState({ isClient: true });
        window.Kendra.TRACK_COMPONENT.broadcast(TrackComponentChannel.RENDER, {
            name: 'Viewport'
        });
    }
    render() {
        const { children, max, min, shouldMatchOnServer = true } = this.props;
        const { isClient } = this.state;
        let query = {
            minWidth: 0
        };
        if (min && Breakpoints.sizes.indexOf(min) >= 0) {
            query.minWidth = Breakpoints.minThresholds[min];
        }
        if (max &&
            Breakpoints.sizes.includes(max) &&
            Breakpoints.sizes.indexOf(max) < Breakpoints.sizes.length - 1) {
            query.maxWidth = Breakpoints.maxThresholds[max];
        }
        // We want the server render and the first client render to match.
        // So, for both of those (!isClient) we will empty the query, falling to `defaultMatches`.
        if (!isClient) {
            query = {
                minWidth: 0
            };
        }
        // We're setting a key here to ensure that the `<Media>` component re-renders when we
        // transition from server->client. If we omit the `key`, then we get stuck results.
        return (React.createElement(Media, { key: isClient, defaultMatches: shouldMatchOnServer, query: query }, children));
    }
}
Viewport.propTypes = {
    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    max: PropTypes.oneOf(Breakpoints.sizes),
    min: PropTypes.oneOf(Breakpoints.sizes),
    shouldMatchOnServer: PropTypes.bool
};
module.exports = Viewport;
//# sourceMappingURL=Viewport.js.map

/***/ }),

/***/ 52089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(87755);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 17204:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const react_intl_1 = __webpack_require__(46984);
exports.A = (0, react_intl_1.defineMessages)({
    secondaryOptinsDangerousLegend: {
        id: 'NewsletterManageContent.SecondaryOptinsDangerousLegend',
        defaultMessage: 'Primary and Third Party Optins',
        description: 'Legend for secondary Optins'
    },
    // CPP: DELETEME
    // ukPrimaryMarketingPermission: {
    //   id: 'NewsletterManagePage.ukPrimaryMarketingPermission',
    //   defaultMessage: `Sign up to receive emails from {brandName} about {brandName}s products, promotions, and services.`,
    //   description: 'Primary marketing permissions for UK users'
    // },
    // ukThirdPartyMarketingPermission: {
    //   id: 'NewsletterManagePage.ukThirdPartyMarketingPermission',
    //   defaultMessage: `Sign up to receive marketing emails from {brandName} about special offers and promotions for other Cond Nast brands and our marketing partners.`,
    //   description: 'Third party marketing permissions for UK users'
    // },
    signUp: {
        id: 'NewsletterManageContent.SignUp',
        defaultMessage: 'Sign up',
        description: 'Legend for sign up'
    },
    signUpMessage: {
        id: 'NewsletterManageContent.SignUpMessage',
        defaultMessage: 'Youre signed up.',
        description: 'Legend for sign up success message'
    },
    previewText: {
        id: 'NewsletterManagePage.previewText',
        defaultMessage: 'Preview',
        description: 'Read a preview text in individual newsletter'
    },
    viewMoreNewsletters: {
        id: 'NewsletterManagePage.viewMoreNewsletters',
        defaultMessage: 'View more newsletters',
        description: 'View more newsletters in individual newsletter page after sign up'
    }
});
//# sourceMappingURL=translations.js.map

/***/ }),

/***/ 52813:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
// Hide an element visually, but have it available for screenreaders
function hideVisually() {
    return css `
    position: absolute;
    margin: 0;
    border: 0;
    padding: 0;
    width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    white-space: nowrap;
  `;
}
/// Hide only visually, but have it available for screenreaders
const visuallyhidden = `
    position: absolute;
    margin: -1px;
    border: 0;
    padding: 0;
    width: 1px;
    height: 1px;
    overflow: hidden;
    clip: rect(0 0 0 0);
`;
// remove styles to hide when focused
function hideVisuallyFocusable() {
    return css `
    ${hideVisually}

    &:active,
    &:focus {
      position: static;
      width: auto;
      height: auto;
      overflow: visible;
      clip: auto;
      clip-path: none;
      white-space: initial;
    }
  `;
}
// only hide text visually
function hideTextVisually() {
    return css `
    text-indent: -9999px;
  `;
}
module.exports = {
    hideTextVisually,
    hideVisually,
    hideVisuallyFocusable,
    visuallyhidden
};
//# sourceMappingURL=accessibility.js.map

/***/ }),

/***/ 63825:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled, css } = __webpack_require__(92168);
const PropTypes = __webpack_require__(5556);
const { getColorToken } = __webpack_require__(26865);
const baseButtonStyles = css `
  display: inline-block;
  background-color: ${({ theme }) => getColorToken(theme, 'colors.interactive.base.light')};

  /* Remove system default appearance for buttons */
  cursor: pointer;
  text-align: center;

  /* Add link styles */
  text-decoration: none;
  appearance: none;

  &:disabled {
    pointer-events: none;
  }

  &:hover,
  &:focus {
    text-decoration: underline;
  }
`;
const BaseButton = styled.button.withConfig({ displayName: 'BaseButton' }) `
  ${baseButtonStyles}
`;
BaseButton.defaultProps = {
    as: 'button'
};
BaseButton.propTypes = {
    as: PropTypes.string
};
module.exports = {
    BaseButton,
    baseButtonStyles
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 63015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { default: styled } = __webpack_require__(92168);
const PropTypes = __webpack_require__(5556);
const { getColorToken, getCheckboxRadioDefaultStyles, baseButtonStyles } = __webpack_require__(26865);
const BaseInput = styled.input.withConfig({ displayName: 'BaseInput' }) `
  border: 1px solid ${getColorToken('colors.interactive.base.black')};
  padding: 0.125em 0.5rem;

  &[disabled] {
    pointer-events: none;
  }

  &[type='checkbox'] {
    ${getCheckboxRadioDefaultStyles()}
  }

  &[type='radio'] {
    ${getCheckboxRadioDefaultStyles()}
  }

  &[type='submit'] {
    ${baseButtonStyles}
  }

  &[type='reset'] {
    cursor: pointer;
  }

  &[type='number']::-webkit-inner-spin-button {
    height: auto;
  }

  &[type='number']::-webkit-outer-spin-button {
    height: auto;
  }

  &[type='search'] {
    box-sizing: border-box;
  }
`;
BaseInput.defaultProps = {
    as: 'input'
};
BaseInput.propTypes = {
    as: PropTypes.string
};
module.exports = {
    BaseInput
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 60881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const PropTypes = __webpack_require__(5556);
const { getColorToken, getTypographyStyles, getLinkStyles } = __webpack_require__(26865);
const { BaseText } = __webpack_require__(18730);
/**
 * This function sets all links for a css class for link handling
 *
 * @param {boolean} hasUnderline - this param is to make links underlined on hover and focus
 *
 * @returns {string} returns CSS for links
 */
const setLinkDefaults = (hasUnderline) => {
    if (hasUnderline) {
        return ``;
    }
    return `
    cursor: pointer;
    text-decoration: none;

    &:active,
    &:link,
    &:visited {
      text-decoration: none;
    }

    &:hover,
    &:focus {
      text-decoration: underline;
    }
  `;
};
/**
 * For base link styling, uses styles from BaseText as base
 *
 * @param {string} [props.as] - the html element you'd like BaseLink to use (should be a if a link..)
 * @param {string} [props.hasUnderline] - this param is to make links underlined on hover and focus
 * @param {string} [props.colorToken] - this param is for the colorToken, defaults to 'colors.interactive.base.light'
 *
 * @returns {ReactElement} <a> with BaseLink CSS
 */
const BaseLink = styled(BaseText).withConfig({ displayName: 'BaseLink' }) `
  color: ${({ theme, colorToken }) => getColorToken(theme, colorToken)};
  transition-property: color, background, text-shadow;
  transition-duration: 5s;
  transition-timing-function: ease-in-out;
  ${({ theme, typeToken }) => getTypographyStyles(theme, typeToken)}
  ${({ theme, colorStaticLinkToken, colorSecondaryLinkToken, linkStyle }) => getLinkStyles(theme, colorStaticLinkToken, colorSecondaryLinkToken, linkStyle)}
  ${({ hasUnderline }) => setLinkDefaults(hasUnderline)}
`;
BaseLink.defaultProps = {
    as: 'a',
    colorToken: 'colors.interactive.base.light',
    hasUnderline: true,
    linkStyle: 'default'
};
BaseLink.propTypes = {
    as: PropTypes.string,
    colorSecondaryLinkToken: PropTypes.string,
    colorStaticLinkToken: PropTypes.string,
    colorToken: PropTypes.string,
    hasUnderline: PropTypes.bool,
    linkStyle: PropTypes.oneOf(['global', 'default', 'navigation']),
    target: PropTypes.string,
    typeToken: PropTypes.string
};
module.exports = {
    BaseLink
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const PropTypes = __webpack_require__(5556);
const { getTypographyStyles, getColorToken } = __webpack_require__(26865);
const { BaseWrap } = __webpack_require__(45741);
/**
 * BaseText can take an typeIdentity prop that maps to a BI typography key and returns all the rules in that key.
 *
 * @param {string} [props.as] - the html element you'd like WrappingLink to use, defaults to <p>
 * @param {number} [props.bottomSpacing] - prop to control top margin on BaseWrap component, which is inherited in BaseText, defaults to 0
 * @param {string} [props.colorToken] - prop to supply a colorToken for our BaseText, defaults to colors.consumption.body.standard.body
 * @param {string} [props.typeIdentity] - prop to supply a typeIdentity for our BaseText, defaults to typography.definitions.consumptionEditorial.body-core
 * @param {number} [props.topSpacing] - prop to control bottom margin on BaseWrap component, which is inherited in BaseText, defaults to 0
 *
 * @returns {ReactElement} <div> with BaseText CSS
 */
const BaseText = styled(BaseWrap).withConfig({ displayName: 'BaseText' }) `
  ${({ theme, typeIdentity }) => getTypographyStyles(theme, typeIdentity)};
  color: ${({ theme, colorToken }) => getColorToken(theme, colorToken)};

  a {
    color: inherit;
  }

  ${({ bottomSpacing, topSpacing }) => bottomSpacing || topSpacing ? `display: block;` : ''}
`;
BaseText.defaultProps = {
    as: 'p',
    bottomSpacing: 0,
    colorToken: 'colors.consumption.body.standard.body',
    topSpacing: 0,
    typeIdentity: 'typography.definitions.consumptionEditorial.body-core'
};
BaseText.props = {
    as: PropTypes.string,
    bottomSpacing: PropTypes.number,
    colorToken: PropTypes.string,
    topSpacing: PropTypes.number,
    typeIdentity: PropTypes.string
};
module.exports = {
    BaseText
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 43079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const PropTypes = __webpack_require__(5556);
const { getColorToken } = __webpack_require__(26865);
const BaseTextarea = styled.textarea.withConfig({
    displayName: 'BaseTextarea'
}) `
  border: 1px solid ${getColorToken('colors.interactive.base.black')};
  padding: 0.125em 0.5rem;
  width: 100%;
  ${({ maxWidth }) => maxWidth && `max-width: ${maxWidth};`}
`;
BaseTextarea.defaultProps = {
    as: 'textarea',
    maxWidth: '25em'
};
BaseTextarea.propTypes = {
    as: PropTypes.string
};
module.exports = {
    BaseTextarea
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 45741:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const styled = (__webpack_require__(92168)["default"]);
const PropTypes = __webpack_require__(5556);
const { calculateSpacing } = __webpack_require__(26865);
/**
 * bottomSpacing function to return bottom margin that is calculated per the sizing unit from brand identity (plucked from theme param)
 *
 * @param {number} bottomSpacing - value to control bottomSpacing margin
 *
 * @returns {string} returns CSS margin-top property with calculated spacing
 */
const bottomSpacing = ({ bottomSpacing }) => {
    if (bottomSpacing && !isNaN(bottomSpacing)) {
        return `margin-bottom: ${calculateSpacing(bottomSpacing)};`;
    }
    return '';
};
/**
 * topSpacing function to return top margin that is calculated per the sizing unit from brand identity (plucked from theme param)
 *
 * @param {number} topSpacing - value to control topSpacing
 *
 * @returns {string} returns CSS margin-top property with calculated spacing
 */
const topSpacing = ({ topSpacing }) => {
    if (topSpacing && !isNaN(topSpacing)) {
        return `margin-top: ${calculateSpacing(topSpacing)};`;
    }
    return '';
};
const alignments = ['left', 'center', 'right'];
const horizontalMargins = {
    left: `
  margin-left: 0;
  margin-right: auto;
  `,
    center: `
  margin-left: auto;
  margin-right: auto;
  `,
    right: `
  margin-right: 0;
  margin-left: auto;
  `
};
/**
 * BaseWrap is a base component template to supply base styles, as well as adding available
 * options for controlling alignment, bottomSpacing, topSpacing, and textAlign
 *
 * @param {string} [props.align] - the alignment for the content, left, center, and right are the available options
 * @param {number} [props.bottomSpacing] - prop to control top margin on BaseWrap component, which is inherited in BaseText, defaults to 0
 * @param {number} [props.topSpacing] - prop to control bottom margin on BaseWrap component, which is inherited in BaseText, defaults to 0
 * @param {string} [props.textAlign] - prop to control text alignment, left, center and right are available options
 *
 * @returns {ReactElement} <div> with BaseWrap CSS
 */
const BaseWrap = styled.div.withConfig({ displayName: 'BaseWrap-sc' }) `
  margin: 0;
  ${bottomSpacing}
  ${topSpacing}
  ${({ align }) => align &&
    alignments.includes(align) &&
    `
    align-self: ${align};
    justify-self: ${align};
    ${horizontalMargins[align]};
 `}
 ${({ textAlign }) => textAlign && alignments.includes(textAlign) && `text-align: ${textAlign}; `}
`;
BaseWrap.propTypes = {
    align: PropTypes.oneOf(alignments),
    as: PropTypes.string,
    bottomSpacing: PropTypes.number,
    textAlign: PropTypes.oneOf(alignments),
    topSpacing: PropTypes.number
};
module.exports = {
    BaseWrap,
    bottomSpacing,
    topSpacing
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 76955:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { BaseLink } = __webpack_require__(60881);
const { BaseText } = __webpack_require__(18730);
const { BaseWrap, topSpacing, bottomSpacing } = __webpack_require__(45741);
const { BaseInput } = __webpack_require__(63015);
const { BaseTextarea } = __webpack_require__(43079);
module.exports = {
    BaseLink,
    BaseText,
    BaseWrap,
    BaseInput,
    BaseTextarea,
    topSpacing,
    bottomSpacing
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 96472:
/***/ ((module) => {

const INTERACTIVE = {
    timingButtonDefault: '200ms',
    timingLinkDefault: '200ms',
    timingLinkNavigation: '200ms'
};
const BREAKPOINTS = {
    sm: '320px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    xxl: '1600px',
    max: '1280px',
    fullBleed: '1600px'
};
const BREAKPOINTS_RANGE = {
    sm: ['0px', '320px'],
    md: ['320px', '768px'],
    lg: ['768px', '1024px'],
    xl: ['1024px', '1280px'],
    xxl: ['1280px', '1600px']
};
const ZINDEX_MAP = {
    // skipLink should remain relatively high: as assistive tech is often tested separate to feature,
    // this is a high number to avoid it becoming hidden if another element is updated
    // stickyLayer must be in front of the page content, but behind the ConnectedNavigation (persistentTopLayer) and the BurgerMenu (persistentBottomLayer)
    skipLink: 800,
    hyperstitialLayer: 700,
    interstitialLayer: 600,
    stickyLayer: 350,
    persistentTopLayer: 500,
    persistentBottomLayer: 400,
    persistentAsideLayer: 300,
    oneNav: 450,
    navFixed: 80,
    tooltip: 50,
    dropdown: 50,
    content: 30
};
const INPUT_FIELD_PALETTE = {
    normal: {
        text: 7,
        icon: 7,
        background: 5,
        border: 6
    },
    active: {
        text: 8,
        icon: 8,
        background: 5,
        border: 8
    },
    valid: {
        text: 8,
        icon: 8,
        background: 5,
        border: 7
    },
    invalid: {
        text: 3,
        icon: 3,
        background: 5,
        border: 3
    },
    disabled: {
        text: 7,
        icon: 7,
        background: 6,
        border: 7
    }
};
const INTERACTIVE_PALLETE_TO_COLOR = {
    1: 'colors.interactive.base.brand-primary',
    2: 'colors.interactive.base.brand-secondary',
    3: 'colors.interactive.feedback.invalid-primary',
    4: 'colors.interactive.feedback.invalid-secondary',
    5: 'colors.interactive.base.white',
    6: 'colors.interactive.base.light',
    7: 'colors.interactive.base.dark',
    8: 'colors.interactive.base.black'
};
const GRID_GAP = {
    sm: 2,
    md: 3,
    lg: 4
};
// Helpful to detect if on server or browser
const CAN_USE_DOM = !!( true &&
    window.document &&
    window.document.createElement);
const GLOBAL_LINKS = {
    link: {
        style: 'null'
    },
    visited: {
        style: 'null'
    },
    hover: {
        style: 'underline'
    },
    active: {
        style: 'underline'
    },
    focus: {
        focus: 'underline'
    }
};
const SHOPIFY_IMAGE_SIZE_MAP = {
    large: '',
    medium: '&width=640',
    small: '&width=320'
};
const ACCESSIBILITY = {
    KEY_ENTER: 'Enter',
    KEY_SPACE: ' ',
    KEY_TAB: 'Tab',
    KEY_ESCAPE: 'Escape'
};
module.exports = {
    BREAKPOINTS,
    BREAKPOINTS_RANGE,
    CAN_USE_DOM,
    GLOBAL_LINKS,
    GRID_GAP,
    INPUT_FIELD_PALETTE,
    INTERACTIVE,
    INTERACTIVE_PALLETE_TO_COLOR,
    SHOPIFY_IMAGE_SIZE_MAP,
    ZINDEX_MAP,
    ACCESSIBILITY
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 72462:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.backgroundToken = exports.badgeToken = exports.graphicBorderFullToken = exports.graphicBorderSimpleToken = void 0;
const { css } = __webpack_require__(92168);
const stripJsonQuotes = (string) => {
    return string.substring(1, string.length - 1);
};
const borderImageSlice = (decorationToken) => {
    switch (decorationToken.side) {
        case 'top':
            return `var(--border-image-thickness) 0 0`;
        case 'right':
            return `0 var(--border-image-thickness) 0 0`;
        case 'left':
            return `0 0 0 var(--border-image-thickness)`;
        case 'bottom':
        default:
            return `0 0 var(--border-image-thickness)`;
    }
};
const borderImageSimpleWidth = (decorationToken) => {
    switch (decorationToken.align) {
        case 'start':
            switch (decorationToken.side) {
                case 'top':
                    return `1 var(--sides-edge) 0 0`;
                case 'right':
                    return `0 1 var(--sides-edge) 0`;
                case 'left':
                    return `0 0 var(--sides-edge) 1`;
                case 'bottom':
                default:
                    return `0 var(--sides-edge) 1 0`;
            }
        case 'end':
            switch (decorationToken.side) {
                case 'top':
                    return `1 0 0 var(--sides-edge)`;
                case 'right':
                    return `var(--sides-edge) 1 0 0`;
                case 'left':
                    return `var(--sides-edge) 0 0 1`;
                case 'bottom':
                default:
                    return `0 0 1 var(--sides-edge)`;
            }
        case 'center':
        default:
            return decorationToken.side === 'top' || decorationToken.side === 'bottom'
                ? `1 var(--sides-center) 1 var(--sides-center)`
                : `var(--sides-center) 1`;
    }
};
const borderImageOutset = (decorationToken) => {
    switch (decorationToken.placement) {
        case 'grid':
            return `calc((var(--grid-gap) / 2) + (var(--border-image-thickness-px) / 2)  + ${decorationToken.offset}px)`;
        case 'edge':
            return `calc(var(--border-image-thickness-px) / 2 + ${decorationToken.offset}px)`;
        case 'outside':
            return `calc(var(--border-image-thickness-px) + ${decorationToken.offset}px)`;
        case 'inside':
        case 'offset':
        default:
            return `${decorationToken.offset}px`;
    }
};
const borderImageFullWidth = (tokenValue) => {
    return `${tokenValue.top} ${tokenValue.right} ${tokenValue.bottom} ${tokenValue.left}`;
};
const graphicBorderSimpleToken = (decorationToken) => {
    return css `
    --width: ${decorationToken.width};
    --sides-center: calc((100% - var(--width)) / 2);
    --sides-edge: calc(100% - var(--width));
    --border-image-thickness: ${decorationToken.thickness};
    --border-image-thickness-px: ${decorationToken.thickness}px;
    border: var(--border-image-thickness-px) solid;
    ${({ theme }) => `border-image-source: url('./verso/static/${theme.meta.name}/assets/decorations/${stripJsonQuotes(decorationToken.file)}')`};
    border-image-slice: ${borderImageSlice(decorationToken)};
    border-image-width: ${borderImageSimpleWidth(decorationToken)};
    border-image-repeat: ${decorationToken.repeat};
    border-image-outset: ${borderImageOutset(decorationToken)};
  `;
};
exports.graphicBorderSimpleToken = graphicBorderSimpleToken;
const graphicBorderFullToken = (decorationToken) => {
    return css `
    --width: ${decorationToken.width};
    --sides-center: calc((100% - var(--width)) / 2);
    --sides-edge: calc(100% - var(--width));
    --border-image-thickness: ${decorationToken.thickness};
    --border-image-thickness-px: calc(var(--border-image-thickness) * 1px);
    border: var(--border-image-thickness-px) solid;
    ${({ theme }) => `border-image-source: url('./verso/static/${theme.meta.name}/assets/decorations/${stripJsonQuotes(decorationToken.file)}')`};
    border-image-slice: var(--border-image-thickness);
    border-image-width: ${borderImageFullWidth(decorationToken.sides)};
    border-image-repeat: ${decorationToken.repeat};
    border-image-outset: ${borderImageOutset(decorationToken)};
  `;
};
exports.graphicBorderFullToken = graphicBorderFullToken;
const badgeXCenter = (decorationToken) => {
    switch (decorationToken.x) {
        case 'left':
        case 'start':
            return css `
        left: calc(var(--widthHalf) * -1 + var(--offsetX));
      `;
        case 'right':
        case 'end':
            return css `
        left: calc(100% - var(--widthHalf) + var(--offsetX));
      `;
        case 'center':
        default:
            return css `
        left: calc(100% / 2 - var(--widthHalf) + var(--offsetX));
      `;
    }
};
const badgeXInside = (decorationToken) => {
    switch (decorationToken.x) {
        case 'left':
        case 'start':
            return css `
        left: var(--offsetX);
      `;
        case 'right':
        case 'end':
            return css `
        left: calc(100% - var(--width) + var(--offsetX));
      `;
        case 'center':
        default:
            return css `
        left: calc(100% / 2 - var(--widthHalf) + var(--offsetX));
      `;
    }
};
const badgeXOutside = (decorationToken) => {
    switch (decorationToken.x) {
        case 'left':
        case 'start':
            return css `
        left: calc(var(--width) * -1 + var(--offsetX));
      `;
        case 'right':
        case 'end':
            return css `
        left: calc(100% + var(--offsetX));
      `;
        case 'center':
        default:
            return css `
        left: calc(100% / 2 - var(--widthHalf) + var(--offsetX));
      `;
    }
};
const badgeYCenter = (decorationToken) => {
    switch (decorationToken.y) {
        case 'top':
        case 'start':
            return css `
        top: calc(var(--heightHalf) * -1 + var(--offsetY));
      `;
        case 'bottom':
        case 'end':
            return css `
        top: calc(100% - var(--heightHalf) + var(--offsetY));
      `;
        case 'center':
        default:
            return css `
        top: calc(100% / 2 - var(--heightHalf) + var(--offsetY));
      `;
    }
};
const badgeYInside = (decorationToken) => {
    switch (decorationToken.y) {
        case 'top':
        case 'start':
            return css `
        top: var(--offsetY);
      `;
        case 'bottom':
        case 'end':
            return css `
        top: calc(100% - var(--height) + var(--offsetY));
      `;
        case 'center':
        default:
            return css `
        top: calc(100% / 2 - var(--heightHalf) + var(--offsetY));
      `;
    }
};
const badgeYOutside = (decorationToken) => {
    switch (decorationToken.y) {
        case 'top':
        case 'start':
            return css `
        top: calc(var(--height) * -1 + var(--offsetY));
      `;
        case 'bottom':
        case 'end':
            return css `
        top: calc(100% + var(--offsetY));
      `;
        case 'center':
        default:
            return css `
        top: calc(100% / 2 - var(--heightHalf) + var(--offsetY));
      `;
    }
};
const badgeX = (decorationToken) => {
    switch (decorationToken.placement) {
        case 'center':
            return badgeXCenter(decorationToken);
        case 'outside':
            return badgeXOutside(decorationToken);
        case 'inside':
        default:
            return badgeXInside(decorationToken);
    }
};
const badgeY = (decorationToken) => {
    switch (decorationToken.placement) {
        case 'center':
            return badgeYCenter(decorationToken);
        case 'outside':
            return badgeYOutside(decorationToken);
        case 'inside':
        default:
            return badgeYInside(decorationToken);
    }
};
const badgeToken = (decorationToken) => {
    return css `
    position: relative;

    &::after {
      ${({ theme }) => `background-image: url('./verso/static/${theme.meta.name}/assets/decorations/${stripJsonQuotes(decorationToken.file)}')`};
      --width: ${decorationToken.width}px;
      --height: ${decorationToken.height}px;
      --widthHalf: calc(var(--width) / 2);
      --heightHalf: calc(var(--height) / 2);
      --offsetX: ${decorationToken.offsetX}px;
      --offsetY: ${decorationToken.offsetY}px;
      ${badgeX(decorationToken)}
      ${badgeY(decorationToken)}
      display: block;
      position: absolute;
      transform: rotate(${decorationToken.rotation}deg);
      width: var(--width);
      height: var(--height);
      content: '';
    }
  `;
};
exports.badgeToken = badgeToken;
const backgroundToken = (decorationToken) => {
    return css `
    position: relative;
    ${({ theme }) => `background-image: url('/verso/static/${theme.meta.name}/assets/decorations/${stripJsonQuotes(decorationToken.file)}')`};
    background-attachment: ${decorationToken.attachment};
    background-repeat: ${decorationToken.repeat};
    background-position: ${decorationToken.position};
    background-size: ${decorationToken.size};
  `;
};
exports.backgroundToken = backgroundToken;
//# sourceMappingURL=decorations.js.map

/***/ }),

/***/ 54482:
/***/ ((module) => {

const ARROW_DIRECTION = {
    top: 'top',
    right: 'right',
    bottom: 'bottom',
    left: 'left'
};
const directionMap = new Map([
    [ARROW_DIRECTION.top, ['left', 'right', 'bottom']],
    [ARROW_DIRECTION.right, ['top', 'bottom', 'left']],
    [ARROW_DIRECTION.bottom, ['right', 'left', 'top']],
    [ARROW_DIRECTION.left, ['bottom', 'top', 'right']]
]);
// This is broken need to redo
const generateArrowBorders = (direction, size, color) => {
    const [border1, border2, border3] = directionMap.get(direction) ?? [];
    return `
    border-${border1}: ${size} solid transparent;
    border-${border2}: ${size} solid transparent;
    border-${border3}: ${size} solid ${color};
  `;
};
const generateArrow = (direction, size, color) => {
    return `
    display: inline-block;
    width: 0;
    height: 0;

    ${generateArrowBorders(direction, size, color)}
  `;
};
module.exports = {
    ARROW_DIRECTION,
    directionMap,
    generateArrowBorders,
    generateArrow
};
//# sourceMappingURL=generate-arrow.js.map

/***/ }),

/***/ 54318:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const striptags = __webpack_require__(67098);
const generateId = (props, generateIdFrom) => {
    if (props[generateIdFrom]) {
        const stripHtmlTag = striptags(props[generateIdFrom])?.trim();
        stripHtmlTag?.replace(/[^a-zA-Z0-9 ]/g, '');
        return stripHtmlTag?.toLowerCase().split(' ').join('-');
    }
    return null;
};
module.exports = {
    generateId
};
//# sourceMappingURL=generate-id.js.map

/***/ }),

/***/ 63799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { getCookie } = __webpack_require__(56892);
const countryCurrencyMapping = {
    US: 'USD',
    GB: 'GBP',
    FR: 'EUR',
    DE: 'EUR',
    IN: 'INR',
    IT: 'EUR',
    JP: 'JPY',
    MX: 'MXN',
    RU: 'RUB',
    ES: 'EUR',
    TW: 'TWD'
};
const filterOffers = (offers, country) => {
    const filteredOffers = offers.filter((offer) => offer.countryCode && offer.countryCode !== ''
        ? offer.countryCode === country
        : offer.currency === countryCurrencyMapping[country]);
    return filteredOffers;
};
const getProductLocalisedOffers = (defaultCountry, offers) => {
    if (!offers || offers.length === 0)
        return offers;
    const countryCode = getCookie('CN_geo_country_code');
    let localisedOffers = [];
    if (countryCurrencyMapping[countryCode]) {
        localisedOffers = filterOffers(offers, countryCode);
    }
    if (localisedOffers.length < 1) {
        localisedOffers = filterOffers(offers, defaultCountry);
        if (localisedOffers.length < 1) {
            localisedOffers.push(offers[0]);
        }
    }
    return localisedOffers;
};
module.exports = { getProductLocalisedOffers, countryCurrencyMapping };
//# sourceMappingURL=get-localised-offers.js.map

/***/ }),

/***/ 16800:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSectionSpacingStyling = void 0;
const { getThemeValue } = __webpack_require__(26865);
/**
 * Returns the CSS values for margin top and bottom based on the Brand Identity and the type of spacing to be applied.
 *
 * @param {...(string|object)} args - The list of arguments passed into the function.
 * @param {object} args[0] - Either the theme object or the token string.
 * @param {string} args[1] - Token string like "gap-sm", "gap-md", etc.
 * @returns {string} - CSS styling containing mostly the margin top and bottom.
 */
const getSectionSpacingStyling = (...args) => {
    // currying the function in case the theme object is not passed
    if (typeof args[0] === 'string') {
        return ({ theme }) => (0, exports.getSectionSpacingStyling)(theme, ...args);
    }
    const defaultValue = {
        section: {
            'gap-sm': 'spacing-0',
            'gap-md': 'spacing-0',
            'padding-top-sm': 'spacing-0',
            'padding-top-md': 'spacing-0',
            'padding-bottom-sm': 'spacing-0',
            'padding-bottom-md': 'spacing-0'
        }
    };
    const [theme, token] = args;
    const spacing = getThemeValue(theme, 'spacing') || defaultValue;
    return spacing[spacing.section[token]];
};
exports.getSectionSpacingStyling = getSectionSpacingStyling;
//# sourceMappingURL=get-spacing-tokens.js.map

/***/ }),

/***/ 89085:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { calculateSpacing } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
const { cssVariablesGrid } = __webpack_require__(1123);
/**
 * cssVariablesCollage
 *
 * @returns {string} returns CSS variables collage
 */
const cssVariablesCollage = () => {
    return `
  @media (min-width: ${BREAKPOINTS.md}) {
    --border-offset: ${calculateSpacing(1.5)} ;

    @media (min-width: ${BREAKPOINTS.xl}) {
      --border-offset: ${calculateSpacing(2)};
    }
  }
  `;
};
/**
 * universalGridCore
 *
 * @param useRowGroup - type of useRowGroup, default to true
 *
 * @returns {string} returns Grid code
 */
const universalGridCore = (useRowGroup = true) => {
    return `
    
    ${cssVariablesGrid()}
    display: grid;
    // four for mobile, default
    grid-template-columns: repeat(4, 1fr);
    column-gap: var(--grid-gap);
    row-gap: ${useRowGroup ? 'var(--grid-gap)' : '0'};
    margin: 0 auto;
    width: 100%;
    max-width: ${BREAKPOINTS.xxl};
  
    @media (min-width: ${BREAKPOINTS.md}) {
      grid-template-columns: repeat(12, 1fr);
    }
    `;
};
// 1. select the first element in the last row
//    item which is both the start of a group of n from the start,
//    and one of the last n
// 2. select the following siblings of the previously selected item
// 3. pass on any styles to those items
/**
 * findLastRow
 *
 * @param linesInRow - select the first element in the last row item which is both the start of a group of n from the start,and one of the last n
 * @param siblingElement - tselect the following siblings of the previously selected item
 * @returns {string} returns Grid code
 */
const findLastRow = (linesInRow, siblingElement = 'div') => {
    return `
  &:nth-child(${linesInRow}n+1):nth-last-child(-n+${linesInRow}),
  &:nth-child(${linesInRow}n+1):nth-last-child(-n+${linesInRow}) ~ ${siblingElement}
  `;
};
function createCSS() {
    let styles = '';
    for (let j = 1; j <= 100; j++) {
        styles += `
    > *:nth-child(${j}) {
      order: ${j};
    }
    `;
    }
    return `
    ${styles}
  `;
}
const createMultipackageContainerStyles = (MultiPackageContainer) => {
    return `
  ${MultiPackageContainer} {
    display: flex;
    flex-flow: row wrap;
    align-items: stretch;
    justify-content: center;

    > * {
      width: 100%;
    }

    ${createCSS()}
  }
  `;
};
module.exports = {
    createMultipackageContainerStyles,
    cssVariablesCollage,
    findLastRow,
    universalGridCore
};
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ 43428:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleLinkClick = void 0;
const short = __webpack_require__(60943);
const { encodeAffiliateLink } = __webpack_require__(25203);
const { getXidAndAmguuid } = __webpack_require__(5344);
const buildAffiliateUrl = (url, actionId, contentUrl, xidAndAmguuid, params, component, queryParams) => {
    const affiliateLink = encodeAffiliateLink(url, {
        actionId,
        contentUrl,
        ...xidAndAmguuid,
        component,
        extractedParams: queryParams // Use new parameter name for consistency
    });
    try {
        const affiliateUrl = new URL(affiliateLink);
        if (params) {
            const extraParams = new URLSearchParams(params);
            for (const [key, value] of extraParams.entries()) {
                if (value && value.trim() !== '') {
                    affiliateUrl.searchParams.set(key, value);
                }
            }
        }
        return affiliateUrl.toString();
    }
    catch (error) {
        console.error('Failed to build affiliate URL:', error);
        return affiliateLink || url;
    }
};
const handleLinkClick = (options) => {
    const { event, onClickHandler, gtmTrackOnClick, linkProps, setLinkProps, label, position, link, type, index, component, queryParams } = options;
    const actionId = short.generate('hex', 10);
    switch (type) {
        case 'upcCard': {
            onClickHandler &&
                onClickHandler({ label, position, link, event, actionId });
            gtmTrackOnClick && gtmTrackOnClick(event, actionId);
            break;
        }
        case 'upcEmbedded': {
            onClickHandler({ label, position, link, event, actionId });
            gtmTrackOnClick && gtmTrackOnClick(event, actionId, null, null, position);
            break;
        }
        case 'PLPProductCard': {
            onClickHandler({ event, actionId });
            break;
        }
        case 'GallerySlideCaption': {
            gtmTrackOnClick(event, actionId);
            break;
        }
        case 'GallerySlideImage': {
            gtmTrackOnClick(position, event, actionId);
            break;
        }
        case 'UPCImage': {
            gtmTrackOnClick(event, actionId, index);
            break;
        }
        case 'ButtonGroupCallout': {
            onClickHandler({});
            gtmTrackOnClick(linkProps, event, actionId);
            break;
        }
        case 'AffiliateLink': {
            const data = {
                type: 'product_affiliate_link',
                actionId,
                component: label
            };
            onClickHandler(event, data);
            break;
        }
        default:
            break;
    }
    const contentUrl = document.querySelector("link[rel='canonical']")?.getAttribute('href') ||
        null;
    const xidAndAmguuid = getXidAndAmguuid();
    const [url, params] = linkProps.includes('?')
        ? linkProps.split('?')
        : [linkProps];
    const newHref = buildAffiliateUrl(url, actionId, contentUrl, xidAndAmguuid, params, component, queryParams);
    if (setLinkProps) {
        setLinkProps(newHref);
    }
};
exports.handleLinkClick = handleLinkClick;
//# sourceMappingURL=handle-product-click.js.map

/***/ }),

/***/ 52027:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.roundImageBase = void 0;
/**
 * Circular Image - Size. It is used in roundImageBase only.
 *
 * @param widthHeight - height and width need to be equal to create a circle
 * @param minWidthHeight - minimum height and width for scaling
 * @param maxWidthHeight - maximum height and width for scaling
 * @returns {string} - the additional, size styles of image
 */
const roundImageSize = (widthHeight, minWidthHeight = null, maxWidthHeight = null) => {
    const styles = [];
    if (widthHeight.includes('%')) {
        styles.push(`
      width: ${widthHeight};
      height: auto;
    `);
    }
    else {
        styles.push(`
      width: ${widthHeight};
      height: ${widthHeight};
    `);
    }
    if (minWidthHeight) {
        styles.push(`
      min-width: ${minWidthHeight};
      min-height: ${minWidthHeight};
    `);
    }
    if (maxWidthHeight) {
        styles.push(`
      max-width: ${maxWidthHeight};
      max-height: ${maxWidthHeight};
    `);
    }
    return styles.join('');
};
/**
 * Circular Image - Base Styles
 *
 * @param widthHeight - height and width need to be equal to create a circle
 * @param minWidthHeight - minimum height and width for scaling
 * @param maxWidthHeight - maximum height and width for scaling
 * @returns {string} - the styles
 */
function roundImageBase(widthHeight, minWidthHeight = null, maxWidthHeight = null) {
    return `
    ${roundImageSize(widthHeight, minWidthHeight, maxWidthHeight)}
    display: block;
    border-radius: 50%;
    overflow: hidden;
  `;
}
exports.roundImageBase = roundImageBase;
//# sourceMappingURL=images.js.map

/***/ }),

/***/ 26865:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(65606);

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.textBoxTrimMixin = exports.isInverted = exports.getJsonMLChildren = exports.isJsonMLElement = exports.firstLetterDropCap = exports.RGBAToHexA = exports.getCheckboxRadioDefaultStyles = exports.customScrollbar = exports.columnCalc = exports.styledProperty = exports.minMaxScreen = exports.maxScreen = exports.minScreen = exports.clearFix = exports.getDecoration = exports.getInputFieldStyles = exports.getInputFieldColor = exports.getZIndex = exports.removeTextDecoration = exports.getLinkStyles = exports.getTypographyStyles = exports.getColorStyles = exports.getColorToken = exports.resolvePaletteKey = exports.getThemeValue = exports.calculateSpacing = exports.gridSpacing = void 0;
const get = __webpack_require__(58156);
const isEqualFp = __webpack_require__(72115);
const { css } = __webpack_require__(92168);
const { graphicBorderSimpleToken, graphicBorderFullToken, badgeToken, backgroundToken } = __webpack_require__(72462);
const { BREAKPOINTS, GLOBAL_LINKS, ZINDEX_MAP, INPUT_FIELD_PALETTE, INTERACTIVE_PALLETE_TO_COLOR } = __webpack_require__(96472);
exports.gridSpacing = 8;
/**
 * calculateSpacing
 *
 * @param {number} multiplier - spacing size, used as the base value for finding the multiplied size, defaults to 1
 * @param {string} returnUnit - unit that the spacing value is returned with, defaults to rem, otherwise px
 * @returns {string} spacing value, if no value, it returns null
 */
function calculateSpacing(multiplier = 1, returnUnit = 'rem') {
    const unit = exports.gridSpacing; // snap spacing to an 8px grid
    const size = unit * multiplier;
    const value = returnUnit === 'rem' ? `${size / 16 / 1}rem` : `${size * 1}px`;
    if (!value) {
        return null;
    }
    return value;
}
exports.calculateSpacing = calculateSpacing;
/**
 * getThemeValue
 *
 * @param {object} theme - Theme object, which comes from our ThemeProvider
 * @param {string} keys - string with object dot notation of token name to find in theme.
 *
 * @returns {string} value of given token
 */
function getThemeValue(theme, keys) {
    if (!theme || Object.keys(theme).length === 0) {
        return null;
    }
    if (!keys || keys.length === 0) {
        return null;
    }
    const value = keys
        .split('.')
        .reduce((previous, current) => previous && previous[current], theme);
    if (value === undefined) {
        if (process.env.BUILD_ENV === 'dev') {
            console.trace(`Invalid theme token ${keys} provided`);
            throw new Error(`Invalid theme token ${keys} provided`);
        }
        return null;
    }
    return value;
}
exports.getThemeValue = getThemeValue;
const PALETTE_KEYS = ['standard', 'inverted', 'special'];
function resolvePaletteKey(theme, keys) {
    if (!keys || keys.length === 0)
        return null;
    const keysList = keys.split('.');
    // The palette key is typically the penultimate key.
    const paletteIndex = keysList.length - 2;
    // Failsafe if we introduce small tokens
    if (paletteIndex < 0)
        return keys;
    const paletteKey = keysList[paletteIndex];
    // Check if its a key we can resolve for.
    if (!PALETTE_KEYS.includes(paletteKey))
        return keys;
    keysList[paletteIndex] = theme.palette || 'standard';
    return keysList.join('.');
}
exports.resolvePaletteKey = resolvePaletteKey;
/**
 * Resolves a token to a colour in a theme's palette
 *
 * @param {...(string|object)} args - The list of arguments passed into the
 * function
 * @param {string|object} args[0] - Either the theme object or token string. If
 * a string is passed in, the function will be curried.
 * @param {string|object} args[1] - Either token string or overrides.
 * @param {object} [args[2]={}] - An override config
 * @param {boolean} [args[2].rgbOnly] - Whether to return just the rgb values
 *
 * @returns {string|({theme: object}) => string} Returns either a curried
 * function of the requested token or the token value.
 *
 * @example
 * // Returns token value - rgba(0,0,0,1)
 * getColorToken({}, 'colors.background.black')
 * // Returns just rgb value of token value - 0,0,0
 * getColorToken({}, 'colors.background.black', { rgbOnly: true })
 * // Returns curried function
 * getColorToken('colors.background.black')
 */
function getColorToken(...args) {
    if (typeof args[0] === 'string') {
        return ({ theme }) => {
            return getColorToken(theme, ...args);
        };
    }
    const [theme, keys, overrides = {}] = args;
    // const paletteCorrectedKeys = resolvePaletteKey(theme, keys);
    const value = getThemeValue(theme, keys);
    const token = value ? getThemeValue(theme, `colors.palette.${value}`) : null;
    if (overrides.rgbOnly && token) {
        return token.slice(5, token.length - 3);
    }
    return token;
}
exports.getColorToken = getColorToken;
/**
 * getTypographyBreakpoints
 *
 * @param {number} fontSizeMd - font size for medium breakpoints
 * @param {number} lineHeightMd - line height for medium breakpoints
 * @param {number} fontSizeLg - font size for large breakpoints
 * @param {number} lineHeightLg - line height for large breakpoints
 *
 * @returns {object} returns object with keys mediumBreakpointOverrides & largeBreakpointOverrides
 */
const getTypographyBreakpoints = (fontSizeMd, lineHeightMd, fontSizeLg, lineHeightLg) => {
    return {
        mediumBreakpointOverrides: fontSizeMd && lineHeightMd
            ? `
    @media (min-width: ${BREAKPOINTS.md}) {
      ${fontSizeMd};
      ${lineHeightMd};
    }
  `
            : '',
        largeBreakpointOverrides: fontSizeLg && lineHeightLg
            ? `
    @media (min-width: ${BREAKPOINTS.lg}) {
      ${fontSizeLg};
      ${lineHeightLg};
    }
  `
            : ''
    };
};
function getColorStyles(...args) {
    if (typeof args[0] === 'string') {
        return ({ theme }) => {
            return getColorStyles(theme, ...args);
        };
    }
    const [theme, property, colorToken] = args;
    const colorVar = `--${property}__token-name: ${colorToken}`;
    const colorStyle = `${property}: ${getColorToken(theme, colorToken)}`;
    return `
    ${colorVar};
    ${colorStyle}
  `;
}
exports.getColorStyles = getColorStyles;
/**
 * Resolves a token to a group of CSS styles
 *
 * @param {...(string|object)} args - The list of arguments passed into the
 * function
 * @param {string|object} args[0] - Either the theme object or token string. If
 * a string is passed in, the function will be curried.
 * @param {string} args[1] - Either token string
 *
 * @returns {string|({theme: object}) => string} Returns either a curried function
 * of the requested token or CSS values for the type token.
 *
 * @example
 * // Returns type settings
 * getTypographyStyles({}, 'typography.definitions.consumptionEditorial.body-core')
 * // Returns curried function
 * getTypographyStyles('typography.definitions.consumptionEditorial.body-core')
 */
/* eslint-disable complexity */
function getTypographyStyles(...args) {
    if (typeof args[0] === 'string') {
        return ({ theme }) => {
            return getTypographyStyles(theme, ...args);
        };
    }
    const [theme, keys] = args;
    const value = getThemeValue(theme, keys);
    if (!value) {
        return null;
    }
    const typeToken = `--type-token: ${keys.split('.').slice(2).join('.')};`;
    const fallbackFamily = getThemeValue(theme, `typography.typefaces.${value.family}`)?.fallback?.slice(1, -1) || '';
    const fontVariantValue = getThemeValue(theme, `typography.typefaces.${value.family}`)?.fontvariant?.slice(1, -1) || '';
    const textTransform = value.case
        ? `text-transform: ${value.case !== 'normal' ? value.case : 'none'};`
        : '';
    const fontFamily = value.family
        ? `font-family: ${value.family} ${fallbackFamily ? `, ${fallbackFamily}` : ``};`
        : '';
    let fontStyle = '';
    if (value.italic === true) {
        fontStyle = `font-style: italic;`;
    }
    else if (value.italic === false) {
        fontStyle = `font-style: normal;`;
    }
    // Thinking about values less than 0, which are indeed truthy, or if the
    // value IS 0, then we return letter spacing normal.
    const letterSpacing = value['letter-spacing']
        ? `letter-spacing: ${value['letter-spacing']}em;`
        : `letter-spacing: normal;`;
    const ligatures = value.ligatures
        ? `font-variant-ligatures: ${value.ligatures};`
        : '';
    const fontVariant = fontVariantValue
        ? `font-variant: ${fontVariantValue};`
        : '';
    const lineHeight = value['line-height']
        ? `line-height: ${value['line-height']}em;`
        : '';
    // Font feature settings spec requires a mix of strings wrapped in quotes
    // that reference features, and integers to disable those features.
    // In order to write valid CSS, we do not wrap the value in quotes.
    const fontFeatureSettings = value['font-feature-settings']
        ? `font-feature-settings: ${value['font-feature-settings']};`
        : 'font-feature-settings: normal;';
    const fontSize = value['mobile-size']
        ? `font-size: ${value['mobile-size']}px;`
        : '';
    const fontWeight = value.weight ? `font-weight: ${value.weight};` : '';
    const fontSizeMd = value.fontSizeMd
        ? `font-size: ${value.fontSizeMd}px`
        : null;
    const lineHeightMd = value.lineHeightMd
        ? `line-height: ${value.lineHeightMd * 1}em`
        : null;
    const fontSizeLg = value.fontSizeLg
        ? `font-size: ${value.fontSizeLg}px`
        : null;
    const lineBreak = value['line-break']
        ? `line-break: ${value['line-break']};`
        : 'line-break: auto;';
    const lineHeightLg = value.lineHeightLg
        ? `line-height: ${value.lineHeightLg * 1}em`
        : null;
    const overflowWrap = value['overflow-wrap']
        ? `overflow-wrap: ${value['overflow-wrap']};`
        : 'overflow-wrap: normal;';
    const breakpoints = getTypographyBreakpoints(fontSizeMd, lineHeightMd, fontSizeLg, lineHeightLg);
    return `
    ${typeToken}
    ${textTransform}
    ${fontFamily}
    ${fontFeatureSettings}
    ${fontStyle}
    ${letterSpacing}
    ${ligatures}
    ${fontVariant}
    ${lineBreak}
    ${lineHeight}
    ${fontSize}
    ${fontWeight}
    ${overflowWrap}
    ${breakpoints.mediumBreakpointOverrides}
    ${breakpoints.largeBreakpointOverrides}
  `;
}
exports.getTypographyStyles = getTypographyStyles;
/* eslint-enable complexity */
/**
 * getLinkStyles
 *
 * @param {...(string|object)} args - The list of arguments passed into the
 * function
 * @param {string|object} args[0] - Either the theme object or token string for
 * static colors. If a string is passed in, the function will be curried.
 * @param {string} args[1] - Either token string for static color or secondary
 * color.
 * @param {string} args[2] - Secondary color token or link styles
 * @param {string} args[3] - Key for link style. Defaults to `default`.
 *
 * @returns {string|({theme: object}) => string} Returns either a curried function
 * of the requested link styles or CSS values for the link styles.
 */
function getLinkStyles(...args) {
    if (typeof args[0] === 'string' || args[0] === null) {
        return ({ theme }) => {
            return getLinkStyles(theme, ...args);
        };
    }
    const [theme, colorStaticToken = null, colorSecondaryToken = null, linkStyle = 'default'] = args;
    const linkStyles = linkStyle === 'global'
        ? GLOBAL_LINKS
        : getThemeValue(theme, `interactive.links.${linkStyle || 'default'}`);
    if (!linkStyles) {
        return '';
    }
    const { link, visited, hover, active, focus } = linkStyles;
    const colorStaticValue = getColorToken(theme, colorStaticToken || 'colors.consumption.body.standard.body');
    const colorSecondaryValue = getColorToken(theme, colorSecondaryToken);
    return `
    color: ${colorStaticValue};
    cursor: pointer;
    &:link {
      text-decoration: ${link.style === 'null' ? `inherit` : link.style};
      color: ${colorStaticValue};
    }
    &:visited {
      text-decoration: ${visited.style === 'null' ? `inherit` : visited.style};
      color: ${colorStaticValue};
    }
    &:hover {
      color: ${colorSecondaryValue && colorStaticValue !== colorSecondaryValue
        ? colorSecondaryValue
        : colorStaticValue};
      text-decoration: ${hover.style === 'null' ? `inherit` : hover.style};
    }
    &:active {
      color: ${colorSecondaryValue && colorStaticValue !== colorSecondaryValue
        ? colorSecondaryValue
        : colorStaticValue};
      text-decoration: ${active.style === 'null' ? `inherit` : active.style};
    }
    &:focus {
      color: ${colorSecondaryValue && colorStaticValue !== colorSecondaryValue
        ? colorSecondaryValue
        : colorStaticValue};
      text-decoration: ${focus.style === 'null' ? `inherit` : focus.style};
    }
    transition-property: color, background, text-shadow;
    transition-duration: 0.2s;
    transition-timing-function: ease-in-out;
  `;
}
exports.getLinkStyles = getLinkStyles;
/**
 * removeTextDecoration
 *
 * @returns {string} CSS to be applied for no text decoration on hover and active states
 */
function removeTextDecoration() {
    return `
    &:hover,
    &:active {
      text-decoration: none;
    }
  `;
}
exports.removeTextDecoration = removeTextDecoration;
/**
 * getZIndex
 *
 * @param {string} element - string of element to return z index of
 *
 * @returns {number} - returns z index of given element passed in as param
 */
function getZIndex(element) {
    return ZINDEX_MAP[element] || 0;
}
exports.getZIndex = getZIndex;
/**
 * getInputFieldColor
 *
 * @param {string} state - string with state to determine the state of input-field : active, valid, normal, disabled
 * @param {string} key - string with key to determine input-field variant : border, background, text, icon
 *
 * @returns {string} CSS Color to be applied for Input Field
 */
function getInputFieldColor(state, key) {
    const inputFieldPalleteConfig = INPUT_FIELD_PALETTE[state][key];
    return INTERACTIVE_PALLETE_TO_COLOR[inputFieldPalleteConfig];
}
exports.getInputFieldColor = getInputFieldColor;
/**
 * getInputFieldStyles
 *
 * @param {object} theme - Theme object, which comes from our ThemeProvider
 * @param {string} state - string with state to determine the state of input-field : active, valid, normal, disabled
 * @param {string} key - string with key to determine input-field variant : border, background, text, icon
 *
 * @returns {string} CSS to be applied for type styles
 */
function getInputFieldStyles(theme, state, key) {
    const colorStaticToken = getInputFieldColor(state, key);
    const colorStaticValue = getColorToken(theme, colorStaticToken);
    const borderStyle = key === 'border'
        ? `border-width: 1px;
      border-style: solid;
      border-color: ${colorStaticValue};`
        : '';
    const backgroundColorStyle = key === 'background' ? `background-color: ${colorStaticValue};` : '';
    const textColorStyle = key === 'text' ? `color: ${colorStaticValue};` : '';
    const iconColorStyle = key === 'icon'
        ? `fill: ${colorStaticValue};
      ${state === 'disabled' ? 'pointer-events: none;' : ''}`
        : '';
    return `
${borderStyle}
${backgroundColorStyle}
${textColorStyle}
${iconColorStyle}
  `;
}
exports.getInputFieldStyles = getInputFieldStyles;
/*
 * getDecoration
 *
 * @param {object} theme - Theme object, which comes from our ThemeProvider
 * @param {string} decorationToken - decoration token
 *
 * @returns {number} - returns value of a decoration token in pixels
 */
function getDecoration(theme, decorationToken) {
    const token = getThemeValue(theme, `decorations.${decorationToken}`);
    if (!token)
        return null;
    switch (token.type) {
        case 'graphic-border-simple':
            return graphicBorderSimpleToken(token);
        case 'graphic-border-full':
            return graphicBorderFullToken(token);
        case 'badge':
            return badgeToken(token);
        case 'background':
            return backgroundToken(token);
        case 'none':
            return null;
        default:
            return `${token}px`;
    }
}
exports.getDecoration = getDecoration;
function clearFix() {
    return `
    &::after {
      display: table;
      clear: both;
      content: '';
    }
  `;
}
exports.clearFix = clearFix;
/**
 * minScreen
 *
 * @param {string} bp - Breakpoint for media query
 *
 * @returns {string} CSS media query
 */
function minScreen(bp) {
    return `@media (min-width: ${bp})`;
}
exports.minScreen = minScreen;
/**
 * maxScreen
 *
 * @param {string} bp - Breakpoint for media query
 *
 * @returns {string} CSS media query
 */
function maxScreen(bp) {
    return `@media (max-width: ${bp})`;
}
exports.maxScreen = maxScreen;
/**
 * minMaxScreen
 *
 * @param {number} minBp - Minimum breakpoint for media query
 * @param {number} maxBp - Maximum breakpoint for media query
 *
 * @returns {string} CSS media query
 */
function minMaxScreen(minBp, maxBp) {
    return `@media (min-width: ${minBp}) and (max-width: ${maxBp})`;
}
exports.minMaxScreen = minMaxScreen;
// Declare a prop on the SC and compare it against a value or predicate to return
// some css.
const styledProperty = (propValue, compareValueOrCompareFunc, css) => (props) => {
    const resolvedProp = get(props, propValue);
    const compareFunction = typeof compareValueOrCompareFunc === 'function'
        ? compareValueOrCompareFunc
        : isEqualFp(compareValueOrCompareFunc);
    const shouldNotDisplayCss = !compareFunction(resolvedProp);
    if (shouldNotDisplayCss) {
        return ``;
    }
    return css;
};
exports.styledProperty = styledProperty;
/**
 * columnCalc
 *
 * @param {number} cols - How many columns to calculate
 * @param {number} total - total number of columns
 *
 * @returns {number} - returns Width(%) of a column in an equal-sized grid
 */
function columnCalc(cols, total = 12) {
    return `${(cols / total) * 100}%`;
}
exports.columnCalc = columnCalc;
/**
 * customScrollbar
 *
 * @param {string} thumbColor - scrollbar thumb color
 * @param {string} trackColor - scrollbar track color
 *
 * @returns {string} - returns CSS for custom scrollbar
 */
function customScrollbar(thumbColor, trackColor) {
    return `
    &::-webkit-scrollbar {
      background-color: ${trackColor};
      width: 12px;
    }

    &::-webkit-scrollbar-track {
      background-color: ${trackColor};
    }

    &::-webkit-scrollbar-thumb {
      border: 2px solid ${trackColor};
      border-radius: 10px;
      background-color: rgba(${thumbColor}, 0.6);
    }
  `;
}
exports.customScrollbar = customScrollbar;
/**
 * getCheckboxRadioDefaultStyles
 *
 * @returns {string} - returns CSS for checkbox and radio type
 */
function getCheckboxRadioDefaultStyles() {
    return `
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    visibility: initial;
    opacity: 0;
    margin: 0;
    cursor: inherit;
    padding: 0;
    width: 100%;
    height: 100%;
  `;
}
exports.getCheckboxRadioDefaultStyles = getCheckboxRadioDefaultStyles;
/*
 * RGBAToHexA
 *
 * @param {number} r - Red component of a color
 * @param {number} g - Green component of a color
 * @param {number} b - Blue component of a color
 * @param {number} a - Alpha component of a color
 *
 * @returns {string} - returns Hex representation of a color
 */
function RGBAToHexA(r, g, b, a) {
    let red = parseInt(r, 10).toString(16);
    let green = parseInt(g, 10).toString(16);
    let blue = parseInt(b, 10).toString(16);
    let alpha = Math.round(parseFloat(a) * 255).toString(16);
    if (red.length === 1)
        red = `0${red}`;
    if (green.length === 1)
        green = `0${green}`;
    if (blue.length === 1)
        blue = `0${blue}`;
    if (alpha.length === 1)
        alpha = `0${alpha}`;
    else if (alpha === 'ff')
        alpha = '';
    return `#${red}${green}${blue}${alpha}`;
}
exports.RGBAToHexA = RGBAToHexA;
/**
 * firstLetterDropCap
 *
 * Dropcap support. These values (in concert with brand identity configs) are
 * intended to be a relatively temporary solution to support dropcaps specifically
 * for VF and Glamour. The variance of font metrics across all the different
 * fonts supported across all brands made it virtually impossible to find a
 * pixel-perfect solution that _only_ relies on token values (especially since
 * those size values (and their tokens) may be used by other placements. A better
 * long term solution, such as a dropcap-specific brand identity value or
 * adjusting font metrics to be consistent across all Verso-supported fonts may
 * allow something closer to cross-brand pixel-perfect placement, but would
 * require further research.
 *
 * 1. Firefox just ignores line height in first-letter. Other browsers respect it
 *    so we set it in the brand identity and it comes through in typography.
 * 2. Padding values chosen to specifically work for VF (VF, Hive, HWD) BIs and
 *    not necessarily a reliable global value.
 *
 * @returns {string} - CSS template
 */
exports.firstLetterDropCap = css `
  ${getTypographyStyles('typography.definitions.consumptionEditorial.display-large')}
  float: left;
  margin-bottom: -0.2em;
  padding: 0 0.05em 0 0; /* 2 */
  color: ${getColorToken('colors.consumption.body.standard.display-signature')};

  @-moz-document url-prefix('') {
    margin-bottom: 0;
  }
`;
/**
 * Returns true if node is a jsonml element
 *
 * @param {Array} node - jsonml node
 * @returns {bool} - should the node be a jsonml element
 */
const isJsonMLElement = (node) => {
    return Array.isArray(node) && typeof node[0] === 'string';
};
exports.isJsonMLElement = isJsonMLElement;
/**
 * Returns jsonML Children
 *
 * @param {Array} node - jsonml node
 * @returns {object} - jsonml object
 */
const getJsonMLChildren = (node) => {
    return (0, exports.isJsonMLElement)(node) &&
        node[1] &&
        typeof node[1] === 'object' &&
        !Array.isArray(node[1])
        ? node.slice(2)
        : node.slice(1);
};
exports.getJsonMLChildren = getJsonMLChildren;
const isInverted = ({ palette }) => palette === 'inverted';
exports.isInverted = isInverted;
/**
 * textBoxTrimMixin
 *
 * Fixes text alignment issues in Clickable components caused by inconsistent font bounding boxes.
 * Some fonts include extra top/bottom spacing which misaligns text. When the theme's "textBoxTrim" token is enabled,
 * this mixin applies the experimental CSS property "text-box: trim-both text alphabetic;" to trim the spacing.
 *
 * Note: This solution is currently applied only for the One Nav component. Applying this globally is not feasible at the moment
 * due to the complexity of different font use-cases across the app.
 *
 * @param {object} theme - Theme object from the ThemeProvider.
 * @returns {import("styled-components").FlattenSimpleInterpolation} CSS styles applying text-box-trim if enabled otherwise, an empty string.
 *
 * @example
 * ${({ theme }) => textBoxTrimMixin(theme)}
 */
function textBoxTrimMixin(theme) {
    const currentTypeface = getThemeValue(theme, 'typography.definitions.consumptionEditorial.body-core.family');
    const typefaceConfig = getThemeValue(theme, `typography.typefaces.${currentTypeface}`);
    return typefaceConfig && typefaceConfig.textBoxTrim
        ? css `
        text-box: trim-both text alphabetic;
      `
        : '';
}
exports.textBoxTrimMixin = textBoxTrimMixin;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8877:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const React = __webpack_require__(96540);
const useClientStatus = () => React.useSyncExternalStore(() => () => { }, () => "object" !== 'undefined', () => false);
module.exports = {
    useClientStatus
};
//# sourceMappingURL=is-client.js.map

/***/ }),

/***/ 1123:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { calculateSpacing } = __webpack_require__(26865);
const { BREAKPOINTS } = __webpack_require__(96472);
/**
 * cssVariablesGrid
 *
 * @returns {string} returns CSS variables
 */
const cssVariablesGrid = () => {
    return `
  --grid-gap: ${calculateSpacing(2)};
  --grid-margin: ${calculateSpacing(3)};

  @media (min-width: ${BREAKPOINTS.md}) {
    --grid-gap: ${calculateSpacing(3)};
    --grid-margin: ${calculateSpacing(6)};
  }

  @media (min-width: ${BREAKPOINTS.lg}) {
    --grid-gap: ${calculateSpacing(4)};
  }

  @media (min-width: ${BREAKPOINTS.xl}) {
    --grid-margin: ${calculateSpacing(8)};
  }
  `;
};
/**
 * applyGridSpacing
 *
 * @param {string} spacingType - type of spacing to be applied, margin or padding
 * @param {boolean} inverted - option for inverted, defaults to false
 *
 * @returns {string} returns CSS with negative left and right margins with sidePadding's value
 */
const applyGridSpacing = (spacingType, inverted = false) => {
    const multiplier = inverted ? -1 : 1;
    return `
    ${spacingType}-right: calc(${multiplier} * var(--grid-margin));
    ${spacingType}-left: calc(${multiplier} * var(--grid-margin));
  `;
};
/**
 * applyCustomBackgroundColor
 *
 * @param {string} pageBackgroundTheme -  page background color code
 *
 * @returns {string} returns CSS with background color
 */
const applyCustomBackgroundColor = (pageBackgroundTheme) => {
    return `
      background-color: #${pageBackgroundTheme};
    `;
};
/**
 * applyCustomDividerColor
 *
 * @param {string} dividerColor - divider color code
 *
 * @returns {string} returns CSS with border color
 */
const applyCustomDividerColor = (dividerColor) => {
    return `
      border-color: #${dividerColor};
    `;
};
/**
 * applyCustomBorderTopColor
 *
 * @param {string} dividerColor - divider color code
 *
 * @returns {string} returns CSS with border color
 */
const applyCustomBorderTopColor = (dividerColor) => {
    return `
      border-top: 1px solid #${dividerColor};
   `;
};
/**
 * applyDefaultPagePadding
 *
 * @returns {string} returns verso default page padding
 */
const applyDefaultPagePadding = () => {
    // Do not change 'px' declaration
    return `padding-top: ${calculateSpacing(7, 'px')};`;
};
module.exports = {
    applyGridSpacing,
    applyCustomBackgroundColor,
    applyCustomDividerColor,
    applyCustomBorderTopColor,
    applyDefaultPagePadding,
    cssVariablesGrid
};
//# sourceMappingURL=layout.js.map

/***/ }),

/***/ 15737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { css } = __webpack_require__(92168);
const { getColorToken } = __webpack_require__(26865);
const setLinkDefault = (underlines = true) => {
    const noUnderLineText = `
    text-decoration: none;

     &:hover,
     &:focus {
       text-decoration: underline;
     }
  `;
    const underlineText = underlines ? '' : noUnderLineText;
    return `
    ${underlineText}

    cursor: pointer;
  `;
};
const linkClean = () => {
    return setLinkDefault(false);
};
const linkStandard = () => {
    return css `
    ${setLinkDefault()}
    color: ${getColorToken('colors.interactive.base.light')};
    transition-property: color, background, text-shadow;
    transition-duration: 0.2s;
    transition-timing-function: ease-in-out;
  `;
};
module.exports = {
    setLinkDefault,
    linkClean,
    linkStandard
};
//# sourceMappingURL=link-clean.js.map

/***/ }),

/***/ 79815:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitForElm = void 0;
const waitForElm = (selector) => {
    return new Promise((resolve) => {
        if (document.querySelector(selector)) {
            resolve(document.querySelector(selector));
            return;
        }
        const observer = new MutationObserver(() => {
            if (document.querySelector(selector)) {
                resolve(document.querySelector(selector));
                observer.disconnect();
            }
        });
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
    });
};
exports.waitForElm = waitForElm;
//# sourceMappingURL=wait-for-element.js.map

/***/ }),

/***/ 18106:
/***/ ((module) => {

const DEFAULT_LANG = 'en-US';
const LOCALES = [
    // Brands in copilot can currently set the locale for an article/gallery etc.
    // but they us the two digit lang code only. In future there will be a change
    // to specify lang-country as below, so we are implementing for this
    // expectation.
    'de-DE',
    'en-AE',
    'en-GB',
    'en-IN',
    'en-US',
    'es-ES',
    'es-MX',
    'fr-FR',
    'it-IT',
    'ja-JP',
    'ru-RU',
    'zh-CN',
    'zh-Hant-TW'
];
const LOCALE_FALLBACK = new Map([
    ['de', 'de-DE'],
    ['en', 'en-US'],
    ['es', 'es-ES'],
    ['fr', 'fr-FR'],
    ['it', 'it-IT'],
    ['ja', 'ja-JP'],
    ['ru', 'ru-RU'],
    ['zh-Hant', 'zh-Hant-TW']
]);
module.exports = {
    DEFAULT_LANG,
    LOCALE_FALLBACK,
    LOCALES
};
//# sourceMappingURL=i18n.js.map

/***/ }),

/***/ 53788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = Object.freeze({
    amgPartnerCookieName: 'amg_user_partner',
    authCompleteCookieName: 'CN_authComplete',
    authCookieName: 'CN_userAuth',
    authTrackingCookieName: 'CN_authCheck',
    emailHashCookie: 'CN_ipeh',
    oidcCookies: {
        access: 'CN_token_access',
        id: 'CN_token_id',
        refresh: 'CN_token_refresh'
    },
    signOutAuthCookies: {
        legacy: [
            'amg_user_partner',
            'CN_userAuth',
            '_wired_logged_in',
            'vfauthtok'
        ],
        paywall: ['pay_ent_sub', 'pay_ent_pass']
    },
    vfAuthCookieName: 'vfauthtok',
    wiredAuthCookieName: '_wired_logged_in',
    xidCookie: 'CN_xid',
    accessCookie: 'CN_access'
});
//# sourceMappingURL=cookies.js.map

/***/ }),

/***/ 79712:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const jwt_decode_1 = __importDefault(__webpack_require__(6765));
function decodeJwt(token) {
    let decoded;
    try {
        decoded = (0, jwt_decode_1.default)(token);
    }
    catch (_e) {
        decoded = null;
    }
    return decoded;
}
exports["default"] = decodeJwt;
//# sourceMappingURL=decode-jwt.js.map

/***/ }),

/***/ 47066:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class ErrorWithStatusCode extends Error {
    constructor(statusCode, ...params) {
        super(...params);
        this.statusCode = statusCode;
    }
}
exports["default"] = ErrorWithStatusCode;
//# sourceMappingURL=error-with-status-code.js.map

/***/ }),

/***/ 84410:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExperimentAssignmentTypes = void 0;
var ExperimentAssignmentTypes;
(function (ExperimentAssignmentTypes) {
    ExperimentAssignmentTypes["CLIENT_ASSIGNMENT"] = "CLIENT_ASSIGNMENT";
    ExperimentAssignmentTypes["EDGE_ASSIGNMENT"] = "EDGE_ASSIGNMENT";
})(ExperimentAssignmentTypes = exports.ExperimentAssignmentTypes || (exports.ExperimentAssignmentTypes = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 45941:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGraphqlErrorHandlerWith404 = exports.getGraphqlErrorHandler = void 0;
const get_1 = __importDefault(__webpack_require__(58156));
const format_graphql_errors_1 = __webpack_require__(69483);
const error_with_status_code_1 = __importDefault(__webpack_require__(47066));
function getGraphqlErrorHandler(queryType, error) {
    const { graphQLErrors, networkError } = error;
    if (networkError) {
        const cause = networkError.message;
        throw new Error(`GraphQL failed due to network error: ${cause}`);
    }
    throw new error_with_status_code_1.default((0, get_1.default)(graphQLErrors[0], 'extensions.response.status', 500), `GraphQL could not resolve ${queryType}. ${(0, format_graphql_errors_1.formatGraphQLErrors)(graphQLErrors)}`);
}
exports.getGraphqlErrorHandler = getGraphqlErrorHandler;
function getGraphqlErrorHandlerWith404(queryType, error) {
    const { graphQLErrors, networkError } = error;
    if (networkError) {
        const cause = networkError.message;
        throw new Error(`GraphQL failed due to network error: ${cause}`);
    }
    throw new error_with_status_code_1.default(404, `GraphQL could not resolve ${queryType}. ${(0, format_graphql_errors_1.formatGraphQLErrors)(graphQLErrors)}`);
}
exports.getGraphqlErrorHandlerWith404 = getGraphqlErrorHandlerWith404;
//# sourceMappingURL=apollo-client-error-handler.js.map

/***/ }),

/***/ 69483:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatGraphQLErrors = void 0;
/**
 * Helper that maps a string of GraphQLErrors to an array of strings, sans stack trace
 *
 * @param errors - a ReadonlyArray of GraphQLErrors
 * @returns an array of formatted errors
 */
function formatGraphQLErrors(errors = []) {
    if (!errors.length) {
        return [];
    }
    return errors.map((error, index) => {
        // path and locations not available outside query validation and execution. Eg 503
        if (error.path || error.locations) {
            return `(${index + 1}) "${error.message}" at "${error.path
                ? error.path.join('.')
                : error.locations
                    ?.map(({ line, column }) => `line ${line}, column ${column}`)
                    .join(' and ')}". `;
        }
        return `(${index + 1}) "${error.message}"`;
    });
}
exports.formatGraphQLErrors = formatGraphQLErrors;
//# sourceMappingURL=format-graphql-errors.js.map

/***/ }),

/***/ 17780:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGraphqlErrorHandlerWith404 = exports.getGraphqlErrorHandler = void 0;
const graphql_1 = __webpack_require__(18346);
const get_1 = __importDefault(__webpack_require__(58156));
const format_graphql_errors_1 = __webpack_require__(69483);
const error_with_status_code_1 = __importDefault(__webpack_require__(47066));
const apollo_client_error_handler_1 = __webpack_require__(45941);
function getGraphqlErrorHandler(queryType) {
    return (error) => {
        if ('graphQLErrors' in error && 'networkError' in error) {
            return (0, apollo_client_error_handler_1.getGraphqlErrorHandler)(queryType, error);
        }
        const { response } = error;
        if (!response) {
            // error.message is 'fetch failed', error.cause.message is actually meaningful
            // eslint-disable-next-line dot-notation
            const cause = error['cause'] || error;
            throw new Error(`GraphQL failed due to network error: ${cause.message}`);
        }
        const errors = (response && response.errors) ?? [
            new graphql_1.GraphQLError(`HTTP status ${response.status}`)
        ];
        throw new error_with_status_code_1.default((0, get_1.default)(response, 'errors[0].extensions.response.status', response.status), `GraphQL could not resolve ${queryType}. ${(0, format_graphql_errors_1.formatGraphQLErrors)(errors)}`);
    };
}
exports.getGraphqlErrorHandler = getGraphqlErrorHandler;
function getGraphqlErrorHandlerWith404(queryType) {
    return (error) => {
        if ('graphQLErrors' in error && 'networkError' in error) {
            return (0, apollo_client_error_handler_1.getGraphqlErrorHandlerWith404)(queryType, error);
        }
        const { response } = error;
        if (!response) {
            // error.message is 'fetch failed', error.cause.message is actually meaningful
            // eslint-disable-next-line dot-notation
            const cause = error['cause'] || error;
            throw new Error(`GraphQL failed due to network error: ${cause.message}`);
        }
        const errors = (response && response.errors) ?? [
            new graphql_1.GraphQLError(`HTTP status ${response.status}`)
        ];
        throw new error_with_status_code_1.default(404, `GraphQL could not resolve ${queryType}. ${(0, format_graphql_errors_1.formatGraphQLErrors)(errors)}`);
    };
}
exports.getGraphqlErrorHandlerWith404 = getGraphqlErrorHandlerWith404;
//# sourceMappingURL=get-graphql-error-handler.js.map

/***/ }),

/***/ 3613:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestGraphService = void 0;
const { GraphQLClient } = __webpack_require__(96497);
const requestGraphService = (federatedGraphqlUrl, accessToken, query, variables = {}, headers = {}) => {
    const client = new GraphQLClient(federatedGraphqlUrl);
    if (!headers['apollographql-client-name']) {
        headers['apollographql-client-name'] = 'Verso';
        headers['apollographql-client-version'] = '0.0.1'; // Something to start with
    }
    const requestHeaders = { ...headers, Authorization: `Bearer ${accessToken}` };
    return client.rawRequest(query, variables, requestHeaders);
};
exports.requestGraphService = requestGraphService;
//# sourceMappingURL=federated-graphql-service.js.map

/***/ }),

/***/ 5736:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.federatedGraphqlService = void 0;
const federated_graphql_service_1 = __webpack_require__(3613);
const get_graphql_error_handler_1 = __webpack_require__(17780);
const user_authentication_1 = __webpack_require__(20656);
const cookies_1 = __importDefault(__webpack_require__(53788));
const collectionsUtils_1 = __webpack_require__(74139);
const federatedGraphqlService = async ({ federatedGraphqlUrl, query, variables, queryLabelForError }) => {
    const accessToken = user_authentication_1.UserAuthenticationClient.getCookieValue(cookies_1.default.oidcCookies.id);
    if (!accessToken) {
        throw new Error(collectionsUtils_1.errorType.MISSING_ACCESS_TOKEN);
    }
    try {
        return await (0, federated_graphql_service_1.requestGraphService)(federatedGraphqlUrl, accessToken, query, {
            ...variables
        });
    }
    catch (error) {
        const errorHandler = (0, get_graphql_error_handler_1.getGraphqlErrorHandler)(queryLabelForError);
        errorHandler(error);
    }
    return {};
};
exports.federatedGraphqlService = federatedGraphqlService;
//# sourceMappingURL=fetch-graphql-data.js.map

/***/ }),

/***/ 51895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(3613), exports);
__exportStar(__webpack_require__(5736), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 22914:
/***/ ((module) => {

// mutation for create user comment
const createUserComment = /* GraphQL */ `
  mutation AddReview($input: AddReviewInput!, $coralUserID: ID!) {
    addReview(input: $input, coralUserID: $coralUserID) {
      message
    }
  }
`;
// query for list user comments
const Comments = /* GraphQL */ `
  query Comments(
    $after: Cursor
    $commentLimit: Int = 10
    $commentsOrderBy: COMMENT_SORT
    $repliesOrderBy: COMMENT_SORT
    $replyLimit: Int = 1
    $storyId: ID!
    $showPrimaryComments: Boolean
    $tag: TAG
    $excludeTag: TAG
  ) {
    coralcomments(
      first: $commentLimit
      after: $after
      storyID: $storyId
      orderBy: $commentsOrderBy
      showPrimaryComments: $showPrimaryComments
      tag: $tag
      excludeTag: $excludeTag
    ) {
      pageInfo {
        hasNextPage
        hasPreviousPage
        startCursor
        endCursor
      }
      nodes {
        id
        body
        isAnonymous
        meta
        createdAt
        rating
        images {
          id
          url
          status
        }
        story {
          url
        }
        author {
          orgRole
        }
        siteUsername {
          name
        }
        revision {
          id
        }
        reviewTags {
          code
        }
        revisionHistory {
          id
        }
        viewerActionPresence {
          reaction
        }
        actionCounts {
          reaction {
            total
          }
        }
        replies(orderBy: $repliesOrderBy, flatten: true, first: $replyLimit) {
          pageInfo {
            hasNextPage
            endCursor
          }
          nodes {
            depth
            id
            body
            createdAt
            images {
              id
              url
              status
            }
            author {
              orgRole
            }
            siteUsername {
              name
            }
            revision {
              id
            }
            story {
              url
            }
            viewerActionPresence {
              reaction
            }
            actionCounts {
              reaction {
                total
              }
            }
            parent {
              siteUsername {
                name
              }
            }
          }
        }
      }
    }
  }
`;
// query for check if story exists
const checkStory = /* GraphQL */ `
  query Story($id: ID!) {
    story(id: $id) {
      id
      url
    }
  }
`;
// mutation for added Story to the coral system
const addStory = /* GraphQL */ `
  mutation createStory($inp: CreateStoryInput!) {
    createStory(input: $inp) {
      story {
        id
      }
    }
  }
`;
// mutation for added Story to the coral system
const updateStory = /* GraphQL */ `
  mutation updateStory($inp: UpdateStoryInput!) {
    updateStory(input: $inp) {
      story {
        id
      }
    }
  }
`;
// mutation for add user rating
const addUserRating = /* GraphQL */ `
  mutation addReview($inp: AddReviewInput!, $coralUserID: ID!) {
    addReview(input: $inp, coralUserID: $coralUserID) {
      message
    }
  }
`;
// query for list user comments
const Ratings = /* GraphQL */ `
  query storyRating($storyId: String, $ratingScale: Int) {
    storyRating(storyId: $storyId, ratingScale: $ratingScale) {
      average
      count
    }
  }
`;
// query for get user rating
const ratingByUser = /* GraphQL */ `
  query coralreviews($siteID: String!, $storyID: String!, $userID: String!) {
    coralreviews(siteID: $siteID, storyID: $storyID, userID: $userID) {
      rating {
        rating
        siteID
        storyID
        authorID
      }
      comment {
        body
      }
    }
  }
`;
// mutation for creating a reaction for the comment
const createCommentReaction = /* GraphQL */ `
  mutation CreateCommentReaction($input: CreateCommentReactionInput!) {
    createCommentReaction(input: $input) {
      clientMutationId
      comment {
        id
      }
    }
  }
`;
// mutation for removing a reaction for the comment
const removeCommentReaction = /* GraphQL */ `
  mutation RemoveCommentReaction($input: RemoveCommentReactionInput!) {
    removeCommentReaction(input: $input) {
      clientMutationId
      comment {
        id
      }
    }
  }
`;
// mutation for creating a reply for the comment
const createReply = /* GraphQL */ `
  mutation Mutation($input: CreateCommentReplyInput!) {
    createCommentReply(input: $input) {
      clientMutationId
      edge {
        cursor
        node {
          body
          id
          depth
          parentCount
          replyCount
          replies {
            nodes {
              depth
              id
              replyCount
            }
          }
        }
      }
    }
  }
`;
// get comment by id. This will retrieve the data for a single comment
const repliesByCommentId = /* GraphQL */ `
  query CommentById(
    $replyLimit: Int = 10
    $after: Cursor
    $orderBy: COMMENT_SORT
    $commentId: ID!
  ) {
    coralcomment(id: $commentId) {
      id
      replies(
        first: $replyLimit
        after: $after
        orderBy: $orderBy
        flatten: true
      ) {
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          id
          body
          createdAt
          images {
            id
            url
            status
          }
          author {
            orgRole
          }
          siteUsername {
            name
          }
          revision {
            id
          }
          viewerActionPresence {
            reaction
          }
          actionCounts {
            reaction {
              total
            }
          }
          parent {
            siteUsername {
              name
            }
          }
        }
      }
    }
  }
`;
// query to get the total primary comments count for a story
const storyCommentsCount = /* GraphQL */ `
  query Story($id: ID!) {
    story(id: $id) {
      totalPrimaryCommentsCount
    }
  }
`;
module.exports = {
    createCommentReaction,
    createReply,
    createUserComment,
    Comments,
    checkStory,
    addStory,
    addUserRating,
    Ratings,
    ratingByUser,
    removeCommentReaction,
    repliesByCommentId,
    storyCommentsCount,
    updateStory
};
//# sourceMappingURL=queries.js.map

/***/ }),

/***/ 60711:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateAndAddStory = exports.addReview = exports.addReply = exports.modifyStory = exports.createStory = exports.storyExists = exports.getStoryCommentsCount = exports.getRepliesByCommentId = exports.getCommentsExcludingFeatured = exports.getFeaturedComments = exports.getComments = exports.requestGraphService = void 0;
const queries_1 = __webpack_require__(22914);
const { GraphQLClient } = __webpack_require__(96497);
const { getCookie } = __webpack_require__(56892);
const cookies = (__webpack_require__(53788)["default"]);
const { oidcCookies } = cookies;
const requestGraphService = (commentingUrl, options, accessToken = '') => {
    const token = getCookie(oidcCookies.access) || accessToken;
    const client = new GraphQLClient(commentingUrl);
    const { query, variables } = options;
    const headers = {
        'Access-Control-Request-Method': 'POST',
        'Access-Control-Request-Headers': 'Content-Type',
        'Content-Type': 'application/json',
        'User-Agent': 'verso-client',
        Authorization: `Bearer ${token}`
    };
    return client.request(query, variables, headers);
};
exports.requestGraphService = requestGraphService;
const getDataUser = (data) => {
    if (!data) {
        return {
            willPrepareAgain: true,
            location: 'No location',
            reviewerInfo: 'ANONYMOUS'
        };
    }
    try {
        const parsedData = JSON.parse(data);
        const { location, displayName: reviewerInfo, willPrepareAgain } = parsedData;
        return { willPrepareAgain, location, reviewerInfo };
    }
    catch (error) {
        return { willPrepareAgain: '', location: '', reviewerInfo: '' };
    }
};
const getComments = async ({ entityId: recipeId, after = null, commentingUrl, logger = console, commentsOrderBy = 'CREATED_AT_ASC', repliesOrderBy = 'CREATED_AT_DESC', reviewLimit, accessToken, replyLimit = 1, tag, excludeTag }) => {
    const reviewsPerPage = reviewLimit || 15;
    const options = {
        operationName: 'Comments',
        query: queries_1.Comments,
        variables: {
            commentLimit: reviewsPerPage,
            replyLimit,
            after,
            storyId: recipeId,
            commentsOrderBy,
            repliesOrderBy,
            showPrimaryComments: true,
            tag,
            excludeTag
        }
    };
    try {
        const commentsResponse = await (0, exports.requestGraphService)(commentingUrl, options, accessToken);
        const { pageInfo: { hasNextPage = false, endCursor = null } = {}, nodes = [] } = commentsResponse?.coralcomments ?? {};
        const reviews = nodes?.map((node) => {
            const { author, isAnonymous, body: reviewText, createdAt, id, meta, rating, revision, viewerActionPresence, actionCounts, replies, reviewTags, siteUsername: siteUserObject, story, images } = node;
            const { location, reviewerInfo, willPrepareAgain } = getDataUser(meta);
            const revisionId = revision?.id || null;
            const tags = reviewTags?.map((tag) => tag.code) || [];
            const totalActionCount = actionCounts?.reaction?.total ?? 0;
            const { orgRole } = author ?? {};
            return {
                isAnonymous,
                location,
                recipeId,
                reviewText,
                reviewerInfo,
                willPrepareAgain,
                createdAt,
                updatedAt: createdAt,
                rating,
                role: orgRole,
                _id: id,
                revisionId,
                viewerActionPresence: viewerActionPresence?.reaction ?? false,
                reactionCount: totalActionCount,
                replies: replies?.nodes,
                replyPageInfo: replies?.pageInfo,
                siteUsername: siteUserObject?.[0]?.name,
                tags,
                storyURL: story?.url,
                images
            };
        });
        return {
            recipeId,
            reviews,
            reviewsCount: reviews.length,
            page: {
                hasNextPage,
                endCursor
            }
        };
    }
    catch (error) {
        logger.warn(`Error making GQL request in getComments: ${error.message}`);
        return {
            recipeId,
            reviews: [],
            reviewsCount: 0,
            page: {
                hasNextPage: false,
                endCursor: ''
            }
        };
    }
};
exports.getComments = getComments;
const getFeaturedComments = async (params) => (0, exports.getComments)({
    ...params,
    commentsOrderBy: 'FEATURED_AT_DESC_REACTION_DESC',
    tag: 'FEATURED'
});
exports.getFeaturedComments = getFeaturedComments;
const getCommentsExcludingFeatured = async (params) => (0, exports.getComments)({
    ...params,
    excludeTag: 'FEATURED'
});
exports.getCommentsExcludingFeatured = getCommentsExcludingFeatured;
const getRepliesByCommentId = async ({ commentId, after, commentingUrl, logger, accessToken, replyLimit = 10, repliesOrderBy = 'CREATED_AT_DESC' }) => {
    const options = {
        operationName: 'CommentById',
        query: queries_1.repliesByCommentId,
        variables: {
            replyLimit,
            after,
            orderBy: repliesOrderBy,
            commentId
        }
    };
    try {
        const commentRepliesResponse = await (0, exports.requestGraphService)(commentingUrl, options, accessToken);
        const { pageInfo: { hasNextPage = false, endCursor = null } = {}, nodes = [] } = commentRepliesResponse?.coralcomment?.replies ?? {};
        return {
            commentId,
            replies: nodes,
            page: {
                hasNextPage,
                endCursor
            }
        };
    }
    catch (error) {
        logger.warn(`Error making GQL request in getRepliesByCommentId: ${error.message}`);
        return {
            commentId,
            replies: [],
            page: {
                hasNextPage: false,
                endCursor: ''
            }
        };
    }
};
exports.getRepliesByCommentId = getRepliesByCommentId;
const getStoryCommentsCount = async (storyId, commentingUrl, logger) => {
    const optionsStory = {
        operationName: 'Story',
        query: queries_1.storyCommentsCount,
        variables: { id: storyId }
    };
    let commentsCount = null;
    try {
        const response = await (0, exports.requestGraphService)(commentingUrl, optionsStory);
        const { totalPrimaryCommentsCount = null } = response?.story || '';
        commentsCount = totalPrimaryCommentsCount;
    }
    catch (error) {
        logger.warn(`Error making GQL request in storyCommentsCount: ${error.message}`);
    }
    return commentsCount;
};
exports.getStoryCommentsCount = getStoryCommentsCount;
const storyExists = async (recipeId, commentingUrl, logger) => {
    const optionsStory = {
        operationName: 'Story',
        query: queries_1.checkStory,
        variables: { id: recipeId }
    };
    let idStory;
    try {
        idStory = await (0, exports.requestGraphService)(commentingUrl, optionsStory);
    }
    catch (error) {
        logger.warn(`Error making GQL request in storyExists: ${error.message}`);
    }
    return idStory;
};
exports.storyExists = storyExists;
const createStory = async ({ id, organizationId, title, url, commentingUrl, logger }) => {
    const inp = {
        clientMutationId: '0',
        story: {
            id,
            siteID: organizationId,
            url,
            metadata: {
                title
            }
        }
    };
    const options = {
        operationName: 'createStory',
        query: queries_1.addStory,
        variables: { inp }
    };
    try {
        const response = await (0, exports.requestGraphService)(commentingUrl, options);
        if (!response) {
            logger.warn('No response from GraphQL service.');
            return false;
        }
        return response;
    }
    catch (error) {
        logger.warn(`Error in createStory: ${error.message}`);
        return false;
    }
};
exports.createStory = createStory;
const modifyStory = async ({ id, title, url, commentingUrl, logger }) => {
    const options = {
        operationName: 'updateStory',
        query: queries_1.updateStory,
        variables: {
            inp: { clientMutationId: '0', id, story: { metadata: { title }, url } }
        }
    };
    try {
        await (0, exports.requestGraphService)(commentingUrl, options);
        return;
    }
    catch (error) {
        logger.warn(`Error making GQL request in updateOrAddStory: ${error.message}`);
    }
};
exports.modifyStory = modifyStory;
const addReply = async (commentingUrl, input) => {
    const options = {
        operationName: 'createReply',
        query: queries_1.createReply,
        variables: { input }
    };
    let isSaved;
    try {
        isSaved = await (0, exports.requestGraphService)(commentingUrl, options);
    }
    catch (error) {
        console.warn(error);
        throw new Error(error);
    }
    return isSaved;
};
exports.addReply = addReply;
const addReview = async (input, coralUserID, commentingUrl, logger) => {
    const options = {
        operationName: 'addReview',
        query: queries_1.createUserComment,
        variables: { input, coralUserID }
    };
    let isSaved = null;
    try {
        isSaved = await (0, exports.requestGraphService)(commentingUrl, options);
    }
    catch (error) {
        logger.warn(`Error making GQL request in addReview: ${error.message}`);
        throw new Error(error);
    }
    return isSaved;
};
exports.addReview = addReview;
const validateAndAddStory = async ({ id, title, organizationId, commentingUrl, console: logger }) => {
    if (!commentingUrl)
        return;
    const { story } = await (0, exports.storyExists)(id, commentingUrl, logger);
    const url = window.location.origin + window.location.pathname;
    if (!story) {
        try {
            await (0, exports.createStory)({
                id,
                organizationId,
                title,
                url,
                commentingUrl,
                logger
            });
            return;
        }
        catch (error) {
            logger.warn(` could not create story for ${id}: ${error}`);
        }
    }
    if (!story.url) {
        try {
            await (0, exports.modifyStory)({ id, title, url, commentingUrl, logger });
            return;
        }
        catch (error) {
            logger.warn(` could not update story for ${id}: ${error}`);
        }
    }
};
exports.validateAndAddStory = validateAndAddStory;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 82692:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFirstTruthyValue = void 0;
/**
 * Allows to get the first truthy value from the list of values or returns default value
 *
 * @param defaultValue - default value if no truthy value exists
 * @param values - array of values
 * @returns {*} - the first truthy value or the default one
 */
function getFirstTruthyValue(values, defaultValue = undefined) {
    return values.find(Boolean) || defaultValue;
}
exports.getFirstTruthyValue = getFirstTruthyValue;
//# sourceMappingURL=get-first-truthy-value.js.map

/***/ }),

/***/ 13659:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isUrlRelative(url) {
    const protocolPattern = /^https?:\/\/|^\/\//i;
    return !protocolPattern.test(url);
}
/**
 * Checks if the link is external
 *
 * @param url - url to check
 * @param currentHostname - current location hostname
 * @returns {boolean} - if the link hostname equals the website's hostname
 */
exports["default"] = (url, currentHostname) => {
    if (isUrlRelative(url)) {
        return false;
    }
    return new URL(url).hostname !== currentHostname;
};
//# sourceMappingURL=is-link-external.js.map

/***/ }),

/***/ 60663:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.storageFactory = void 0;
function storageFactory(getStorage) {
    let inMemoryStorage = {};
    function isSupported() {
        try {
            const testKey = 'is_localStorage_supported_check_key';
            getStorage().setItem(testKey, testKey);
            getStorage().removeItem(testKey);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    function clear() {
        if (isSupported()) {
            getStorage().clear();
        }
        else {
            inMemoryStorage = {};
        }
    }
    function getItem(name) {
        if (isSupported()) {
            return getStorage().getItem(name);
        }
        if (Object.prototype.hasOwnProperty.call(inMemoryStorage, name)) {
            return inMemoryStorage[name];
        }
        return null;
    }
    function key(index) {
        if (isSupported()) {
            return getStorage().key(index);
        }
        return Object.keys(inMemoryStorage)[index] || null;
    }
    function removeItem(name) {
        if (isSupported()) {
            getStorage().removeItem(name);
        }
        else {
            delete inMemoryStorage[name];
        }
    }
    function setItem(name, value) {
        if (isSupported()) {
            getStorage().setItem(name, value);
        }
        else {
            inMemoryStorage[name] = String(value);
        }
    }
    function length() {
        if (isSupported()) {
            return getStorage().length;
        }
        return Object.keys(inMemoryStorage).length;
    }
    return {
        getItem,
        setItem,
        removeItem,
        clear,
        key,
        get length() {
            return length();
        }
    };
}
exports.storageFactory = storageFactory;
//# sourceMappingURL=local-storage-error-boundary.js.map

/***/ }),

/***/ 52009:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapSourcesToSegmentedSources = void 0;
const get_first_truthy_value_1 = __webpack_require__(82692);
/**
 * Transforms the sources to the right shaped segmented sources.
 * It allows to get the image sizes for mobile and tablet viewports.
 *
 * @param sources - sources having many different sizes
 * @returns {object} - segmented sources having "sm" and "lg" sizes only
 */
function mapSourcesToSegmentedSources(sources) {
    return {
        sm: [(0, get_first_truthy_value_1.getFirstTruthyValue)([sources.md, sources.sm], null)],
        lg: [(0, get_first_truthy_value_1.getFirstTruthyValue)([sources.xxl, sources.xl, sources.lg], null)]
    };
}
exports.mapSourcesToSegmentedSources = mapSourcesToSegmentedSources;
//# sourceMappingURL=map-sources-to-segmented-sources.js.map

/***/ }),

/***/ 65947:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizePrice = void 0;
/**
 * Validates if a cleaned price string has a valid format
 * @param cleanedString - The price string after removing currency symbols
 * @returns true if format is valid, false otherwise
 */
function isValidPriceFormat(cleanedString) {
    // Check for consecutive separators (e.g., "..", ",,", ".,")
    if (/[.,]{2,}/.test(cleanedString))
        return false;
    // Check for leading separators (e.g., ",100", ".100")
    if (/^[.,]/.test(cleanedString))
        return false;
    // Check for trailing separators (e.g., "100,", "100.")
    if (/[.,]$/.test(cleanedString))
        return false;
    // Check for clearly malformed patterns with too many separators in wrong places
    // Allow valid patterns like "1,000,000.00" (multiple thousands separators + decimal)
    const separatorCount = (cleanedString.match(/[.,]/g) || []).length;
    // If more than 3 separators, definitely invalid
    if (separatorCount > 3)
        return false;
    // Check for invalid comma patterns like "1,2,3" (single digits between commas)
    // But allow Indian numbering format like "1,00,000" (2 digits between commas)
    if (/,\d{1},/.test(cleanedString))
        return false;
    // Check for invalid period patterns like "1.2.3" (single digits between periods)
    if (/\.\d{1,2}\./.test(cleanedString))
        return false;
    // Check for mixed invalid patterns like "1,2.3,4" (comma-digit-period-digit-comma)
    if (/,\d{1,2}\.\d+,/.test(cleanedString))
        return false;
    // Check for mixed invalid patterns like "1.2,3.4" (period-digit-comma-digit-period)
    if (/\.\d{1,2},\d+\./.test(cleanedString))
        return false;
    // Check for alternating separators in clearly wrong patterns
    // This is more permissive than before - only catch obvious errors
    if (/\.[^.,]*,.*\.[^.,]*,/.test(cleanedString) ||
        /,[^.,]*\.[^.,]*\./.test(cleanedString)) {
        return false;
    }
    return true;
}
/**
 * Determines if a separator is likely a decimal separator based on context
 * @param cleanedString - The cleaned price string
 * @param separatorIndex - Index of the separator
 * @param separatorChar - The separator character ('.' or ',')
 * @returns true if likely decimal separator, false if thousands separator
 */
function isLikelyDecimalSeparator(cleanedString, separatorIndex, separatorChar) {
    const afterSeparator = cleanedString.substring(separatorIndex + 1);
    // Special case: if string starts with "0.", it's always a decimal
    if (cleanedString.startsWith('0.') && separatorChar === '.') {
        return true;
    }
    // Special case: if string starts with "0,", it could be either
    // For now, follow the same rule as other cases
    if (cleanedString.startsWith('0,') && separatorChar === ',') {
        // If 1-2 digits after comma, treat as decimal; if 3+ digits, treat as thousands
        return afterSeparator.length <= 2 && afterSeparator.length > 0;
    }
    // If 1-2 digits after separator, likely decimal
    if (afterSeparator.length <= 2 && afterSeparator.length > 0) {
        return true;
    }
    // If 3+ digits after separator, likely thousands separator
    return false;
}
/**
 * Normalizes a price string by removing currency symbols and handling various
 * international number formats (commas, periods, spaces as separators).
 *
 * @param priceString - The price string to normalize (e.g., "$1,234.56", "1.234,56")
 * @returns The normalized price as a number, or null if the input is invalid
 *
 * @example
 * normalizePrice("$1,234.56") // returns 1234.56
 * normalizePrice("1.234,56") // returns 1234.56
 * normalizePrice("invalid") // returns null
 * normalizePrice("") // returns null
 * normalizePrice(null) // returns null
 */
function normalizePrice(priceString) {
    if (!priceString || typeof priceString !== 'string')
        return null;
    let cleanedString = priceString
        .replace(/[$]/g, '') // Remove currency symbols
        .replace(/\s/g, ''); // Remove whitespace
    // Validate that the remaining string contains only digits, commas, and periods
    // This prevents processing of invalid strings with mixed characters
    if (!/^[0-9.,]+$/.test(cleanedString)) {
        return null;
    }
    // Validate the format before processing
    if (!isValidPriceFormat(cleanedString)) {
        return null;
    }
    // Handle empty string after cleaning
    if (!cleanedString)
        return null;
    // Identify last comma and last period
    const lastComma = cleanedString.lastIndexOf(',');
    const lastPeriod = cleanedString.lastIndexOf('.');
    // Determine the decimal separator based on position and context
    if (lastComma > lastPeriod && lastComma !== -1) {
        // Comma comes after period, or only comma exists
        if (isLikelyDecimalSeparator(cleanedString, lastComma, ',')) {
            // Comma is decimal separator (e.g., "1.234,56" or "1,50")
            cleanedString = cleanedString.replace(/\./g, ''); // Remove periods (thousands separator)
            cleanedString = cleanedString.replace(/,/g, '.'); // Convert comma to decimal
        }
        else {
            // Comma is thousands separator (e.g., "1,200" or "1,200,000")
            cleanedString = cleanedString.replace(/,/g, ''); // Remove commas (thousands separator)
        }
    }
    else if (lastPeriod > lastComma && lastPeriod !== -1) {
        // Period comes after comma, or only period exists
        if (isLikelyDecimalSeparator(cleanedString, lastPeriod, '.')) {
            // Period is decimal separator (e.g., "1,234.56" or "1.50")
            cleanedString = cleanedString.replace(/,/g, ''); // Remove commas (thousands separator)
        }
        else if (!cleanedString.startsWith('0.')) {
            // Period is thousands separator (e.g., "1.200" European format)
            // BUT: Special handling for zero-prefix cases
            cleanedString = cleanedString.replace(/\./g, ''); // Remove periods (thousands separator)
        }
    }
    else if (lastComma !== -1) {
        // Only comma exists, check context
        if (isLikelyDecimalSeparator(cleanedString, lastComma, ',')) {
            // Comma is decimal separator
            cleanedString = cleanedString.replace(/,/g, '.'); // Convert comma to decimal
        }
        else {
            // Comma is thousands separator
            cleanedString = cleanedString.replace(/,/g, ''); // Remove comma (thousands separator)
        }
    }
    else if (lastPeriod !== -1) {
        // Only period exists, check context
        if (!isLikelyDecimalSeparator(cleanedString, lastPeriod, '.')) {
            // Period is thousands separator (e.g., "1.200")
            // BUT: Special handling for zero-prefix cases
            if (!cleanedString.startsWith('0.')) {
                cleanedString = cleanedString.replace(/\./g, ''); // Remove period (thousands separator)
            }
        }
        // Otherwise, period is decimal separator, leave as is
    }
    // Convert to float and validate
    const parsedPrice = parseFloat(cleanedString);
    // Additional validation for the result
    if (isNaN(parsedPrice) || !isFinite(parsedPrice)) {
        return null;
    }
    return parsedPrice;
}
exports.normalizePrice = normalizePrice;
//# sourceMappingURL=normalize-price.js.map

/***/ }),

/***/ 84077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({ value: true });
const { stringify } = __webpack_require__(47186);
const buildQueryString = ({ applicationID, brandSlugs, excludeCategories, modifiedCategories, numberOfDays, language, strategy, isMobile, mobilePageSize, pageSize, copilotId, url, contentTypes, excludeCopilotIds, xid = undefined, amgUserId = undefined }) => {
    const queryOptions = stringify({
        applicationID,
        brand: brandSlugs.join(','),
        ...(excludeCategories ? { 'exclude[category]': excludeCategories } : {}),
        ...(modifiedCategories ? { 'filter[category]': modifiedCategories } : {}),
        ...(numberOfDays ? { 'filter[numberOfDays]': numberOfDays } : {}),
        ...(excludeCopilotIds ? { 'exclude[copilotId]': excludeCopilotIds } : {}),
        'filter[language]': language,
        'filter[strategy]': strategy.toUpperCase(),
        'page[size]': isMobile ? mobilePageSize || pageSize : pageSize,
        ...(copilotId ? { copilotId } : {}),
        url,
        ...(xid ? { xid } : {}),
        ...(amgUserId ? { amgUserId } : {})
    });
    // We can stringify most of the params, but we can't stringify `filter[contentType]`
    // or `filter[section]` because it's valid to have multiple identical param names.
    const queryString = contentTypes
        ? contentTypes
            .toUpperCase()
            .split(',')
            .reduce((currentString, contentType) => `${currentString}&filter%5BcontentType%5D=${contentType}`, queryOptions)
        : queryOptions;
    return queryString;
};
exports.A = buildQueryString;
//# sourceMappingURL=build-recirc-query-string.js.map

/***/ }),

/***/ 56187:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.interactionResponse = exports.yieldToMain = void 0;
// A function for shimming scheduler.yield and setTimeout:
// Note: Yield to mai back to parent task only. Didn't back the main thread
const yieldToMain = () => {
    // Use scheduler.yield if it exists:
    if ('scheduler' in window && 'yield' in window.scheduler) {
        return window.scheduler.yield();
    }
    // Fall back to setTimeout:
    return new Promise((resolve) => {
        setTimeout(resolve, 0);
    });
};
exports.yieldToMain = yieldToMain;
// Note: Yeilding the Main Thread
function interactionResponse() {
    return new Promise((resolve) => {
        setTimeout(resolve, 100); // Fallback for the case where the animation frame never fires.
        requestAnimationFrame(() => {
            setTimeout(resolve, 0);
        });
    });
}
exports.interactionResponse = interactionResponse;
//# sourceMappingURL=yield-main.js.map

/***/ }),

/***/ 78788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TrackComponent = exports.TrackComponentChannel = void 0;
const event_1 = __webpack_require__(53836);
var TrackComponentChannel;
(function (TrackComponentChannel) {
    TrackComponentChannel["RENDER"] = "RENDER";
})(TrackComponentChannel = exports.TrackComponentChannel || (exports.TrackComponentChannel = {}));
class TrackComponent extends event_1.Event {
    constructor() {
        super(500); // considering single components can be rendered multiple times
    }
}
exports.TrackComponent = TrackComponent;
//# sourceMappingURL=track-component.js.map

/***/ }),

/***/ 51735:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowEvent = exports.WindowEventChannel = void 0;
const event_1 = __webpack_require__(53836);
var WindowEventChannel;
(function (WindowEventChannel) {
    WindowEventChannel["RESIZE_DEBOUNCE"] = "resize-debounce";
    WindowEventChannel["SCROLL_DEBOUNCE"] = "scroll-debounce";
    WindowEventChannel["RESIZE_THROTTLE"] = "resize-throttle";
    WindowEventChannel["SCROLL_THROTTLE"] = "scroll-throttle";
    WindowEventChannel["LOAD_DEBOUNCE"] = "load-debounce";
    WindowEventChannel["UNLOAD_DEBOUNCE"] = "unload-debounce";
    WindowEventChannel["FOCUS_DEBOUNCE"] = "focus-debounce";
    WindowEventChannel["BLUR_DEBOUNCE"] = "blur-debounce";
    WindowEventChannel["KEY_DOWN"] = "keydown";
    WindowEventChannel["KEY_DOWN_DEBOUNCE"] = "keydown-debounce"; // only debounce, no throttle
})(WindowEventChannel = exports.WindowEventChannel || (exports.WindowEventChannel = {}));
class WindowEvent extends event_1.Event {
    constructor() {
        super(50); // Store up to 50 history events
        this.debounceTimers = {};
        this.throttleTimers = {};
        // Delays in milliseconds for throttling and debouncing
        this.delays = {
            [WindowEventChannel.RESIZE_DEBOUNCE]: 200,
            [WindowEventChannel.SCROLL_DEBOUNCE]: 100,
            [WindowEventChannel.RESIZE_THROTTLE]: 200,
            [WindowEventChannel.SCROLL_THROTTLE]: 100,
            [WindowEventChannel.LOAD_DEBOUNCE]: 20,
            [WindowEventChannel.UNLOAD_DEBOUNCE]: 20,
            [WindowEventChannel.FOCUS_DEBOUNCE]: 20,
            [WindowEventChannel.BLUR_DEBOUNCE]: 20,
            [WindowEventChannel.KEY_DOWN_DEBOUNCE]: 20
        };
        this.attachNativeListeners();
    }
    /**
     * Attaches native window event listeners with both throttling and debouncing.
     */
    attachNativeListeners() {
        const eventMappings = {
            resize: [
                WindowEventChannel.RESIZE_THROTTLE,
                WindowEventChannel.RESIZE_DEBOUNCE
            ],
            scroll: [
                WindowEventChannel.SCROLL_THROTTLE,
                WindowEventChannel.SCROLL_DEBOUNCE
            ],
            keydown: [
                WindowEventChannel.KEY_DOWN,
                WindowEventChannel.KEY_DOWN_DEBOUNCE
            ],
            load: [WindowEventChannel.LOAD_DEBOUNCE],
            unload: [WindowEventChannel.UNLOAD_DEBOUNCE],
            focus: [WindowEventChannel.FOCUS_DEBOUNCE],
            blur: [WindowEventChannel.BLUR_DEBOUNCE]
        };
        Object.entries(eventMappings).forEach(([nativeEvent, channels]) => {
            window.addEventListener(nativeEvent, (e) => {
                channels.forEach((channel) => {
                    if (channel.includes('throttle')) {
                        // Only throttle
                        this.throttledBroadcast(channel, e);
                    }
                    else if (channel.includes('debounce')) {
                        // Only debounce
                        this.debouncedBroadcast(channel, e);
                    }
                    else {
                        // No throttling or debouncing
                        this.broadcast(channel, e);
                    }
                });
            });
        });
    }
    /**
     * Throttled broadcast to limit emissions to once per delay period.
     * @param channel WindowEventChannel name
     * @param e Native window event object
     */
    throttledBroadcast(channel, e) {
        const now = Date.now();
        const delay = this.delays[channel];
        const throttleState = this.throttleTimers[channel];
        if (!throttleState || now - throttleState.lastRun >= delay) {
            this.broadcast(channel, e);
            this.throttleTimers[channel] = {
                timer: null,
                lastRun: now
            };
        }
        else if (!throttleState.timer) {
            this.throttleTimers[channel] = {
                timer: setTimeout(() => {
                    this.broadcast(channel, e);
                    this.throttleTimers[channel] = {
                        timer: null,
                        lastRun: Date.now()
                    };
                }, delay - (now - throttleState.lastRun)),
                lastRun: throttleState.lastRun
            };
        }
    }
    /**
     * Debounced broadcast to prevent excessive emissions.
     * @param channel WindowEventChannel name
     * @param e Native window event object
     */
    debouncedBroadcast(channel, e) {
        if (this.debounceTimers[channel]) {
            clearTimeout(this.debounceTimers[channel]);
        }
        const delay = this.delays[channel];
        this.debounceTimers[channel] = setTimeout(() => {
            this.broadcast(channel, e);
            this.debounceTimers[channel] = undefined;
        }, delay);
    }
}
exports.WindowEvent = WindowEvent;
//# sourceMappingURL=window-event.js.map

/***/ }),

/***/ 53836:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Event = exports.ChannelWildcard = void 0;
var ChannelWildcard;
(function (ChannelWildcard) {
    ChannelWildcard["ALL"] = "*";
})(ChannelWildcard = exports.ChannelWildcard || (exports.ChannelWildcard = {}));
/**
 * Event class manages broadcasting and subscribing to values per named channels.
 * Supports history tracking, one-time broadcasts, and wildcard subscriptions.
 */
class Event {
    constructor(historyLimit = 10) {
        this.listeners = new Map();
        this.eventHistory = [];
        this.historyLimit = historyLimit;
    }
    /**
     * Broadcasts a value to listeners on a given channel.
     * If options.once is true, it ensures this value is broadcast only once per channel.
     */
    broadcast(channel, value, options) {
        const timestamp = Date.now();
        if (options?.once) {
            if (channel === ChannelWildcard.ALL) {
                console.warn(`'once: true' is not supported with ChannelWildcard.ALL`);
                return;
            }
            const hasBroadcasted = this.eventHistory.some((entry) => entry.channel === channel);
            if (hasBroadcasted)
                return;
        }
        const entry = { timestamp, value, channel };
        this.eventHistory.push(entry);
        if (this.eventHistory.length > this.historyLimit) {
            this.eventHistory.shift();
        }
        if (channel === ChannelWildcard.ALL) {
            for (const ch of this.listeners.keys()) {
                this.listeners.get(ch)?.forEach((listener) => listener(value));
            }
        }
        else {
            this.listeners.get(channel)?.forEach((listener) => listener(value));
        }
    }
    /**
     * Subscribes a listener to one or more channels, or to all channels using ChannelWildcard.ALL.
     */
    on(channel, listener) {
        const channels = Array.isArray(channel)
            ? channel
            : [channel];
        for (const ch of channels) {
            if (!this.listeners.has(ch)) {
                this.listeners.set(ch, new Set());
            }
            this.listeners.get(ch).add(listener);
        }
        return {
            off: () => {
                for (const ch of channels) {
                    this.listeners.get(ch)?.delete(listener);
                }
            }
        };
    }
    /**
     * Unsubscribes a listener from one or more channels, or from all channels using ChannelWildcard.ALL.
     */
    off(channel, listener) {
        const channels = Array.isArray(channel)
            ? channel
            : [channel];
        for (const ch of channels) {
            this.listeners.get(ch)?.delete(listener);
        }
    }
    /**
     * Returns the entire broadcast history, ordered by timestamp (decending).
     */
    history() {
        return [...this.eventHistory].sort((a, b) => b.timestamp - a.timestamp);
    }
    /**
     * Returns the last broadcasted value (or undefined if none).
     */
    get() {
        const last = this.eventHistory[this.eventHistory.length - 1];
        return last?.value;
    }
}
exports.Event = Event;
//# sourceMappingURL=event.js.map

/***/ }),

/***/ 45831:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cytokine = void 0;
const cytokine_1 = __importDefault(__webpack_require__(92366));
/*
 * cytokine - module for interacting with the Cytokine library.
 */
let client;
/**
 * Initializes the Cytokine client with credentials from the application store.
 *
 * @param {Store} store - The Redux store
 * @returns {void}
 */
const initialize = (store) => {
    const { cytokine = {} } = store.getState();
    const { credentials } = cytokine;
    client = (0, cytokine_1.default)({ credentials });
};
exports.cytokine = {
    initialize,
    get client() {
        client = client || (0, cytokine_1.default)({});
        return client;
    }
};
//# sourceMappingURL=client.js.map

/***/ }),

/***/ 22214:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserAuthenticationClient = void 0;
const cookies_1 = __importDefault(__webpack_require__(53788));
const apiRoutes_1 = __importDefault(__webpack_require__(15822));
const { fetchWithTimeout } = __webpack_require__(57743);
const MAX_TIMEOUT = 5000;
class UserAuthenticationClient {
    static getDecodedToken(authCookieName) {
        const cookie = this.getCookieValue(authCookieName);
        return this.decodeCookie(cookie);
    }
    static getDecodedAuthToken() {
        let decodedToken = UserAuthenticationClient.getDecodedToken(cookies_1.default.authCookieName);
        const decodedOIDCToken = UserAuthenticationClient.getDecodedToken(cookies_1.default.oidcCookies.access);
        if (!decodedToken.sub && decodedOIDCToken.sub) {
            decodedToken = decodedOIDCToken;
        }
        return decodedToken;
    }
    static isTokenValid(token) {
        return (typeof token.sub === 'string' &&
            token.sub.length > 0 &&
            token.exp * 1000 > Date.now());
    }
    /**
     * This function is used to check if the CN_token_access should be used.
     *
     * It returns false in these cases:
     *   1. There is a valid CN_userAuth cookie
     *   2. The refresh fails to produce a valid CN_token_access
     *
     * It returns true in these cases:
     *   1. There is an existing CN_token_access (without a valid CN_userAuth token)
     *   2. There is no CN_userAuth and no CN_token_access,
     *   but a refresh call has produced a valid CN_token_access
     *
     * This method should only attempt to refresh tokens in the absence of both
     * the CN_userAuth and the CN_token_access.
     *
     * @returns {boolean} - true if and only if there is a valid CN_token_access
     */
    static async checkAccessWithRefresh() {
        const decodedAuthToken = UserAuthenticationClient.getDecodedToken(cookies_1.default.authCookieName);
        const isValidAuthToken = UserAuthenticationClient.isTokenValid(decodedAuthToken);
        if (isValidAuthToken) {
            return false;
        }
        const decodedAccessToken = UserAuthenticationClient.getDecodedToken(cookies_1.default.oidcCookies.access);
        const isValidAcccessToken = UserAuthenticationClient.isTokenValid(decodedAccessToken);
        if (!isValidAcccessToken) {
            // Attempt to get new access token
            await fetchWithTimeout(apiRoutes_1.default.oidcRefresh, {
                credentials: 'include',
                method: 'GET'
            }, MAX_TIMEOUT);
            const accessToken = UserAuthenticationClient.getDecodedToken(cookies_1.default.oidcCookies.access);
            return UserAuthenticationClient.isTokenValid(accessToken);
        }
        return isValidAcccessToken;
    }
    static getDocumentCookie(cookieName) {
        const allCookies = document.cookie || '';
        const [, cookieValue = ''] = allCookies
            .split('; ')
            .map((pair) => pair.split('='))
            .find(([key]) => key === cookieName) || [];
        return cookieValue;
    }
    static getCookieValue(cookieName) {
        try {
            return this.getDocumentCookie(cookieName);
        }
        catch (err) {
            return '';
        }
    }
    static decodeCookie(cookie) {
        try {
            const [, payload] = cookie.split('.');
            return JSON.parse(window.atob(payload));
        }
        catch (e) {
            return {
                email: '',
                sub: '',
                exp: 0,
                xid: ''
            };
        }
    }
}
exports.UserAuthenticationClient = UserAuthenticationClient;
//# sourceMappingURL=UserAuthenticationClient.js.map

/***/ }),

/***/ 20656:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserAuthenticationClient = void 0;
var UserAuthenticationClient_1 = __webpack_require__(22214);
Object.defineProperty(exports, "UserAuthenticationClient", ({ enumerable: true, get: function () { return UserAuthenticationClient_1.UserAuthenticationClient; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 61796:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.articleFieldFragment = exports.articleFragmentName = void 0;
exports.articleFragmentName = 'articleField';
exports.articleFieldFragment = `
  fragment ${exports.articleFragmentName} on Article {
    __typename
    metadata {
      contentType
    }
    id
    organizationId
    hed
    contextualHed
    promoHed
    promoDek
    dek
    contextualDek
    rubric
    contextualRubric
    uri
    ledeCaption
    lang
    isSponsored
    bylineOption
    bylineVariant
    campaignUrl
    pubDate
    socialTitle
    socialDescription
    issueDate
    contentSource
    contextualBody
    tout {
      id
      organizationId
      metadata {
        contentType
        archived
      }
      altText
      generatedAltText
      filename
      height
      width
      lang
      aspectRatios {
        name
        height
        width
        format
        duration
        url
        override
      }
      restrictCropping
      caption
      contextualCaption
      credit
      contextualCredit
      title
      contextualTitle
      contextualBody
      cropMode
      url
    }
  }
`;
//# sourceMappingURL=article-fragment.js.map

/***/ }),

/***/ 5116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.businessFragment = exports.businessFragmentName = void 0;
exports.businessFragmentName = 'getBookmarkedBusiness';
exports.businessFragment = `
    fragment ${exports.businessFragmentName} on Business  {
        address {
          city
        }
      
        organizationId
        name
        pubDate
      
        seoDescription
        seoTitle
        tout: connected(relname: "photosTout") {
          edges {
            node {
              ... on Photo {
                altText
                aspectRatios {
                  name
                  url
                  width
                  height
                  format
                  modifications {
                    crop {
                      height
                      width
                      x
                      y
                    }
                  }
                }
                caption
                contextualBody
                contextualCaption
                contextualTitle
                cropMode
                credit
                filename
                id
                metadata {
                  contentType
                }
                contentWarnings {
                  slug
                }
                restrictCropping
                __typename
              }
            }
          }
        }
        uri
      }
      `;
//# sourceMappingURL=business-fragment.js.map

/***/ }),

/***/ 7444:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cartoonFragment = void 0;
exports.cartoonFragment = `
  fragment cartoonFragment on Cartoon {
    id
    metadata {
      contentType
    }
    filename
    height
    width
    altText
    title
    caption
    contextualBody
    contextualCaption
    credit
    socialTitle
    socialDescription
    __typename
    url: uri
    aspectRatios {
      height
      name
      url
      width
    }
    pubDate
    storeUrl
    publishInfo {
      firstPublished
    }
  }
`;
//# sourceMappingURL=cartoon-fragment.js.map

/***/ }),

/***/ 64836:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContentReferenceFragment = void 0;
const getContentReferenceFragment = () => {
    return `
        fragment contentReferenceField on ContentReference {
            id
            identifier
            contextualCaption
            provider
            hed
            dek
            contextualTitle
            contextualCaption
            metadata {
            contentType
            }
      }`;
};
exports.getContentReferenceFragment = getContentReferenceFragment;
//# sourceMappingURL=content-reference-fragments.js.map

/***/ }),

/***/ 9715:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.contributorFragment = void 0;
exports.contributorFragment = `
  fragment contributorFragment on Contributor {
    __typename
    id
    url: uri
    name
    title
    # type comes from fragment in search query
    type
    contributorType: type
    photo: tout {
      id
      aspectRatios {
        url
      }
      metadata {
        contentType
      }
    }
    title
    bio
    socialMedia {
      handle
      network
    }
    metadata {
      contentType
    }
  }
`;
//# sourceMappingURL=contributors-fragments.js.map

/***/ }),

/***/ 57448:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.galleryFieldFragment = exports.galleryFragmentName = void 0;
exports.galleryFragmentName = 'galleryField';
exports.galleryFieldFragment = `
  fragment ${exports.galleryFragmentName} on Gallery {
    __typename
    metadata {
      contentType
    }
    id
    uri
    contentSource
    hed
    dek
    promoDek
    promoHed
    contextualHed
    contextualDek
    tout {
      id
      organizationId
      metadata {
        contentType
        archived
      }
      altText
      generatedAltText
      filename
      height
      width
      lang
      aspectRatios {
        name
        height
        width
        format
        duration
        url
        override
      }
      restrictCropping
      caption
      contextualCaption
      credit
      contextualCredit
      title
      contextualTitle
      contextualBody
      cropMode
      url
    }
    pubDate
    socialDescription
    rubric
    socialTitle
    socialDescription
  }
`;
//# sourceMappingURL=gallery-fragment.js.map

/***/ }),

/***/ 63576:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCategoryTaxonomiesFragment = void 0;
const getCategoryTaxonomiesFragment = () => {
    return `
    fragment categoryTaxonomiesFragment on CategoryTaxonomy  {
      name: taxonomy
      categories {
        id
        name
        slug
        hierarchy {
          name
          slug
        }
        parent: parentCategory {
          name
          slug
        }
        root {
          slug
        }
      }
    }
  `;
};
exports.getCategoryTaxonomiesFragment = getCategoryTaxonomiesFragment;
//# sourceMappingURL=get-category-taxonomies.js.map

/***/ }),

/***/ 45977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChannelFieldsFragment = void 0;
const getChannelFieldsFragment = () => {
    return `
        fragment channelFields on Category {
            name
            slug
        }`;
};
exports.getChannelFieldsFragment = getChannelFieldsFragment;
//# sourceMappingURL=get-channel-fields.js.map

/***/ }),

/***/ 59808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getClipFieldFragment = void 0;
const getClipFieldFragment = () => {
    return `
    fragment clipField on Clip {
      id
      metadata {
        contentType
      }
      altText
      credit
      caption
      filename
      thumbnails: connected(relname: "thumbnails") {
        edges {
          node {
            ... on Photo {
              url
              filename
              aspectRatios {
                height
                width
                url
                name
                format
              }
            }
          }
        }
      }
      renditions {
        mp4 {
          url
          width
          height
          resolution
        }
      }
    }
    `;
};
exports.getClipFieldFragment = getClipFieldFragment;
//# sourceMappingURL=get-clip-fields.js.map

/***/ }),

/***/ 88264:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCneInterludeOverride = void 0;
const getCneInterludeOverride = () => {
    return `
    interludeOverride: firstConnected(relname:"interludeOverride") {
      node {
        ... on CNEVideo {
          cneId
        }
      }
    }
    `;
};
exports.getCneInterludeOverride = getCneInterludeOverride;
//# sourceMappingURL=get-cne-interlude-override.js.map

/***/ }),

/***/ 36526:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCNEVideoFragment = void 0;
const getCNEVideoFragment = () => {
    return `
        fragment CNEVideoField on CNEVideo {
            #pubDate
            __typename
            metadata {
            contentType
            }
            embedUrl
            id
            photo: imageUrl
            scriptEmbedUrl: scriptUrl
            title
            url: canonicalUrl
            animationClip {
              highResUrl
              lowResUrl
            }
        }`;
};
exports.getCNEVideoFragment = getCNEVideoFragment;
//# sourceMappingURL=get-cne-video-fields.js.map

/***/ }),

/***/ 56326:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContentList = void 0;
const getContentList = () => `
fragment contentList on CuratedList {
    id
    hed
    content(limit: 5) {
        results {
            __typename
            metadata {
                contentType
            }
            ...on Article {
                id
                hed
                dek
                contextualDek
                promoDek
                contextualHed
                promoHed
                uri
                rubric
                channel {
                    slug
                    name
                }
            }
            ...on Gallery {
                id
                hed
                dek
                contextualDek
                promoDek
                contextualHed
                promoHed
                uri
                rubric
                channel {
                    slug
                    name
                }
            }
            ...on ExternalLink {
                id
                hed
                url
                rubric
                contextualRubric

            }
        }
    }
}
`;
exports.getContentList = getContentList;
//# sourceMappingURL=get-content-list.js.map

/***/ }),

/***/ 38023:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContributorFieldFragment = void 0;
const getContributorFieldFragment = () => {
    return `
    fragment contributorField on Contributor {
      id
      url: uri
      name
      contributorType: type
      photo: tout {
        ...photoField
      }
      title
      bio
      email
      shortBio
      socialMedia {
        handle
        network
      }
      metadata {
        contentType
      }
      relatedContent: firstConnected(relname: "relatedContent") {
          node {
            ... on ExternalLink {
              id
              dek
              hed
              url
              __typename
              metadata {
                contentType
              }
              rubric
              source
            }
          }
        }
    featuredStories: connected(relname: "featuredStories") {
      edges {
        node {
          ... on Article {
            id
            url: uri
            hed
            dek
            rubric
            pubDate
            photo: tout {
              ...photoField
            }
            __typename
              metadata {
                contentType
              }
          }
        }
      }
    }
      __typename
    }
  `;
};
exports.getContributorFieldFragment = getContributorFieldFragment;
//# sourceMappingURL=get-contributor-fields.js.map

/***/ }),

/***/ 31506:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCulturalEventFragment = void 0;
const getCulturalEventFragment = () => {
    return `
    fragment culturalEventData on CulturalEvent {
      id
      eventDetails
      body {
        content
      }
      dek
      hed
      location {
        name
        city
        region
        country
      }
      promoHed
      promoDek
      ticketUrl
      eventRubric
      eventStatus
      timeZone
      ctaLabel
      tout {
        ...clipField
        ...photoField
      }
      url: uri
      startDate
      endDate
      metadata {
        contentType
      }
     eventFunctionalTags : connected(relname:"categories-functional-tags"){
        edges{
          node{
            ... on Category{
              name
              slug
            }
          }
        }
      }
      eventVenues: connected(relname: "venues") {
        edges {
          node {
            ... on Venue {
              venueName: name
              address {
                city
                region
                country
              }
            }
          }
        }
      }
      pubDate
      contributorsAuthor: connected(relname: "contributorsAuthor") {
        edges {
          node {
            id
            ... on Contributor {
              name
              url: uri
            }
          }
        }
      }
      categoriesSections: connected(relname: "categories-sections") {
        edges {
          node {
            id
            __typename
            ... on Category {
              name
              hierarchy {
                name
                slug
              }
            }
          }
        }
      }
      categoriesIssues: connected(relname: "categories-issues") {
        edges {
          node {
            id
            __typename
            ... on Category {
              id
              name
              hierarchy {
                name
                slug
              }
              parent: parentCategory {
                name
                slug
              }
            }
          }
        }
      }
      __typename
    }
  `;
};
exports.getCulturalEventFragment = getCulturalEventFragment;
//# sourceMappingURL=get-cultural-event.js.map

/***/ }),

/***/ 81711:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCuratedList = void 0;
const get_photo_fields_1 = __webpack_require__(36680);
exports.getCuratedList = `
    ${(0, get_photo_fields_1.getPhotoFieldFragment)()}
    query GetCuratedList($organizationId: ID!, $id: String, $uri: String) {
        getCuratedList(
          organizationId: $organizationId
          id: $id
          uri: $uri
        ) {
          id
          hed
          uri
          channel {
            id
            slug
            name
          }
          content {
            results {
              id
              ... on Article {
                contextualHed
                contextualDek
                hed
                dek
                url: uri
                promoHed
                promoDek
                metadata {
                  contentType
                  archived
                }
                rubric
                tout {
                  ...photoField
                }
              }
              ... on ExternalLink {
                contextualHed
                contextualDek
                hed
                dek
                rubric
                url
                tout {
                  ...photoField
                }
                metadata {
                  contentType
                  archived
                }
              }
              ... on Gallery {
                contextualHed
                contextualDek
                hed
                dek
                url: uri
                promoHed
                promoDek
                metadata {
                  contentType
                  archived
                }
                rubric
                tout {
                  ...photoField
                }
              }
              ... on LiveStory {
                contextualHed
                contextualDek
                hed
                dek
                url: uri
                promoHed
                promoDek
                metadata {
                  contentType
                  archived
                }
                rubric
                tout {
                  ...photoField
                }
              }
            }
          }

          categories(taxonomy: "channels") {
            name
            slug
            hierarchy {
              name
            }
          }
          tout {
            ...photoField
          }
          metadata {
            contentType
          }
          functionalTags {
            id
            name
            slug
            hierarchy {
              name
              slug
            }
          }
          __typename
        }
      }
`;
//# sourceMappingURL=get-curated-list.js.map

/***/ }),

/***/ 94808:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.liveStoryFragment = void 0;
exports.liveStoryFragment = `
  fragment liveStoryField on LiveStory {
    __typename
    id
    hed
    dek
    uri
    url: uri
    rubric
    tout {
      id
      organizationId
      metadata {
        contentType
        archived
      }
      altText
      generatedAltText
      filename
      height
      width
      lang
      aspectRatios {
        name
        height
        width
        format
        duration
        url
        override
      }
      restrictCropping
      caption
      contextualCaption
      credit
      contextualCredit
      title
      contextualTitle
      contextualBody
      cropMode
      url
    }
    organizationId
    metadata {
      contentType
    }
    allContributors(types: [AUTHOR, PHOTOGRAPHER]) {
      edges {
        node {
          ...contributorFragment
        }
      }
    }
  }
`;
//# sourceMappingURL=get-live-story-fields.js.map

/***/ }),

/***/ 82433:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMusicReviewFieldFragment = void 0;
const getMusicReviewFieldFragment = () => {
    return /* GraphQL */ `
    fragment musicReviewField on MusicReview {
      __typename
      metadata {
        contentType
      }
      dek
      hed
      promoDek
      promoHed
      pubDate
      rubric
      channels: categories(taxonomy: "channels") {
        ...channelFields
        parent: parentCategory {
          ...channelFields
        }
      }
      sections: categories(taxonomy: "sections") {
        name
        slug
      }
      url: uri
      allContributors(types: [AUTHOR, PHOTOGRAPHER]) {
        edges {
          node {
            ...contributorFragment
          }
        }
      }
      tout {
        ...photoField
      }
    }
  `;
};
exports.getMusicReviewFieldFragment = getMusicReviewFieldFragment;
//# sourceMappingURL=get-music-review-fragment.js.map

/***/ }),

/***/ 51730:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActivityOfferFragment = exports.getLodgingOfferFragment = void 0;
const getLodgingOfferFragment = () => {
    return `
    fragment offersFragment on Lodging {
      offers {
        seller {
          name
        }
        purchaseUri
        offerId
        shortUrl
      }
      name
      operationalInfo {
        price
      }
    }
  `;
};
exports.getLodgingOfferFragment = getLodgingOfferFragment;
const getActivityOfferFragment = () => {
    return `
    fragment activityOffersData on Activity {
      offers {
        seller {
          name
        }
        purchaseUri
        offerId
        shortUrl
      }
      name
    }
  `;
};
exports.getActivityOfferFragment = getActivityOfferFragment;
//# sourceMappingURL=get-offer-fields.js.map

/***/ }),

/***/ 36680:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPhotoFieldFragment = exports.photoFragmentName = void 0;
exports.photoFragmentName = 'photoField';
const getPhotoFieldFragment = () => {
    return `
    fragment ${exports.photoFragmentName} on Photo {
        bookMarkedUrl: url
        altText
        aspectRatios {
            name
            url
            width
            height
            format
            modifications {
                crop {
                    height
                    width
                    x
                    y
                }
            }
        }
        caption
        contextualBody
        contextualCaption
        contextualTitle
        cropMode
        credit
        filename
        id
        metadata {
          contentType
        }
        contentWarnings{
          slug
        }
        restrictCropping
        __typename
    }
  `;
};
exports.getPhotoFieldFragment = getPhotoFieldFragment;
//# sourceMappingURL=get-photo-fields.js.map

/***/ }),

/***/ 4283:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPlaceEditorialFragment = void 0;
const get_offer_fields_1 = __webpack_require__(51730);
const get_photo_fields_1 = __webpack_require__(36680);
const getPlaceEditorialFragment = () => {
    return `
    ${(0, get_offer_fields_1.getLodgingOfferFragment)()}
    ${(0, get_offer_fields_1.getActivityOfferFragment)()}
    ${(0, get_photo_fields_1.getPhotoFieldFragment)()}

    fragment placeEditorialField on PlaceEditorial {
      uri
      id
      shortDescription
      promoDek
      connected(relname: "photos", type: PHOTO) {
        edges {
          node {
            ... on Photo {
              ...photoField
            }
          }
        }
      }
      awards: categories(taxonomy: "award-winner") {
        name
        hierarchy {
          name
          slug
        }
      }
      place {
        node {
          ... on Lodging {
            ...offersFragment
          }
          ... on Activity {
            ...activityOffersData
          }
          ...locationInfo
        }
      }
      price: categories(taxonomy: "price") {
        id
        name
        slug
      }
    }
    fragment locationInfo on Place {
      locationInfo {
        addressString
        address
        city {
          name
        }
        country {
          name
        }
      }
    }
  `;
};
exports.getPlaceEditorialFragment = getPlaceEditorialFragment;
//# sourceMappingURL=get-place-editorial.js.map

/***/ }),

/***/ 77681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProductFieldFragment = void 0;
const _1 = __webpack_require__(2697);
const getProductFieldFragment = () => {
    return `

  ${(0, _1.getCNEVideoFragment)()}

 fragment ClipDataFragment on Clip {
    altText
    credit
    caption
    filename
    thumbnails: connected(relname: "thumbnails") {
      edges {
        node {
          ... on Photo {
            url
            filename
            aspectRatios {
              height
              width
              url
              name
              format
            }
          }
        }
      }
    }
    id
    metadata {
      contentType
    }
    renditions {
      mp4 {
        url
        width
        height
        resolution
      }
    }
  }

  fragment productField on Product {
    id
    brand {
      name
      id
    }
    awards {
      name
      date
    }
    lang
    revisionInfo {
      createdAt
      version
      authorName
    }
    category:connected{
      edges {
        node {
          ...on Category {
            hierarchy {
              slug
            }
          }
        }
      }
    }
    contextualBody
    contextualCaption
    contextualTitle
    description
    functionalTags {
      name
      slug
    }
    name
    pros
    cons
    rating
    offers {
      currency
      comparisonPrice
      purchaseUri: offerLink
      offerId
      offerType
      price
      sellerName
      shortUrl: shortLink
      countryCode
      earningPerClick
    }
    tout {
      ...photoField
    }
    connected(relname: ["videosTout"]) {
      edges {
        node {
          ...on CNEVideo {
            ...CNEVideoField
          }
        }
      }
    }
    media:connected{
      edges{
        node{
          ...on Photo{
            ...photoField
            }    
          ...on Clip{
            ...ClipDataFragment  
            }
        ...on CNEVideo{
            ...CNEVideoField
            }
       }
      }
    }
    url: uri
    metadata {
      contentType
    }
    __typename
  }
    `;
};
exports.getProductFieldFragment = getProductFieldFragment;
//# sourceMappingURL=get-product-fields.js.map

/***/ }),

/***/ 3012:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRevisionInfoFragment = void 0;
const getRevisionInfoFragment = () => {
    return `
          fragment revisionInfoField on RevisionInfo {
            version
            createdAt
            authorName
        }`;
};
exports.getRevisionInfoFragment = getRevisionInfoFragment;
//# sourceMappingURL=get-revisionInfo-fragment.js.map

/***/ }),

/***/ 76681:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getVisualStoryBanner = void 0;
const getVisualStoryBanner = () => {
    return `
        visualStoryBanner: connected(relname: "visualStoryBanner") {
            edges {
                items: node {
                    ... on CuratedList {
                        id
                        hed
                        dek
                        date: pubDate
                        url: uri
                        metadata {
                            contentType
                        }
                        curationSubType
                        connected(limit: 100) {
                            totalResults
                            items: edges {
                                item: node {
                                    ...visualStoryData
                                }
                            }
                        }
                    }
                    ... on CuratedSearch {
                        id
                        hed
                        dek
                        date: pubDate
                        url: uri
                        metadata {
                            contentType
                        }
                        content(limit: 100) {
                            totalResults
                            results {
                                ...visualStoryData
                            }
                        }
                    }
                }
            }
        }`;
};
exports.getVisualStoryBanner = getVisualStoryBanner;
//# sourceMappingURL=get-visual-story-banner.js.map

/***/ }),

/***/ 59172:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getVisualStoryDataFragment = void 0;
const getVisualStoryDataFragment = (clipFragmentName = 'clipField') => `
    fragment visualStoryData on VisualStory {
      id
      hed
      date: pubDate
      url: uri
      metadata {
        contentType
      }
      toutMedia {
        node {
          ...photoField
        }
      }
      photoLede: connected(relname: ["photosLede"]) {
        edges {
          node {
           ...photoField
           ...${clipFragmentName}
          }
        }
      }
    }`;
exports.getVisualStoryDataFragment = getVisualStoryDataFragment;
//# sourceMappingURL=get-visual-story-data-fragment.js.map

/***/ }),

/***/ 2697:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(61796), exports);
__exportStar(__webpack_require__(5116), exports);
__exportStar(__webpack_require__(7444), exports);
__exportStar(__webpack_require__(64836), exports);
__exportStar(__webpack_require__(9715), exports);
__exportStar(__webpack_require__(57448), exports);
__exportStar(__webpack_require__(63576), exports);
__exportStar(__webpack_require__(45977), exports);
__exportStar(__webpack_require__(59808), exports);
__exportStar(__webpack_require__(88264), exports);
__exportStar(__webpack_require__(36526), exports);
__exportStar(__webpack_require__(56326), exports);
__exportStar(__webpack_require__(38023), exports);
__exportStar(__webpack_require__(31506), exports);
__exportStar(__webpack_require__(81711), exports);
__exportStar(__webpack_require__(94808), exports);
__exportStar(__webpack_require__(82433), exports);
__exportStar(__webpack_require__(36680), exports);
__exportStar(__webpack_require__(4283), exports);
__exportStar(__webpack_require__(77681), exports);
__exportStar(__webpack_require__(3012), exports);
__exportStar(__webpack_require__(76681), exports);
__exportStar(__webpack_require__(59172), exports);
__exportStar(__webpack_require__(19036), exports);
__exportStar(__webpack_require__(14828), exports);
__exportStar(__webpack_require__(47423), exports);
__exportStar(__webpack_require__(77811), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19036:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.productReviewFieldFragment = exports.productReviewFragmentName = void 0;
exports.productReviewFragmentName = 'productReviewField';
exports.productReviewFieldFragment = `
  fragment ${exports.productReviewFragmentName} on ProductReview {
    id
    organizationId
    hed
    promoHed
    promoDek
    dek
    rubric
    uri
    lang
    pubDate
    socialTitle
    socialDescription
    issueDate
    contentSource
    tout {
      id
      organizationId
      metadata {
        contentType
        archived
      }
      altText
      generatedAltText
      filename
      height
      width
      lang
      aspectRatios {
        name
        height
        width
        format
        duration
        url
        override
      }
      restrictCropping
      caption
      contextualCaption
      credit
      contextualCredit
      title
      contextualTitle
      contextualBody
      cropMode
      url
    }
  }
`;
//# sourceMappingURL=product-review-fragment.js.map

/***/ }),

/***/ 14828:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recipeFieldFragment = exports.recipeFragmentName = void 0;
exports.recipeFragmentName = 'recipeField';
exports.recipeFieldFragment = `
  fragment ${exports.recipeFragmentName} on Recipe {
      __typename
      metadata {
        contentType
      }
      organizationId
      aggregateRating
      id
      url: uri
      metadata {
        contentType
      }
      canonicalUrl
      allContributors {
        edges {
          node {
            name
            type
            uri
          }
        }
      }
      hed
      promoDek
      promoHed
      pubDate
      tout {
        altText
        aspectRatios {
          format
          height
          name
          url
          width
        }
        caption
        contextualCaption
        contextualTitle
        credit
        filename
        id
        metadata {
          contentType
        }
      }
      socialTitle
      uri
  }
`;
//# sourceMappingURL=recipe-fragment.js.map

/***/ }),

/***/ 47423:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runwaySeasonAllShowsFragment = exports.designerAllCollectionsFragment = exports.runwayPhotoFieldFragment = void 0;
exports.runwayPhotoFieldFragment = `
  fragment photoField on Photo {
    altText
    contextualBody
    credit
    cropMode
    id
    filename
    title
    restrictCropping
    aspectRatios {
      name
      override
      width
      height
      url
      modifications {
        crop {
          height
          width
          x
          y
        }
      }
    }
    metadata {
      contentType
    }
    __typename
  }
`;
exports.designerAllCollectionsFragment = `
  fragment designerAllCollections on RunwayShowsConnection {
    edges {
      node {
        season {
          name
        }
        isSponsored
        url: uri
        promoImage {
          ...photoField
        }
        gallery {
          collection {
            promoImage {
              ...photoField
            }
          }
        }
      }
    }
  }
`;
exports.runwaySeasonAllShowsFragment = `
  fragment runwaySeasonAllShows on RunwayShowsConnection {
    totalResults
    edges {
      node {
        id
        url: uri
        pubDate
        designer {
          name
        }
      }
    }
  }
`;
//# sourceMappingURL=runway-shared-fragments.js.map

/***/ }),

/***/ 77811:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getVenueFragment = exports.getVenueFragmentName = void 0;
const camelCase_1 = __importDefault(__webpack_require__(84058));
const getVenueFragmentName = (venueType) => {
    const name = `${venueType}Field`;
    return (0, camelCase_1.default)(name);
};
exports.getVenueFragmentName = getVenueFragmentName;
const getVenueFragment = (venueType) => {
    return `
    fragment ${(0, exports.getVenueFragmentName)(venueType)} on ${venueType} {
      id
      tout: connected(relname: "photosTout", limit: 1) {
        edges {
          node {
            ... on Photo {
              url
            }
          }
        }
      }
    }
`;
};
exports.getVenueFragment = getVenueFragment;
//# sourceMappingURL=venue-fragment.js.map

/***/ }),

/***/ 68073:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const get_1 = __importDefault(__webpack_require__(58156));
const pick_1 = __importDefault(__webpack_require__(44383));
const toPairs_1 = __importDefault(__webpack_require__(18938));
const fromPairs_1 = __importDefault(__webpack_require__(44377));
const VulcanSDKManager_1 = __importDefault(__webpack_require__(15272));
const get_image_widths_1 = __importDefault(__webpack_require__(97906));
const get_image_overlay_from_content_warning_1 = __importDefault(__webpack_require__(25053));
const get_image_orientation_from_content_warning_1 = __importDefault(__webpack_require__(98183));
/**
 * Update a URL object in place, replacing file extension at the end of the path with the new one
 * If there is no existing file extension, the new one will be added
 *
 * @param url - a URL object, usually pointing to a Vulcan URL
 * @param extension - a file extension to append, usually 'mp4'
 */
function normalizeClipFileExtension(url, extension) {
    const pathParts = url.pathname.split('/');
    const filenameParts = pathParts.pop().split('.');
    if (filenameParts.length > 1) {
        filenameParts.pop();
    }
    filenameParts.push(extension);
    pathParts.push(filenameParts.join('.'));
    url.pathname = pathParts.join('/');
}
/**
 * Calculates image aspect ratio and sets missing dimension
 *
 * @param source - the vulcan source
 * @param master - the master aspect ratio for an entity
 *
 */
function setMissingDimension(source, { height: masterHeight, width: masterWidth }) {
    if (masterHeight > 0 && masterWidth > 0) {
        const ratio = masterWidth / masterHeight;
        if (source.width) {
            source.height = Math.round(source.width / ratio);
        }
        else if (source.height) {
            source.width = Math.round(source.height * ratio);
        }
    }
}
const masterDimensionFetchers = {
    clip(photo) {
        const renditions = (0, get_1.default)(photo, 'renditions.mp4', []);
        return (renditions.find((rendition) => rendition.resolution === 'master') ?? {});
    },
    photo(photo) {
        return (0, get_1.default)(photo, 'aspectRatios.master', {});
    }
};
/**
 * Calculates the most optimal video clip resolution based on image rendition spec
 *
 * @param {RenditionSize} source image rendition spec
 * @param {ClipRenditions} renditions available video clip renditions
 * @return {MediaSource} video source object
 */
function setMissingResolution(source, { mp4: renditions }) {
    // each clip has a "master" resolution for the default aspect ratio
    if (renditions.length) {
        const masterResolution = renditions.find(({ resolution }) => resolution === 'master');
        const { height: masterHeight, width: masterWidth } = masterResolution;
        const masterRatio = `${masterWidth}:${masterHeight}`;
        const { width, height, aspectRatio } = source;
        const actualAspectRatio = !aspectRatio || aspectRatio === 'master' ? masterRatio : aspectRatio;
        const [widthComponent, heightComponent] = actualAspectRatio.split(':');
        const ratio = widthComponent / heightComponent;
        const preferredHeight = height || width / ratio || masterResolution.height;
        const match = renditions.reduce((acc, rendition) => {
            if (rendition.height >= preferredHeight && rendition.height < acc.height)
                return rendition;
            return acc;
        }, masterResolution);
        source.resolution = match.resolution;
    }
}
/**
 * Create a set of vulcan urls given image data and configuration
 *
 * @param photo - photo data from copilot
 *   (see buildUrl docs https://github.com/CondeNast-Copilot/autopilot-utils-vulcan#buildurl)
 * @param photoConfig - rendition config for this image
 * @param vulcanUrl - the url for the cdn where the images are
 * @param imageOverlay - Image Overlay Array
 * @returns {VulcanImageSources} sizes - dictionary of urls keyed by image size or empty object
 */
function createVulcanSources(photo, photoConfig, vulcanUrl, imageOverlay) {
    const vulcan = VulcanSDKManager_1.default.get(vulcanUrl);
    const contentWarningOverlay = (0, get_image_overlay_from_content_warning_1.default)(photo, imageOverlay);
    // video clip renditions unavailable
    if (photo.modelName === 'clip' &&
        (!photo.renditions || !photo.renditions.mp4)) {
        return {};
    }
    // Convert this to key values and filter out a select few properties
    const modifiedPairs = (0, toPairs_1.default)(photoConfig).map(([key, value]) => {
        const vulcanOptions = { ...value };
        const valuesToKeep = (0, pick_1.default)(value, [
            'aspectRatio',
            'height',
            'width',
            'sizes'
        ]);
        // set the missing "resolution" option for video clips
        let url;
        if (photo.modelName === 'clip' && !vulcanOptions.resolution) {
            setMissingResolution(vulcanOptions, photo.renditions);
        }
        if (photo.modelName === 'clip' && photo.isInlineEmbed) {
            // For inline embeds, we will use the thumbnail URL directly without modification
            url = photo.thumbnails[0] ? new URL(photo.thumbnails[0]) : '';
        }
        else {
            // For regular clips and other content types, will use Vulcan URL
            url = new URL(vulcan.buildUrl(photo, vulcanOptions));
            // Only for regular clips with non-master resolution, ensure .mp4 extension
            if (photo.modelName === 'clip' && vulcanOptions.resolution !== 'master') {
                normalizeClipFileExtension(url, 'mp4');
            }
        }
        const newValue = { ...valuesToKeep, url: url?.href || '', srcset: undefined };
        const currentAspectRatio = (0, get_1.default)(newValue, 'aspectRatio', 'master');
        if (currentAspectRatio === 'master') {
            const fetchMasterDimension = masterDimensionFetchers[photo.modelName] ??
                masterDimensionFetchers.photo;
            setMissingDimension(newValue, fetchMasterDimension(photo));
        }
        let imageOrientation;
        // generating the srcset only for images
        if (photo.modelName !== 'clip' && newValue.width) {
            const imageWidths = (0, get_image_widths_1.default)(newValue.width);
            newValue.srcset = imageWidths
                .map((imageWidth) => {
                const imageUrl = new URL(vulcan.buildUrl(photo, {
                    ...value,
                    width: imageWidth
                }));
                if (contentWarningOverlay) {
                    imageOrientation = (0, get_image_orientation_from_content_warning_1.default)(imageWidth, newValue.height, currentAspectRatio);
                    imageUrl.searchParams.append('overlay', `${contentWarningOverlay}-${imageOrientation}`);
                }
                return `${imageUrl.href} ${imageWidth}w`;
            })
                .join(', ');
        }
        else {
            delete newValue.srcset;
        }
        if (contentWarningOverlay) {
            imageOrientation = (0, get_image_orientation_from_content_warning_1.default)(newValue.width, newValue.height, currentAspectRatio);
            const newValueURL = new URL(newValue.url);
            newValueURL.searchParams.append('overlay', `${contentWarningOverlay}-${imageOrientation}`);
            newValue.url = newValueURL.href;
        }
        return [key, newValue];
    });
    const vulcanSource = (0, fromPairs_1.default)(modifiedPairs);
    return vulcanSource;
}
exports["default"] = createVulcanSources;
//# sourceMappingURL=create-vulcan-sources.js.map

/***/ }),

/***/ 74644:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatRecirculationUrl = void 0;
/**
 * format uri.
 *    1. returns empty string if URI is falsey
 *    2. prepends '/' if the URI doesn't start with a protocol or string
 *    3. returns URI otherwise
 *
 * @param uri - data to pull uri from
 * @returns the formatted URI
 */
function formatUri(uri) {
    if (!uri) {
        return '';
    }
    if (!uri.startsWith('/') && uri.search(/^https?:\/\//) === -1) {
        return `/${uri}`;
    }
    return uri;
}
exports["default"] = formatUri;
/**
 * format url of related items.
 *
 * Fix urls given by RECS API: add slash to the first instance of the `#` symbol
 * OR adds to the end of URL if no # symbols
 *
 * @param uri - data to pull url from
 * @returns the formatted URL
 */
function formatRecirculationUrl(uri) {
    if (!uri) {
        return '';
    }
    if (uri.includes('#') && !uri.includes('/#')) {
        return uri.replace('#', '/#');
    }
    if (!uri.includes('#') && !uri.endsWith('/')) {
        return `${uri}/`;
    }
    return uri;
}
exports.formatRecirculationUrl = formatRecirculationUrl;
//# sourceMappingURL=format-uri.js.map

/***/ }),

/***/ 98183:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Gets the Image Orientation of the device
 *
 * @param width - width of the device
 * @param height - height of the device
 * @param aspectRatio - aspect-ratio of the device
 * @returns image orientation of the device
 *
 */
function getImageOrientationFromContentWarning(width, height, aspectRatio) {
    if (width === undefined || height === undefined) {
        const [w, h] = aspectRatio.split(':');
        return parseInt(w, 10) > parseInt(h, 10) ? 'landscape' : 'portrait';
    }
    return width > height ? 'landscape' : 'portrait';
}
exports["default"] = getImageOrientationFromContentWarning;
//# sourceMappingURL=get-image-orientation-from-content-warning.js.map

/***/ }),

/***/ 25053:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Checks if image content warning is present and send backs the overlay slug
 *
 * @param photo - entity of the photo attributes
 * @param imageOverlay - Image Overlay Array
 * @returns image overlay slug if image has content-warnings ,else undefined
 *
 */
function getImageOverlayFromContentWarning(photo, imageOverlay) {
    if (photo?.contentWarnings?.length && imageOverlay?.length) {
        /*
            The below loop is to understand the first occurence of the imageOverlay slug would be applied ,no matter how many contentWarning slug is present on the photo. If there is no match, we shall send back the original url.
          */
        for (let i = 0; i < imageOverlay.length; i++) {
            for (let j = 0; j < photo.contentWarnings.length; j++) {
                const { contentWarningSlug, overlay } = imageOverlay[i];
                const { slug } = photo.contentWarnings[j];
                if (contentWarningSlug === slug) {
                    return overlay.toString();
                }
            }
        }
    }
    return undefined;
}
exports["default"] = getImageOverlayFromContentWarning;
//# sourceMappingURL=get-image-overlay-from-content-warning.js.map

/***/ }),

/***/ 97906:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Generates list of widths for the image srcset
 *
 * @param renditionWidth - width from the rendition
 * @returns list of widths
 */
function getImageWidths(renditionWidth) {
    const IMAGE_WIDTHS = [
        120, 240, 320, 640, 960, 1280, 1600, 1920, 2240, 2580, 2920, 3260, 3600,
        3940
    ];
    const imageWidths = IMAGE_WIDTHS.filter((width) => width <= renditionWidth);
    if (imageWidths.length === 0 && renditionWidth) {
        imageWidths.push(renditionWidth);
    }
    return imageWidths;
}
exports["default"] = getImageWidths;
//# sourceMappingURL=get-image-widths.js.map

/***/ }),

/***/ 66916:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const striptags_1 = __importDefault(__webpack_require__(67098));
/**
 * Takes a string and returns a string without HTML tags
 *
 * @param str - string - Some string with HTML tags
 * @returns a clean string without HTML tags
 */
exports["default"] = (html) => (0, striptags_1.default)(html).trim();
//# sourceMappingURL=remove-html-tags.js.map

/***/ }),

/***/ 46520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./ar": 61509,
	"./ar.js": 61509,
	"./de": 77853,
	"./de.js": 77853,
	"./en-au": 53872,
	"./en-au.js": 53872,
	"./en-ca": 28298,
	"./en-ca.js": 28298,
	"./en-gb": 56195,
	"./en-gb.js": 56195,
	"./en-in": 9033,
	"./en-in.js": 9033,
	"./es": 97650,
	"./es-mx": 17730,
	"./es-mx.js": 17730,
	"./es-us": 56575,
	"./es-us.js": 56575,
	"./es.js": 97650,
	"./fr": 85498,
	"./fr.js": 85498,
	"./it": 88383,
	"./it.js": 88383,
	"./ja": 23827,
	"./ja.js": 23827,
	"./ru": 82271,
	"./ru.js": 82271,
	"./zh-tw": 50304,
	"./zh-tw.js": 50304
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46520;

/***/ }),

/***/ 50477:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 42634:
/***/ (() => {

/* (ignored) */

/***/ })

}]);