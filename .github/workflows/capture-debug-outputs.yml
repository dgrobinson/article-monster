name: Capture Debug Outputs

on:
  repository_dispatch:
    types: [extraction-debug]

jobs:
  capture-outputs:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
      - name: Checkout latest-outputs-debug branch
        uses: actions/checkout@v4
        with:
          ref: latest-outputs-debug
          fetch-depth: 0
          
      - name: Configure git
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Fail if branch doesn't exist - it should be created manually
          if ! git show-ref --verify --quiet refs/heads/latest-outputs-debug; then
            echo "ERROR: latest-outputs-debug branch does not exist!"
            echo "Please create it manually first with:"
            echo "  git checkout -b latest-outputs-debug"
            echo "  git push origin latest-outputs-debug"
            exit 1
          fi
          
      - name: Generate output directory name
        id: dirname
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=$(echo "${{ github.event.client_payload.commit_sha }}" | cut -c1-7)
          DIR_NAME="outputs/${TIMESTAMP}-${SHORT_SHA}"
          echo "dir_name=${DIR_NAME}" >> $GITHUB_OUTPUT
          
      - name: Save debug outputs
        run: |
          mkdir -p "${{ steps.dirname.outputs.dir_name }}"
          
          # Parse the debug_data JSON string
          echo '${{ github.event.client_payload.debug_data }}' > "${{ steps.dirname.outputs.dir_name }}/debug_data_raw.json"
          
          # Extract individual components from debug_data
          cat "${{ steps.dirname.outputs.dir_name }}/debug_data_raw.json" | jq -r '.' | jq '.bookmarklet_log' > "${{ steps.dirname.outputs.dir_name }}/bookmarklet-log.json"
          cat "${{ steps.dirname.outputs.dir_name }}/debug_data_raw.json" | jq -r '.' | jq '.payload_truncated' > "${{ steps.dirname.outputs.dir_name }}/payload-truncated.txt"
          cat "${{ steps.dirname.outputs.dir_name }}/debug_data_raw.json" | jq -r '.' | jq '.server_logs' > "${{ steps.dirname.outputs.dir_name }}/server-logs.json"
          
          # Save email content
          cat "${{ steps.dirname.outputs.dir_name }}/debug_data_raw.json" | jq -r '.' | jq -r '.email_content' > "${{ steps.dirname.outputs.dir_name }}/email-content.html"
          
          # Note if EPUB was available but not included
          echo "EPUB available: $(cat "${{ steps.dirname.outputs.dir_name }}/debug_data_raw.json" | jq -r '.' | jq -r '.epub_available')" > "${{ steps.dirname.outputs.dir_name }}/epub-status.txt"
          
          # Create summary
          cat > "${{ steps.dirname.outputs.dir_name }}/summary.md" << EOF
          # Extraction Debug Output
          
          **Timestamp**: ${{ github.event.client_payload.timestamp }}
          **Article URL**: ${{ github.event.client_payload.url }}
          **Title**: ${{ github.event.client_payload.title }}
          **Success**: ${{ github.event.client_payload.success }}
          **Status**: ${{ github.event.client_payload.status }}
          
          ## Files
          - bookmarklet-log.json - Client-side extraction logs
          - payload.json - Full payload sent to server
          - server-logs.json - Server processing logs
          - article.epub - Generated EPUB file (if available)
          - email-content.html - Email sent to Kindle
          - debug_data_raw.json - Complete debug data
          EOF
          
      - name: Commit and push
        run: |
          git add outputs/
          git commit -m "Debug output: ${{ github.event.client_payload.title }} [$(date +%Y%m%d-%H%M%S)]"
          git push origin latest-outputs-debug